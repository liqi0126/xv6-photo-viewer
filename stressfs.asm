
_stressfs：     文件格式 elf32-i386


Disassembly of section .text:

00000000 <main>:
#include "fs.h"
#include "fcntl.h"

int
main(int argc, char *argv[])
{
       0:	8d 4c 24 04          	lea    0x4(%esp),%ecx
       4:	83 e4 f0             	and    $0xfffffff0,%esp
       7:	ff 71 fc             	pushl  -0x4(%ecx)
       a:	55                   	push   %ebp
       b:	89 e5                	mov    %esp,%ebp
       d:	51                   	push   %ecx
       e:	81 ec 24 02 00 00    	sub    $0x224,%esp
  int fd, i;
  char path[] = "stressfs0";
      14:	c7 45 e6 73 74 72 65 	movl   $0x65727473,-0x1a(%ebp)
      1b:	c7 45 ea 73 73 66 73 	movl   $0x73667373,-0x16(%ebp)
      22:	66 c7 45 ee 30 00    	movw   $0x30,-0x12(%ebp)
  char data[512];

  printf(1, "stressfs starting\n");
      28:	83 ec 08             	sub    $0x8,%esp
      2b:	68 a0 5e 01 00       	push   $0x15ea0
      30:	6a 01                	push   $0x1
      32:	e8 19 05 00 00       	call   550 <printf>
      37:	83 c4 10             	add    $0x10,%esp
  memset(data, 'a', sizeof(data));
      3a:	83 ec 04             	sub    $0x4,%esp
      3d:	68 00 02 00 00       	push   $0x200
      42:	6a 61                	push   $0x61
      44:	8d 85 e6 fd ff ff    	lea    -0x21a(%ebp),%eax
      4a:	50                   	push   %eax
      4b:	e8 be 01 00 00       	call   20e <memset>
      50:	83 c4 10             	add    $0x10,%esp

  for(i = 0; i < 4; i++)
      53:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
      5a:	eb 0d                	jmp    69 <main+0x69>
    if(fork() > 0)
      5c:	e8 40 03 00 00       	call   3a1 <fork>
      61:	85 c0                	test   %eax,%eax
      63:	7f 0c                	jg     71 <main+0x71>
  char data[512];

  printf(1, "stressfs starting\n");
  memset(data, 'a', sizeof(data));

  for(i = 0; i < 4; i++)
      65:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
      69:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
      6d:	7e ed                	jle    5c <main+0x5c>
      6f:	eb 01                	jmp    72 <main+0x72>
    if(fork() > 0)
      break;
      71:	90                   	nop

  printf(1, "write %d\n", i);
      72:	83 ec 04             	sub    $0x4,%esp
      75:	ff 75 f4             	pushl  -0xc(%ebp)
      78:	68 b3 5e 01 00       	push   $0x15eb3
      7d:	6a 01                	push   $0x1
      7f:	e8 cc 04 00 00       	call   550 <printf>
      84:	83 c4 10             	add    $0x10,%esp

  path[8] += i;
      87:	0f b6 45 ee          	movzbl -0x12(%ebp),%eax
      8b:	89 c2                	mov    %eax,%edx
      8d:	8b 45 f4             	mov    -0xc(%ebp),%eax
      90:	01 d0                	add    %edx,%eax
      92:	88 45 ee             	mov    %al,-0x12(%ebp)
  fd = open(path, O_CREATE | O_RDWR);
      95:	83 ec 08             	sub    $0x8,%esp
      98:	68 02 02 00 00       	push   $0x202
      9d:	8d 45 e6             	lea    -0x1a(%ebp),%eax
      a0:	50                   	push   %eax
      a1:	e8 43 03 00 00       	call   3e9 <open>
      a6:	83 c4 10             	add    $0x10,%esp
      a9:	89 45 f0             	mov    %eax,-0x10(%ebp)
  for(i = 0; i < 20; i++)
      ac:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
      b3:	eb 1e                	jmp    d3 <main+0xd3>
//    printf(fd, "%d\n", i);
    write(fd, data, sizeof(data));
      b5:	83 ec 04             	sub    $0x4,%esp
      b8:	68 00 02 00 00       	push   $0x200
      bd:	8d 85 e6 fd ff ff    	lea    -0x21a(%ebp),%eax
      c3:	50                   	push   %eax
      c4:	ff 75 f0             	pushl  -0x10(%ebp)
      c7:	e8 fd 02 00 00       	call   3c9 <write>
      cc:	83 c4 10             	add    $0x10,%esp

  printf(1, "write %d\n", i);

  path[8] += i;
  fd = open(path, O_CREATE | O_RDWR);
  for(i = 0; i < 20; i++)
      cf:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
      d3:	83 7d f4 13          	cmpl   $0x13,-0xc(%ebp)
      d7:	7e dc                	jle    b5 <main+0xb5>
//    printf(fd, "%d\n", i);
    write(fd, data, sizeof(data));
  close(fd);
      d9:	83 ec 0c             	sub    $0xc,%esp
      dc:	ff 75 f0             	pushl  -0x10(%ebp)
      df:	e8 ed 02 00 00       	call   3d1 <close>
      e4:	83 c4 10             	add    $0x10,%esp

  printf(1, "read\n");
      e7:	83 ec 08             	sub    $0x8,%esp
      ea:	68 bd 5e 01 00       	push   $0x15ebd
      ef:	6a 01                	push   $0x1
      f1:	e8 5a 04 00 00       	call   550 <printf>
      f6:	83 c4 10             	add    $0x10,%esp

  fd = open(path, O_RDONLY);
      f9:	83 ec 08             	sub    $0x8,%esp
      fc:	6a 00                	push   $0x0
      fe:	8d 45 e6             	lea    -0x1a(%ebp),%eax
     101:	50                   	push   %eax
     102:	e8 e2 02 00 00       	call   3e9 <open>
     107:	83 c4 10             	add    $0x10,%esp
     10a:	89 45 f0             	mov    %eax,-0x10(%ebp)
  for (i = 0; i < 20; i++)
     10d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
     114:	eb 1e                	jmp    134 <main+0x134>
    read(fd, data, sizeof(data));
     116:	83 ec 04             	sub    $0x4,%esp
     119:	68 00 02 00 00       	push   $0x200
     11e:	8d 85 e6 fd ff ff    	lea    -0x21a(%ebp),%eax
     124:	50                   	push   %eax
     125:	ff 75 f0             	pushl  -0x10(%ebp)
     128:	e8 94 02 00 00       	call   3c1 <read>
     12d:	83 c4 10             	add    $0x10,%esp
  close(fd);

  printf(1, "read\n");

  fd = open(path, O_RDONLY);
  for (i = 0; i < 20; i++)
     130:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
     134:	83 7d f4 13          	cmpl   $0x13,-0xc(%ebp)
     138:	7e dc                	jle    116 <main+0x116>
    read(fd, data, sizeof(data));
  close(fd);
     13a:	83 ec 0c             	sub    $0xc,%esp
     13d:	ff 75 f0             	pushl  -0x10(%ebp)
     140:	e8 8c 02 00 00       	call   3d1 <close>
     145:	83 c4 10             	add    $0x10,%esp

  wait();
     148:	e8 64 02 00 00       	call   3b1 <wait>
  
  exit();
     14d:	e8 57 02 00 00       	call   3a9 <exit>

00000152 <stosb>:
               "cc");
}

static inline void
stosb(void *addr, int data, int cnt)
{
     152:	55                   	push   %ebp
     153:	89 e5                	mov    %esp,%ebp
     155:	57                   	push   %edi
     156:	53                   	push   %ebx
  asm volatile("cld; rep stosb" :
     157:	8b 4d 08             	mov    0x8(%ebp),%ecx
     15a:	8b 55 10             	mov    0x10(%ebp),%edx
     15d:	8b 45 0c             	mov    0xc(%ebp),%eax
     160:	89 cb                	mov    %ecx,%ebx
     162:	89 df                	mov    %ebx,%edi
     164:	89 d1                	mov    %edx,%ecx
     166:	fc                   	cld    
     167:	f3 aa                	rep stos %al,%es:(%edi)
     169:	89 ca                	mov    %ecx,%edx
     16b:	89 fb                	mov    %edi,%ebx
     16d:	89 5d 08             	mov    %ebx,0x8(%ebp)
     170:	89 55 10             	mov    %edx,0x10(%ebp)
               "=D" (addr), "=c" (cnt) :
               "0" (addr), "1" (cnt), "a" (data) :
               "memory", "cc");
}
     173:	90                   	nop
     174:	5b                   	pop    %ebx
     175:	5f                   	pop    %edi
     176:	5d                   	pop    %ebp
     177:	c3                   	ret    

00000178 <strcpy>:
#include "user.h"
#include "x86.h"

char*
strcpy(char *s, char *t)
{
     178:	55                   	push   %ebp
     179:	89 e5                	mov    %esp,%ebp
     17b:	83 ec 10             	sub    $0x10,%esp
  char *os;

  os = s;
     17e:	8b 45 08             	mov    0x8(%ebp),%eax
     181:	89 45 fc             	mov    %eax,-0x4(%ebp)
  while((*s++ = *t++) != 0)
     184:	90                   	nop
     185:	8b 45 08             	mov    0x8(%ebp),%eax
     188:	8d 50 01             	lea    0x1(%eax),%edx
     18b:	89 55 08             	mov    %edx,0x8(%ebp)
     18e:	8b 55 0c             	mov    0xc(%ebp),%edx
     191:	8d 4a 01             	lea    0x1(%edx),%ecx
     194:	89 4d 0c             	mov    %ecx,0xc(%ebp)
     197:	0f b6 12             	movzbl (%edx),%edx
     19a:	88 10                	mov    %dl,(%eax)
     19c:	0f b6 00             	movzbl (%eax),%eax
     19f:	84 c0                	test   %al,%al
     1a1:	75 e2                	jne    185 <strcpy+0xd>
    ;
  return os;
     1a3:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
     1a6:	c9                   	leave  
     1a7:	c3                   	ret    

000001a8 <strcmp>:

int
strcmp(const char *p, const char *q)
{
     1a8:	55                   	push   %ebp
     1a9:	89 e5                	mov    %esp,%ebp
  while(*p && *p == *q)
     1ab:	eb 08                	jmp    1b5 <strcmp+0xd>
    p++, q++;
     1ad:	83 45 08 01          	addl   $0x1,0x8(%ebp)
     1b1:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
}

int
strcmp(const char *p, const char *q)
{
  while(*p && *p == *q)
     1b5:	8b 45 08             	mov    0x8(%ebp),%eax
     1b8:	0f b6 00             	movzbl (%eax),%eax
     1bb:	84 c0                	test   %al,%al
     1bd:	74 10                	je     1cf <strcmp+0x27>
     1bf:	8b 45 08             	mov    0x8(%ebp),%eax
     1c2:	0f b6 10             	movzbl (%eax),%edx
     1c5:	8b 45 0c             	mov    0xc(%ebp),%eax
     1c8:	0f b6 00             	movzbl (%eax),%eax
     1cb:	38 c2                	cmp    %al,%dl
     1cd:	74 de                	je     1ad <strcmp+0x5>
    p++, q++;
  return (uchar)*p - (uchar)*q;
     1cf:	8b 45 08             	mov    0x8(%ebp),%eax
     1d2:	0f b6 00             	movzbl (%eax),%eax
     1d5:	0f b6 d0             	movzbl %al,%edx
     1d8:	8b 45 0c             	mov    0xc(%ebp),%eax
     1db:	0f b6 00             	movzbl (%eax),%eax
     1de:	0f b6 c0             	movzbl %al,%eax
     1e1:	29 c2                	sub    %eax,%edx
     1e3:	89 d0                	mov    %edx,%eax
}
     1e5:	5d                   	pop    %ebp
     1e6:	c3                   	ret    

000001e7 <strlen>:

uint
strlen(char *s)
{
     1e7:	55                   	push   %ebp
     1e8:	89 e5                	mov    %esp,%ebp
     1ea:	83 ec 10             	sub    $0x10,%esp
  int n;

  for(n = 0; s[n]; n++)
     1ed:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
     1f4:	eb 04                	jmp    1fa <strlen+0x13>
     1f6:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
     1fa:	8b 55 fc             	mov    -0x4(%ebp),%edx
     1fd:	8b 45 08             	mov    0x8(%ebp),%eax
     200:	01 d0                	add    %edx,%eax
     202:	0f b6 00             	movzbl (%eax),%eax
     205:	84 c0                	test   %al,%al
     207:	75 ed                	jne    1f6 <strlen+0xf>
    ;
  return n;
     209:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
     20c:	c9                   	leave  
     20d:	c3                   	ret    

0000020e <memset>:

void*
memset(void *dst, int c, uint n)
{
     20e:	55                   	push   %ebp
     20f:	89 e5                	mov    %esp,%ebp
  stosb(dst, c, n);
     211:	8b 45 10             	mov    0x10(%ebp),%eax
     214:	50                   	push   %eax
     215:	ff 75 0c             	pushl  0xc(%ebp)
     218:	ff 75 08             	pushl  0x8(%ebp)
     21b:	e8 32 ff ff ff       	call   152 <stosb>
     220:	83 c4 0c             	add    $0xc,%esp
  return dst;
     223:	8b 45 08             	mov    0x8(%ebp),%eax
}
     226:	c9                   	leave  
     227:	c3                   	ret    

00000228 <strchr>:

char*
strchr(const char *s, char c)
{
     228:	55                   	push   %ebp
     229:	89 e5                	mov    %esp,%ebp
     22b:	83 ec 04             	sub    $0x4,%esp
     22e:	8b 45 0c             	mov    0xc(%ebp),%eax
     231:	88 45 fc             	mov    %al,-0x4(%ebp)
  for(; *s; s++)
     234:	eb 14                	jmp    24a <strchr+0x22>
    if(*s == c)
     236:	8b 45 08             	mov    0x8(%ebp),%eax
     239:	0f b6 00             	movzbl (%eax),%eax
     23c:	3a 45 fc             	cmp    -0x4(%ebp),%al
     23f:	75 05                	jne    246 <strchr+0x1e>
      return (char*)s;
     241:	8b 45 08             	mov    0x8(%ebp),%eax
     244:	eb 13                	jmp    259 <strchr+0x31>
}

char*
strchr(const char *s, char c)
{
  for(; *s; s++)
     246:	83 45 08 01          	addl   $0x1,0x8(%ebp)
     24a:	8b 45 08             	mov    0x8(%ebp),%eax
     24d:	0f b6 00             	movzbl (%eax),%eax
     250:	84 c0                	test   %al,%al
     252:	75 e2                	jne    236 <strchr+0xe>
    if(*s == c)
      return (char*)s;
  return 0;
     254:	b8 00 00 00 00       	mov    $0x0,%eax
}
     259:	c9                   	leave  
     25a:	c3                   	ret    

0000025b <gets>:

char*
gets(char *buf, int max)
{
     25b:	55                   	push   %ebp
     25c:	89 e5                	mov    %esp,%ebp
     25e:	83 ec 18             	sub    $0x18,%esp
  int i, cc;
  char c;

  for(i=0; i+1 < max; ){
     261:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
     268:	eb 42                	jmp    2ac <gets+0x51>
    cc = read(0, &c, 1);
     26a:	83 ec 04             	sub    $0x4,%esp
     26d:	6a 01                	push   $0x1
     26f:	8d 45 ef             	lea    -0x11(%ebp),%eax
     272:	50                   	push   %eax
     273:	6a 00                	push   $0x0
     275:	e8 47 01 00 00       	call   3c1 <read>
     27a:	83 c4 10             	add    $0x10,%esp
     27d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(cc < 1)
     280:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
     284:	7e 33                	jle    2b9 <gets+0x5e>
      break;
    buf[i++] = c;
     286:	8b 45 f4             	mov    -0xc(%ebp),%eax
     289:	8d 50 01             	lea    0x1(%eax),%edx
     28c:	89 55 f4             	mov    %edx,-0xc(%ebp)
     28f:	89 c2                	mov    %eax,%edx
     291:	8b 45 08             	mov    0x8(%ebp),%eax
     294:	01 c2                	add    %eax,%edx
     296:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
     29a:	88 02                	mov    %al,(%edx)
    if(c == '\n' || c == '\r')
     29c:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
     2a0:	3c 0a                	cmp    $0xa,%al
     2a2:	74 16                	je     2ba <gets+0x5f>
     2a4:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
     2a8:	3c 0d                	cmp    $0xd,%al
     2aa:	74 0e                	je     2ba <gets+0x5f>
gets(char *buf, int max)
{
  int i, cc;
  char c;

  for(i=0; i+1 < max; ){
     2ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
     2af:	83 c0 01             	add    $0x1,%eax
     2b2:	3b 45 0c             	cmp    0xc(%ebp),%eax
     2b5:	7c b3                	jl     26a <gets+0xf>
     2b7:	eb 01                	jmp    2ba <gets+0x5f>
    cc = read(0, &c, 1);
    if(cc < 1)
      break;
     2b9:	90                   	nop
    buf[i++] = c;
    if(c == '\n' || c == '\r')
      break;
  }
  buf[i] = '\0';
     2ba:	8b 55 f4             	mov    -0xc(%ebp),%edx
     2bd:	8b 45 08             	mov    0x8(%ebp),%eax
     2c0:	01 d0                	add    %edx,%eax
     2c2:	c6 00 00             	movb   $0x0,(%eax)
  return buf;
     2c5:	8b 45 08             	mov    0x8(%ebp),%eax
}
     2c8:	c9                   	leave  
     2c9:	c3                   	ret    

000002ca <stat>:

int
stat(char *n, struct stat *st)
{
     2ca:	55                   	push   %ebp
     2cb:	89 e5                	mov    %esp,%ebp
     2cd:	83 ec 18             	sub    $0x18,%esp
  int fd;
  int r;

  fd = open(n, O_RDONLY);
     2d0:	83 ec 08             	sub    $0x8,%esp
     2d3:	6a 00                	push   $0x0
     2d5:	ff 75 08             	pushl  0x8(%ebp)
     2d8:	e8 0c 01 00 00       	call   3e9 <open>
     2dd:	83 c4 10             	add    $0x10,%esp
     2e0:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(fd < 0)
     2e3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     2e7:	79 07                	jns    2f0 <stat+0x26>
    return -1;
     2e9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
     2ee:	eb 25                	jmp    315 <stat+0x4b>
  r = fstat(fd, st);
     2f0:	83 ec 08             	sub    $0x8,%esp
     2f3:	ff 75 0c             	pushl  0xc(%ebp)
     2f6:	ff 75 f4             	pushl  -0xc(%ebp)
     2f9:	e8 03 01 00 00       	call   401 <fstat>
     2fe:	83 c4 10             	add    $0x10,%esp
     301:	89 45 f0             	mov    %eax,-0x10(%ebp)
  close(fd);
     304:	83 ec 0c             	sub    $0xc,%esp
     307:	ff 75 f4             	pushl  -0xc(%ebp)
     30a:	e8 c2 00 00 00       	call   3d1 <close>
     30f:	83 c4 10             	add    $0x10,%esp
  return r;
     312:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
     315:	c9                   	leave  
     316:	c3                   	ret    

00000317 <atoi>:

int
atoi(const char *s)
{
     317:	55                   	push   %ebp
     318:	89 e5                	mov    %esp,%ebp
     31a:	83 ec 10             	sub    $0x10,%esp
  int n;

  n = 0;
     31d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  while('0' <= *s && *s <= '9')
     324:	eb 25                	jmp    34b <atoi+0x34>
    n = n*10 + *s++ - '0';
     326:	8b 55 fc             	mov    -0x4(%ebp),%edx
     329:	89 d0                	mov    %edx,%eax
     32b:	c1 e0 02             	shl    $0x2,%eax
     32e:	01 d0                	add    %edx,%eax
     330:	01 c0                	add    %eax,%eax
     332:	89 c1                	mov    %eax,%ecx
     334:	8b 45 08             	mov    0x8(%ebp),%eax
     337:	8d 50 01             	lea    0x1(%eax),%edx
     33a:	89 55 08             	mov    %edx,0x8(%ebp)
     33d:	0f b6 00             	movzbl (%eax),%eax
     340:	0f be c0             	movsbl %al,%eax
     343:	01 c8                	add    %ecx,%eax
     345:	83 e8 30             	sub    $0x30,%eax
     348:	89 45 fc             	mov    %eax,-0x4(%ebp)
atoi(const char *s)
{
  int n;

  n = 0;
  while('0' <= *s && *s <= '9')
     34b:	8b 45 08             	mov    0x8(%ebp),%eax
     34e:	0f b6 00             	movzbl (%eax),%eax
     351:	3c 2f                	cmp    $0x2f,%al
     353:	7e 0a                	jle    35f <atoi+0x48>
     355:	8b 45 08             	mov    0x8(%ebp),%eax
     358:	0f b6 00             	movzbl (%eax),%eax
     35b:	3c 39                	cmp    $0x39,%al
     35d:	7e c7                	jle    326 <atoi+0xf>
    n = n*10 + *s++ - '0';
  return n;
     35f:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
     362:	c9                   	leave  
     363:	c3                   	ret    

00000364 <memmove>:

void*
memmove(void *vdst, void *vsrc, int n)
{
     364:	55                   	push   %ebp
     365:	89 e5                	mov    %esp,%ebp
     367:	83 ec 10             	sub    $0x10,%esp
  char *dst, *src;
  
  dst = vdst;
     36a:	8b 45 08             	mov    0x8(%ebp),%eax
     36d:	89 45 fc             	mov    %eax,-0x4(%ebp)
  src = vsrc;
     370:	8b 45 0c             	mov    0xc(%ebp),%eax
     373:	89 45 f8             	mov    %eax,-0x8(%ebp)
  while(n-- > 0)
     376:	eb 17                	jmp    38f <memmove+0x2b>
    *dst++ = *src++;
     378:	8b 45 fc             	mov    -0x4(%ebp),%eax
     37b:	8d 50 01             	lea    0x1(%eax),%edx
     37e:	89 55 fc             	mov    %edx,-0x4(%ebp)
     381:	8b 55 f8             	mov    -0x8(%ebp),%edx
     384:	8d 4a 01             	lea    0x1(%edx),%ecx
     387:	89 4d f8             	mov    %ecx,-0x8(%ebp)
     38a:	0f b6 12             	movzbl (%edx),%edx
     38d:	88 10                	mov    %dl,(%eax)
{
  char *dst, *src;
  
  dst = vdst;
  src = vsrc;
  while(n-- > 0)
     38f:	8b 45 10             	mov    0x10(%ebp),%eax
     392:	8d 50 ff             	lea    -0x1(%eax),%edx
     395:	89 55 10             	mov    %edx,0x10(%ebp)
     398:	85 c0                	test   %eax,%eax
     39a:	7f dc                	jg     378 <memmove+0x14>
    *dst++ = *src++;
  return vdst;
     39c:	8b 45 08             	mov    0x8(%ebp),%eax
}
     39f:	c9                   	leave  
     3a0:	c3                   	ret    

000003a1 <fork>:
  name: \
    movl $SYS_ ## name, %eax; \
    int $T_SYSCALL; \
    ret

SYSCALL(fork)
     3a1:	b8 01 00 00 00       	mov    $0x1,%eax
     3a6:	cd 40                	int    $0x40
     3a8:	c3                   	ret    

000003a9 <exit>:
SYSCALL(exit)
     3a9:	b8 02 00 00 00       	mov    $0x2,%eax
     3ae:	cd 40                	int    $0x40
     3b0:	c3                   	ret    

000003b1 <wait>:
SYSCALL(wait)
     3b1:	b8 03 00 00 00       	mov    $0x3,%eax
     3b6:	cd 40                	int    $0x40
     3b8:	c3                   	ret    

000003b9 <pipe>:
SYSCALL(pipe)
     3b9:	b8 04 00 00 00       	mov    $0x4,%eax
     3be:	cd 40                	int    $0x40
     3c0:	c3                   	ret    

000003c1 <read>:
SYSCALL(read)
     3c1:	b8 05 00 00 00       	mov    $0x5,%eax
     3c6:	cd 40                	int    $0x40
     3c8:	c3                   	ret    

000003c9 <write>:
SYSCALL(write)
     3c9:	b8 10 00 00 00       	mov    $0x10,%eax
     3ce:	cd 40                	int    $0x40
     3d0:	c3                   	ret    

000003d1 <close>:
SYSCALL(close)
     3d1:	b8 15 00 00 00       	mov    $0x15,%eax
     3d6:	cd 40                	int    $0x40
     3d8:	c3                   	ret    

000003d9 <kill>:
SYSCALL(kill)
     3d9:	b8 06 00 00 00       	mov    $0x6,%eax
     3de:	cd 40                	int    $0x40
     3e0:	c3                   	ret    

000003e1 <exec>:
SYSCALL(exec)
     3e1:	b8 07 00 00 00       	mov    $0x7,%eax
     3e6:	cd 40                	int    $0x40
     3e8:	c3                   	ret    

000003e9 <open>:
SYSCALL(open)
     3e9:	b8 0f 00 00 00       	mov    $0xf,%eax
     3ee:	cd 40                	int    $0x40
     3f0:	c3                   	ret    

000003f1 <mknod>:
SYSCALL(mknod)
     3f1:	b8 11 00 00 00       	mov    $0x11,%eax
     3f6:	cd 40                	int    $0x40
     3f8:	c3                   	ret    

000003f9 <unlink>:
SYSCALL(unlink)
     3f9:	b8 12 00 00 00       	mov    $0x12,%eax
     3fe:	cd 40                	int    $0x40
     400:	c3                   	ret    

00000401 <fstat>:
SYSCALL(fstat)
     401:	b8 08 00 00 00       	mov    $0x8,%eax
     406:	cd 40                	int    $0x40
     408:	c3                   	ret    

00000409 <link>:
SYSCALL(link)
     409:	b8 13 00 00 00       	mov    $0x13,%eax
     40e:	cd 40                	int    $0x40
     410:	c3                   	ret    

00000411 <mkdir>:
SYSCALL(mkdir)
     411:	b8 14 00 00 00       	mov    $0x14,%eax
     416:	cd 40                	int    $0x40
     418:	c3                   	ret    

00000419 <chdir>:
SYSCALL(chdir)
     419:	b8 09 00 00 00       	mov    $0x9,%eax
     41e:	cd 40                	int    $0x40
     420:	c3                   	ret    

00000421 <dup>:
SYSCALL(dup)
     421:	b8 0a 00 00 00       	mov    $0xa,%eax
     426:	cd 40                	int    $0x40
     428:	c3                   	ret    

00000429 <getpid>:
SYSCALL(getpid)
     429:	b8 0b 00 00 00       	mov    $0xb,%eax
     42e:	cd 40                	int    $0x40
     430:	c3                   	ret    

00000431 <sbrk>:
SYSCALL(sbrk)
     431:	b8 0c 00 00 00       	mov    $0xc,%eax
     436:	cd 40                	int    $0x40
     438:	c3                   	ret    

00000439 <sleep>:
SYSCALL(sleep)
     439:	b8 0d 00 00 00       	mov    $0xd,%eax
     43e:	cd 40                	int    $0x40
     440:	c3                   	ret    

00000441 <uptime>:
SYSCALL(uptime)
     441:	b8 0e 00 00 00       	mov    $0xe,%eax
     446:	cd 40                	int    $0x40
     448:	c3                   	ret    

00000449 <createwindow>:
SYSCALL(createwindow)
     449:	b8 16 00 00 00       	mov    $0x16,%eax
     44e:	cd 40                	int    $0x40
     450:	c3                   	ret    

00000451 <repaintwindow>:
SYSCALL(repaintwindow)
     451:	b8 17 00 00 00       	mov    $0x17,%eax
     456:	cd 40                	int    $0x40
     458:	c3                   	ret    

00000459 <getmessage>:
SYSCALL(getmessage)
     459:	b8 18 00 00 00       	mov    $0x18,%eax
     45e:	cd 40                	int    $0x40
     460:	c3                   	ret    

00000461 <settimer>:
SYSCALL(settimer)
     461:	b8 19 00 00 00       	mov    $0x19,%eax
     466:	cd 40                	int    $0x40
     468:	c3                   	ret    

00000469 <updatewindow>:
SYSCALL(updatewindow)
     469:	b8 1a 00 00 00       	mov    $0x1a,%eax
     46e:	cd 40                	int    $0x40
     470:	c3                   	ret    

00000471 <destroywindow>:
SYSCALL(destroywindow)
     471:	b8 1b 00 00 00       	mov    $0x1b,%eax
     476:	cd 40                	int    $0x40
     478:	c3                   	ret    

00000479 <putc>:
#include "stat.h"
#include "user.h"

static void
putc(int fd, char c)
{
     479:	55                   	push   %ebp
     47a:	89 e5                	mov    %esp,%ebp
     47c:	83 ec 18             	sub    $0x18,%esp
     47f:	8b 45 0c             	mov    0xc(%ebp),%eax
     482:	88 45 f4             	mov    %al,-0xc(%ebp)
  write(fd, &c, 1);
     485:	83 ec 04             	sub    $0x4,%esp
     488:	6a 01                	push   $0x1
     48a:	8d 45 f4             	lea    -0xc(%ebp),%eax
     48d:	50                   	push   %eax
     48e:	ff 75 08             	pushl  0x8(%ebp)
     491:	e8 33 ff ff ff       	call   3c9 <write>
     496:	83 c4 10             	add    $0x10,%esp
}
     499:	90                   	nop
     49a:	c9                   	leave  
     49b:	c3                   	ret    

0000049c <printint>:

static void
printint(int fd, int xx, int base, int sgn)
{
     49c:	55                   	push   %ebp
     49d:	89 e5                	mov    %esp,%ebp
     49f:	53                   	push   %ebx
     4a0:	83 ec 24             	sub    $0x24,%esp
  static char digits[] = "0123456789ABCDEF";
  char buf[16];
  int i, neg;
  uint x;

  neg = 0;
     4a3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  if(sgn && xx < 0){
     4aa:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
     4ae:	74 17                	je     4c7 <printint+0x2b>
     4b0:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     4b4:	79 11                	jns    4c7 <printint+0x2b>
    neg = 1;
     4b6:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    x = -xx;
     4bd:	8b 45 0c             	mov    0xc(%ebp),%eax
     4c0:	f7 d8                	neg    %eax
     4c2:	89 45 ec             	mov    %eax,-0x14(%ebp)
     4c5:	eb 06                	jmp    4cd <printint+0x31>
  } else {
    x = xx;
     4c7:	8b 45 0c             	mov    0xc(%ebp),%eax
     4ca:	89 45 ec             	mov    %eax,-0x14(%ebp)
  }

  i = 0;
     4cd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  do{
    buf[i++] = digits[x % base];
     4d4:	8b 4d f4             	mov    -0xc(%ebp),%ecx
     4d7:	8d 41 01             	lea    0x1(%ecx),%eax
     4da:	89 45 f4             	mov    %eax,-0xc(%ebp)
     4dd:	8b 5d 10             	mov    0x10(%ebp),%ebx
     4e0:	8b 45 ec             	mov    -0x14(%ebp),%eax
     4e3:	ba 00 00 00 00       	mov    $0x0,%edx
     4e8:	f7 f3                	div    %ebx
     4ea:	89 d0                	mov    %edx,%eax
     4ec:	0f b6 80 c0 e1 01 00 	movzbl 0x1e1c0(%eax),%eax
     4f3:	88 44 0d dc          	mov    %al,-0x24(%ebp,%ecx,1)
  }while((x /= base) != 0);
     4f7:	8b 5d 10             	mov    0x10(%ebp),%ebx
     4fa:	8b 45 ec             	mov    -0x14(%ebp),%eax
     4fd:	ba 00 00 00 00       	mov    $0x0,%edx
     502:	f7 f3                	div    %ebx
     504:	89 45 ec             	mov    %eax,-0x14(%ebp)
     507:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
     50b:	75 c7                	jne    4d4 <printint+0x38>
  if(neg)
     50d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
     511:	74 2d                	je     540 <printint+0xa4>
    buf[i++] = '-';
     513:	8b 45 f4             	mov    -0xc(%ebp),%eax
     516:	8d 50 01             	lea    0x1(%eax),%edx
     519:	89 55 f4             	mov    %edx,-0xc(%ebp)
     51c:	c6 44 05 dc 2d       	movb   $0x2d,-0x24(%ebp,%eax,1)

  while(--i >= 0)
     521:	eb 1d                	jmp    540 <printint+0xa4>
    putc(fd, buf[i]);
     523:	8d 55 dc             	lea    -0x24(%ebp),%edx
     526:	8b 45 f4             	mov    -0xc(%ebp),%eax
     529:	01 d0                	add    %edx,%eax
     52b:	0f b6 00             	movzbl (%eax),%eax
     52e:	0f be c0             	movsbl %al,%eax
     531:	83 ec 08             	sub    $0x8,%esp
     534:	50                   	push   %eax
     535:	ff 75 08             	pushl  0x8(%ebp)
     538:	e8 3c ff ff ff       	call   479 <putc>
     53d:	83 c4 10             	add    $0x10,%esp
    buf[i++] = digits[x % base];
  }while((x /= base) != 0);
  if(neg)
    buf[i++] = '-';

  while(--i >= 0)
     540:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
     544:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     548:	79 d9                	jns    523 <printint+0x87>
    putc(fd, buf[i]);
}
     54a:	90                   	nop
     54b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
     54e:	c9                   	leave  
     54f:	c3                   	ret    

00000550 <printf>:

// Print to the given fd. Only understands %d, %x, %p, %s.
void
printf(int fd, char *fmt, ...)
{
     550:	55                   	push   %ebp
     551:	89 e5                	mov    %esp,%ebp
     553:	83 ec 28             	sub    $0x28,%esp
  char *s;
  int c, i, state;
  uint *ap;

  state = 0;
     556:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  ap = (uint*)(void*)&fmt + 1;
     55d:	8d 45 0c             	lea    0xc(%ebp),%eax
     560:	83 c0 04             	add    $0x4,%eax
     563:	89 45 e8             	mov    %eax,-0x18(%ebp)
  for(i = 0; fmt[i]; i++){
     566:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
     56d:	e9 59 01 00 00       	jmp    6cb <printf+0x17b>
    c = fmt[i] & 0xff;
     572:	8b 55 0c             	mov    0xc(%ebp),%edx
     575:	8b 45 f0             	mov    -0x10(%ebp),%eax
     578:	01 d0                	add    %edx,%eax
     57a:	0f b6 00             	movzbl (%eax),%eax
     57d:	0f be c0             	movsbl %al,%eax
     580:	25 ff 00 00 00       	and    $0xff,%eax
     585:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(state == 0){
     588:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
     58c:	75 2c                	jne    5ba <printf+0x6a>
      if(c == '%'){
     58e:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
     592:	75 0c                	jne    5a0 <printf+0x50>
        state = '%';
     594:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
     59b:	e9 27 01 00 00       	jmp    6c7 <printf+0x177>
      } else {
        putc(fd, c);
     5a0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     5a3:	0f be c0             	movsbl %al,%eax
     5a6:	83 ec 08             	sub    $0x8,%esp
     5a9:	50                   	push   %eax
     5aa:	ff 75 08             	pushl  0x8(%ebp)
     5ad:	e8 c7 fe ff ff       	call   479 <putc>
     5b2:	83 c4 10             	add    $0x10,%esp
     5b5:	e9 0d 01 00 00       	jmp    6c7 <printf+0x177>
      }
    } else if(state == '%'){
     5ba:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
     5be:	0f 85 03 01 00 00    	jne    6c7 <printf+0x177>
      if(c == 'd'){
     5c4:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
     5c8:	75 1e                	jne    5e8 <printf+0x98>
        printint(fd, *ap, 10, 1);
     5ca:	8b 45 e8             	mov    -0x18(%ebp),%eax
     5cd:	8b 00                	mov    (%eax),%eax
     5cf:	6a 01                	push   $0x1
     5d1:	6a 0a                	push   $0xa
     5d3:	50                   	push   %eax
     5d4:	ff 75 08             	pushl  0x8(%ebp)
     5d7:	e8 c0 fe ff ff       	call   49c <printint>
     5dc:	83 c4 10             	add    $0x10,%esp
        ap++;
     5df:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
     5e3:	e9 d8 00 00 00       	jmp    6c0 <printf+0x170>
      } else if(c == 'x' || c == 'p'){
     5e8:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
     5ec:	74 06                	je     5f4 <printf+0xa4>
     5ee:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
     5f2:	75 1e                	jne    612 <printf+0xc2>
        printint(fd, *ap, 16, 0);
     5f4:	8b 45 e8             	mov    -0x18(%ebp),%eax
     5f7:	8b 00                	mov    (%eax),%eax
     5f9:	6a 00                	push   $0x0
     5fb:	6a 10                	push   $0x10
     5fd:	50                   	push   %eax
     5fe:	ff 75 08             	pushl  0x8(%ebp)
     601:	e8 96 fe ff ff       	call   49c <printint>
     606:	83 c4 10             	add    $0x10,%esp
        ap++;
     609:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
     60d:	e9 ae 00 00 00       	jmp    6c0 <printf+0x170>
      } else if(c == 's'){
     612:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
     616:	75 43                	jne    65b <printf+0x10b>
        s = (char*)*ap;
     618:	8b 45 e8             	mov    -0x18(%ebp),%eax
     61b:	8b 00                	mov    (%eax),%eax
     61d:	89 45 f4             	mov    %eax,-0xc(%ebp)
        ap++;
     620:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
        if(s == 0)
     624:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     628:	75 25                	jne    64f <printf+0xff>
          s = "(null)";
     62a:	c7 45 f4 c3 5e 01 00 	movl   $0x15ec3,-0xc(%ebp)
        while(*s != 0){
     631:	eb 1c                	jmp    64f <printf+0xff>
          putc(fd, *s);
     633:	8b 45 f4             	mov    -0xc(%ebp),%eax
     636:	0f b6 00             	movzbl (%eax),%eax
     639:	0f be c0             	movsbl %al,%eax
     63c:	83 ec 08             	sub    $0x8,%esp
     63f:	50                   	push   %eax
     640:	ff 75 08             	pushl  0x8(%ebp)
     643:	e8 31 fe ff ff       	call   479 <putc>
     648:	83 c4 10             	add    $0x10,%esp
          s++;
     64b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
      } else if(c == 's'){
        s = (char*)*ap;
        ap++;
        if(s == 0)
          s = "(null)";
        while(*s != 0){
     64f:	8b 45 f4             	mov    -0xc(%ebp),%eax
     652:	0f b6 00             	movzbl (%eax),%eax
     655:	84 c0                	test   %al,%al
     657:	75 da                	jne    633 <printf+0xe3>
     659:	eb 65                	jmp    6c0 <printf+0x170>
          putc(fd, *s);
          s++;
        }
      } else if(c == 'c'){
     65b:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
     65f:	75 1d                	jne    67e <printf+0x12e>
        putc(fd, *ap);
     661:	8b 45 e8             	mov    -0x18(%ebp),%eax
     664:	8b 00                	mov    (%eax),%eax
     666:	0f be c0             	movsbl %al,%eax
     669:	83 ec 08             	sub    $0x8,%esp
     66c:	50                   	push   %eax
     66d:	ff 75 08             	pushl  0x8(%ebp)
     670:	e8 04 fe ff ff       	call   479 <putc>
     675:	83 c4 10             	add    $0x10,%esp
        ap++;
     678:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
     67c:	eb 42                	jmp    6c0 <printf+0x170>
      } else if(c == '%'){
     67e:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
     682:	75 17                	jne    69b <printf+0x14b>
        putc(fd, c);
     684:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     687:	0f be c0             	movsbl %al,%eax
     68a:	83 ec 08             	sub    $0x8,%esp
     68d:	50                   	push   %eax
     68e:	ff 75 08             	pushl  0x8(%ebp)
     691:	e8 e3 fd ff ff       	call   479 <putc>
     696:	83 c4 10             	add    $0x10,%esp
     699:	eb 25                	jmp    6c0 <printf+0x170>
      } else {
        // Unknown % sequence.  Print it to draw attention.
        putc(fd, '%');
     69b:	83 ec 08             	sub    $0x8,%esp
     69e:	6a 25                	push   $0x25
     6a0:	ff 75 08             	pushl  0x8(%ebp)
     6a3:	e8 d1 fd ff ff       	call   479 <putc>
     6a8:	83 c4 10             	add    $0x10,%esp
        putc(fd, c);
     6ab:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     6ae:	0f be c0             	movsbl %al,%eax
     6b1:	83 ec 08             	sub    $0x8,%esp
     6b4:	50                   	push   %eax
     6b5:	ff 75 08             	pushl  0x8(%ebp)
     6b8:	e8 bc fd ff ff       	call   479 <putc>
     6bd:	83 c4 10             	add    $0x10,%esp
      }
      state = 0;
     6c0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  int c, i, state;
  uint *ap;

  state = 0;
  ap = (uint*)(void*)&fmt + 1;
  for(i = 0; fmt[i]; i++){
     6c7:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
     6cb:	8b 55 0c             	mov    0xc(%ebp),%edx
     6ce:	8b 45 f0             	mov    -0x10(%ebp),%eax
     6d1:	01 d0                	add    %edx,%eax
     6d3:	0f b6 00             	movzbl (%eax),%eax
     6d6:	84 c0                	test   %al,%al
     6d8:	0f 85 94 fe ff ff    	jne    572 <printf+0x22>
        putc(fd, c);
      }
      state = 0;
    }
  }
}
     6de:	90                   	nop
     6df:	c9                   	leave  
     6e0:	c3                   	ret    

000006e1 <free>:
static Header base;
static Header *freep;

void
free(void *ap)
{
     6e1:	55                   	push   %ebp
     6e2:	89 e5                	mov    %esp,%ebp
     6e4:	83 ec 10             	sub    $0x10,%esp
  Header *bp, *p;

  bp = (Header*)ap - 1;
     6e7:	8b 45 08             	mov    0x8(%ebp),%eax
     6ea:	83 e8 08             	sub    $0x8,%eax
     6ed:	89 45 f8             	mov    %eax,-0x8(%ebp)
  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
     6f0:	a1 08 e6 01 00       	mov    0x1e608,%eax
     6f5:	89 45 fc             	mov    %eax,-0x4(%ebp)
     6f8:	eb 24                	jmp    71e <free+0x3d>
    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
     6fa:	8b 45 fc             	mov    -0x4(%ebp),%eax
     6fd:	8b 00                	mov    (%eax),%eax
     6ff:	3b 45 fc             	cmp    -0x4(%ebp),%eax
     702:	77 12                	ja     716 <free+0x35>
     704:	8b 45 f8             	mov    -0x8(%ebp),%eax
     707:	3b 45 fc             	cmp    -0x4(%ebp),%eax
     70a:	77 24                	ja     730 <free+0x4f>
     70c:	8b 45 fc             	mov    -0x4(%ebp),%eax
     70f:	8b 00                	mov    (%eax),%eax
     711:	3b 45 f8             	cmp    -0x8(%ebp),%eax
     714:	77 1a                	ja     730 <free+0x4f>
free(void *ap)
{
  Header *bp, *p;

  bp = (Header*)ap - 1;
  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
     716:	8b 45 fc             	mov    -0x4(%ebp),%eax
     719:	8b 00                	mov    (%eax),%eax
     71b:	89 45 fc             	mov    %eax,-0x4(%ebp)
     71e:	8b 45 f8             	mov    -0x8(%ebp),%eax
     721:	3b 45 fc             	cmp    -0x4(%ebp),%eax
     724:	76 d4                	jbe    6fa <free+0x19>
     726:	8b 45 fc             	mov    -0x4(%ebp),%eax
     729:	8b 00                	mov    (%eax),%eax
     72b:	3b 45 f8             	cmp    -0x8(%ebp),%eax
     72e:	76 ca                	jbe    6fa <free+0x19>
    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
      break;
  if(bp + bp->s.size == p->s.ptr){
     730:	8b 45 f8             	mov    -0x8(%ebp),%eax
     733:	8b 40 04             	mov    0x4(%eax),%eax
     736:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
     73d:	8b 45 f8             	mov    -0x8(%ebp),%eax
     740:	01 c2                	add    %eax,%edx
     742:	8b 45 fc             	mov    -0x4(%ebp),%eax
     745:	8b 00                	mov    (%eax),%eax
     747:	39 c2                	cmp    %eax,%edx
     749:	75 24                	jne    76f <free+0x8e>
    bp->s.size += p->s.ptr->s.size;
     74b:	8b 45 f8             	mov    -0x8(%ebp),%eax
     74e:	8b 50 04             	mov    0x4(%eax),%edx
     751:	8b 45 fc             	mov    -0x4(%ebp),%eax
     754:	8b 00                	mov    (%eax),%eax
     756:	8b 40 04             	mov    0x4(%eax),%eax
     759:	01 c2                	add    %eax,%edx
     75b:	8b 45 f8             	mov    -0x8(%ebp),%eax
     75e:	89 50 04             	mov    %edx,0x4(%eax)
    bp->s.ptr = p->s.ptr->s.ptr;
     761:	8b 45 fc             	mov    -0x4(%ebp),%eax
     764:	8b 00                	mov    (%eax),%eax
     766:	8b 10                	mov    (%eax),%edx
     768:	8b 45 f8             	mov    -0x8(%ebp),%eax
     76b:	89 10                	mov    %edx,(%eax)
     76d:	eb 0a                	jmp    779 <free+0x98>
  } else
    bp->s.ptr = p->s.ptr;
     76f:	8b 45 fc             	mov    -0x4(%ebp),%eax
     772:	8b 10                	mov    (%eax),%edx
     774:	8b 45 f8             	mov    -0x8(%ebp),%eax
     777:	89 10                	mov    %edx,(%eax)
  if(p + p->s.size == bp){
     779:	8b 45 fc             	mov    -0x4(%ebp),%eax
     77c:	8b 40 04             	mov    0x4(%eax),%eax
     77f:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
     786:	8b 45 fc             	mov    -0x4(%ebp),%eax
     789:	01 d0                	add    %edx,%eax
     78b:	3b 45 f8             	cmp    -0x8(%ebp),%eax
     78e:	75 20                	jne    7b0 <free+0xcf>
    p->s.size += bp->s.size;
     790:	8b 45 fc             	mov    -0x4(%ebp),%eax
     793:	8b 50 04             	mov    0x4(%eax),%edx
     796:	8b 45 f8             	mov    -0x8(%ebp),%eax
     799:	8b 40 04             	mov    0x4(%eax),%eax
     79c:	01 c2                	add    %eax,%edx
     79e:	8b 45 fc             	mov    -0x4(%ebp),%eax
     7a1:	89 50 04             	mov    %edx,0x4(%eax)
    p->s.ptr = bp->s.ptr;
     7a4:	8b 45 f8             	mov    -0x8(%ebp),%eax
     7a7:	8b 10                	mov    (%eax),%edx
     7a9:	8b 45 fc             	mov    -0x4(%ebp),%eax
     7ac:	89 10                	mov    %edx,(%eax)
     7ae:	eb 08                	jmp    7b8 <free+0xd7>
  } else
    p->s.ptr = bp;
     7b0:	8b 45 fc             	mov    -0x4(%ebp),%eax
     7b3:	8b 55 f8             	mov    -0x8(%ebp),%edx
     7b6:	89 10                	mov    %edx,(%eax)
  freep = p;
     7b8:	8b 45 fc             	mov    -0x4(%ebp),%eax
     7bb:	a3 08 e6 01 00       	mov    %eax,0x1e608
}
     7c0:	90                   	nop
     7c1:	c9                   	leave  
     7c2:	c3                   	ret    

000007c3 <morecore>:

static Header*
morecore(uint nu)
{
     7c3:	55                   	push   %ebp
     7c4:	89 e5                	mov    %esp,%ebp
     7c6:	83 ec 18             	sub    $0x18,%esp
  char *p;
  Header *hp;

  if(nu < 4096)
     7c9:	81 7d 08 ff 0f 00 00 	cmpl   $0xfff,0x8(%ebp)
     7d0:	77 07                	ja     7d9 <morecore+0x16>
    nu = 4096;
     7d2:	c7 45 08 00 10 00 00 	movl   $0x1000,0x8(%ebp)
  p = sbrk(nu * sizeof(Header));
     7d9:	8b 45 08             	mov    0x8(%ebp),%eax
     7dc:	c1 e0 03             	shl    $0x3,%eax
     7df:	83 ec 0c             	sub    $0xc,%esp
     7e2:	50                   	push   %eax
     7e3:	e8 49 fc ff ff       	call   431 <sbrk>
     7e8:	83 c4 10             	add    $0x10,%esp
     7eb:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(p == (char*)-1)
     7ee:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
     7f2:	75 07                	jne    7fb <morecore+0x38>
    return 0;
     7f4:	b8 00 00 00 00       	mov    $0x0,%eax
     7f9:	eb 26                	jmp    821 <morecore+0x5e>
  hp = (Header*)p;
     7fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
     7fe:	89 45 f0             	mov    %eax,-0x10(%ebp)
  hp->s.size = nu;
     801:	8b 45 f0             	mov    -0x10(%ebp),%eax
     804:	8b 55 08             	mov    0x8(%ebp),%edx
     807:	89 50 04             	mov    %edx,0x4(%eax)
  free((void*)(hp + 1));
     80a:	8b 45 f0             	mov    -0x10(%ebp),%eax
     80d:	83 c0 08             	add    $0x8,%eax
     810:	83 ec 0c             	sub    $0xc,%esp
     813:	50                   	push   %eax
     814:	e8 c8 fe ff ff       	call   6e1 <free>
     819:	83 c4 10             	add    $0x10,%esp
  return freep;
     81c:	a1 08 e6 01 00       	mov    0x1e608,%eax
}
     821:	c9                   	leave  
     822:	c3                   	ret    

00000823 <malloc>:

void*
malloc(uint nbytes)
{
     823:	55                   	push   %ebp
     824:	89 e5                	mov    %esp,%ebp
     826:	83 ec 18             	sub    $0x18,%esp
  Header *p, *prevp;
  uint nunits;

  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
     829:	8b 45 08             	mov    0x8(%ebp),%eax
     82c:	83 c0 07             	add    $0x7,%eax
     82f:	c1 e8 03             	shr    $0x3,%eax
     832:	83 c0 01             	add    $0x1,%eax
     835:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if((prevp = freep) == 0){
     838:	a1 08 e6 01 00       	mov    0x1e608,%eax
     83d:	89 45 f0             	mov    %eax,-0x10(%ebp)
     840:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
     844:	75 23                	jne    869 <malloc+0x46>
    base.s.ptr = freep = prevp = &base;
     846:	c7 45 f0 00 e6 01 00 	movl   $0x1e600,-0x10(%ebp)
     84d:	8b 45 f0             	mov    -0x10(%ebp),%eax
     850:	a3 08 e6 01 00       	mov    %eax,0x1e608
     855:	a1 08 e6 01 00       	mov    0x1e608,%eax
     85a:	a3 00 e6 01 00       	mov    %eax,0x1e600
    base.s.size = 0;
     85f:	c7 05 04 e6 01 00 00 	movl   $0x0,0x1e604
     866:	00 00 00 
  }
  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
     869:	8b 45 f0             	mov    -0x10(%ebp),%eax
     86c:	8b 00                	mov    (%eax),%eax
     86e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(p->s.size >= nunits){
     871:	8b 45 f4             	mov    -0xc(%ebp),%eax
     874:	8b 40 04             	mov    0x4(%eax),%eax
     877:	3b 45 ec             	cmp    -0x14(%ebp),%eax
     87a:	72 4d                	jb     8c9 <malloc+0xa6>
      if(p->s.size == nunits)
     87c:	8b 45 f4             	mov    -0xc(%ebp),%eax
     87f:	8b 40 04             	mov    0x4(%eax),%eax
     882:	3b 45 ec             	cmp    -0x14(%ebp),%eax
     885:	75 0c                	jne    893 <malloc+0x70>
        prevp->s.ptr = p->s.ptr;
     887:	8b 45 f4             	mov    -0xc(%ebp),%eax
     88a:	8b 10                	mov    (%eax),%edx
     88c:	8b 45 f0             	mov    -0x10(%ebp),%eax
     88f:	89 10                	mov    %edx,(%eax)
     891:	eb 26                	jmp    8b9 <malloc+0x96>
      else {
        p->s.size -= nunits;
     893:	8b 45 f4             	mov    -0xc(%ebp),%eax
     896:	8b 40 04             	mov    0x4(%eax),%eax
     899:	2b 45 ec             	sub    -0x14(%ebp),%eax
     89c:	89 c2                	mov    %eax,%edx
     89e:	8b 45 f4             	mov    -0xc(%ebp),%eax
     8a1:	89 50 04             	mov    %edx,0x4(%eax)
        p += p->s.size;
     8a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
     8a7:	8b 40 04             	mov    0x4(%eax),%eax
     8aa:	c1 e0 03             	shl    $0x3,%eax
     8ad:	01 45 f4             	add    %eax,-0xc(%ebp)
        p->s.size = nunits;
     8b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
     8b3:	8b 55 ec             	mov    -0x14(%ebp),%edx
     8b6:	89 50 04             	mov    %edx,0x4(%eax)
      }
      freep = prevp;
     8b9:	8b 45 f0             	mov    -0x10(%ebp),%eax
     8bc:	a3 08 e6 01 00       	mov    %eax,0x1e608
      return (void*)(p + 1);
     8c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
     8c4:	83 c0 08             	add    $0x8,%eax
     8c7:	eb 3b                	jmp    904 <malloc+0xe1>
    }
    if(p == freep)
     8c9:	a1 08 e6 01 00       	mov    0x1e608,%eax
     8ce:	39 45 f4             	cmp    %eax,-0xc(%ebp)
     8d1:	75 1e                	jne    8f1 <malloc+0xce>
      if((p = morecore(nunits)) == 0)
     8d3:	83 ec 0c             	sub    $0xc,%esp
     8d6:	ff 75 ec             	pushl  -0x14(%ebp)
     8d9:	e8 e5 fe ff ff       	call   7c3 <morecore>
     8de:	83 c4 10             	add    $0x10,%esp
     8e1:	89 45 f4             	mov    %eax,-0xc(%ebp)
     8e4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     8e8:	75 07                	jne    8f1 <malloc+0xce>
        return 0;
     8ea:	b8 00 00 00 00       	mov    $0x0,%eax
     8ef:	eb 13                	jmp    904 <malloc+0xe1>
  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
  if((prevp = freep) == 0){
    base.s.ptr = freep = prevp = &base;
    base.s.size = 0;
  }
  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
     8f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
     8f4:	89 45 f0             	mov    %eax,-0x10(%ebp)
     8f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
     8fa:	8b 00                	mov    (%eax),%eax
     8fc:	89 45 f4             	mov    %eax,-0xc(%ebp)
      return (void*)(p + 1);
    }
    if(p == freep)
      if((p = morecore(nunits)) == 0)
        return 0;
  }
     8ff:	e9 6d ff ff ff       	jmp    871 <malloc+0x4e>
}
     904:	c9                   	leave  
     905:	c3                   	ret    

00000906 <fastrand>:
#include "math.h"

static unsigned int g_seed = 0;

int fastrand() {
     906:	55                   	push   %ebp
     907:	89 e5                	mov    %esp,%ebp
    ++g_seed;
     909:	a1 0c e6 01 00       	mov    0x1e60c,%eax
     90e:	83 c0 01             	add    $0x1,%eax
     911:	a3 0c e6 01 00       	mov    %eax,0x1e60c
    g_seed = (214013*g_seed+2531011);
     916:	a1 0c e6 01 00       	mov    0x1e60c,%eax
     91b:	69 c0 fd 43 03 00    	imul   $0x343fd,%eax,%eax
     921:	05 c3 9e 26 00       	add    $0x269ec3,%eax
     926:	a3 0c e6 01 00       	mov    %eax,0x1e60c
    return (g_seed>>16)&0x7FFF;
     92b:	a1 0c e6 01 00       	mov    0x1e60c,%eax
     930:	c1 e8 10             	shr    $0x10,%eax
     933:	25 ff 7f 00 00       	and    $0x7fff,%eax
}
     938:	5d                   	pop    %ebp
     939:	c3                   	ret    

0000093a <abs>:

#define PI 3.1415926536

float abs(float x) 
{
     93a:	55                   	push   %ebp
     93b:	89 e5                	mov    %esp,%ebp
	if (x > 0) return x;
     93d:	d9 45 08             	flds   0x8(%ebp)
     940:	d9 ee                	fldz   
     942:	d9 c9                	fxch   %st(1)
     944:	df e9                	fucomip %st(1),%st
     946:	dd d8                	fstp   %st(0)
     948:	76 05                	jbe    94f <abs+0x15>
     94a:	d9 45 08             	flds   0x8(%ebp)
     94d:	eb 05                	jmp    954 <abs+0x1a>
	return -x;
     94f:	d9 45 08             	flds   0x8(%ebp)
     952:	d9 e0                	fchs   
}
     954:	5d                   	pop    %ebp
     955:	c3                   	ret    

00000956 <pow>:

float pow(float a, int b)
{
     956:	55                   	push   %ebp
     957:	89 e5                	mov    %esp,%ebp
     959:	83 ec 10             	sub    $0x10,%esp
	float r = a;
     95c:	d9 45 08             	flds   0x8(%ebp)
     95f:	d9 5d fc             	fstps  -0x4(%ebp)
	if (b > 0) {
     962:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     966:	7e 17                	jle    97f <pow+0x29>
		while (--b)
     968:	eb 09                	jmp    973 <pow+0x1d>
			r *= a;
     96a:	d9 45 fc             	flds   -0x4(%ebp)
     96d:	d8 4d 08             	fmuls  0x8(%ebp)
     970:	d9 5d fc             	fstps  -0x4(%ebp)

float pow(float a, int b)
{
	float r = a;
	if (b > 0) {
		while (--b)
     973:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
     977:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     97b:	75 ed                	jne    96a <pow+0x14>
     97d:	eb 2a                	jmp    9a9 <pow+0x53>
			r *= a;
	}
	else if (b < 0) {
     97f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     983:	79 1f                	jns    9a4 <pow+0x4e>
		while (++b)
     985:	eb 09                	jmp    990 <pow+0x3a>
			r *= a;
     987:	d9 45 fc             	flds   -0x4(%ebp)
     98a:	d8 4d 08             	fmuls  0x8(%ebp)
     98d:	d9 5d fc             	fstps  -0x4(%ebp)
	if (b > 0) {
		while (--b)
			r *= a;
	}
	else if (b < 0) {
		while (++b)
     990:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
     994:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     998:	75 ed                	jne    987 <pow+0x31>
			r *= a;
		r = 1.0 / r;
     99a:	d9 e8                	fld1   
     99c:	d8 75 fc             	fdivs  -0x4(%ebp)
     99f:	d9 5d fc             	fstps  -0x4(%ebp)
     9a2:	eb 05                	jmp    9a9 <pow+0x53>
	}
	else r = 0;
     9a4:	d9 ee                	fldz   
     9a6:	d9 5d fc             	fstps  -0x4(%ebp)
	return r;
     9a9:	d9 45 fc             	flds   -0x4(%ebp)
}
     9ac:	c9                   	leave  
     9ad:	c3                   	ret    

000009ae <sqrt>:

float sqrt(float number) {
     9ae:	55                   	push   %ebp
     9af:	89 e5                	mov    %esp,%ebp
     9b1:	83 ec 10             	sub    $0x10,%esp
	float new_guess;
	float last_guess;

	if (number < 0) {
     9b4:	d9 ee                	fldz   
     9b6:	d9 45 08             	flds   0x8(%ebp)
     9b9:	d9 c9                	fxch   %st(1)
     9bb:	df e9                	fucomip %st(1),%st
     9bd:	dd d8                	fstp   %st(0)
     9bf:	76 06                	jbe    9c7 <sqrt+0x19>
		return -1;
     9c1:	d9 e8                	fld1   
     9c3:	d9 e0                	fchs   
     9c5:	eb 3a                	jmp    a01 <sqrt+0x53>
	}

	new_guess = 1;
     9c7:	d9 e8                	fld1   
     9c9:	d9 5d fc             	fstps  -0x4(%ebp)
	do {
		last_guess = new_guess;
     9cc:	d9 45 fc             	flds   -0x4(%ebp)
     9cf:	d9 5d f8             	fstps  -0x8(%ebp)
		new_guess = (last_guess + number / last_guess) / 2;
     9d2:	d9 45 08             	flds   0x8(%ebp)
     9d5:	d8 75 f8             	fdivs  -0x8(%ebp)
     9d8:	d8 45 f8             	fadds  -0x8(%ebp)
     9db:	d9 05 d0 5e 01 00    	flds   0x15ed0
     9e1:	de f9                	fdivrp %st,%st(1)
     9e3:	d9 5d fc             	fstps  -0x4(%ebp)
	} while (new_guess != last_guess);
     9e6:	d9 45 fc             	flds   -0x4(%ebp)
     9e9:	d9 45 f8             	flds   -0x8(%ebp)
     9ec:	df e9                	fucomip %st(1),%st
     9ee:	dd d8                	fstp   %st(0)
     9f0:	7a da                	jp     9cc <sqrt+0x1e>
     9f2:	d9 45 fc             	flds   -0x4(%ebp)
     9f5:	d9 45 f8             	flds   -0x8(%ebp)
     9f8:	df e9                	fucomip %st(1),%st
     9fa:	dd d8                	fstp   %st(0)
     9fc:	75 ce                	jne    9cc <sqrt+0x1e>

	return new_guess;
     9fe:	d9 45 fc             	flds   -0x4(%ebp)
}
     a01:	c9                   	leave  
     a02:	c3                   	ret    

00000a03 <cos>:

float cos(float x)
{
     a03:	55                   	push   %ebp
     a04:	89 e5                	mov    %esp,%ebp
     a06:	83 ec 28             	sub    $0x28,%esp
    float fl = 1;
     a09:	d9 e8                	fld1   
     a0b:	d9 5d f4             	fstps  -0xc(%ebp)
    if (x > 2 * PI || x < -2 * PI) x -= (int)(x / (2 * PI)) * 2 * PI;
     a0e:	d9 45 08             	flds   0x8(%ebp)
     a11:	dd 05 d8 5e 01 00    	fldl   0x15ed8
     a17:	d9 c9                	fxch   %st(1)
     a19:	df e9                	fucomip %st(1),%st
     a1b:	dd d8                	fstp   %st(0)
     a1d:	77 0f                	ja     a2e <cos+0x2b>
     a1f:	d9 45 08             	flds   0x8(%ebp)
     a22:	dd 05 e0 5e 01 00    	fldl   0x15ee0
     a28:	df e9                	fucomip %st(1),%st
     a2a:	dd d8                	fstp   %st(0)
     a2c:	76 3c                	jbe    a6a <cos+0x67>
     a2e:	d9 45 08             	flds   0x8(%ebp)
     a31:	d9 45 08             	flds   0x8(%ebp)
     a34:	dd 05 d8 5e 01 00    	fldl   0x15ed8
     a3a:	de f9                	fdivrp %st,%st(1)
     a3c:	d9 7d e2             	fnstcw -0x1e(%ebp)
     a3f:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
     a43:	b4 0c                	mov    $0xc,%ah
     a45:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
     a49:	d9 6d e0             	fldcw  -0x20(%ebp)
     a4c:	db 5d dc             	fistpl -0x24(%ebp)
     a4f:	d9 6d e2             	fldcw  -0x1e(%ebp)
     a52:	8b 45 dc             	mov    -0x24(%ebp),%eax
     a55:	01 c0                	add    %eax,%eax
     a57:	89 45 d8             	mov    %eax,-0x28(%ebp)
     a5a:	db 45 d8             	fildl  -0x28(%ebp)
     a5d:	dd 05 e8 5e 01 00    	fldl   0x15ee8
     a63:	de c9                	fmulp  %st,%st(1)
     a65:	de e9                	fsubrp %st,%st(1)
     a67:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI) x -= 2 * PI;
     a6a:	d9 45 08             	flds   0x8(%ebp)
     a6d:	dd 05 e8 5e 01 00    	fldl   0x15ee8
     a73:	d9 c9                	fxch   %st(1)
     a75:	df e9                	fucomip %st(1),%st
     a77:	dd d8                	fstp   %st(0)
     a79:	76 0e                	jbe    a89 <cos+0x86>
     a7b:	d9 45 08             	flds   0x8(%ebp)
     a7e:	dd 05 d8 5e 01 00    	fldl   0x15ed8
     a84:	de e9                	fsubrp %st,%st(1)
     a86:	d9 5d 08             	fstps  0x8(%ebp)
    if (x < -PI) x += 2 * PI;
     a89:	d9 45 08             	flds   0x8(%ebp)
     a8c:	dd 05 f0 5e 01 00    	fldl   0x15ef0
     a92:	df e9                	fucomip %st(1),%st
     a94:	dd d8                	fstp   %st(0)
     a96:	76 0e                	jbe    aa6 <cos+0xa3>
     a98:	d9 45 08             	flds   0x8(%ebp)
     a9b:	dd 05 d8 5e 01 00    	fldl   0x15ed8
     aa1:	de c1                	faddp  %st,%st(1)
     aa3:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI / 2)
     aa6:	d9 45 08             	flds   0x8(%ebp)
     aa9:	dd 05 f8 5e 01 00    	fldl   0x15ef8
     aaf:	d9 c9                	fxch   %st(1)
     ab1:	df e9                	fucomip %st(1),%st
     ab3:	dd d8                	fstp   %st(0)
     ab5:	76 16                	jbe    acd <cos+0xca>
    {
        x -= PI;
     ab7:	d9 45 08             	flds   0x8(%ebp)
     aba:	dd 05 e8 5e 01 00    	fldl   0x15ee8
     ac0:	de e9                	fsubrp %st,%st(1)
     ac2:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     ac5:	d9 45 f4             	flds   -0xc(%ebp)
     ac8:	d9 e0                	fchs   
     aca:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x < -PI / 2)
     acd:	d9 45 08             	flds   0x8(%ebp)
     ad0:	dd 05 00 5f 01 00    	fldl   0x15f00
     ad6:	df e9                	fucomip %st(1),%st
     ad8:	dd d8                	fstp   %st(0)
     ada:	76 16                	jbe    af2 <cos+0xef>
    {
        x += PI;
     adc:	d9 45 08             	flds   0x8(%ebp)
     adf:	dd 05 e8 5e 01 00    	fldl   0x15ee8
     ae5:	de c1                	faddp  %st,%st(1)
     ae7:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     aea:	d9 45 f4             	flds   -0xc(%ebp)
     aed:	d9 e0                	fchs   
     aef:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x > PI / 4) return fl * sin(PI / 2 - x);
     af2:	d9 45 08             	flds   0x8(%ebp)
     af5:	dd 05 08 5f 01 00    	fldl   0x15f08
     afb:	d9 c9                	fxch   %st(1)
     afd:	df e9                	fucomip %st(1),%st
     aff:	dd d8                	fstp   %st(0)
     b01:	76 28                	jbe    b2b <cos+0x128>
     b03:	d9 45 08             	flds   0x8(%ebp)
     b06:	dd 05 f8 5e 01 00    	fldl   0x15ef8
     b0c:	de e1                	fsubp  %st,%st(1)
     b0e:	d9 5d e4             	fstps  -0x1c(%ebp)
     b11:	d9 45 e4             	flds   -0x1c(%ebp)
     b14:	83 ec 0c             	sub    $0xc,%esp
     b17:	8d 64 24 fc          	lea    -0x4(%esp),%esp
     b1b:	d9 1c 24             	fstps  (%esp)
     b1e:	e8 83 00 00 00       	call   ba6 <sin>
     b23:	83 c4 10             	add    $0x10,%esp
     b26:	d8 4d f4             	fmuls  -0xc(%ebp)
     b29:	eb 79                	jmp    ba4 <cos+0x1a1>
    else return fl * (1 - pow(x, 2) / 2 + pow(x, 4) / 24 - pow(x, 6) / 720 + pow(x, 8) / 40320);//̩�չ�ʽ
     b2b:	83 ec 08             	sub    $0x8,%esp
     b2e:	6a 02                	push   $0x2
     b30:	ff 75 08             	pushl  0x8(%ebp)
     b33:	e8 1e fe ff ff       	call   956 <pow>
     b38:	83 c4 10             	add    $0x10,%esp
     b3b:	d9 05 d0 5e 01 00    	flds   0x15ed0
     b41:	de f9                	fdivrp %st,%st(1)
     b43:	d9 e8                	fld1   
     b45:	de e1                	fsubp  %st,%st(1)
     b47:	d9 5d d8             	fstps  -0x28(%ebp)
     b4a:	83 ec 08             	sub    $0x8,%esp
     b4d:	6a 04                	push   $0x4
     b4f:	ff 75 08             	pushl  0x8(%ebp)
     b52:	e8 ff fd ff ff       	call   956 <pow>
     b57:	83 c4 10             	add    $0x10,%esp
     b5a:	d9 05 10 5f 01 00    	flds   0x15f10
     b60:	de f9                	fdivrp %st,%st(1)
     b62:	d8 45 d8             	fadds  -0x28(%ebp)
     b65:	d9 5d d8             	fstps  -0x28(%ebp)
     b68:	83 ec 08             	sub    $0x8,%esp
     b6b:	6a 06                	push   $0x6
     b6d:	ff 75 08             	pushl  0x8(%ebp)
     b70:	e8 e1 fd ff ff       	call   956 <pow>
     b75:	83 c4 10             	add    $0x10,%esp
     b78:	d9 05 14 5f 01 00    	flds   0x15f14
     b7e:	de f9                	fdivrp %st,%st(1)
     b80:	d8 6d d8             	fsubrs -0x28(%ebp)
     b83:	d9 5d d8             	fstps  -0x28(%ebp)
     b86:	83 ec 08             	sub    $0x8,%esp
     b89:	6a 08                	push   $0x8
     b8b:	ff 75 08             	pushl  0x8(%ebp)
     b8e:	e8 c3 fd ff ff       	call   956 <pow>
     b93:	83 c4 10             	add    $0x10,%esp
     b96:	d9 05 18 5f 01 00    	flds   0x15f18
     b9c:	de f9                	fdivrp %st,%st(1)
     b9e:	d8 45 d8             	fadds  -0x28(%ebp)
     ba1:	d8 4d f4             	fmuls  -0xc(%ebp)
}
     ba4:	c9                   	leave  
     ba5:	c3                   	ret    

00000ba6 <sin>:

float sin(float x)
{
     ba6:	55                   	push   %ebp
     ba7:	89 e5                	mov    %esp,%ebp
     ba9:	83 ec 28             	sub    $0x28,%esp
    float fl = 1;
     bac:	d9 e8                	fld1   
     bae:	d9 5d f4             	fstps  -0xc(%ebp)
    if (x > 2 * PI || x < -2 * PI) x -= (int)(x / (2 * PI)) * 2 * PI;
     bb1:	d9 45 08             	flds   0x8(%ebp)
     bb4:	dd 05 d8 5e 01 00    	fldl   0x15ed8
     bba:	d9 c9                	fxch   %st(1)
     bbc:	df e9                	fucomip %st(1),%st
     bbe:	dd d8                	fstp   %st(0)
     bc0:	77 0f                	ja     bd1 <sin+0x2b>
     bc2:	d9 45 08             	flds   0x8(%ebp)
     bc5:	dd 05 e0 5e 01 00    	fldl   0x15ee0
     bcb:	df e9                	fucomip %st(1),%st
     bcd:	dd d8                	fstp   %st(0)
     bcf:	76 3c                	jbe    c0d <sin+0x67>
     bd1:	d9 45 08             	flds   0x8(%ebp)
     bd4:	d9 45 08             	flds   0x8(%ebp)
     bd7:	dd 05 d8 5e 01 00    	fldl   0x15ed8
     bdd:	de f9                	fdivrp %st,%st(1)
     bdf:	d9 7d e2             	fnstcw -0x1e(%ebp)
     be2:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
     be6:	b4 0c                	mov    $0xc,%ah
     be8:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
     bec:	d9 6d e0             	fldcw  -0x20(%ebp)
     bef:	db 5d dc             	fistpl -0x24(%ebp)
     bf2:	d9 6d e2             	fldcw  -0x1e(%ebp)
     bf5:	8b 45 dc             	mov    -0x24(%ebp),%eax
     bf8:	01 c0                	add    %eax,%eax
     bfa:	89 45 d8             	mov    %eax,-0x28(%ebp)
     bfd:	db 45 d8             	fildl  -0x28(%ebp)
     c00:	dd 05 e8 5e 01 00    	fldl   0x15ee8
     c06:	de c9                	fmulp  %st,%st(1)
     c08:	de e9                	fsubrp %st,%st(1)
     c0a:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI) x -= 2 * PI;
     c0d:	d9 45 08             	flds   0x8(%ebp)
     c10:	dd 05 e8 5e 01 00    	fldl   0x15ee8
     c16:	d9 c9                	fxch   %st(1)
     c18:	df e9                	fucomip %st(1),%st
     c1a:	dd d8                	fstp   %st(0)
     c1c:	76 0e                	jbe    c2c <sin+0x86>
     c1e:	d9 45 08             	flds   0x8(%ebp)
     c21:	dd 05 d8 5e 01 00    	fldl   0x15ed8
     c27:	de e9                	fsubrp %st,%st(1)
     c29:	d9 5d 08             	fstps  0x8(%ebp)
    if (x < -PI) x += 2 * PI;
     c2c:	d9 45 08             	flds   0x8(%ebp)
     c2f:	dd 05 f0 5e 01 00    	fldl   0x15ef0
     c35:	df e9                	fucomip %st(1),%st
     c37:	dd d8                	fstp   %st(0)
     c39:	76 0e                	jbe    c49 <sin+0xa3>
     c3b:	d9 45 08             	flds   0x8(%ebp)
     c3e:	dd 05 d8 5e 01 00    	fldl   0x15ed8
     c44:	de c1                	faddp  %st,%st(1)
     c46:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI / 2)
     c49:	d9 45 08             	flds   0x8(%ebp)
     c4c:	dd 05 f8 5e 01 00    	fldl   0x15ef8
     c52:	d9 c9                	fxch   %st(1)
     c54:	df e9                	fucomip %st(1),%st
     c56:	dd d8                	fstp   %st(0)
     c58:	76 16                	jbe    c70 <sin+0xca>
    {
        x -= PI;
     c5a:	d9 45 08             	flds   0x8(%ebp)
     c5d:	dd 05 e8 5e 01 00    	fldl   0x15ee8
     c63:	de e9                	fsubrp %st,%st(1)
     c65:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     c68:	d9 45 f4             	flds   -0xc(%ebp)
     c6b:	d9 e0                	fchs   
     c6d:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x < -PI / 2)
     c70:	d9 45 08             	flds   0x8(%ebp)
     c73:	dd 05 00 5f 01 00    	fldl   0x15f00
     c79:	df e9                	fucomip %st(1),%st
     c7b:	dd d8                	fstp   %st(0)
     c7d:	76 16                	jbe    c95 <sin+0xef>
    {
        x += PI;
     c7f:	d9 45 08             	flds   0x8(%ebp)
     c82:	dd 05 e8 5e 01 00    	fldl   0x15ee8
     c88:	de c1                	faddp  %st,%st(1)
     c8a:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     c8d:	d9 45 f4             	flds   -0xc(%ebp)
     c90:	d9 e0                	fchs   
     c92:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x < 0)
     c95:	d9 ee                	fldz   
     c97:	d9 45 08             	flds   0x8(%ebp)
     c9a:	d9 c9                	fxch   %st(1)
     c9c:	df e9                	fucomip %st(1),%st
     c9e:	dd d8                	fstp   %st(0)
     ca0:	76 10                	jbe    cb2 <sin+0x10c>
    {
        x *= -1;
     ca2:	d9 45 08             	flds   0x8(%ebp)
     ca5:	d9 e0                	fchs   
     ca7:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     caa:	d9 45 f4             	flds   -0xc(%ebp)
     cad:	d9 e0                	fchs   
     caf:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x > PI / 4) return fl * cos(PI / 2 - x);
     cb2:	d9 45 08             	flds   0x8(%ebp)
     cb5:	dd 05 08 5f 01 00    	fldl   0x15f08
     cbb:	d9 c9                	fxch   %st(1)
     cbd:	df e9                	fucomip %st(1),%st
     cbf:	dd d8                	fstp   %st(0)
     cc1:	76 28                	jbe    ceb <sin+0x145>
     cc3:	d9 45 08             	flds   0x8(%ebp)
     cc6:	dd 05 f8 5e 01 00    	fldl   0x15ef8
     ccc:	de e1                	fsubp  %st,%st(1)
     cce:	d9 5d e4             	fstps  -0x1c(%ebp)
     cd1:	d9 45 e4             	flds   -0x1c(%ebp)
     cd4:	83 ec 0c             	sub    $0xc,%esp
     cd7:	8d 64 24 fc          	lea    -0x4(%esp),%esp
     cdb:	d9 1c 24             	fstps  (%esp)
     cde:	e8 20 fd ff ff       	call   a03 <cos>
     ce3:	83 c4 10             	add    $0x10,%esp
     ce6:	d8 4d f4             	fmuls  -0xc(%ebp)
     ce9:	eb 7a                	jmp    d65 <sin+0x1bf>
    else return fl * (x - pow(x, 3) / 6 + pow(x, 5) / 120 - pow(x, 7) / 5040 + pow(x, 9) / 362880);//̩�չ�ʽ
     ceb:	83 ec 08             	sub    $0x8,%esp
     cee:	6a 03                	push   $0x3
     cf0:	ff 75 08             	pushl  0x8(%ebp)
     cf3:	e8 5e fc ff ff       	call   956 <pow>
     cf8:	83 c4 10             	add    $0x10,%esp
     cfb:	d9 05 1c 5f 01 00    	flds   0x15f1c
     d01:	de f9                	fdivrp %st,%st(1)
     d03:	d9 45 08             	flds   0x8(%ebp)
     d06:	de e1                	fsubp  %st,%st(1)
     d08:	d9 5d d8             	fstps  -0x28(%ebp)
     d0b:	83 ec 08             	sub    $0x8,%esp
     d0e:	6a 05                	push   $0x5
     d10:	ff 75 08             	pushl  0x8(%ebp)
     d13:	e8 3e fc ff ff       	call   956 <pow>
     d18:	83 c4 10             	add    $0x10,%esp
     d1b:	d9 05 20 5f 01 00    	flds   0x15f20
     d21:	de f9                	fdivrp %st,%st(1)
     d23:	d8 45 d8             	fadds  -0x28(%ebp)
     d26:	d9 5d d8             	fstps  -0x28(%ebp)
     d29:	83 ec 08             	sub    $0x8,%esp
     d2c:	6a 07                	push   $0x7
     d2e:	ff 75 08             	pushl  0x8(%ebp)
     d31:	e8 20 fc ff ff       	call   956 <pow>
     d36:	83 c4 10             	add    $0x10,%esp
     d39:	d9 05 24 5f 01 00    	flds   0x15f24
     d3f:	de f9                	fdivrp %st,%st(1)
     d41:	d8 6d d8             	fsubrs -0x28(%ebp)
     d44:	d9 5d d8             	fstps  -0x28(%ebp)
     d47:	83 ec 08             	sub    $0x8,%esp
     d4a:	6a 09                	push   $0x9
     d4c:	ff 75 08             	pushl  0x8(%ebp)
     d4f:	e8 02 fc ff ff       	call   956 <pow>
     d54:	83 c4 10             	add    $0x10,%esp
     d57:	d9 05 28 5f 01 00    	flds   0x15f28
     d5d:	de f9                	fdivrp %st,%st(1)
     d5f:	d8 45 d8             	fadds  -0x28(%ebp)
     d62:	d8 4d f4             	fmuls  -0xc(%ebp)
}
     d65:	c9                   	leave  
     d66:	c3                   	ret    

00000d67 <readBitmapHeader>:
#include "user.h"
#include "x86.h"
#include "gui_base.h"
#include "bitmap.h"

void readBitmapHeader(int bmpFile, BITMAP_FILE_HEADER *bmpFileHeader, BITMAP_INFO_HEADER *bmpInfoHeader) {
     d67:	55                   	push   %ebp
     d68:	89 e5                	mov    %esp,%ebp
     d6a:	83 ec 08             	sub    $0x8,%esp
    // Read Bitmap file header
    read(bmpFile, bmpFileHeader, sizeof(BITMAP_FILE_HEADER));
     d6d:	83 ec 04             	sub    $0x4,%esp
     d70:	6a 0e                	push   $0xe
     d72:	ff 75 0c             	pushl  0xc(%ebp)
     d75:	ff 75 08             	pushl  0x8(%ebp)
     d78:	e8 44 f6 ff ff       	call   3c1 <read>
     d7d:	83 c4 10             	add    $0x10,%esp
    // Read Bitmap info header
    read(bmpFile, bmpInfoHeader, sizeof(BITMAP_INFO_HEADER));
     d80:	83 ec 04             	sub    $0x4,%esp
     d83:	6a 28                	push   $0x28
     d85:	ff 75 10             	pushl  0x10(%ebp)
     d88:	ff 75 08             	pushl  0x8(%ebp)
     d8b:	e8 31 f6 ff ff       	call   3c1 <read>
     d90:	83 c4 10             	add    $0x10,%esp
}
     d93:	90                   	nop
     d94:	c9                   	leave  
     d95:	c3                   	ret    

00000d96 <readBitmapFile>:

int readBitmapFile(char *fileName, RGBA *result, int *height, int *width) {
     d96:	55                   	push   %ebp
     d97:	89 e5                	mov    %esp,%ebp
     d99:	81 ec c8 00 00 00    	sub    $0xc8,%esp
    int i;
    int bmpFile = open(fileName, 0);
     d9f:	83 ec 08             	sub    $0x8,%esp
     da2:	6a 00                	push   $0x0
     da4:	ff 75 08             	pushl  0x8(%ebp)
     da7:	e8 3d f6 ff ff       	call   3e9 <open>
     dac:	83 c4 10             	add    $0x10,%esp
     daf:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (bmpFile < 0) {
     db2:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
     db6:	79 0a                	jns    dc2 <readBitmapFile+0x2c>
        return -1;
     db8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
     dbd:	e9 6e 01 00 00       	jmp    f30 <readBitmapFile+0x19a>
    }

    BITMAP_FILE_HEADER bmpFileHeader;
    BITMAP_INFO_HEADER bmpInfoHeader;

    readBitmapHeader(bmpFile, &bmpFileHeader, &bmpInfoHeader);
     dc2:	83 ec 04             	sub    $0x4,%esp
     dc5:	8d 45 a2             	lea    -0x5e(%ebp),%eax
     dc8:	50                   	push   %eax
     dc9:	8d 45 ca             	lea    -0x36(%ebp),%eax
     dcc:	50                   	push   %eax
     dcd:	ff 75 ec             	pushl  -0x14(%ebp)
     dd0:	e8 92 ff ff ff       	call   d67 <readBitmapHeader>
     dd5:	83 c4 10             	add    $0x10,%esp
    char headerbuf[100];
    read(bmpFile, headerbuf, bmpFileHeader.btOffBits - 54); // read out the extra header
     dd8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
     ddb:	83 e8 36             	sub    $0x36,%eax
     dde:	83 ec 04             	sub    $0x4,%esp
     de1:	50                   	push   %eax
     de2:	8d 85 3e ff ff ff    	lea    -0xc2(%ebp),%eax
     de8:	50                   	push   %eax
     de9:	ff 75 ec             	pushl  -0x14(%ebp)
     dec:	e8 d0 f5 ff ff       	call   3c1 <read>
     df1:	83 c4 10             	add    $0x10,%esp
    *width = bmpInfoHeader.biWidth;
     df4:	8b 55 a6             	mov    -0x5a(%ebp),%edx
     df7:	8b 45 14             	mov    0x14(%ebp),%eax
     dfa:	89 10                	mov    %edx,(%eax)
    *height = bmpInfoHeader.biHeight;
     dfc:	8b 55 aa             	mov    -0x56(%ebp),%edx
     dff:	8b 45 10             	mov    0x10(%ebp),%eax
     e02:	89 10                	mov    %edx,(%eax)
    int column = bmpInfoHeader.biWidth;
     e04:	8b 45 a6             	mov    -0x5a(%ebp),%eax
     e07:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int row = bmpInfoHeader.biHeight;
     e0a:	8b 45 aa             	mov    -0x56(%ebp),%eax
     e0d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    int bits = bmpInfoHeader.biBitCount;
     e10:	0f b7 45 b0          	movzwl -0x50(%ebp),%eax
     e14:	0f b7 c0             	movzwl %ax,%eax
     e17:	89 45 e0             	mov    %eax,-0x20(%ebp)
    char tmpBytes[3];
    int rowBytes = column * bits / 8;
     e1a:	8b 45 e8             	mov    -0x18(%ebp),%eax
     e1d:	0f af 45 e0          	imul   -0x20(%ebp),%eax
     e21:	8d 50 07             	lea    0x7(%eax),%edx
     e24:	85 c0                	test   %eax,%eax
     e26:	0f 48 c2             	cmovs  %edx,%eax
     e29:	c1 f8 03             	sar    $0x3,%eax
     e2c:	89 45 dc             	mov    %eax,-0x24(%ebp)
    char *buf = (char *) result;
     e2f:	8b 45 0c             	mov    0xc(%ebp),%eax
     e32:	89 45 d8             	mov    %eax,-0x28(%ebp)
    for (i = row - 1; i >= 0; i--) {
     e35:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     e38:	83 e8 01             	sub    $0x1,%eax
     e3b:	89 45 f4             	mov    %eax,-0xc(%ebp)
     e3e:	e9 d0 00 00 00       	jmp    f13 <readBitmapFile+0x17d>
        if (bits == 32) {
     e43:	83 7d e0 20          	cmpl   $0x20,-0x20(%ebp)
     e47:	75 22                	jne    e6b <readBitmapFile+0xd5>
            read(bmpFile, buf + i * rowBytes, rowBytes);
     e49:	8b 45 f4             	mov    -0xc(%ebp),%eax
     e4c:	0f af 45 dc          	imul   -0x24(%ebp),%eax
     e50:	89 c2                	mov    %eax,%edx
     e52:	8b 45 d8             	mov    -0x28(%ebp),%eax
     e55:	01 d0                	add    %edx,%eax
     e57:	83 ec 04             	sub    $0x4,%esp
     e5a:	ff 75 dc             	pushl  -0x24(%ebp)
     e5d:	50                   	push   %eax
     e5e:	ff 75 ec             	pushl  -0x14(%ebp)
     e61:	e8 5b f5 ff ff       	call   3c1 <read>
     e66:	83 c4 10             	add    $0x10,%esp
     e69:	eb 65                	jmp    ed0 <readBitmapFile+0x13a>
        } else {
            int j = 0;
     e6b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
            for (j = 0; j < column; j++) {
     e72:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
     e79:	eb 4d                	jmp    ec8 <readBitmapFile+0x132>
                read(bmpFile, buf + i * column * 4 + j * sizeof(RGBA), 3);
     e7b:	8b 45 f4             	mov    -0xc(%ebp),%eax
     e7e:	0f af 45 e8          	imul   -0x18(%ebp),%eax
     e82:	c1 e0 02             	shl    $0x2,%eax
     e85:	89 c2                	mov    %eax,%edx
     e87:	8b 45 f0             	mov    -0x10(%ebp),%eax
     e8a:	c1 e0 02             	shl    $0x2,%eax
     e8d:	01 c2                	add    %eax,%edx
     e8f:	8b 45 d8             	mov    -0x28(%ebp),%eax
     e92:	01 d0                	add    %edx,%eax
     e94:	83 ec 04             	sub    $0x4,%esp
     e97:	6a 03                	push   $0x3
     e99:	50                   	push   %eax
     e9a:	ff 75 ec             	pushl  -0x14(%ebp)
     e9d:	e8 1f f5 ff ff       	call   3c1 <read>
     ea2:	83 c4 10             	add    $0x10,%esp
                *(buf + i * column * 4 + j * sizeof(RGBA) + 3) = 255;
     ea5:	8b 45 f4             	mov    -0xc(%ebp),%eax
     ea8:	0f af 45 e8          	imul   -0x18(%ebp),%eax
     eac:	c1 e0 02             	shl    $0x2,%eax
     eaf:	89 c2                	mov    %eax,%edx
     eb1:	8b 45 f0             	mov    -0x10(%ebp),%eax
     eb4:	c1 e0 02             	shl    $0x2,%eax
     eb7:	01 d0                	add    %edx,%eax
     eb9:	8d 50 03             	lea    0x3(%eax),%edx
     ebc:	8b 45 d8             	mov    -0x28(%ebp),%eax
     ebf:	01 d0                	add    %edx,%eax
     ec1:	c6 00 ff             	movb   $0xff,(%eax)
    for (i = row - 1; i >= 0; i--) {
        if (bits == 32) {
            read(bmpFile, buf + i * rowBytes, rowBytes);
        } else {
            int j = 0;
            for (j = 0; j < column; j++) {
     ec4:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
     ec8:	8b 45 f0             	mov    -0x10(%ebp),%eax
     ecb:	3b 45 e8             	cmp    -0x18(%ebp),%eax
     ece:	7c ab                	jl     e7b <readBitmapFile+0xe5>
                read(bmpFile, buf + i * column * 4 + j * sizeof(RGBA), 3);
                *(buf + i * column * 4 + j * sizeof(RGBA) + 3) = 255;
            }
        }
        if (rowBytes % 4 > 0) {
     ed0:	8b 45 dc             	mov    -0x24(%ebp),%eax
     ed3:	99                   	cltd   
     ed4:	c1 ea 1e             	shr    $0x1e,%edx
     ed7:	01 d0                	add    %edx,%eax
     ed9:	83 e0 03             	and    $0x3,%eax
     edc:	29 d0                	sub    %edx,%eax
     ede:	85 c0                	test   %eax,%eax
     ee0:	7e 2d                	jle    f0f <readBitmapFile+0x179>
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
     ee2:	8b 45 dc             	mov    -0x24(%ebp),%eax
     ee5:	99                   	cltd   
     ee6:	c1 ea 1e             	shr    $0x1e,%edx
     ee9:	01 d0                	add    %edx,%eax
     eeb:	83 e0 03             	and    $0x3,%eax
     eee:	29 d0                	sub    %edx,%eax
     ef0:	ba 04 00 00 00       	mov    $0x4,%edx
     ef5:	29 c2                	sub    %eax,%edx
     ef7:	89 d0                	mov    %edx,%eax
     ef9:	83 ec 04             	sub    $0x4,%esp
     efc:	50                   	push   %eax
     efd:	8d 85 3b ff ff ff    	lea    -0xc5(%ebp),%eax
     f03:	50                   	push   %eax
     f04:	ff 75 ec             	pushl  -0x14(%ebp)
     f07:	e8 b5 f4 ff ff       	call   3c1 <read>
     f0c:	83 c4 10             	add    $0x10,%esp
    int row = bmpInfoHeader.biHeight;
    int bits = bmpInfoHeader.biBitCount;
    char tmpBytes[3];
    int rowBytes = column * bits / 8;
    char *buf = (char *) result;
    for (i = row - 1; i >= 0; i--) {
     f0f:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
     f13:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     f17:	0f 89 26 ff ff ff    	jns    e43 <readBitmapFile+0xad>
        if (rowBytes % 4 > 0) {
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
        }
    }

    close(bmpFile);
     f1d:	83 ec 0c             	sub    $0xc,%esp
     f20:	ff 75 ec             	pushl  -0x14(%ebp)
     f23:	e8 a9 f4 ff ff       	call   3d1 <close>
     f28:	83 c4 10             	add    $0x10,%esp
    return 0;
     f2b:	b8 00 00 00 00       	mov    $0x0,%eax
}
     f30:	c9                   	leave  
     f31:	c3                   	ret    

00000f32 <read24BitmapFile>:

int read24BitmapFile(char *fileName, RGB *result, int *height, int *width) {
     f32:	55                   	push   %ebp
     f33:	89 e5                	mov    %esp,%ebp
     f35:	81 ec c8 00 00 00    	sub    $0xc8,%esp
    int i;
    int bmpFile = open(fileName, 0);
     f3b:	83 ec 08             	sub    $0x8,%esp
     f3e:	6a 00                	push   $0x0
     f40:	ff 75 08             	pushl  0x8(%ebp)
     f43:	e8 a1 f4 ff ff       	call   3e9 <open>
     f48:	83 c4 10             	add    $0x10,%esp
     f4b:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (bmpFile < 0) {
     f4e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
     f52:	79 0a                	jns    f5e <read24BitmapFile+0x2c>
        return -1;
     f54:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
     f59:	e9 66 01 00 00       	jmp    10c4 <read24BitmapFile+0x192>
    }

    BITMAP_FILE_HEADER bmpFileHeader;
    BITMAP_INFO_HEADER bmpInfoHeader;

    readBitmapHeader(bmpFile, &bmpFileHeader, &bmpInfoHeader);
     f5e:	83 ec 04             	sub    $0x4,%esp
     f61:	8d 45 a2             	lea    -0x5e(%ebp),%eax
     f64:	50                   	push   %eax
     f65:	8d 45 ca             	lea    -0x36(%ebp),%eax
     f68:	50                   	push   %eax
     f69:	ff 75 ec             	pushl  -0x14(%ebp)
     f6c:	e8 f6 fd ff ff       	call   d67 <readBitmapHeader>
     f71:	83 c4 10             	add    $0x10,%esp
    char headerbuf[100];
    read(bmpFile, headerbuf, bmpFileHeader.btOffBits - 54); // read out the extra header
     f74:	8b 45 d4             	mov    -0x2c(%ebp),%eax
     f77:	83 e8 36             	sub    $0x36,%eax
     f7a:	83 ec 04             	sub    $0x4,%esp
     f7d:	50                   	push   %eax
     f7e:	8d 85 3e ff ff ff    	lea    -0xc2(%ebp),%eax
     f84:	50                   	push   %eax
     f85:	ff 75 ec             	pushl  -0x14(%ebp)
     f88:	e8 34 f4 ff ff       	call   3c1 <read>
     f8d:	83 c4 10             	add    $0x10,%esp
    *width = bmpInfoHeader.biWidth;
     f90:	8b 55 a6             	mov    -0x5a(%ebp),%edx
     f93:	8b 45 14             	mov    0x14(%ebp),%eax
     f96:	89 10                	mov    %edx,(%eax)
    *height = bmpInfoHeader.biHeight;
     f98:	8b 55 aa             	mov    -0x56(%ebp),%edx
     f9b:	8b 45 10             	mov    0x10(%ebp),%eax
     f9e:	89 10                	mov    %edx,(%eax)
    int column = bmpInfoHeader.biWidth;
     fa0:	8b 45 a6             	mov    -0x5a(%ebp),%eax
     fa3:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int row = bmpInfoHeader.biHeight;
     fa6:	8b 45 aa             	mov    -0x56(%ebp),%eax
     fa9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    int bits = bmpInfoHeader.biBitCount;
     fac:	0f b7 45 b0          	movzwl -0x50(%ebp),%eax
     fb0:	0f b7 c0             	movzwl %ax,%eax
     fb3:	89 45 e0             	mov    %eax,-0x20(%ebp)
    char tmpBytes[3];
    int rowBytes = column * 3;
     fb6:	8b 55 e8             	mov    -0x18(%ebp),%edx
     fb9:	89 d0                	mov    %edx,%eax
     fbb:	01 c0                	add    %eax,%eax
     fbd:	01 d0                	add    %edx,%eax
     fbf:	89 45 dc             	mov    %eax,-0x24(%ebp)
    char *buf = (char *) result;
     fc2:	8b 45 0c             	mov    0xc(%ebp),%eax
     fc5:	89 45 d8             	mov    %eax,-0x28(%ebp)
    for (i = row - 1; i >= 0; i--) {
     fc8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     fcb:	83 e8 01             	sub    $0x1,%eax
     fce:	89 45 f4             	mov    %eax,-0xc(%ebp)
     fd1:	e9 d1 00 00 00       	jmp    10a7 <read24BitmapFile+0x175>
        if (bits == 24) {
     fd6:	83 7d e0 18          	cmpl   $0x18,-0x20(%ebp)
     fda:	75 22                	jne    ffe <read24BitmapFile+0xcc>
            read(bmpFile, buf + i * rowBytes, rowBytes);
     fdc:	8b 45 f4             	mov    -0xc(%ebp),%eax
     fdf:	0f af 45 dc          	imul   -0x24(%ebp),%eax
     fe3:	89 c2                	mov    %eax,%edx
     fe5:	8b 45 d8             	mov    -0x28(%ebp),%eax
     fe8:	01 d0                	add    %edx,%eax
     fea:	83 ec 04             	sub    $0x4,%esp
     fed:	ff 75 dc             	pushl  -0x24(%ebp)
     ff0:	50                   	push   %eax
     ff1:	ff 75 ec             	pushl  -0x14(%ebp)
     ff4:	e8 c8 f3 ff ff       	call   3c1 <read>
     ff9:	83 c4 10             	add    $0x10,%esp
     ffc:	eb 66                	jmp    1064 <read24BitmapFile+0x132>
        } else {
            int j = 0;
     ffe:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
            for (j = 0; j < column; j++) {
    1005:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    100c:	eb 4e                	jmp    105c <read24BitmapFile+0x12a>
                read(bmpFile, buf + i * column * 3 + j * sizeof(RGB), 3);
    100e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1011:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    1015:	89 c2                	mov    %eax,%edx
    1017:	89 d0                	mov    %edx,%eax
    1019:	01 c0                	add    %eax,%eax
    101b:	01 d0                	add    %edx,%eax
    101d:	89 c1                	mov    %eax,%ecx
    101f:	8b 55 f0             	mov    -0x10(%ebp),%edx
    1022:	89 d0                	mov    %edx,%eax
    1024:	01 c0                	add    %eax,%eax
    1026:	01 d0                	add    %edx,%eax
    1028:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    102b:	8b 45 d8             	mov    -0x28(%ebp),%eax
    102e:	01 d0                	add    %edx,%eax
    1030:	83 ec 04             	sub    $0x4,%esp
    1033:	6a 03                	push   $0x3
    1035:	50                   	push   %eax
    1036:	ff 75 ec             	pushl  -0x14(%ebp)
    1039:	e8 83 f3 ff ff       	call   3c1 <read>
    103e:	83 c4 10             	add    $0x10,%esp
                read(bmpFile, tmpBytes, 1);
    1041:	83 ec 04             	sub    $0x4,%esp
    1044:	6a 01                	push   $0x1
    1046:	8d 85 3b ff ff ff    	lea    -0xc5(%ebp),%eax
    104c:	50                   	push   %eax
    104d:	ff 75 ec             	pushl  -0x14(%ebp)
    1050:	e8 6c f3 ff ff       	call   3c1 <read>
    1055:	83 c4 10             	add    $0x10,%esp
    for (i = row - 1; i >= 0; i--) {
        if (bits == 24) {
            read(bmpFile, buf + i * rowBytes, rowBytes);
        } else {
            int j = 0;
            for (j = 0; j < column; j++) {
    1058:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    105c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    105f:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    1062:	7c aa                	jl     100e <read24BitmapFile+0xdc>
                read(bmpFile, buf + i * column * 3 + j * sizeof(RGB), 3);
                read(bmpFile, tmpBytes, 1);
            }
        }

        if (rowBytes % 4 > 0) {
    1064:	8b 45 dc             	mov    -0x24(%ebp),%eax
    1067:	99                   	cltd   
    1068:	c1 ea 1e             	shr    $0x1e,%edx
    106b:	01 d0                	add    %edx,%eax
    106d:	83 e0 03             	and    $0x3,%eax
    1070:	29 d0                	sub    %edx,%eax
    1072:	85 c0                	test   %eax,%eax
    1074:	7e 2d                	jle    10a3 <read24BitmapFile+0x171>
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
    1076:	8b 45 dc             	mov    -0x24(%ebp),%eax
    1079:	99                   	cltd   
    107a:	c1 ea 1e             	shr    $0x1e,%edx
    107d:	01 d0                	add    %edx,%eax
    107f:	83 e0 03             	and    $0x3,%eax
    1082:	29 d0                	sub    %edx,%eax
    1084:	ba 04 00 00 00       	mov    $0x4,%edx
    1089:	29 c2                	sub    %eax,%edx
    108b:	89 d0                	mov    %edx,%eax
    108d:	83 ec 04             	sub    $0x4,%esp
    1090:	50                   	push   %eax
    1091:	8d 85 3b ff ff ff    	lea    -0xc5(%ebp),%eax
    1097:	50                   	push   %eax
    1098:	ff 75 ec             	pushl  -0x14(%ebp)
    109b:	e8 21 f3 ff ff       	call   3c1 <read>
    10a0:	83 c4 10             	add    $0x10,%esp
    int row = bmpInfoHeader.biHeight;
    int bits = bmpInfoHeader.biBitCount;
    char tmpBytes[3];
    int rowBytes = column * 3;
    char *buf = (char *) result;
    for (i = row - 1; i >= 0; i--) {
    10a3:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
    10a7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    10ab:	0f 89 25 ff ff ff    	jns    fd6 <read24BitmapFile+0xa4>
        if (rowBytes % 4 > 0) {
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
        }
    }

    close(bmpFile);
    10b1:	83 ec 0c             	sub    $0xc,%esp
    10b4:	ff 75 ec             	pushl  -0x14(%ebp)
    10b7:	e8 15 f3 ff ff       	call   3d1 <close>
    10bc:	83 c4 10             	add    $0x10,%esp
    return 0;
    10bf:	b8 00 00 00 00       	mov    $0x0,%eax
}
    10c4:	c9                   	leave  
    10c5:	c3                   	ret    

000010c6 <write24BitmapFileHeader>:

void write24BitmapFileHeader(int bmpFile, int height, int width) {
    10c6:	55                   	push   %ebp
    10c7:	89 e5                	mov    %esp,%ebp
    10c9:	83 ec 48             	sub    $0x48,%esp
    int rowSize = (24 * width + 31) / 32 * 4;  // zero padding
    10cc:	8b 55 10             	mov    0x10(%ebp),%edx
    10cf:	89 d0                	mov    %edx,%eax
    10d1:	01 c0                	add    %eax,%eax
    10d3:	01 d0                	add    %edx,%eax
    10d5:	c1 e0 03             	shl    $0x3,%eax
    10d8:	83 c0 1f             	add    $0x1f,%eax
    10db:	8d 50 1f             	lea    0x1f(%eax),%edx
    10de:	85 c0                	test   %eax,%eax
    10e0:	0f 48 c2             	cmovs  %edx,%eax
    10e3:	c1 f8 05             	sar    $0x5,%eax
    10e6:	c1 e0 02             	shl    $0x2,%eax
    10e9:	89 45 f4             	mov    %eax,-0xc(%ebp)
    BITMAP_FILE_HEADER bmpFileHeader;
    bmpFileHeader.bfType = 0x4D42;  // "BM"
    10ec:	66 c7 45 e6 42 4d    	movw   $0x4d42,-0x1a(%ebp)
    bmpFileHeader.bfSize = rowSize * height + 54;
    10f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    10f5:	0f af 45 0c          	imul   0xc(%ebp),%eax
    10f9:	83 c0 36             	add    $0x36,%eax
    10fc:	89 45 e8             	mov    %eax,-0x18(%ebp)
    bmpFileHeader.bfReserved1 = 0;
    10ff:	66 c7 45 ec 00 00    	movw   $0x0,-0x14(%ebp)
    bmpFileHeader.bfReserved2 = 0;
    1105:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%ebp)
    bmpFileHeader.btOffBits = 54;  // size of header
    110b:	c7 45 f0 36 00 00 00 	movl   $0x36,-0x10(%ebp)

    BITMAP_INFO_HEADER bmpInfoHeader;
    bmpInfoHeader.biSize = 40;  // header size
    1112:	c7 45 be 28 00 00 00 	movl   $0x28,-0x42(%ebp)
    bmpInfoHeader.biWidth = width;
    1119:	8b 45 10             	mov    0x10(%ebp),%eax
    111c:	89 45 c2             	mov    %eax,-0x3e(%ebp)
    bmpInfoHeader.biHeight = height;
    111f:	8b 45 0c             	mov    0xc(%ebp),%eax
    1122:	89 45 c6             	mov    %eax,-0x3a(%ebp)
    bmpInfoHeader.biPlanes = 1;
    1125:	66 c7 45 ca 01 00    	movw   $0x1,-0x36(%ebp)
    bmpInfoHeader.biBitCount = 24;
    112b:	66 c7 45 cc 18 00    	movw   $0x18,-0x34(%ebp)
    bmpInfoHeader.biCompression = 0;               // No Compression
    1131:	c7 45 ce 00 00 00 00 	movl   $0x0,-0x32(%ebp)
    bmpInfoHeader.biSizeImage = rowSize * height;  // TODO:
    1138:	8b 45 f4             	mov    -0xc(%ebp),%eax
    113b:	0f af 45 0c          	imul   0xc(%ebp),%eax
    113f:	89 45 d2             	mov    %eax,-0x2e(%ebp)
    bmpInfoHeader.biXPelsPerMeter = 0;             //TODO:
    1142:	c7 45 d6 00 00 00 00 	movl   $0x0,-0x2a(%ebp)
    bmpInfoHeader.biYPelsPerMeter = 0;             //TODO:
    1149:	c7 45 da 00 00 00 00 	movl   $0x0,-0x26(%ebp)
    bmpInfoHeader.biCirUserd = 0;
    1150:	c7 45 de 00 00 00 00 	movl   $0x0,-0x22(%ebp)
    bmpInfoHeader.biCirImportant = 0;
    1157:	c7 45 e2 00 00 00 00 	movl   $0x0,-0x1e(%ebp)

    write(bmpFile, &bmpFileHeader, sizeof(BITMAP_FILE_HEADER));
    115e:	83 ec 04             	sub    $0x4,%esp
    1161:	6a 0e                	push   $0xe
    1163:	8d 45 e6             	lea    -0x1a(%ebp),%eax
    1166:	50                   	push   %eax
    1167:	ff 75 08             	pushl  0x8(%ebp)
    116a:	e8 5a f2 ff ff       	call   3c9 <write>
    116f:	83 c4 10             	add    $0x10,%esp
    write(bmpFile, &bmpInfoHeader, sizeof(BITMAP_INFO_HEADER));
    1172:	83 ec 04             	sub    $0x4,%esp
    1175:	6a 28                	push   $0x28
    1177:	8d 45 be             	lea    -0x42(%ebp),%eax
    117a:	50                   	push   %eax
    117b:	ff 75 08             	pushl  0x8(%ebp)
    117e:	e8 46 f2 ff ff       	call   3c9 <write>
    1183:	83 c4 10             	add    $0x10,%esp
}
    1186:	90                   	nop
    1187:	c9                   	leave  
    1188:	c3                   	ret    

00001189 <write24BitmapFile>:

int write24BitmapFile(char *filename, RGB *img, int height, int width) {
    1189:	55                   	push   %ebp
    118a:	89 e5                	mov    %esp,%ebp
    118c:	83 ec 18             	sub    $0x18,%esp
    int bmpFile = open(filename, O_CREATE | O_RDWR);
    118f:	83 ec 08             	sub    $0x8,%esp
    1192:	68 02 02 00 00       	push   $0x202
    1197:	ff 75 08             	pushl  0x8(%ebp)
    119a:	e8 4a f2 ff ff       	call   3e9 <open>
    119f:	83 c4 10             	add    $0x10,%esp
    11a2:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int rowBytes = width * 3;
    11a5:	8b 55 14             	mov    0x14(%ebp),%edx
    11a8:	89 d0                	mov    %edx,%eax
    11aa:	01 c0                	add    %eax,%eax
    11ac:	01 d0                	add    %edx,%eax
    11ae:	89 45 ec             	mov    %eax,-0x14(%ebp)
    char tmpBytes[3] = {0, 0, 0};
    11b1:	c6 45 e9 00          	movb   $0x0,-0x17(%ebp)
    11b5:	c6 45 ea 00          	movb   $0x0,-0x16(%ebp)
    11b9:	c6 45 eb 00          	movb   $0x0,-0x15(%ebp)

    write24BitmapFileHeader(bmpFile, height, width);
    11bd:	83 ec 04             	sub    $0x4,%esp
    11c0:	ff 75 14             	pushl  0x14(%ebp)
    11c3:	ff 75 10             	pushl  0x10(%ebp)
    11c6:	ff 75 f0             	pushl  -0x10(%ebp)
    11c9:	e8 f8 fe ff ff       	call   10c6 <write24BitmapFileHeader>
    11ce:	83 c4 10             	add    $0x10,%esp
    for (int i = height - 1; i >= 0; i--) {
    11d1:	8b 45 10             	mov    0x10(%ebp),%eax
    11d4:	83 e8 01             	sub    $0x1,%eax
    11d7:	89 45 f4             	mov    %eax,-0xc(%ebp)
    11da:	eb 66                	jmp    1242 <write24BitmapFile+0xb9>
        write(bmpFile, img + i * width, rowBytes);
    11dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    11df:	0f af 45 14          	imul   0x14(%ebp),%eax
    11e3:	89 c2                	mov    %eax,%edx
    11e5:	89 d0                	mov    %edx,%eax
    11e7:	01 c0                	add    %eax,%eax
    11e9:	01 c2                	add    %eax,%edx
    11eb:	8b 45 0c             	mov    0xc(%ebp),%eax
    11ee:	01 d0                	add    %edx,%eax
    11f0:	83 ec 04             	sub    $0x4,%esp
    11f3:	ff 75 ec             	pushl  -0x14(%ebp)
    11f6:	50                   	push   %eax
    11f7:	ff 75 f0             	pushl  -0x10(%ebp)
    11fa:	e8 ca f1 ff ff       	call   3c9 <write>
    11ff:	83 c4 10             	add    $0x10,%esp
        if (rowBytes % 4 > 0) {
    1202:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1205:	99                   	cltd   
    1206:	c1 ea 1e             	shr    $0x1e,%edx
    1209:	01 d0                	add    %edx,%eax
    120b:	83 e0 03             	and    $0x3,%eax
    120e:	29 d0                	sub    %edx,%eax
    1210:	85 c0                	test   %eax,%eax
    1212:	7e 2a                	jle    123e <write24BitmapFile+0xb5>
            write(bmpFile, tmpBytes, 4 - (rowBytes % 4));
    1214:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1217:	99                   	cltd   
    1218:	c1 ea 1e             	shr    $0x1e,%edx
    121b:	01 d0                	add    %edx,%eax
    121d:	83 e0 03             	and    $0x3,%eax
    1220:	29 d0                	sub    %edx,%eax
    1222:	ba 04 00 00 00       	mov    $0x4,%edx
    1227:	29 c2                	sub    %eax,%edx
    1229:	89 d0                	mov    %edx,%eax
    122b:	83 ec 04             	sub    $0x4,%esp
    122e:	50                   	push   %eax
    122f:	8d 45 e9             	lea    -0x17(%ebp),%eax
    1232:	50                   	push   %eax
    1233:	ff 75 f0             	pushl  -0x10(%ebp)
    1236:	e8 8e f1 ff ff       	call   3c9 <write>
    123b:	83 c4 10             	add    $0x10,%esp
    int bmpFile = open(filename, O_CREATE | O_RDWR);
    int rowBytes = width * 3;
    char tmpBytes[3] = {0, 0, 0};

    write24BitmapFileHeader(bmpFile, height, width);
    for (int i = height - 1; i >= 0; i--) {
    123e:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
    1242:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    1246:	79 94                	jns    11dc <write24BitmapFile+0x53>
        if (rowBytes % 4 > 0) {
            write(bmpFile, tmpBytes, 4 - (rowBytes % 4));
        }
    }

    close(bmpFile);
    1248:	83 ec 0c             	sub    $0xc,%esp
    124b:	ff 75 f0             	pushl  -0x10(%ebp)
    124e:	e8 7e f1 ff ff       	call   3d1 <close>
    1253:	83 c4 10             	add    $0x10,%esp
    return 0;
    1256:	b8 00 00 00 00       	mov    $0x0,%eax
    125b:	c9                   	leave  
    125c:	c3                   	ret    

0000125d <api_createwindow>:
#include "gui_base.h"
#include "msg.h"
#include "character.h"

int api_createwindow(Window* wnd)
{
    125d:	55                   	push   %ebp
    125e:	89 e5                	mov    %esp,%ebp
    1260:	57                   	push   %edi
    1261:	56                   	push   %esi
    1262:	53                   	push   %ebx
    1263:	83 ec 1c             	sub    $0x1c,%esp
    Size size = wnd->size;
    1266:	8b 45 08             	mov    0x8(%ebp),%eax
    1269:	8b 50 10             	mov    0x10(%eax),%edx
    126c:	8b 40 0c             	mov    0xc(%eax),%eax
    126f:	89 45 e0             	mov    %eax,-0x20(%ebp)
    1272:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    wnd->wholeContent = malloc(size.w * (size.h + UTITLE_HEIGHT) * 3);
    1275:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    1278:	8b 55 e0             	mov    -0x20(%ebp),%edx
    127b:	83 c2 1e             	add    $0x1e,%edx
    127e:	0f af d0             	imul   %eax,%edx
    1281:	89 d0                	mov    %edx,%eax
    1283:	01 c0                	add    %eax,%eax
    1285:	01 d0                	add    %edx,%eax
    1287:	83 ec 0c             	sub    $0xc,%esp
    128a:	50                   	push   %eax
    128b:	e8 93 f5 ff ff       	call   823 <malloc>
    1290:	83 c4 10             	add    $0x10,%esp
    1293:	89 c2                	mov    %eax,%edx
    1295:	8b 45 08             	mov    0x8(%ebp),%eax
    1298:	89 50 1c             	mov    %edx,0x1c(%eax)
    wnd->content = wnd->wholeContent + size.w * UTITLE_HEIGHT;
    129b:	8b 45 08             	mov    0x8(%ebp),%eax
    129e:	8b 40 1c             	mov    0x1c(%eax),%eax
    12a1:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    12a4:	6b d2 5a             	imul   $0x5a,%edx,%edx
    12a7:	01 c2                	add    %eax,%edx
    12a9:	8b 45 08             	mov    0x8(%ebp),%eax
    12ac:	89 50 18             	mov    %edx,0x18(%eax)
    // set all content to zero
    memset(wnd->content, 255, size.w * size.h * 3);
    12af:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    12b2:	8b 45 e0             	mov    -0x20(%ebp),%eax
    12b5:	0f af d0             	imul   %eax,%edx
    12b8:	89 d0                	mov    %edx,%eax
    12ba:	01 c0                	add    %eax,%eax
    12bc:	01 d0                	add    %edx,%eax
    12be:	89 c2                	mov    %eax,%edx
    12c0:	8b 45 08             	mov    0x8(%ebp),%eax
    12c3:	8b 40 18             	mov    0x18(%eax),%eax
    12c6:	83 ec 04             	sub    $0x4,%esp
    12c9:	52                   	push   %edx
    12ca:	68 ff 00 00 00       	push   $0xff
    12cf:	50                   	push   %eax
    12d0:	e8 39 ef ff ff       	call   20e <memset>
    12d5:	83 c4 10             	add    $0x10,%esp
    wnd->hwnd = createwindow(wnd->pos.x, wnd->pos.y,
    12d8:	8b 45 08             	mov    0x8(%ebp),%eax
    12db:	8b 78 1c             	mov    0x1c(%eax),%edi
    12de:	8b 45 08             	mov    0x8(%ebp),%eax
    12e1:	8b 70 14             	mov    0x14(%eax),%esi
    12e4:	8b 45 08             	mov    0x8(%ebp),%eax
    12e7:	8b 58 0c             	mov    0xc(%eax),%ebx
    12ea:	8b 45 08             	mov    0x8(%ebp),%eax
    12ed:	8b 48 10             	mov    0x10(%eax),%ecx
    12f0:	8b 45 08             	mov    0x8(%ebp),%eax
    12f3:	8b 50 08             	mov    0x8(%eax),%edx
    12f6:	8b 45 08             	mov    0x8(%ebp),%eax
    12f9:	8b 40 04             	mov    0x4(%eax),%eax
    12fc:	83 ec 08             	sub    $0x8,%esp
    12ff:	57                   	push   %edi
    1300:	56                   	push   %esi
    1301:	53                   	push   %ebx
    1302:	51                   	push   %ecx
    1303:	52                   	push   %edx
    1304:	50                   	push   %eax
    1305:	e8 3f f1 ff ff       	call   449 <createwindow>
    130a:	83 c4 20             	add    $0x20,%esp
    130d:	89 c2                	mov    %eax,%edx
    130f:	8b 45 08             	mov    0x8(%ebp),%eax
    1312:	89 10                	mov    %edx,(%eax)
            wnd->size.w, wnd->size.h, wnd->title, wnd->wholeContent);
    return wnd->hwnd;
    1314:	8b 45 08             	mov    0x8(%ebp),%eax
    1317:	8b 00                	mov    (%eax),%eax
}
    1319:	8d 65 f4             	lea    -0xc(%ebp),%esp
    131c:	5b                   	pop    %ebx
    131d:	5e                   	pop    %esi
    131e:	5f                   	pop    %edi
    131f:	5d                   	pop    %ebp
    1320:	c3                   	ret    

00001321 <api_paint24Bitmap>:

int api_paint24Bitmap(Window* wnd, struct RGB* img, Point p, Size s)
{
    1321:	55                   	push   %ebp
    1322:	89 e5                	mov    %esp,%ebp
    1324:	83 ec 18             	sub    $0x18,%esp
    drawBitmap(wnd->content, img, p, (Point){0, 0}, wnd->size, s, s);
    1327:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    132e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    1335:	8b 45 08             	mov    0x8(%ebp),%eax
    1338:	8b 40 18             	mov    0x18(%eax),%eax
    133b:	ff 75 1c             	pushl  0x1c(%ebp)
    133e:	ff 75 18             	pushl  0x18(%ebp)
    1341:	ff 75 1c             	pushl  0x1c(%ebp)
    1344:	ff 75 18             	pushl  0x18(%ebp)
    1347:	8b 55 08             	mov    0x8(%ebp),%edx
    134a:	ff 72 10             	pushl  0x10(%edx)
    134d:	ff 72 0c             	pushl  0xc(%edx)
    1350:	ff 75 f4             	pushl  -0xc(%ebp)
    1353:	ff 75 f0             	pushl  -0x10(%ebp)
    1356:	ff 75 14             	pushl  0x14(%ebp)
    1359:	ff 75 10             	pushl  0x10(%ebp)
    135c:	ff 75 0c             	pushl  0xc(%ebp)
    135f:	50                   	push   %eax
    1360:	e8 d5 07 00 00       	call   1b3a <drawBitmap>
    1365:	83 c4 30             	add    $0x30,%esp
    return 0;
    1368:	b8 00 00 00 00       	mov    $0x0,%eax
}
    136d:	c9                   	leave  
    136e:	c3                   	ret    

0000136f <api_paint24BitmapToContent>:

int api_paint24BitmapToContent(Window* wnd, struct RGB* img, Point pWnd, Point pBmp, Size sBmp, Size s)
{
    136f:	55                   	push   %ebp
    1370:	89 e5                	mov    %esp,%ebp
    1372:	83 ec 08             	sub    $0x8,%esp
    drawBitmap(wnd->content, img, pWnd, pBmp, wnd->size, sBmp, s);
    1375:	8b 45 08             	mov    0x8(%ebp),%eax
    1378:	8b 40 18             	mov    0x18(%eax),%eax
    137b:	ff 75 2c             	pushl  0x2c(%ebp)
    137e:	ff 75 28             	pushl  0x28(%ebp)
    1381:	ff 75 24             	pushl  0x24(%ebp)
    1384:	ff 75 20             	pushl  0x20(%ebp)
    1387:	8b 55 08             	mov    0x8(%ebp),%edx
    138a:	ff 72 10             	pushl  0x10(%edx)
    138d:	ff 72 0c             	pushl  0xc(%edx)
    1390:	ff 75 1c             	pushl  0x1c(%ebp)
    1393:	ff 75 18             	pushl  0x18(%ebp)
    1396:	ff 75 14             	pushl  0x14(%ebp)
    1399:	ff 75 10             	pushl  0x10(%ebp)
    139c:	ff 75 0c             	pushl  0xc(%ebp)
    139f:	50                   	push   %eax
    13a0:	e8 95 07 00 00       	call   1b3a <drawBitmap>
    13a5:	83 c4 30             	add    $0x30,%esp
    return 0;
    13a8:	b8 00 00 00 00       	mov    $0x0,%eax
}
    13ad:	c9                   	leave  
    13ae:	c3                   	ret    

000013af <api_paint24BitmapToContentTransparent>:

int api_paint24BitmapToContentTransparent(Window* wnd, struct RGB* img, Point pWnd, Point pBmp, Size sBmp, Size s)
{
    13af:	55                   	push   %ebp
    13b0:	89 e5                	mov    %esp,%ebp
    13b2:	83 ec 08             	sub    $0x8,%esp
    drawTransparentBitmap(wnd->content, img, pWnd, pBmp, wnd->size, sBmp, s);
    13b5:	8b 45 08             	mov    0x8(%ebp),%eax
    13b8:	8b 40 18             	mov    0x18(%eax),%eax
    13bb:	ff 75 2c             	pushl  0x2c(%ebp)
    13be:	ff 75 28             	pushl  0x28(%ebp)
    13c1:	ff 75 24             	pushl  0x24(%ebp)
    13c4:	ff 75 20             	pushl  0x20(%ebp)
    13c7:	8b 55 08             	mov    0x8(%ebp),%edx
    13ca:	ff 72 10             	pushl  0x10(%edx)
    13cd:	ff 72 0c             	pushl  0xc(%edx)
    13d0:	ff 75 1c             	pushl  0x1c(%ebp)
    13d3:	ff 75 18             	pushl  0x18(%ebp)
    13d6:	ff 75 14             	pushl  0x14(%ebp)
    13d9:	ff 75 10             	pushl  0x10(%ebp)
    13dc:	ff 75 0c             	pushl  0xc(%ebp)
    13df:	50                   	push   %eax
    13e0:	e8 75 08 00 00       	call   1c5a <drawTransparentBitmap>
    13e5:	83 c4 30             	add    $0x30,%esp
    return 0;
    13e8:	b8 00 00 00 00       	mov    $0x0,%eax
}
    13ed:	c9                   	leave  
    13ee:	c3                   	ret    

000013ef <api_repaint>:

int api_repaint(Window* wnd)
{
    13ef:	55                   	push   %ebp
    13f0:	89 e5                	mov    %esp,%ebp
    13f2:	83 ec 08             	sub    $0x8,%esp
    repaintwindow(wnd->hwnd);
    13f5:	8b 45 08             	mov    0x8(%ebp),%eax
    13f8:	8b 00                	mov    (%eax),%eax
    13fa:	83 ec 0c             	sub    $0xc,%esp
    13fd:	50                   	push   %eax
    13fe:	e8 4e f0 ff ff       	call   451 <repaintwindow>
    1403:	83 c4 10             	add    $0x10,%esp
    return 0;
    1406:	b8 00 00 00 00       	mov    $0x0,%eax
}
    140b:	c9                   	leave  
    140c:	c3                   	ret    

0000140d <api_update>:

int api_update(Window* wnd, Rect rect)
{
    140d:	55                   	push   %ebp
    140e:	89 e5                	mov    %esp,%ebp
    1410:	56                   	push   %esi
    1411:	53                   	push   %ebx
    updatewindow(wnd->hwnd, rect.x, rect.y, rect.h, rect.w);
    1412:	8b 75 18             	mov    0x18(%ebp),%esi
    1415:	8b 5d 14             	mov    0x14(%ebp),%ebx
    1418:	8b 4d 10             	mov    0x10(%ebp),%ecx
    141b:	8b 55 0c             	mov    0xc(%ebp),%edx
    141e:	8b 45 08             	mov    0x8(%ebp),%eax
    1421:	8b 00                	mov    (%eax),%eax
    1423:	83 ec 0c             	sub    $0xc,%esp
    1426:	56                   	push   %esi
    1427:	53                   	push   %ebx
    1428:	51                   	push   %ecx
    1429:	52                   	push   %edx
    142a:	50                   	push   %eax
    142b:	e8 39 f0 ff ff       	call   469 <updatewindow>
    1430:	83 c4 20             	add    $0x20,%esp
    return 0;
    1433:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1438:	8d 65 f8             	lea    -0x8(%ebp),%esp
    143b:	5b                   	pop    %ebx
    143c:	5e                   	pop    %esi
    143d:	5d                   	pop    %ebp
    143e:	c3                   	ret    

0000143f <api_exec>:

int api_exec(Window* wnd, ProcFun pf)
{
    143f:	55                   	push   %ebp
    1440:	89 e5                	mov    %esp,%ebp
    1442:	83 ec 38             	sub    $0x38,%esp
    message msg;
    int r = 0;
    1445:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    while(1)
    {
        r = getmessage(wnd->hwnd, &msg);
    144c:	8b 45 08             	mov    0x8(%ebp),%eax
    144f:	8b 00                	mov    (%eax),%eax
    1451:	83 ec 08             	sub    $0x8,%esp
    1454:	8d 55 c8             	lea    -0x38(%ebp),%edx
    1457:	52                   	push   %edx
    1458:	50                   	push   %eax
    1459:	e8 fb ef ff ff       	call   459 <getmessage>
    145e:	83 c4 10             	add    $0x10,%esp
    1461:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(r)
    1464:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    1468:	74 e2                	je     144c <api_exec+0xd>
        {
            pf(&msg);
    146a:	83 ec 0c             	sub    $0xc,%esp
    146d:	8d 45 c8             	lea    -0x38(%ebp),%eax
    1470:	50                   	push   %eax
    1471:	8b 45 0c             	mov    0xc(%ebp),%eax
    1474:	ff d0                	call   *%eax
    1476:	83 c4 10             	add    $0x10,%esp
        }
    }
    1479:	eb d1                	jmp    144c <api_exec+0xd>

0000147b <api_settimer>:
    return -1;
}

int api_settimer(Window* wnd, int interval)
{
    147b:	55                   	push   %ebp
    147c:	89 e5                	mov    %esp,%ebp
    147e:	83 ec 08             	sub    $0x8,%esp
    settimer(wnd->hwnd, interval);
    1481:	8b 45 08             	mov    0x8(%ebp),%eax
    1484:	8b 00                	mov    (%eax),%eax
    1486:	83 ec 08             	sub    $0x8,%esp
    1489:	ff 75 0c             	pushl  0xc(%ebp)
    148c:	50                   	push   %eax
    148d:	e8 cf ef ff ff       	call   461 <settimer>
    1492:	83 c4 10             	add    $0x10,%esp
    return 0;
    1495:	b8 00 00 00 00       	mov    $0x0,%eax
}
    149a:	c9                   	leave  
    149b:	c3                   	ret    

0000149c <api_drawRect>:

int api_drawRect(Window *wnd, Point p, Size s, RGB color)
{
    149c:	55                   	push   %ebp
    149d:	89 e5                	mov    %esp,%ebp
    149f:	83 ec 08             	sub    $0x8,%esp
    drawRect(wnd->content, p, wnd->size, color, s);
    14a2:	8b 45 08             	mov    0x8(%ebp),%eax
    14a5:	8b 50 18             	mov    0x18(%eax),%edx
    14a8:	ff 75 18             	pushl  0x18(%ebp)
    14ab:	ff 75 14             	pushl  0x14(%ebp)
    14ae:	83 ec 04             	sub    $0x4,%esp
    14b1:	89 e0                	mov    %esp,%eax
    14b3:	0f b7 4d 1c          	movzwl 0x1c(%ebp),%ecx
    14b7:	66 89 08             	mov    %cx,(%eax)
    14ba:	0f b6 4d 1e          	movzbl 0x1e(%ebp),%ecx
    14be:	88 48 02             	mov    %cl,0x2(%eax)
    14c1:	8b 45 08             	mov    0x8(%ebp),%eax
    14c4:	ff 70 10             	pushl  0x10(%eax)
    14c7:	ff 70 0c             	pushl  0xc(%eax)
    14ca:	ff 75 10             	pushl  0x10(%ebp)
    14cd:	ff 75 0c             	pushl  0xc(%ebp)
    14d0:	52                   	push   %edx
    14d1:	e8 6f 04 00 00       	call   1945 <drawRect>
    14d6:	83 c4 20             	add    $0x20,%esp
    return 0;
    14d9:	b8 00 00 00 00       	mov    $0x0,%eax
}
    14de:	c9                   	leave  
    14df:	c3                   	ret    

000014e0 <api_drawCharacter>:

int api_drawCharacter(Window *wnd, int x, int y, char ch, RGBA color) {
    14e0:	55                   	push   %ebp
    14e1:	89 e5                	mov    %esp,%ebp
    14e3:	83 ec 28             	sub    $0x28,%esp
    14e6:	8b 45 14             	mov    0x14(%ebp),%eax
    14e9:	88 45 e4             	mov    %al,-0x1c(%ebp)
    drawCharacter(wnd->content, (Point){x, y}, wnd->size, ch, color);
    14ec:	0f be 55 e4          	movsbl -0x1c(%ebp),%edx
    14f0:	8b 45 0c             	mov    0xc(%ebp),%eax
    14f3:	89 45 f0             	mov    %eax,-0x10(%ebp)
    14f6:	8b 45 10             	mov    0x10(%ebp),%eax
    14f9:	89 45 f4             	mov    %eax,-0xc(%ebp)
    14fc:	8b 45 08             	mov    0x8(%ebp),%eax
    14ff:	8b 40 18             	mov    0x18(%eax),%eax
    1502:	83 ec 04             	sub    $0x4,%esp
    1505:	ff 75 18             	pushl  0x18(%ebp)
    1508:	52                   	push   %edx
    1509:	8b 55 08             	mov    0x8(%ebp),%edx
    150c:	ff 72 10             	pushl  0x10(%edx)
    150f:	ff 72 0c             	pushl  0xc(%edx)
    1512:	ff 75 f4             	pushl  -0xc(%ebp)
    1515:	ff 75 f0             	pushl  -0x10(%ebp)
    1518:	50                   	push   %eax
    1519:	e8 d4 02 00 00       	call   17f2 <drawCharacter>
    151e:	83 c4 20             	add    $0x20,%esp
    return 0;
    1521:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1526:	c9                   	leave  
    1527:	c3                   	ret    

00001528 <api_drawString>:


int api_drawString(Window *wnd, int x, int y, char *str, RGBA color) {
    1528:	55                   	push   %ebp
    1529:	89 e5                	mov    %esp,%ebp
    152b:	83 ec 18             	sub    $0x18,%esp
    drawString(wnd->content, (Point){x, y}, wnd->size, str, color);
    152e:	8b 45 0c             	mov    0xc(%ebp),%eax
    1531:	89 45 f0             	mov    %eax,-0x10(%ebp)
    1534:	8b 45 10             	mov    0x10(%ebp),%eax
    1537:	89 45 f4             	mov    %eax,-0xc(%ebp)
    153a:	8b 45 08             	mov    0x8(%ebp),%eax
    153d:	8b 40 18             	mov    0x18(%eax),%eax
    1540:	83 ec 04             	sub    $0x4,%esp
    1543:	ff 75 18             	pushl  0x18(%ebp)
    1546:	ff 75 14             	pushl  0x14(%ebp)
    1549:	8b 55 08             	mov    0x8(%ebp),%edx
    154c:	ff 72 10             	pushl  0x10(%edx)
    154f:	ff 72 0c             	pushl  0xc(%edx)
    1552:	ff 75 f4             	pushl  -0xc(%ebp)
    1555:	ff 75 f0             	pushl  -0x10(%ebp)
    1558:	50                   	push   %eax
    1559:	e8 8e 03 00 00       	call   18ec <drawString>
    155e:	83 c4 20             	add    $0x20,%esp
    return 0;
    1561:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1566:	c9                   	leave  
    1567:	c3                   	ret    

00001568 <api_drawButton>:

int api_drawButton(Window *wnd, Point p, Size s, char * str)
{
    1568:	55                   	push   %ebp
    1569:	89 e5                	mov    %esp,%ebp
    156b:	83 ec 18             	sub    $0x18,%esp
    RGB bColor;
    bColor.R = 9;
    156e:	c6 45 f3 09          	movb   $0x9,-0xd(%ebp)
    bColor.G = 163;
    1572:	c6 45 f2 a3          	movb   $0xa3,-0xe(%ebp)
    bColor.B = 220;
    1576:	c6 45 f1 dc          	movb   $0xdc,-0xf(%ebp)
    api_drawRect(wnd, p, s, bColor);
    157a:	83 ec 08             	sub    $0x8,%esp
    157d:	83 ec 04             	sub    $0x4,%esp
    1580:	89 e0                	mov    %esp,%eax
    1582:	0f b7 55 f1          	movzwl -0xf(%ebp),%edx
    1586:	66 89 10             	mov    %dx,(%eax)
    1589:	0f b6 55 f3          	movzbl -0xd(%ebp),%edx
    158d:	88 50 02             	mov    %dl,0x2(%eax)
    1590:	ff 75 18             	pushl  0x18(%ebp)
    1593:	ff 75 14             	pushl  0x14(%ebp)
    1596:	ff 75 10             	pushl  0x10(%ebp)
    1599:	ff 75 0c             	pushl  0xc(%ebp)
    159c:	ff 75 08             	pushl  0x8(%ebp)
    159f:	e8 f8 fe ff ff       	call   149c <api_drawRect>
    15a4:	83 c4 20             	add    $0x20,%esp
    api_drawString(wnd, p.x + 10, p.y + 10, str, (RGBA){255,255,255,255});
    15a7:	c6 45 f4 ff          	movb   $0xff,-0xc(%ebp)
    15ab:	c6 45 f5 ff          	movb   $0xff,-0xb(%ebp)
    15af:	c6 45 f6 ff          	movb   $0xff,-0xa(%ebp)
    15b3:	c6 45 f7 ff          	movb   $0xff,-0x9(%ebp)
    15b7:	8b 45 10             	mov    0x10(%ebp),%eax
    15ba:	8d 50 0a             	lea    0xa(%eax),%edx
    15bd:	8b 45 0c             	mov    0xc(%ebp),%eax
    15c0:	83 c0 0a             	add    $0xa,%eax
    15c3:	83 ec 0c             	sub    $0xc,%esp
    15c6:	ff 75 f4             	pushl  -0xc(%ebp)
    15c9:	ff 75 1c             	pushl  0x1c(%ebp)
    15cc:	52                   	push   %edx
    15cd:	50                   	push   %eax
    15ce:	ff 75 08             	pushl  0x8(%ebp)
    15d1:	e8 52 ff ff ff       	call   1528 <api_drawString>
    15d6:	83 c4 20             	add    $0x20,%esp
    return 0;
    15d9:	b8 00 00 00 00       	mov    $0x0,%eax
}
    15de:	c9                   	leave  
    15df:	c3                   	ret    

000015e0 <api_drawImgButton>:


int api_drawImgButton(Window* wnd, struct RGB* img, Point pWnd, Size s, int borderWidth, RGB borderColor, int shift) {
    15e0:	55                   	push   %ebp
    15e1:	89 e5                	mov    %esp,%ebp
    15e3:	83 ec 18             	sub    $0x18,%esp
    drawBitmap(wnd->content, img, pWnd, (Point){0, 0}, wnd->size, s, s);
    15e6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    15ed:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    15f4:	8b 45 08             	mov    0x8(%ebp),%eax
    15f7:	8b 40 18             	mov    0x18(%eax),%eax
    15fa:	ff 75 1c             	pushl  0x1c(%ebp)
    15fd:	ff 75 18             	pushl  0x18(%ebp)
    1600:	ff 75 1c             	pushl  0x1c(%ebp)
    1603:	ff 75 18             	pushl  0x18(%ebp)
    1606:	8b 55 08             	mov    0x8(%ebp),%edx
    1609:	ff 72 10             	pushl  0x10(%edx)
    160c:	ff 72 0c             	pushl  0xc(%edx)
    160f:	ff 75 f4             	pushl  -0xc(%ebp)
    1612:	ff 75 f0             	pushl  -0x10(%ebp)
    1615:	ff 75 14             	pushl  0x14(%ebp)
    1618:	ff 75 10             	pushl  0x10(%ebp)
    161b:	ff 75 0c             	pushl  0xc(%ebp)
    161e:	50                   	push   %eax
    161f:	e8 16 05 00 00       	call   1b3a <drawBitmap>
    1624:	83 c4 30             	add    $0x30,%esp
    colorShift(wnd->content, pWnd, wnd->size, s, shift);
    1627:	8b 45 08             	mov    0x8(%ebp),%eax
    162a:	8b 40 18             	mov    0x18(%eax),%eax
    162d:	ff 75 28             	pushl  0x28(%ebp)
    1630:	ff 75 1c             	pushl  0x1c(%ebp)
    1633:	ff 75 18             	pushl  0x18(%ebp)
    1636:	8b 55 08             	mov    0x8(%ebp),%edx
    1639:	ff 72 10             	pushl  0x10(%edx)
    163c:	ff 72 0c             	pushl  0xc(%edx)
    163f:	ff 75 14             	pushl  0x14(%ebp)
    1642:	ff 75 10             	pushl  0x10(%ebp)
    1645:	50                   	push   %eax
    1646:	e8 99 07 00 00       	call   1de4 <colorShift>
    164b:	83 c4 20             	add    $0x20,%esp
    drawBorder(wnd->content, pWnd, wnd->size, borderColor, s, borderWidth);
    164e:	8b 45 08             	mov    0x8(%ebp),%eax
    1651:	8b 50 18             	mov    0x18(%eax),%edx
    1654:	83 ec 0c             	sub    $0xc,%esp
    1657:	ff 75 20             	pushl  0x20(%ebp)
    165a:	ff 75 1c             	pushl  0x1c(%ebp)
    165d:	ff 75 18             	pushl  0x18(%ebp)
    1660:	83 ec 04             	sub    $0x4,%esp
    1663:	89 e0                	mov    %esp,%eax
    1665:	0f b7 4d 24          	movzwl 0x24(%ebp),%ecx
    1669:	66 89 08             	mov    %cx,(%eax)
    166c:	0f b6 4d 26          	movzbl 0x26(%ebp),%ecx
    1670:	88 48 02             	mov    %cl,0x2(%eax)
    1673:	8b 45 08             	mov    0x8(%ebp),%eax
    1676:	ff 70 10             	pushl  0x10(%eax)
    1679:	ff 70 0c             	pushl  0xc(%eax)
    167c:	ff 75 14             	pushl  0x14(%ebp)
    167f:	ff 75 10             	pushl  0x10(%ebp)
    1682:	52                   	push   %edx
    1683:	e8 6d 03 00 00       	call   19f5 <drawBorder>
    1688:	83 c4 30             	add    $0x30,%esp
    return 0;
    168b:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1690:	c9                   	leave  
    1691:	c3                   	ret    

00001692 <api_destroywindow>:


int api_destroywindow(Window *wnd) {
    1692:	55                   	push   %ebp
    1693:	89 e5                	mov    %esp,%ebp
    1695:	83 ec 08             	sub    $0x8,%esp
    destroywindow(wnd->hwnd);
    1698:	8b 45 08             	mov    0x8(%ebp),%eax
    169b:	8b 00                	mov    (%eax),%eax
    169d:	83 ec 0c             	sub    $0xc,%esp
    16a0:	50                   	push   %eax
    16a1:	e8 cb ed ff ff       	call   471 <destroywindow>
    16a6:	83 c4 10             	add    $0x10,%esp
    return 0;
    16a9:	b8 00 00 00 00       	mov    $0x0,%eax
    16ae:	c9                   	leave  
    16af:	c3                   	ret    

000016b0 <drawPoint>:
#include "gui_base.h"
#include "mouse_shape.h"
#include "character.h"


void drawPoint(RGB* color, RGB origin) {
    16b0:	55                   	push   %ebp
    16b1:	89 e5                	mov    %esp,%ebp
    color->R = origin.R;
    16b3:	0f b6 55 0e          	movzbl 0xe(%ebp),%edx
    16b7:	8b 45 08             	mov    0x8(%ebp),%eax
    16ba:	88 50 02             	mov    %dl,0x2(%eax)
    color->G = origin.G;
    16bd:	0f b6 55 0d          	movzbl 0xd(%ebp),%edx
    16c1:	8b 45 08             	mov    0x8(%ebp),%eax
    16c4:	88 50 01             	mov    %dl,0x1(%eax)
    color->B = origin.B;
    16c7:	0f b6 55 0c          	movzbl 0xc(%ebp),%edx
    16cb:	8b 45 08             	mov    0x8(%ebp),%eax
    16ce:	88 10                	mov    %dl,(%eax)
}
    16d0:	90                   	nop
    16d1:	5d                   	pop    %ebp
    16d2:	c3                   	ret    

000016d3 <drawPointAlpha>:

void drawPointAlpha(RGB* color, RGBA origin) {
    16d3:	55                   	push   %ebp
    16d4:	89 e5                	mov    %esp,%ebp
    16d6:	83 ec 1c             	sub    $0x1c,%esp
    float alpha;
    if (origin.A == 255) {
    16d9:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    16dd:	3c ff                	cmp    $0xff,%al
    16df:	75 22                	jne    1703 <drawPointAlpha+0x30>
        color->R = origin.R;
    16e1:	0f b6 55 0f          	movzbl 0xf(%ebp),%edx
    16e5:	8b 45 08             	mov    0x8(%ebp),%eax
    16e8:	88 50 02             	mov    %dl,0x2(%eax)
        color->G = origin.G;
    16eb:	0f b6 55 0e          	movzbl 0xe(%ebp),%edx
    16ef:	8b 45 08             	mov    0x8(%ebp),%eax
    16f2:	88 50 01             	mov    %dl,0x1(%eax)
        color->B = origin.B;
    16f5:	0f b6 55 0d          	movzbl 0xd(%ebp),%edx
    16f9:	8b 45 08             	mov    0x8(%ebp),%eax
    16fc:	88 10                	mov    %dl,(%eax)
        return;
    16fe:	e9 ed 00 00 00       	jmp    17f0 <drawPointAlpha+0x11d>
    }
    if (origin.A == 0) {
    1703:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    1707:	84 c0                	test   %al,%al
    1709:	0f 84 e0 00 00 00    	je     17ef <drawPointAlpha+0x11c>
        return;
    }
    alpha = (float)origin.A / 255;
    170f:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    1713:	0f b6 c0             	movzbl %al,%eax
    1716:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    171a:	df 45 e4             	fild   -0x1c(%ebp)
    171d:	d9 05 80 9d 01 00    	flds   0x19d80
    1723:	de f9                	fdivrp %st,%st(1)
    1725:	d9 5d fc             	fstps  -0x4(%ebp)
    color->R = color->R * (1 - alpha) + origin.R * alpha;
    1728:	8b 45 08             	mov    0x8(%ebp),%eax
    172b:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    172f:	0f b6 c0             	movzbl %al,%eax
    1732:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    1735:	db 45 e4             	fildl  -0x1c(%ebp)
    1738:	d9 e8                	fld1   
    173a:	d8 65 fc             	fsubs  -0x4(%ebp)
    173d:	de c9                	fmulp  %st,%st(1)
    173f:	0f b6 45 0f          	movzbl 0xf(%ebp),%eax
    1743:	0f b6 c0             	movzbl %al,%eax
    1746:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    1749:	db 45 e4             	fildl  -0x1c(%ebp)
    174c:	d8 4d fc             	fmuls  -0x4(%ebp)
    174f:	de c1                	faddp  %st,%st(1)
    1751:	d9 7d ee             	fnstcw -0x12(%ebp)
    1754:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
    1758:	b4 0c                	mov    $0xc,%ah
    175a:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    175e:	d9 6d ec             	fldcw  -0x14(%ebp)
    1761:	df 5d ea             	fistp  -0x16(%ebp)
    1764:	d9 6d ee             	fldcw  -0x12(%ebp)
    1767:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
    176b:	89 c2                	mov    %eax,%edx
    176d:	8b 45 08             	mov    0x8(%ebp),%eax
    1770:	88 50 02             	mov    %dl,0x2(%eax)
    color->G = color->G * (1 - alpha) + origin.G * alpha;
    1773:	8b 45 08             	mov    0x8(%ebp),%eax
    1776:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    177a:	0f b6 c0             	movzbl %al,%eax
    177d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    1780:	db 45 e4             	fildl  -0x1c(%ebp)
    1783:	d9 e8                	fld1   
    1785:	d8 65 fc             	fsubs  -0x4(%ebp)
    1788:	de c9                	fmulp  %st,%st(1)
    178a:	0f b6 45 0e          	movzbl 0xe(%ebp),%eax
    178e:	0f b6 c0             	movzbl %al,%eax
    1791:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    1794:	db 45 e4             	fildl  -0x1c(%ebp)
    1797:	d8 4d fc             	fmuls  -0x4(%ebp)
    179a:	de c1                	faddp  %st,%st(1)
    179c:	d9 6d ec             	fldcw  -0x14(%ebp)
    179f:	df 5d ea             	fistp  -0x16(%ebp)
    17a2:	d9 6d ee             	fldcw  -0x12(%ebp)
    17a5:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
    17a9:	89 c2                	mov    %eax,%edx
    17ab:	8b 45 08             	mov    0x8(%ebp),%eax
    17ae:	88 50 01             	mov    %dl,0x1(%eax)
    color->B = color->B * (1 - alpha) + origin.B * alpha;
    17b1:	8b 45 08             	mov    0x8(%ebp),%eax
    17b4:	0f b6 00             	movzbl (%eax),%eax
    17b7:	0f b6 c0             	movzbl %al,%eax
    17ba:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    17bd:	db 45 e4             	fildl  -0x1c(%ebp)
    17c0:	d9 e8                	fld1   
    17c2:	d8 65 fc             	fsubs  -0x4(%ebp)
    17c5:	de c9                	fmulp  %st,%st(1)
    17c7:	0f b6 45 0d          	movzbl 0xd(%ebp),%eax
    17cb:	0f b6 c0             	movzbl %al,%eax
    17ce:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    17d1:	db 45 e4             	fildl  -0x1c(%ebp)
    17d4:	d8 4d fc             	fmuls  -0x4(%ebp)
    17d7:	de c1                	faddp  %st,%st(1)
    17d9:	d9 6d ec             	fldcw  -0x14(%ebp)
    17dc:	df 5d ea             	fistp  -0x16(%ebp)
    17df:	d9 6d ee             	fldcw  -0x12(%ebp)
    17e2:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
    17e6:	89 c2                	mov    %eax,%edx
    17e8:	8b 45 08             	mov    0x8(%ebp),%eax
    17eb:	88 10                	mov    %dl,(%eax)
    17ed:	eb 01                	jmp    17f0 <drawPointAlpha+0x11d>
        color->G = origin.G;
        color->B = origin.B;
        return;
    }
    if (origin.A == 0) {
        return;
    17ef:	90                   	nop
    }
    alpha = (float)origin.A / 255;
    color->R = color->R * (1 - alpha) + origin.R * alpha;
    color->G = color->G * (1 - alpha) + origin.G * alpha;
    color->B = color->B * (1 - alpha) + origin.B * alpha;
}
    17f0:	c9                   	leave  
    17f1:	c3                   	ret    

000017f2 <drawCharacter>:

void drawCharacter(RGB *buf, Point p, Size s, char ch, RGBA color) {
    17f2:	55                   	push   %ebp
    17f3:	89 e5                	mov    %esp,%ebp
    17f5:	83 ec 14             	sub    $0x14,%esp
    17f8:	8b 45 1c             	mov    0x1c(%ebp),%eax
    17fb:	88 45 ec             	mov    %al,-0x14(%ebp)
    int i, j;
    RGB *t;
    int ord = ch - 0x20; // omit control ASCII code.
    17fe:	0f be 45 ec          	movsbl -0x14(%ebp),%eax
    1802:	83 e8 20             	sub    $0x20,%eax
    1805:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (ord < 0 || ord >= (CHARACTER_NUMBER - 1)) {
    1808:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    180c:	0f 88 d7 00 00 00    	js     18e9 <drawCharacter+0xf7>
    1812:	83 7d f4 5e          	cmpl   $0x5e,-0xc(%ebp)
    1816:	0f 8f cd 00 00 00    	jg     18e9 <drawCharacter+0xf7>
        return;
    }

    for (i = 0; i < CHARACTER_HEIGHT; i++) {
    181c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    1823:	e9 b5 00 00 00       	jmp    18dd <drawCharacter+0xeb>
        if (p.y + i > s.h || p.y + i < 0) {
    1828:	8b 55 10             	mov    0x10(%ebp),%edx
    182b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    182e:	01 c2                	add    %eax,%edx
    1830:	8b 45 14             	mov    0x14(%ebp),%eax
    1833:	39 c2                	cmp    %eax,%edx
    1835:	0f 8f af 00 00 00    	jg     18ea <drawCharacter+0xf8>
    183b:	8b 55 10             	mov    0x10(%ebp),%edx
    183e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1841:	01 d0                	add    %edx,%eax
    1843:	85 c0                	test   %eax,%eax
    1845:	0f 88 9f 00 00 00    	js     18ea <drawCharacter+0xf8>
            break;
        }
        for (j = 0; j < CHARACTER_WIDTH; j++) {
    184b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    1852:	eb 7b                	jmp    18cf <drawCharacter+0xdd>
            if (character[ord][i][j] == 1) {
    1854:	8b 55 fc             	mov    -0x4(%ebp),%edx
    1857:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    185a:	89 d0                	mov    %edx,%eax
    185c:	c1 e0 03             	shl    $0x3,%eax
    185f:	01 d0                	add    %edx,%eax
    1861:	69 d1 a2 00 00 00    	imul   $0xa2,%ecx,%edx
    1867:	01 c2                	add    %eax,%edx
    1869:	8b 45 f8             	mov    -0x8(%ebp),%eax
    186c:	01 d0                	add    %edx,%eax
    186e:	05 60 61 01 00       	add    $0x16160,%eax
    1873:	0f b6 00             	movzbl (%eax),%eax
    1876:	3c 01                	cmp    $0x1,%al
    1878:	75 51                	jne    18cb <drawCharacter+0xd9>
                if (p.x + j > s.w || p.x + j < 0) {
    187a:	8b 55 0c             	mov    0xc(%ebp),%edx
    187d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1880:	01 c2                	add    %eax,%edx
    1882:	8b 45 18             	mov    0x18(%ebp),%eax
    1885:	39 c2                	cmp    %eax,%edx
    1887:	7f 50                	jg     18d9 <drawCharacter+0xe7>
    1889:	8b 55 0c             	mov    0xc(%ebp),%edx
    188c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    188f:	01 d0                	add    %edx,%eax
    1891:	85 c0                	test   %eax,%eax
    1893:	78 44                	js     18d9 <drawCharacter+0xe7>
                    break;
                }
                t = buf + (p.y + i) * s.w + p.x + j;
    1895:	8b 55 10             	mov    0x10(%ebp),%edx
    1898:	8b 45 fc             	mov    -0x4(%ebp),%eax
    189b:	01 c2                	add    %eax,%edx
    189d:	8b 45 18             	mov    0x18(%ebp),%eax
    18a0:	0f af c2             	imul   %edx,%eax
    18a3:	89 c2                	mov    %eax,%edx
    18a5:	8b 45 0c             	mov    0xc(%ebp),%eax
    18a8:	01 c2                	add    %eax,%edx
    18aa:	8b 45 f8             	mov    -0x8(%ebp),%eax
    18ad:	01 c2                	add    %eax,%edx
    18af:	89 d0                	mov    %edx,%eax
    18b1:	01 c0                	add    %eax,%eax
    18b3:	01 c2                	add    %eax,%edx
    18b5:	8b 45 08             	mov    0x8(%ebp),%eax
    18b8:	01 d0                	add    %edx,%eax
    18ba:	89 45 f0             	mov    %eax,-0x10(%ebp)
                drawPointAlpha(t, color);
    18bd:	ff 75 20             	pushl  0x20(%ebp)
    18c0:	ff 75 f0             	pushl  -0x10(%ebp)
    18c3:	e8 0b fe ff ff       	call   16d3 <drawPointAlpha>
    18c8:	83 c4 08             	add    $0x8,%esp

    for (i = 0; i < CHARACTER_HEIGHT; i++) {
        if (p.y + i > s.h || p.y + i < 0) {
            break;
        }
        for (j = 0; j < CHARACTER_WIDTH; j++) {
    18cb:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    18cf:	83 7d f8 08          	cmpl   $0x8,-0x8(%ebp)
    18d3:	0f 8e 7b ff ff ff    	jle    1854 <drawCharacter+0x62>
    int ord = ch - 0x20; // omit control ASCII code.
    if (ord < 0 || ord >= (CHARACTER_NUMBER - 1)) {
        return;
    }

    for (i = 0; i < CHARACTER_HEIGHT; i++) {
    18d9:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    18dd:	83 7d fc 11          	cmpl   $0x11,-0x4(%ebp)
    18e1:	0f 8e 41 ff ff ff    	jle    1828 <drawCharacter+0x36>
    18e7:	eb 01                	jmp    18ea <drawCharacter+0xf8>
void drawCharacter(RGB *buf, Point p, Size s, char ch, RGBA color) {
    int i, j;
    RGB *t;
    int ord = ch - 0x20; // omit control ASCII code.
    if (ord < 0 || ord >= (CHARACTER_NUMBER - 1)) {
        return;
    18e9:	90                   	nop
                t = buf + (p.y + i) * s.w + p.x + j;
                drawPointAlpha(t, color);
            }
        }
    }
}
    18ea:	c9                   	leave  
    18eb:	c3                   	ret    

000018ec <drawString>:

void drawString(RGB *buf, Point p, Size s, char *str, RGBA color) {
    18ec:	55                   	push   %ebp
    18ed:	89 e5                	mov    %esp,%ebp
    18ef:	83 ec 10             	sub    $0x10,%esp
    int offset_x = 0;
    18f2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)

    while (*str != '\0') {
    18f9:	eb 3d                	jmp    1938 <drawString+0x4c>
        drawCharacter(buf, (Point){p.x+offset_x, p.y}, s, *str, color);
    18fb:	8b 45 1c             	mov    0x1c(%ebp),%eax
    18fe:	0f b6 00             	movzbl (%eax),%eax
    1901:	0f be c0             	movsbl %al,%eax
    1904:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    1907:	8b 55 fc             	mov    -0x4(%ebp),%edx
    190a:	01 ca                	add    %ecx,%edx
    190c:	89 55 f4             	mov    %edx,-0xc(%ebp)
    190f:	8b 55 10             	mov    0x10(%ebp),%edx
    1912:	89 55 f8             	mov    %edx,-0x8(%ebp)
    1915:	ff 75 20             	pushl  0x20(%ebp)
    1918:	50                   	push   %eax
    1919:	ff 75 18             	pushl  0x18(%ebp)
    191c:	ff 75 14             	pushl  0x14(%ebp)
    191f:	ff 75 f8             	pushl  -0x8(%ebp)
    1922:	ff 75 f4             	pushl  -0xc(%ebp)
    1925:	ff 75 08             	pushl  0x8(%ebp)
    1928:	e8 c5 fe ff ff       	call   17f2 <drawCharacter>
    192d:	83 c4 1c             	add    $0x1c,%esp
        offset_x += CHARACTER_WIDTH;
    1930:	83 45 fc 09          	addl   $0x9,-0x4(%ebp)
        str++;
    1934:	83 45 1c 01          	addl   $0x1,0x1c(%ebp)
}

void drawString(RGB *buf, Point p, Size s, char *str, RGBA color) {
    int offset_x = 0;

    while (*str != '\0') {
    1938:	8b 45 1c             	mov    0x1c(%ebp),%eax
    193b:	0f b6 00             	movzbl (%eax),%eax
    193e:	84 c0                	test   %al,%al
    1940:	75 b9                	jne    18fb <drawString+0xf>
        drawCharacter(buf, (Point){p.x+offset_x, p.y}, s, *str, color);
        offset_x += CHARACTER_WIDTH;
        str++;
    }
}
    1942:	90                   	nop
    1943:	c9                   	leave  
    1944:	c3                   	ret    

00001945 <drawRect>:

void drawRect(RGB *buf, Point p, Size s, RGB color, Size rect_size) {
    1945:	55                   	push   %ebp
    1946:	89 e5                	mov    %esp,%ebp
    1948:	83 ec 20             	sub    $0x20,%esp
    struct RGB * t;
    int draw_h = rect_size.h;
    194b:	8b 45 20             	mov    0x20(%ebp),%eax
    194e:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int draw_w = rect_size.w;
    1951:	8b 45 24             	mov    0x24(%ebp),%eax
    1954:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if (draw_h > s.h - p.y) {
    1957:	8b 55 14             	mov    0x14(%ebp),%edx
    195a:	8b 45 10             	mov    0x10(%ebp),%eax
    195d:	29 c2                	sub    %eax,%edx
    195f:	89 d0                	mov    %edx,%eax
    1961:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1964:	7d 0d                	jge    1973 <drawRect+0x2e>
        draw_h = s.h - p.y;
    1966:	8b 55 14             	mov    0x14(%ebp),%edx
    1969:	8b 45 10             	mov    0x10(%ebp),%eax
    196c:	29 c2                	sub    %eax,%edx
    196e:	89 d0                	mov    %edx,%eax
    1970:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }

    if (draw_w > s.w - p.x) {
    1973:	8b 55 18             	mov    0x18(%ebp),%edx
    1976:	8b 45 0c             	mov    0xc(%ebp),%eax
    1979:	29 c2                	sub    %eax,%edx
    197b:	89 d0                	mov    %edx,%eax
    197d:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1980:	7d 0d                	jge    198f <drawRect+0x4a>
        draw_w = s.w - p.x;
    1982:	8b 55 18             	mov    0x18(%ebp),%edx
    1985:	8b 45 0c             	mov    0xc(%ebp),%eax
    1988:	29 c2                	sub    %eax,%edx
    198a:	89 d0                	mov    %edx,%eax
    198c:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }

    for (int i = 0; i < draw_h; i++) {
    198f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    1996:	eb 52                	jmp    19ea <drawRect+0xa5>
        for(int j = 0; j < draw_w; j++) {
    1998:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    199f:	eb 3d                	jmp    19de <drawRect+0x99>
            t = buf + (p.y + i) * s.w + p.x + j;
    19a1:	8b 55 10             	mov    0x10(%ebp),%edx
    19a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    19a7:	01 c2                	add    %eax,%edx
    19a9:	8b 45 18             	mov    0x18(%ebp),%eax
    19ac:	0f af c2             	imul   %edx,%eax
    19af:	89 c2                	mov    %eax,%edx
    19b1:	8b 45 0c             	mov    0xc(%ebp),%eax
    19b4:	01 c2                	add    %eax,%edx
    19b6:	8b 45 f0             	mov    -0x10(%ebp),%eax
    19b9:	01 c2                	add    %eax,%edx
    19bb:	89 d0                	mov    %edx,%eax
    19bd:	01 c0                	add    %eax,%eax
    19bf:	01 c2                	add    %eax,%edx
    19c1:	8b 45 08             	mov    0x8(%ebp),%eax
    19c4:	01 d0                	add    %edx,%eax
    19c6:	89 45 ec             	mov    %eax,-0x14(%ebp)
            *t = color;
    19c9:	8b 45 ec             	mov    -0x14(%ebp),%eax
    19cc:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    19d0:	66 89 10             	mov    %dx,(%eax)
    19d3:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    19d7:	88 50 02             	mov    %dl,0x2(%eax)
    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
        for(int j = 0; j < draw_w; j++) {
    19da:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    19de:	8b 45 f0             	mov    -0x10(%ebp),%eax
    19e1:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    19e4:	7c bb                	jl     19a1 <drawRect+0x5c>

    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
    19e6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    19ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
    19ed:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    19f0:	7c a6                	jl     1998 <drawRect+0x53>
        for(int j = 0; j < draw_w; j++) {
            t = buf + (p.y + i) * s.w + p.x + j;
            *t = color;
        }
    }
}
    19f2:	90                   	nop
    19f3:	c9                   	leave  
    19f4:	c3                   	ret    

000019f5 <drawBorder>:

void drawBorder(RGB* buf, Point p, Size s, RGB color, Size rect_size, int border) {
    19f5:	55                   	push   %ebp
    19f6:	89 e5                	mov    %esp,%ebp
    19f8:	83 ec 40             	sub    $0x40,%esp
    drawRect(buf, p, s, color, (Size){border, rect_size.w});
    19fb:	8b 45 28             	mov    0x28(%ebp),%eax
    19fe:	89 45 c8             	mov    %eax,-0x38(%ebp)
    1a01:	8b 45 24             	mov    0x24(%ebp),%eax
    1a04:	89 45 cc             	mov    %eax,-0x34(%ebp)
    1a07:	ff 75 cc             	pushl  -0x34(%ebp)
    1a0a:	ff 75 c8             	pushl  -0x38(%ebp)
    1a0d:	83 ec 04             	sub    $0x4,%esp
    1a10:	89 e0                	mov    %esp,%eax
    1a12:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    1a16:	66 89 10             	mov    %dx,(%eax)
    1a19:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    1a1d:	88 50 02             	mov    %dl,0x2(%eax)
    1a20:	ff 75 18             	pushl  0x18(%ebp)
    1a23:	ff 75 14             	pushl  0x14(%ebp)
    1a26:	ff 75 10             	pushl  0x10(%ebp)
    1a29:	ff 75 0c             	pushl  0xc(%ebp)
    1a2c:	ff 75 08             	pushl  0x8(%ebp)
    1a2f:	e8 11 ff ff ff       	call   1945 <drawRect>
    1a34:	83 c4 20             	add    $0x20,%esp
    drawRect(buf, (Point){p.x, p.y + rect_size.h - border}, s, color, (Size){border, rect_size.w});
    1a37:	8b 45 28             	mov    0x28(%ebp),%eax
    1a3a:	89 45 d0             	mov    %eax,-0x30(%ebp)
    1a3d:	8b 45 24             	mov    0x24(%ebp),%eax
    1a40:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    1a43:	8b 45 0c             	mov    0xc(%ebp),%eax
    1a46:	89 45 d8             	mov    %eax,-0x28(%ebp)
    1a49:	8b 55 10             	mov    0x10(%ebp),%edx
    1a4c:	8b 45 20             	mov    0x20(%ebp),%eax
    1a4f:	01 d0                	add    %edx,%eax
    1a51:	2b 45 28             	sub    0x28(%ebp),%eax
    1a54:	89 45 dc             	mov    %eax,-0x24(%ebp)
    1a57:	ff 75 d4             	pushl  -0x2c(%ebp)
    1a5a:	ff 75 d0             	pushl  -0x30(%ebp)
    1a5d:	83 ec 04             	sub    $0x4,%esp
    1a60:	89 e0                	mov    %esp,%eax
    1a62:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    1a66:	66 89 10             	mov    %dx,(%eax)
    1a69:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    1a6d:	88 50 02             	mov    %dl,0x2(%eax)
    1a70:	ff 75 18             	pushl  0x18(%ebp)
    1a73:	ff 75 14             	pushl  0x14(%ebp)
    1a76:	ff 75 dc             	pushl  -0x24(%ebp)
    1a79:	ff 75 d8             	pushl  -0x28(%ebp)
    1a7c:	ff 75 08             	pushl  0x8(%ebp)
    1a7f:	e8 c1 fe ff ff       	call   1945 <drawRect>
    1a84:	83 c4 20             	add    $0x20,%esp

    drawRect(buf, (Point){p.x, p.y + border}, s, color, (Size){rect_size.h - 2 * border, border});
    1a87:	8b 45 20             	mov    0x20(%ebp),%eax
    1a8a:	8b 55 28             	mov    0x28(%ebp),%edx
    1a8d:	01 d2                	add    %edx,%edx
    1a8f:	29 d0                	sub    %edx,%eax
    1a91:	89 45 e0             	mov    %eax,-0x20(%ebp)
    1a94:	8b 45 28             	mov    0x28(%ebp),%eax
    1a97:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    1a9a:	8b 45 0c             	mov    0xc(%ebp),%eax
    1a9d:	89 45 e8             	mov    %eax,-0x18(%ebp)
    1aa0:	8b 55 10             	mov    0x10(%ebp),%edx
    1aa3:	8b 45 28             	mov    0x28(%ebp),%eax
    1aa6:	01 d0                	add    %edx,%eax
    1aa8:	89 45 ec             	mov    %eax,-0x14(%ebp)
    1aab:	ff 75 e4             	pushl  -0x1c(%ebp)
    1aae:	ff 75 e0             	pushl  -0x20(%ebp)
    1ab1:	83 ec 04             	sub    $0x4,%esp
    1ab4:	89 e0                	mov    %esp,%eax
    1ab6:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    1aba:	66 89 10             	mov    %dx,(%eax)
    1abd:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    1ac1:	88 50 02             	mov    %dl,0x2(%eax)
    1ac4:	ff 75 18             	pushl  0x18(%ebp)
    1ac7:	ff 75 14             	pushl  0x14(%ebp)
    1aca:	ff 75 ec             	pushl  -0x14(%ebp)
    1acd:	ff 75 e8             	pushl  -0x18(%ebp)
    1ad0:	ff 75 08             	pushl  0x8(%ebp)
    1ad3:	e8 6d fe ff ff       	call   1945 <drawRect>
    1ad8:	83 c4 20             	add    $0x20,%esp
    drawRect(buf, (Point){p.x + rect_size.w - border, p.y + border}, s, color, (Size){rect_size.h - 2 * border, border});
    1adb:	8b 45 20             	mov    0x20(%ebp),%eax
    1ade:	8b 55 28             	mov    0x28(%ebp),%edx
    1ae1:	01 d2                	add    %edx,%edx
    1ae3:	29 d0                	sub    %edx,%eax
    1ae5:	89 45 f0             	mov    %eax,-0x10(%ebp)
    1ae8:	8b 45 28             	mov    0x28(%ebp),%eax
    1aeb:	89 45 f4             	mov    %eax,-0xc(%ebp)
    1aee:	8b 55 0c             	mov    0xc(%ebp),%edx
    1af1:	8b 45 24             	mov    0x24(%ebp),%eax
    1af4:	01 d0                	add    %edx,%eax
    1af6:	2b 45 28             	sub    0x28(%ebp),%eax
    1af9:	89 45 f8             	mov    %eax,-0x8(%ebp)
    1afc:	8b 55 10             	mov    0x10(%ebp),%edx
    1aff:	8b 45 28             	mov    0x28(%ebp),%eax
    1b02:	01 d0                	add    %edx,%eax
    1b04:	89 45 fc             	mov    %eax,-0x4(%ebp)
    1b07:	ff 75 f4             	pushl  -0xc(%ebp)
    1b0a:	ff 75 f0             	pushl  -0x10(%ebp)
    1b0d:	83 ec 04             	sub    $0x4,%esp
    1b10:	89 e0                	mov    %esp,%eax
    1b12:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    1b16:	66 89 10             	mov    %dx,(%eax)
    1b19:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    1b1d:	88 50 02             	mov    %dl,0x2(%eax)
    1b20:	ff 75 18             	pushl  0x18(%ebp)
    1b23:	ff 75 14             	pushl  0x14(%ebp)
    1b26:	ff 75 fc             	pushl  -0x4(%ebp)
    1b29:	ff 75 f8             	pushl  -0x8(%ebp)
    1b2c:	ff 75 08             	pushl  0x8(%ebp)
    1b2f:	e8 11 fe ff ff       	call   1945 <drawRect>
    1b34:	83 c4 20             	add    $0x20,%esp
}
    1b37:	90                   	nop
    1b38:	c9                   	leave  
    1b39:	c3                   	ret    

00001b3a <drawBitmap>:
// pt: start point of target
// pc: start point of content
// st: size of target
// sc: size of content
// s: size to be drawed
void drawBitmap(struct RGB* tgt, struct RGB* cont, Point pt, Point pc, Size st, Size sc, Size s) {
    1b3a:	55                   	push   %ebp
    1b3b:	89 e5                	mov    %esp,%ebp
    1b3d:	83 ec 28             	sub    $0x28,%esp
    struct RGB *t;
    struct RGB *o;
    int draw_h = s.h;
    1b40:	8b 45 30             	mov    0x30(%ebp),%eax
    1b43:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int draw_w = s.w;
    1b46:	8b 45 34             	mov    0x34(%ebp),%eax
    1b49:	89 45 f0             	mov    %eax,-0x10(%ebp)

    if (draw_h > st.h - pt.y) {
    1b4c:	8b 55 20             	mov    0x20(%ebp),%edx
    1b4f:	8b 45 14             	mov    0x14(%ebp),%eax
    1b52:	29 c2                	sub    %eax,%edx
    1b54:	89 d0                	mov    %edx,%eax
    1b56:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    1b59:	7d 0d                	jge    1b68 <drawBitmap+0x2e>
        draw_h = st.h - pt.y;
    1b5b:	8b 55 20             	mov    0x20(%ebp),%edx
    1b5e:	8b 45 14             	mov    0x14(%ebp),%eax
    1b61:	29 c2                	sub    %eax,%edx
    1b63:	89 d0                	mov    %edx,%eax
    1b65:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }
    if (draw_h > sc.h - pc.y) {
    1b68:	8b 55 28             	mov    0x28(%ebp),%edx
    1b6b:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1b6e:	29 c2                	sub    %eax,%edx
    1b70:	89 d0                	mov    %edx,%eax
    1b72:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    1b75:	7d 0d                	jge    1b84 <drawBitmap+0x4a>
        draw_h = sc.h - pc.y;
    1b77:	8b 55 28             	mov    0x28(%ebp),%edx
    1b7a:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1b7d:	29 c2                	sub    %eax,%edx
    1b7f:	89 d0                	mov    %edx,%eax
    1b81:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

    if (draw_w > st.w - pt.x) {
    1b84:	8b 55 24             	mov    0x24(%ebp),%edx
    1b87:	8b 45 10             	mov    0x10(%ebp),%eax
    1b8a:	29 c2                	sub    %eax,%edx
    1b8c:	89 d0                	mov    %edx,%eax
    1b8e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    1b91:	7d 0d                	jge    1ba0 <drawBitmap+0x66>
        draw_w = st.w - pt.x;
    1b93:	8b 55 24             	mov    0x24(%ebp),%edx
    1b96:	8b 45 10             	mov    0x10(%ebp),%eax
    1b99:	29 c2                	sub    %eax,%edx
    1b9b:	89 d0                	mov    %edx,%eax
    1b9d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }
    if (draw_w > sc.w - pc.x) {
    1ba0:	8b 55 2c             	mov    0x2c(%ebp),%edx
    1ba3:	8b 45 18             	mov    0x18(%ebp),%eax
    1ba6:	29 c2                	sub    %eax,%edx
    1ba8:	89 d0                	mov    %edx,%eax
    1baa:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    1bad:	7d 0d                	jge    1bbc <drawBitmap+0x82>
        draw_w = sc.w - pc.x;
    1baf:	8b 55 2c             	mov    0x2c(%ebp),%edx
    1bb2:	8b 45 18             	mov    0x18(%ebp),%eax
    1bb5:	29 c2                	sub    %eax,%edx
    1bb7:	89 d0                	mov    %edx,%eax
    1bb9:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }

    for (int i = 0; i < draw_h; i++) {
    1bbc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    1bc3:	e9 83 00 00 00       	jmp    1c4b <drawBitmap+0x111>
        if (pt.y + i < 0 || pt.y + i >= st.h) {
    1bc8:	8b 55 14             	mov    0x14(%ebp),%edx
    1bcb:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1bce:	01 d0                	add    %edx,%eax
    1bd0:	85 c0                	test   %eax,%eax
    1bd2:	78 72                	js     1c46 <drawBitmap+0x10c>
    1bd4:	8b 55 14             	mov    0x14(%ebp),%edx
    1bd7:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1bda:	01 c2                	add    %eax,%edx
    1bdc:	8b 45 20             	mov    0x20(%ebp),%eax
    1bdf:	39 c2                	cmp    %eax,%edx
    1be1:	7d 63                	jge    1c46 <drawBitmap+0x10c>
            continue;
        }
        t = tgt + (pt.y + i) * st.w + pt.x;
    1be3:	8b 55 14             	mov    0x14(%ebp),%edx
    1be6:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1be9:	01 c2                	add    %eax,%edx
    1beb:	8b 45 24             	mov    0x24(%ebp),%eax
    1bee:	0f af c2             	imul   %edx,%eax
    1bf1:	89 c2                	mov    %eax,%edx
    1bf3:	8b 45 10             	mov    0x10(%ebp),%eax
    1bf6:	01 c2                	add    %eax,%edx
    1bf8:	89 d0                	mov    %edx,%eax
    1bfa:	01 c0                	add    %eax,%eax
    1bfc:	01 c2                	add    %eax,%edx
    1bfe:	8b 45 08             	mov    0x8(%ebp),%eax
    1c01:	01 d0                	add    %edx,%eax
    1c03:	89 45 e8             	mov    %eax,-0x18(%ebp)
        o = cont + (pc.y + i) * sc.w + pc.x;
    1c06:	8b 55 1c             	mov    0x1c(%ebp),%edx
    1c09:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1c0c:	01 c2                	add    %eax,%edx
    1c0e:	8b 45 2c             	mov    0x2c(%ebp),%eax
    1c11:	0f af c2             	imul   %edx,%eax
    1c14:	89 c2                	mov    %eax,%edx
    1c16:	8b 45 18             	mov    0x18(%ebp),%eax
    1c19:	01 c2                	add    %eax,%edx
    1c1b:	89 d0                	mov    %edx,%eax
    1c1d:	01 c0                	add    %eax,%eax
    1c1f:	01 c2                	add    %eax,%edx
    1c21:	8b 45 0c             	mov    0xc(%ebp),%eax
    1c24:	01 d0                	add    %edx,%eax
    1c26:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        memmove(t, o, draw_w * 3);
    1c29:	8b 55 f0             	mov    -0x10(%ebp),%edx
    1c2c:	89 d0                	mov    %edx,%eax
    1c2e:	01 c0                	add    %eax,%eax
    1c30:	01 d0                	add    %edx,%eax
    1c32:	83 ec 04             	sub    $0x4,%esp
    1c35:	50                   	push   %eax
    1c36:	ff 75 e4             	pushl  -0x1c(%ebp)
    1c39:	ff 75 e8             	pushl  -0x18(%ebp)
    1c3c:	e8 23 e7 ff ff       	call   364 <memmove>
    1c41:	83 c4 10             	add    $0x10,%esp
    1c44:	eb 01                	jmp    1c47 <drawBitmap+0x10d>
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < draw_h; i++) {
        if (pt.y + i < 0 || pt.y + i >= st.h) {
            continue;
    1c46:	90                   	nop
    }
    if (draw_w > sc.w - pc.x) {
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < draw_h; i++) {
    1c47:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    1c4b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1c4e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    1c51:	0f 8c 71 ff ff ff    	jl     1bc8 <drawBitmap+0x8e>
        }
        t = tgt + (pt.y + i) * st.w + pt.x;
        o = cont + (pc.y + i) * sc.w + pc.x;
        memmove(t, o, draw_w * 3);
    }
}
    1c57:	90                   	nop
    1c58:	c9                   	leave  
    1c59:	c3                   	ret    

00001c5a <drawTransparentBitmap>:

void drawTransparentBitmap(struct RGB* tgt, struct RGB* cont, Point pt, Point pc, Size st, Size sc, Size s) {
    1c5a:	55                   	push   %ebp
    1c5b:	89 e5                	mov    %esp,%ebp
    1c5d:	83 ec 20             	sub    $0x20,%esp
    struct RGB *t;
    struct RGB *o;
    int draw_h = s.h;
    1c60:	8b 45 30             	mov    0x30(%ebp),%eax
    1c63:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int draw_w = s.w;
    1c66:	8b 45 34             	mov    0x34(%ebp),%eax
    1c69:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if (draw_h > st.h - pt.y) {
    1c6c:	8b 55 20             	mov    0x20(%ebp),%edx
    1c6f:	8b 45 14             	mov    0x14(%ebp),%eax
    1c72:	29 c2                	sub    %eax,%edx
    1c74:	89 d0                	mov    %edx,%eax
    1c76:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1c79:	7d 0d                	jge    1c88 <drawTransparentBitmap+0x2e>
        draw_h = st.h - pt.y;
    1c7b:	8b 55 20             	mov    0x20(%ebp),%edx
    1c7e:	8b 45 14             	mov    0x14(%ebp),%eax
    1c81:	29 c2                	sub    %eax,%edx
    1c83:	89 d0                	mov    %edx,%eax
    1c85:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
    if (draw_h > sc.h - pc.y) {
    1c88:	8b 55 28             	mov    0x28(%ebp),%edx
    1c8b:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1c8e:	29 c2                	sub    %eax,%edx
    1c90:	89 d0                	mov    %edx,%eax
    1c92:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1c95:	7d 0d                	jge    1ca4 <drawTransparentBitmap+0x4a>
        draw_h = sc.h - pc.y;
    1c97:	8b 55 28             	mov    0x28(%ebp),%edx
    1c9a:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1c9d:	29 c2                	sub    %eax,%edx
    1c9f:	89 d0                	mov    %edx,%eax
    1ca1:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }

    if (draw_w > st.w - pt.x) {
    1ca4:	8b 55 24             	mov    0x24(%ebp),%edx
    1ca7:	8b 45 10             	mov    0x10(%ebp),%eax
    1caa:	29 c2                	sub    %eax,%edx
    1cac:	89 d0                	mov    %edx,%eax
    1cae:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1cb1:	7d 0d                	jge    1cc0 <drawTransparentBitmap+0x66>
        draw_w = st.w - pt.x;
    1cb3:	8b 55 24             	mov    0x24(%ebp),%edx
    1cb6:	8b 45 10             	mov    0x10(%ebp),%eax
    1cb9:	29 c2                	sub    %eax,%edx
    1cbb:	89 d0                	mov    %edx,%eax
    1cbd:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }
    if (draw_w > sc.w - pc.x) {
    1cc0:	8b 55 2c             	mov    0x2c(%ebp),%edx
    1cc3:	8b 45 18             	mov    0x18(%ebp),%eax
    1cc6:	29 c2                	sub    %eax,%edx
    1cc8:	89 d0                	mov    %edx,%eax
    1cca:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1ccd:	7d 0d                	jge    1cdc <drawTransparentBitmap+0x82>
        draw_w = sc.w - pc.x;
    1ccf:	8b 55 2c             	mov    0x2c(%ebp),%edx
    1cd2:	8b 45 18             	mov    0x18(%ebp),%eax
    1cd5:	29 c2                	sub    %eax,%edx
    1cd7:	89 d0                	mov    %edx,%eax
    1cd9:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }

    for (int i = 0; i < s.h; ++i) {
    1cdc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    1ce3:	e9 b8 00 00 00       	jmp    1da0 <drawTransparentBitmap+0x146>
        for(int j = 0; j < s.w; ++j)
    1ce8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    1cef:	e9 9c 00 00 00       	jmp    1d90 <drawTransparentBitmap+0x136>
        {
            t = tgt + (pt.y + i) * st.w + pt.x + j;
    1cf4:	8b 55 14             	mov    0x14(%ebp),%edx
    1cf7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1cfa:	01 c2                	add    %eax,%edx
    1cfc:	8b 45 24             	mov    0x24(%ebp),%eax
    1cff:	0f af c2             	imul   %edx,%eax
    1d02:	89 c2                	mov    %eax,%edx
    1d04:	8b 45 10             	mov    0x10(%ebp),%eax
    1d07:	01 c2                	add    %eax,%edx
    1d09:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1d0c:	01 c2                	add    %eax,%edx
    1d0e:	89 d0                	mov    %edx,%eax
    1d10:	01 c0                	add    %eax,%eax
    1d12:	01 c2                	add    %eax,%edx
    1d14:	8b 45 08             	mov    0x8(%ebp),%eax
    1d17:	01 d0                	add    %edx,%eax
    1d19:	89 45 ec             	mov    %eax,-0x14(%ebp)
            o = cont + (pc.y + i) * sc.w + pc.x + j;
    1d1c:	8b 55 1c             	mov    0x1c(%ebp),%edx
    1d1f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1d22:	01 c2                	add    %eax,%edx
    1d24:	8b 45 2c             	mov    0x2c(%ebp),%eax
    1d27:	0f af c2             	imul   %edx,%eax
    1d2a:	89 c2                	mov    %eax,%edx
    1d2c:	8b 45 18             	mov    0x18(%ebp),%eax
    1d2f:	01 c2                	add    %eax,%edx
    1d31:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1d34:	01 c2                	add    %eax,%edx
    1d36:	89 d0                	mov    %edx,%eax
    1d38:	01 c0                	add    %eax,%eax
    1d3a:	01 c2                	add    %eax,%edx
    1d3c:	8b 45 0c             	mov    0xc(%ebp),%eax
    1d3f:	01 d0                	add    %edx,%eax
    1d41:	89 45 e8             	mov    %eax,-0x18(%ebp)

            if(o->R==255 && o->G == 255 && o->B==255)
    1d44:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1d47:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    1d4b:	3c ff                	cmp    $0xff,%al
    1d4d:	75 15                	jne    1d64 <drawTransparentBitmap+0x10a>
    1d4f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1d52:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    1d56:	3c ff                	cmp    $0xff,%al
    1d58:	75 0a                	jne    1d64 <drawTransparentBitmap+0x10a>
    1d5a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1d5d:	0f b6 00             	movzbl (%eax),%eax
    1d60:	3c ff                	cmp    $0xff,%al
    1d62:	74 27                	je     1d8b <drawTransparentBitmap+0x131>
                continue;
            t->R = o->R;
    1d64:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1d67:	0f b6 50 02          	movzbl 0x2(%eax),%edx
    1d6b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1d6e:	88 50 02             	mov    %dl,0x2(%eax)
            t->G = o->G;
    1d71:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1d74:	0f b6 50 01          	movzbl 0x1(%eax),%edx
    1d78:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1d7b:	88 50 01             	mov    %dl,0x1(%eax)
            t->B = o->B;
    1d7e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1d81:	0f b6 10             	movzbl (%eax),%edx
    1d84:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1d87:	88 10                	mov    %dl,(%eax)
    1d89:	eb 01                	jmp    1d8c <drawTransparentBitmap+0x132>
        {
            t = tgt + (pt.y + i) * st.w + pt.x + j;
            o = cont + (pc.y + i) * sc.w + pc.x + j;

            if(o->R==255 && o->G == 255 && o->B==255)
                continue;
    1d8b:	90                   	nop
    if (draw_w > sc.w - pc.x) {
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < s.h; ++i) {
        for(int j = 0; j < s.w; ++j)
    1d8c:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    1d90:	8b 45 34             	mov    0x34(%ebp),%eax
    1d93:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    1d96:	0f 8f 58 ff ff ff    	jg     1cf4 <drawTransparentBitmap+0x9a>
    }
    if (draw_w > sc.w - pc.x) {
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < s.h; ++i) {
    1d9c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    1da0:	8b 45 30             	mov    0x30(%ebp),%eax
    1da3:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    1da6:	0f 8f 3c ff ff ff    	jg     1ce8 <drawTransparentBitmap+0x8e>
            t->R = o->R;
            t->G = o->G;
            t->B = o->B;
        }
    }
}
    1dac:	90                   	nop
    1dad:	c9                   	leave  
    1dae:	c3                   	ret    

00001daf <copyContent>:

void copyContent(RGB* tgt, RGB* src, Point p, Size s, Size copy_size) {
    1daf:	55                   	push   %ebp
    1db0:	89 e5                	mov    %esp,%ebp
    1db2:	83 ec 08             	sub    $0x8,%esp
    drawBitmap(tgt, src, p, p, s, s, copy_size);
    1db5:	ff 75 24             	pushl  0x24(%ebp)
    1db8:	ff 75 20             	pushl  0x20(%ebp)
    1dbb:	ff 75 1c             	pushl  0x1c(%ebp)
    1dbe:	ff 75 18             	pushl  0x18(%ebp)
    1dc1:	ff 75 1c             	pushl  0x1c(%ebp)
    1dc4:	ff 75 18             	pushl  0x18(%ebp)
    1dc7:	ff 75 14             	pushl  0x14(%ebp)
    1dca:	ff 75 10             	pushl  0x10(%ebp)
    1dcd:	ff 75 14             	pushl  0x14(%ebp)
    1dd0:	ff 75 10             	pushl  0x10(%ebp)
    1dd3:	ff 75 0c             	pushl  0xc(%ebp)
    1dd6:	ff 75 08             	pushl  0x8(%ebp)
    1dd9:	e8 5c fd ff ff       	call   1b3a <drawBitmap>
    1dde:	83 c4 30             	add    $0x30,%esp
}
    1de1:	90                   	nop
    1de2:	c9                   	leave  
    1de3:	c3                   	ret    

00001de4 <colorShift>:

void colorShift(RGB* buf, Point p, Size s, Size rect_size, int shift) {
    1de4:	55                   	push   %ebp
    1de5:	89 e5                	mov    %esp,%ebp
    1de7:	83 ec 20             	sub    $0x20,%esp
    struct RGB * t;
    int draw_h = rect_size.h;
    1dea:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1ded:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int draw_w = rect_size.w;
    1df0:	8b 45 20             	mov    0x20(%ebp),%eax
    1df3:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if (draw_h > s.h - p.y) {
    1df6:	8b 55 14             	mov    0x14(%ebp),%edx
    1df9:	8b 45 10             	mov    0x10(%ebp),%eax
    1dfc:	29 c2                	sub    %eax,%edx
    1dfe:	89 d0                	mov    %edx,%eax
    1e00:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1e03:	7d 0d                	jge    1e12 <colorShift+0x2e>
        draw_h = s.h - p.y;
    1e05:	8b 55 14             	mov    0x14(%ebp),%edx
    1e08:	8b 45 10             	mov    0x10(%ebp),%eax
    1e0b:	29 c2                	sub    %eax,%edx
    1e0d:	89 d0                	mov    %edx,%eax
    1e0f:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }

    if (draw_w > s.w - p.x) {
    1e12:	8b 55 18             	mov    0x18(%ebp),%edx
    1e15:	8b 45 0c             	mov    0xc(%ebp),%eax
    1e18:	29 c2                	sub    %eax,%edx
    1e1a:	89 d0                	mov    %edx,%eax
    1e1c:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1e1f:	7d 0d                	jge    1e2e <colorShift+0x4a>
        draw_w = s.w - p.x;
    1e21:	8b 55 18             	mov    0x18(%ebp),%edx
    1e24:	8b 45 0c             	mov    0xc(%ebp),%eax
    1e27:	29 c2                	sub    %eax,%edx
    1e29:	89 d0                	mov    %edx,%eax
    1e2b:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }

    for (int i = 0; i < draw_h; i++) {
    1e2e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    1e35:	e9 fc 00 00 00       	jmp    1f36 <colorShift+0x152>
        for(int j = 0; j < draw_w; j++) {
    1e3a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    1e41:	e9 e0 00 00 00       	jmp    1f26 <colorShift+0x142>
            t = buf + (p.y + i) * s.w + p.x + j;
    1e46:	8b 55 10             	mov    0x10(%ebp),%edx
    1e49:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1e4c:	01 c2                	add    %eax,%edx
    1e4e:	8b 45 18             	mov    0x18(%ebp),%eax
    1e51:	0f af c2             	imul   %edx,%eax
    1e54:	89 c2                	mov    %eax,%edx
    1e56:	8b 45 0c             	mov    0xc(%ebp),%eax
    1e59:	01 c2                	add    %eax,%edx
    1e5b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1e5e:	01 c2                	add    %eax,%edx
    1e60:	89 d0                	mov    %edx,%eax
    1e62:	01 c0                	add    %eax,%eax
    1e64:	01 c2                	add    %eax,%edx
    1e66:	8b 45 08             	mov    0x8(%ebp),%eax
    1e69:	01 d0                	add    %edx,%eax
    1e6b:	89 45 ec             	mov    %eax,-0x14(%ebp)
            if (t->R > 200 && t->G > 200 && t->B > 200) {
    1e6e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1e71:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    1e75:	3c c8                	cmp    $0xc8,%al
    1e77:	0f 86 a5 00 00 00    	jbe    1f22 <colorShift+0x13e>
    1e7d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1e80:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    1e84:	3c c8                	cmp    $0xc8,%al
    1e86:	0f 86 96 00 00 00    	jbe    1f22 <colorShift+0x13e>
    1e8c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1e8f:	0f b6 00             	movzbl (%eax),%eax
    1e92:	3c c8                	cmp    $0xc8,%al
    1e94:	0f 86 88 00 00 00    	jbe    1f22 <colorShift+0x13e>
                t->R = (t->R + shift + 256) % 256;
    1e9a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1e9d:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    1ea1:	0f b6 d0             	movzbl %al,%edx
    1ea4:	8b 45 24             	mov    0x24(%ebp),%eax
    1ea7:	01 d0                	add    %edx,%eax
    1ea9:	8d 90 00 01 00 00    	lea    0x100(%eax),%edx
    1eaf:	89 d0                	mov    %edx,%eax
    1eb1:	c1 f8 1f             	sar    $0x1f,%eax
    1eb4:	c1 e8 18             	shr    $0x18,%eax
    1eb7:	01 c2                	add    %eax,%edx
    1eb9:	0f b6 d2             	movzbl %dl,%edx
    1ebc:	29 c2                	sub    %eax,%edx
    1ebe:	89 d0                	mov    %edx,%eax
    1ec0:	89 c2                	mov    %eax,%edx
    1ec2:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1ec5:	88 50 02             	mov    %dl,0x2(%eax)
                t->G = (t->G + shift + 256) % 256;
    1ec8:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1ecb:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    1ecf:	0f b6 d0             	movzbl %al,%edx
    1ed2:	8b 45 24             	mov    0x24(%ebp),%eax
    1ed5:	01 d0                	add    %edx,%eax
    1ed7:	8d 90 00 01 00 00    	lea    0x100(%eax),%edx
    1edd:	89 d0                	mov    %edx,%eax
    1edf:	c1 f8 1f             	sar    $0x1f,%eax
    1ee2:	c1 e8 18             	shr    $0x18,%eax
    1ee5:	01 c2                	add    %eax,%edx
    1ee7:	0f b6 d2             	movzbl %dl,%edx
    1eea:	29 c2                	sub    %eax,%edx
    1eec:	89 d0                	mov    %edx,%eax
    1eee:	89 c2                	mov    %eax,%edx
    1ef0:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1ef3:	88 50 01             	mov    %dl,0x1(%eax)
                t->B = (t->B + shift + 256) % 256;
    1ef6:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1ef9:	0f b6 00             	movzbl (%eax),%eax
    1efc:	0f b6 d0             	movzbl %al,%edx
    1eff:	8b 45 24             	mov    0x24(%ebp),%eax
    1f02:	01 d0                	add    %edx,%eax
    1f04:	8d 90 00 01 00 00    	lea    0x100(%eax),%edx
    1f0a:	89 d0                	mov    %edx,%eax
    1f0c:	c1 f8 1f             	sar    $0x1f,%eax
    1f0f:	c1 e8 18             	shr    $0x18,%eax
    1f12:	01 c2                	add    %eax,%edx
    1f14:	0f b6 d2             	movzbl %dl,%edx
    1f17:	29 c2                	sub    %eax,%edx
    1f19:	89 d0                	mov    %edx,%eax
    1f1b:	89 c2                	mov    %eax,%edx
    1f1d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1f20:	88 10                	mov    %dl,(%eax)
    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
        for(int j = 0; j < draw_w; j++) {
    1f22:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    1f26:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1f29:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1f2c:	0f 8c 14 ff ff ff    	jl     1e46 <colorShift+0x62>

    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
    1f32:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    1f36:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1f39:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1f3c:	0f 8c f8 fe ff ff    	jl     1e3a <colorShift+0x56>
                t->G = (t->G + shift + 256) % 256;
                t->B = (t->B + shift + 256) % 256;
            }
        }
    }
}
    1f42:	90                   	nop
    1f43:	c9                   	leave  
    1f44:	c3                   	ret    

00001f45 <drawMouse>:

void drawMouse(RGB *buf, int mode, int x, int y) {
    1f45:	55                   	push   %ebp
    1f46:	89 e5                	mov    %esp,%ebp
    1f48:	83 ec 10             	sub    $0x10,%esp
    int i, j;
    RGB *t;
    for (i = 0; i < MOUSE_HEIGHT; i++) {
    1f4b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    1f52:	e9 fb 00 00 00       	jmp    2052 <drawMouse+0x10d>
        if (y + i > SCREEN_HEIGHT || y + i < 0) {
    1f57:	8b 55 14             	mov    0x14(%ebp),%edx
    1f5a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1f5d:	01 c2                	add    %eax,%edx
    1f5f:	0f b7 05 16 e6 01 00 	movzwl 0x1e616,%eax
    1f66:	0f b7 c0             	movzwl %ax,%eax
    1f69:	39 c2                	cmp    %eax,%edx
    1f6b:	0f 8f eb 00 00 00    	jg     205c <drawMouse+0x117>
    1f71:	8b 55 14             	mov    0x14(%ebp),%edx
    1f74:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1f77:	01 d0                	add    %edx,%eax
    1f79:	85 c0                	test   %eax,%eax
    1f7b:	0f 88 db 00 00 00    	js     205c <drawMouse+0x117>
            break;
        }
        for (j = 0; j < MOUSE_WIDTH; j++) {
    1f81:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    1f88:	e9 b7 00 00 00       	jmp    2044 <drawMouse+0xff>
            if (x + j > SCREEN_WIDTH || x + j < 0) {
    1f8d:	8b 55 10             	mov    0x10(%ebp),%edx
    1f90:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1f93:	01 c2                	add    %eax,%edx
    1f95:	0f b7 05 14 e6 01 00 	movzwl 0x1e614,%eax
    1f9c:	0f b7 c0             	movzwl %ax,%eax
    1f9f:	39 c2                	cmp    %eax,%edx
    1fa1:	0f 8f a7 00 00 00    	jg     204e <drawMouse+0x109>
    1fa7:	8b 55 10             	mov    0x10(%ebp),%edx
    1faa:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1fad:	01 d0                	add    %edx,%eax
    1faf:	85 c0                	test   %eax,%eax
    1fb1:	0f 88 97 00 00 00    	js     204e <drawMouse+0x109>
                break;
            }
            uchar temp = mouse_pointer[mode][i][j];
    1fb7:	8b 55 fc             	mov    -0x4(%ebp),%edx
    1fba:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    1fbd:	89 d0                	mov    %edx,%eax
    1fbf:	c1 e0 04             	shl    $0x4,%eax
    1fc2:	29 d0                	sub    %edx,%eax
    1fc4:	69 d1 0e 01 00 00    	imul   $0x10e,%ecx,%edx
    1fca:	01 c2                	add    %eax,%edx
    1fcc:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1fcf:	01 d0                	add    %edx,%eax
    1fd1:	05 40 5f 01 00       	add    $0x15f40,%eax
    1fd6:	0f b6 00             	movzbl (%eax),%eax
    1fd9:	88 45 f7             	mov    %al,-0x9(%ebp)
            if (temp) {
    1fdc:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
    1fe0:	74 5e                	je     2040 <drawMouse+0xfb>
                t = buf + (y + i) * SCREEN_WIDTH + x + j;
    1fe2:	8b 55 14             	mov    0x14(%ebp),%edx
    1fe5:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1fe8:	01 c2                	add    %eax,%edx
    1fea:	0f b7 05 14 e6 01 00 	movzwl 0x1e614,%eax
    1ff1:	0f b7 c0             	movzwl %ax,%eax
    1ff4:	0f af c2             	imul   %edx,%eax
    1ff7:	89 c2                	mov    %eax,%edx
    1ff9:	8b 45 10             	mov    0x10(%ebp),%eax
    1ffc:	01 c2                	add    %eax,%edx
    1ffe:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2001:	01 c2                	add    %eax,%edx
    2003:	89 d0                	mov    %edx,%eax
    2005:	01 c0                	add    %eax,%eax
    2007:	01 c2                	add    %eax,%edx
    2009:	8b 45 08             	mov    0x8(%ebp),%eax
    200c:	01 d0                	add    %edx,%eax
    200e:	89 45 f0             	mov    %eax,-0x10(%ebp)
                drawPoint(t, mouse_color[temp - 1]);
    2011:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
    2015:	8d 50 ff             	lea    -0x1(%eax),%edx
    2018:	89 d0                	mov    %edx,%eax
    201a:	01 c0                	add    %eax,%eax
    201c:	01 d0                	add    %edx,%eax
    201e:	05 1c e6 01 00       	add    $0x1e61c,%eax
    2023:	83 ec 04             	sub    $0x4,%esp
    2026:	89 e2                	mov    %esp,%edx
    2028:	0f b7 08             	movzwl (%eax),%ecx
    202b:	66 89 0a             	mov    %cx,(%edx)
    202e:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2032:	88 42 02             	mov    %al,0x2(%edx)
    2035:	ff 75 f0             	pushl  -0x10(%ebp)
    2038:	e8 73 f6 ff ff       	call   16b0 <drawPoint>
    203d:	83 c4 08             	add    $0x8,%esp
    RGB *t;
    for (i = 0; i < MOUSE_HEIGHT; i++) {
        if (y + i > SCREEN_HEIGHT || y + i < 0) {
            break;
        }
        for (j = 0; j < MOUSE_WIDTH; j++) {
    2040:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    2044:	83 7d f8 0e          	cmpl   $0xe,-0x8(%ebp)
    2048:	0f 8e 3f ff ff ff    	jle    1f8d <drawMouse+0x48>
}

void drawMouse(RGB *buf, int mode, int x, int y) {
    int i, j;
    RGB *t;
    for (i = 0; i < MOUSE_HEIGHT; i++) {
    204e:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    2052:	83 7d fc 11          	cmpl   $0x11,-0x4(%ebp)
    2056:	0f 8e fb fe ff ff    	jle    1f57 <drawMouse+0x12>
                t = buf + (y + i) * SCREEN_WIDTH + x + j;
                drawPoint(t, mouse_color[temp - 1]);
            }
        }
    }
}
    205c:	90                   	nop
    205d:	c9                   	leave  
    205e:	c3                   	ret    

0000205f <getColor>:
RGB whiteRGB = {255, 255, 255};
RGB blackRGB = {0, 0, 0};

// 排除边界，获取对应的RGB，对于错误的x，y，将isInPic置位0
struct RGB *getColor(PBitmap *pic, int y, int x, int *isInPic)
{
    205f:	55                   	push   %ebp
    2060:	89 e5                	mov    %esp,%ebp
    if (y < 0 || y > pic->height || x < 0 || x > pic->width)
    2062:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    2066:	78 1b                	js     2083 <getColor+0x24>
    2068:	8b 45 08             	mov    0x8(%ebp),%eax
    206b:	8b 40 04             	mov    0x4(%eax),%eax
    206e:	3b 45 0c             	cmp    0xc(%ebp),%eax
    2071:	7c 10                	jl     2083 <getColor+0x24>
    2073:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    2077:	78 0a                	js     2083 <getColor+0x24>
    2079:	8b 45 08             	mov    0x8(%ebp),%eax
    207c:	8b 00                	mov    (%eax),%eax
    207e:	3b 45 10             	cmp    0x10(%ebp),%eax
    2081:	7d 10                	jge    2093 <getColor+0x34>
    {
        *isInPic = 1;
    2083:	8b 45 14             	mov    0x14(%ebp),%eax
    2086:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        return (&whiteRGB);
    208c:	b8 d1 e1 01 00       	mov    $0x1e1d1,%eax
    2091:	eb 44                	jmp    20d7 <getColor+0x78>
    }

    if (y == pic->height)
    2093:	8b 45 08             	mov    0x8(%ebp),%eax
    2096:	8b 40 04             	mov    0x4(%eax),%eax
    2099:	3b 45 0c             	cmp    0xc(%ebp),%eax
    209c:	75 04                	jne    20a2 <getColor+0x43>
        y--;
    209e:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
    if (x == pic->width)
    20a2:	8b 45 08             	mov    0x8(%ebp),%eax
    20a5:	8b 00                	mov    (%eax),%eax
    20a7:	3b 45 10             	cmp    0x10(%ebp),%eax
    20aa:	75 04                	jne    20b0 <getColor+0x51>
        x--;
    20ac:	83 6d 10 01          	subl   $0x1,0x10(%ebp)

    *isInPic = 1;
    20b0:	8b 45 14             	mov    0x14(%ebp),%eax
    20b3:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    return (pic->data + y * pic->width + x);
    20b9:	8b 45 08             	mov    0x8(%ebp),%eax
    20bc:	8b 48 08             	mov    0x8(%eax),%ecx
    20bf:	8b 45 08             	mov    0x8(%ebp),%eax
    20c2:	8b 00                	mov    (%eax),%eax
    20c4:	0f af 45 0c          	imul   0xc(%ebp),%eax
    20c8:	89 c2                	mov    %eax,%edx
    20ca:	8b 45 10             	mov    0x10(%ebp),%eax
    20cd:	01 c2                	add    %eax,%edx
    20cf:	89 d0                	mov    %edx,%eax
    20d1:	01 c0                	add    %eax,%eax
    20d3:	01 d0                	add    %edx,%eax
    20d5:	01 c8                	add    %ecx,%eax
}
    20d7:	5d                   	pop    %ebp
    20d8:	c3                   	ret    

000020d9 <setColor>:

int setColor(RGB *src, RGB *dst)
{
    20d9:	55                   	push   %ebp
    20da:	89 e5                	mov    %esp,%ebp
    dst->R = src->R;
    20dc:	8b 45 08             	mov    0x8(%ebp),%eax
    20df:	0f b6 50 02          	movzbl 0x2(%eax),%edx
    20e3:	8b 45 0c             	mov    0xc(%ebp),%eax
    20e6:	88 50 02             	mov    %dl,0x2(%eax)
    dst->G = src->G;
    20e9:	8b 45 08             	mov    0x8(%ebp),%eax
    20ec:	0f b6 50 01          	movzbl 0x1(%eax),%edx
    20f0:	8b 45 0c             	mov    0xc(%ebp),%eax
    20f3:	88 50 01             	mov    %dl,0x1(%eax)
    dst->B = src->B;
    20f6:	8b 45 08             	mov    0x8(%ebp),%eax
    20f9:	0f b6 10             	movzbl (%eax),%edx
    20fc:	8b 45 0c             	mov    0xc(%ebp),%eax
    20ff:	88 10                	mov    %dl,(%eax)

    return 1;
    2101:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2106:	5d                   	pop    %ebp
    2107:	c3                   	ret    

00002108 <mixColor>:

// 获取经过二次插值之后的RGB
int mixColor(PBitmap *src, float fy, float fx, RGB *dst)
{
    2108:	55                   	push   %ebp
    2109:	89 e5                	mov    %esp,%ebp
    210b:	83 ec 4c             	sub    $0x4c,%esp
    int x = (int)fx;
    210e:	d9 45 10             	flds   0x10(%ebp)
    2111:	d9 7d be             	fnstcw -0x42(%ebp)
    2114:	0f b7 45 be          	movzwl -0x42(%ebp),%eax
    2118:	b4 0c                	mov    $0xc,%ah
    211a:	66 89 45 bc          	mov    %ax,-0x44(%ebp)
    211e:	d9 6d bc             	fldcw  -0x44(%ebp)
    2121:	db 5d fc             	fistpl -0x4(%ebp)
    2124:	d9 6d be             	fldcw  -0x42(%ebp)
    int y = (int)fy;
    2127:	d9 45 0c             	flds   0xc(%ebp)
    212a:	d9 6d bc             	fldcw  -0x44(%ebp)
    212d:	db 5d f8             	fistpl -0x8(%ebp)
    2130:	d9 6d be             	fldcw  -0x42(%ebp)
    if (x > fx)
    2133:	db 45 fc             	fildl  -0x4(%ebp)
    2136:	d9 45 10             	flds   0x10(%ebp)
    2139:	d9 c9                	fxch   %st(1)
    213b:	df e9                	fucomip %st(1),%st
    213d:	dd d8                	fstp   %st(0)
    213f:	76 04                	jbe    2145 <mixColor+0x3d>
        x--;
    2141:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
    if (y > fy)
    2145:	db 45 f8             	fildl  -0x8(%ebp)
    2148:	d9 45 0c             	flds   0xc(%ebp)
    214b:	d9 c9                	fxch   %st(1)
    214d:	df e9                	fucomip %st(1),%st
    214f:	dd d8                	fstp   %st(0)
    2151:	76 04                	jbe    2157 <mixColor+0x4f>
        y--;
    2153:	83 6d f8 01          	subl   $0x1,-0x8(%ebp)

    int flag[4];
    RGB *Color0 = getColor(src, y, x, &flag[0]);
    2157:	8d 45 c0             	lea    -0x40(%ebp),%eax
    215a:	50                   	push   %eax
    215b:	ff 75 fc             	pushl  -0x4(%ebp)
    215e:	ff 75 f8             	pushl  -0x8(%ebp)
    2161:	ff 75 08             	pushl  0x8(%ebp)
    2164:	e8 f6 fe ff ff       	call   205f <getColor>
    2169:	83 c4 10             	add    $0x10,%esp
    216c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    RGB *Color1 = getColor(src, y + 1, x, &flag[1]);
    216f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2172:	83 c0 01             	add    $0x1,%eax
    2175:	8d 55 c0             	lea    -0x40(%ebp),%edx
    2178:	83 c2 04             	add    $0x4,%edx
    217b:	52                   	push   %edx
    217c:	ff 75 fc             	pushl  -0x4(%ebp)
    217f:	50                   	push   %eax
    2180:	ff 75 08             	pushl  0x8(%ebp)
    2183:	e8 d7 fe ff ff       	call   205f <getColor>
    2188:	83 c4 10             	add    $0x10,%esp
    218b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    RGB *Color2 = getColor(src, y, x + 1, &flag[2]);
    218e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    2191:	83 c0 01             	add    $0x1,%eax
    2194:	8d 55 c0             	lea    -0x40(%ebp),%edx
    2197:	83 c2 08             	add    $0x8,%edx
    219a:	52                   	push   %edx
    219b:	50                   	push   %eax
    219c:	ff 75 f8             	pushl  -0x8(%ebp)
    219f:	ff 75 08             	pushl  0x8(%ebp)
    21a2:	e8 b8 fe ff ff       	call   205f <getColor>
    21a7:	83 c4 10             	add    $0x10,%esp
    21aa:	89 45 ec             	mov    %eax,-0x14(%ebp)
    RGB *Color3 = getColor(src, y + 1, x + 1, &flag[3]);
    21ad:	8b 45 fc             	mov    -0x4(%ebp),%eax
    21b0:	8d 50 01             	lea    0x1(%eax),%edx
    21b3:	8b 45 f8             	mov    -0x8(%ebp),%eax
    21b6:	83 c0 01             	add    $0x1,%eax
    21b9:	8d 4d c0             	lea    -0x40(%ebp),%ecx
    21bc:	83 c1 0c             	add    $0xc,%ecx
    21bf:	51                   	push   %ecx
    21c0:	52                   	push   %edx
    21c1:	50                   	push   %eax
    21c2:	ff 75 08             	pushl  0x8(%ebp)
    21c5:	e8 95 fe ff ff       	call   205f <getColor>
    21ca:	83 c4 10             	add    $0x10,%esp
    21cd:	89 45 e8             	mov    %eax,-0x18(%ebp)

    float u = fx - x;
    21d0:	db 45 fc             	fildl  -0x4(%ebp)
    21d3:	d9 45 10             	flds   0x10(%ebp)
    21d6:	de e1                	fsubp  %st,%st(1)
    21d8:	d9 5d e4             	fstps  -0x1c(%ebp)
    float v = fy - y;
    21db:	db 45 f8             	fildl  -0x8(%ebp)
    21de:	d9 45 0c             	flds   0xc(%ebp)
    21e1:	de e1                	fsubp  %st,%st(1)
    21e3:	d9 5d e0             	fstps  -0x20(%ebp)

    float pm3 = u * v;
    21e6:	d9 45 e4             	flds   -0x1c(%ebp)
    21e9:	d8 4d e0             	fmuls  -0x20(%ebp)
    21ec:	d9 5d dc             	fstps  -0x24(%ebp)
    float pm2 = u * (1 - v);
    21ef:	d9 e8                	fld1   
    21f1:	d8 65 e0             	fsubs  -0x20(%ebp)
    21f4:	d8 4d e4             	fmuls  -0x1c(%ebp)
    21f7:	d9 5d d8             	fstps  -0x28(%ebp)
    float pm1 = (1 - u) * v;
    21fa:	d9 e8                	fld1   
    21fc:	d8 65 e4             	fsubs  -0x1c(%ebp)
    21ff:	d8 4d e0             	fmuls  -0x20(%ebp)
    2202:	d9 5d d4             	fstps  -0x2c(%ebp)
    float pm0 = (1 - u) * (1 - v);
    2205:	d9 e8                	fld1   
    2207:	d8 65 e4             	fsubs  -0x1c(%ebp)
    220a:	d9 e8                	fld1   
    220c:	d8 65 e0             	fsubs  -0x20(%ebp)
    220f:	de c9                	fmulp  %st,%st(1)
    2211:	d9 5d d0             	fstps  -0x30(%ebp)

    dst->R = (int)(Color0->R * pm0 * flag[0] + Color1->R * pm1 * flag[1] + Color2->R * pm2 * flag[2] + Color3->R * pm3 * flag[3]);
    2214:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2217:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    221b:	0f b6 c0             	movzbl %al,%eax
    221e:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2221:	db 45 b4             	fildl  -0x4c(%ebp)
    2224:	d8 4d d0             	fmuls  -0x30(%ebp)
    2227:	8b 45 c0             	mov    -0x40(%ebp),%eax
    222a:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    222d:	db 45 b4             	fildl  -0x4c(%ebp)
    2230:	de c9                	fmulp  %st,%st(1)
    2232:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2235:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2239:	0f b6 c0             	movzbl %al,%eax
    223c:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    223f:	db 45 b4             	fildl  -0x4c(%ebp)
    2242:	d8 4d d4             	fmuls  -0x2c(%ebp)
    2245:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2248:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    224b:	db 45 b4             	fildl  -0x4c(%ebp)
    224e:	de c9                	fmulp  %st,%st(1)
    2250:	de c1                	faddp  %st,%st(1)
    2252:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2255:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2259:	0f b6 c0             	movzbl %al,%eax
    225c:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    225f:	db 45 b4             	fildl  -0x4c(%ebp)
    2262:	d8 4d d8             	fmuls  -0x28(%ebp)
    2265:	8b 45 c8             	mov    -0x38(%ebp),%eax
    2268:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    226b:	db 45 b4             	fildl  -0x4c(%ebp)
    226e:	de c9                	fmulp  %st,%st(1)
    2270:	de c1                	faddp  %st,%st(1)
    2272:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2275:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2279:	0f b6 c0             	movzbl %al,%eax
    227c:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    227f:	db 45 b4             	fildl  -0x4c(%ebp)
    2282:	d8 4d dc             	fmuls  -0x24(%ebp)
    2285:	8b 45 cc             	mov    -0x34(%ebp),%eax
    2288:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    228b:	db 45 b4             	fildl  -0x4c(%ebp)
    228e:	de c9                	fmulp  %st,%st(1)
    2290:	de c1                	faddp  %st,%st(1)
    2292:	d9 7d be             	fnstcw -0x42(%ebp)
    2295:	0f b7 45 be          	movzwl -0x42(%ebp),%eax
    2299:	b4 0c                	mov    $0xc,%ah
    229b:	66 89 45 bc          	mov    %ax,-0x44(%ebp)
    229f:	d9 6d bc             	fldcw  -0x44(%ebp)
    22a2:	db 5d b8             	fistpl -0x48(%ebp)
    22a5:	d9 6d be             	fldcw  -0x42(%ebp)
    22a8:	8b 45 b8             	mov    -0x48(%ebp),%eax
    22ab:	89 c2                	mov    %eax,%edx
    22ad:	8b 45 14             	mov    0x14(%ebp),%eax
    22b0:	88 50 02             	mov    %dl,0x2(%eax)
    dst->G = (int)(Color0->G * pm0 * flag[0] + Color1->G * pm1 * flag[1] + Color2->G * pm2 * flag[2] + Color3->G * pm3 * flag[3]);
    22b3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    22b6:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    22ba:	0f b6 c0             	movzbl %al,%eax
    22bd:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    22c0:	db 45 b4             	fildl  -0x4c(%ebp)
    22c3:	d8 4d d0             	fmuls  -0x30(%ebp)
    22c6:	8b 45 c0             	mov    -0x40(%ebp),%eax
    22c9:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    22cc:	db 45 b4             	fildl  -0x4c(%ebp)
    22cf:	de c9                	fmulp  %st,%st(1)
    22d1:	8b 45 f0             	mov    -0x10(%ebp),%eax
    22d4:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    22d8:	0f b6 c0             	movzbl %al,%eax
    22db:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    22de:	db 45 b4             	fildl  -0x4c(%ebp)
    22e1:	d8 4d d4             	fmuls  -0x2c(%ebp)
    22e4:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    22e7:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    22ea:	db 45 b4             	fildl  -0x4c(%ebp)
    22ed:	de c9                	fmulp  %st,%st(1)
    22ef:	de c1                	faddp  %st,%st(1)
    22f1:	8b 45 ec             	mov    -0x14(%ebp),%eax
    22f4:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    22f8:	0f b6 c0             	movzbl %al,%eax
    22fb:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    22fe:	db 45 b4             	fildl  -0x4c(%ebp)
    2301:	d8 4d d8             	fmuls  -0x28(%ebp)
    2304:	8b 45 c8             	mov    -0x38(%ebp),%eax
    2307:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    230a:	db 45 b4             	fildl  -0x4c(%ebp)
    230d:	de c9                	fmulp  %st,%st(1)
    230f:	de c1                	faddp  %st,%st(1)
    2311:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2314:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2318:	0f b6 c0             	movzbl %al,%eax
    231b:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    231e:	db 45 b4             	fildl  -0x4c(%ebp)
    2321:	d8 4d dc             	fmuls  -0x24(%ebp)
    2324:	8b 45 cc             	mov    -0x34(%ebp),%eax
    2327:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    232a:	db 45 b4             	fildl  -0x4c(%ebp)
    232d:	de c9                	fmulp  %st,%st(1)
    232f:	de c1                	faddp  %st,%st(1)
    2331:	d9 6d bc             	fldcw  -0x44(%ebp)
    2334:	db 5d b8             	fistpl -0x48(%ebp)
    2337:	d9 6d be             	fldcw  -0x42(%ebp)
    233a:	8b 45 b8             	mov    -0x48(%ebp),%eax
    233d:	89 c2                	mov    %eax,%edx
    233f:	8b 45 14             	mov    0x14(%ebp),%eax
    2342:	88 50 01             	mov    %dl,0x1(%eax)
    dst->B = (int)(Color0->B * pm0 * flag[0] + Color1->B * pm1 * flag[1] + Color2->B * pm2 * flag[2] + Color3->B * pm3 * flag[3]);
    2345:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2348:	0f b6 00             	movzbl (%eax),%eax
    234b:	0f b6 c0             	movzbl %al,%eax
    234e:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2351:	db 45 b4             	fildl  -0x4c(%ebp)
    2354:	d8 4d d0             	fmuls  -0x30(%ebp)
    2357:	8b 45 c0             	mov    -0x40(%ebp),%eax
    235a:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    235d:	db 45 b4             	fildl  -0x4c(%ebp)
    2360:	de c9                	fmulp  %st,%st(1)
    2362:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2365:	0f b6 00             	movzbl (%eax),%eax
    2368:	0f b6 c0             	movzbl %al,%eax
    236b:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    236e:	db 45 b4             	fildl  -0x4c(%ebp)
    2371:	d8 4d d4             	fmuls  -0x2c(%ebp)
    2374:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2377:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    237a:	db 45 b4             	fildl  -0x4c(%ebp)
    237d:	de c9                	fmulp  %st,%st(1)
    237f:	de c1                	faddp  %st,%st(1)
    2381:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2384:	0f b6 00             	movzbl (%eax),%eax
    2387:	0f b6 c0             	movzbl %al,%eax
    238a:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    238d:	db 45 b4             	fildl  -0x4c(%ebp)
    2390:	d8 4d d8             	fmuls  -0x28(%ebp)
    2393:	8b 45 c8             	mov    -0x38(%ebp),%eax
    2396:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2399:	db 45 b4             	fildl  -0x4c(%ebp)
    239c:	de c9                	fmulp  %st,%st(1)
    239e:	de c1                	faddp  %st,%st(1)
    23a0:	8b 45 e8             	mov    -0x18(%ebp),%eax
    23a3:	0f b6 00             	movzbl (%eax),%eax
    23a6:	0f b6 c0             	movzbl %al,%eax
    23a9:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    23ac:	db 45 b4             	fildl  -0x4c(%ebp)
    23af:	d8 4d dc             	fmuls  -0x24(%ebp)
    23b2:	8b 45 cc             	mov    -0x34(%ebp),%eax
    23b5:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    23b8:	db 45 b4             	fildl  -0x4c(%ebp)
    23bb:	de c9                	fmulp  %st,%st(1)
    23bd:	de c1                	faddp  %st,%st(1)
    23bf:	d9 6d bc             	fldcw  -0x44(%ebp)
    23c2:	db 5d b8             	fistpl -0x48(%ebp)
    23c5:	d9 6d be             	fldcw  -0x42(%ebp)
    23c8:	8b 45 b8             	mov    -0x48(%ebp),%eax
    23cb:	89 c2                	mov    %eax,%edx
    23cd:	8b 45 14             	mov    0x14(%ebp),%eax
    23d0:	88 10                	mov    %dl,(%eax)

    return 1;
    23d2:	b8 01 00 00 00       	mov    $0x1,%eax
}
    23d7:	c9                   	leave  
    23d8:	c3                   	ret    

000023d9 <mixColorInt>:

// 将float改为int计算，加快速度
int mixColorInt(PBitmap *src, const int y_16, const int x_16, RGB *dst)
{
    23d9:	55                   	push   %ebp
    23da:	89 e5                	mov    %esp,%ebp
    23dc:	53                   	push   %ebx
    23dd:	83 ec 40             	sub    $0x40,%esp
    int x = x_16 >> 16;
    23e0:	8b 45 10             	mov    0x10(%ebp),%eax
    23e3:	c1 f8 10             	sar    $0x10,%eax
    23e6:	89 45 f8             	mov    %eax,-0x8(%ebp)
    int y = y_16 >> 16;
    23e9:	8b 45 0c             	mov    0xc(%ebp),%eax
    23ec:	c1 f8 10             	sar    $0x10,%eax
    23ef:	89 45 f4             	mov    %eax,-0xc(%ebp)

    int flag[4];
    RGB *Color0 = getColor(src, y, x, &flag[0]);
    23f2:	8d 45 bc             	lea    -0x44(%ebp),%eax
    23f5:	50                   	push   %eax
    23f6:	ff 75 f8             	pushl  -0x8(%ebp)
    23f9:	ff 75 f4             	pushl  -0xc(%ebp)
    23fc:	ff 75 08             	pushl  0x8(%ebp)
    23ff:	e8 5b fc ff ff       	call   205f <getColor>
    2404:	83 c4 10             	add    $0x10,%esp
    2407:	89 45 f0             	mov    %eax,-0x10(%ebp)
    RGB *Color1 = getColor(src, y + 1, x, &flag[1]);
    240a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    240d:	83 c0 01             	add    $0x1,%eax
    2410:	8d 55 bc             	lea    -0x44(%ebp),%edx
    2413:	83 c2 04             	add    $0x4,%edx
    2416:	52                   	push   %edx
    2417:	ff 75 f8             	pushl  -0x8(%ebp)
    241a:	50                   	push   %eax
    241b:	ff 75 08             	pushl  0x8(%ebp)
    241e:	e8 3c fc ff ff       	call   205f <getColor>
    2423:	83 c4 10             	add    $0x10,%esp
    2426:	89 45 ec             	mov    %eax,-0x14(%ebp)
    RGB *Color2 = getColor(src, y, x + 1, &flag[2]);
    2429:	8b 45 f8             	mov    -0x8(%ebp),%eax
    242c:	83 c0 01             	add    $0x1,%eax
    242f:	8d 55 bc             	lea    -0x44(%ebp),%edx
    2432:	83 c2 08             	add    $0x8,%edx
    2435:	52                   	push   %edx
    2436:	50                   	push   %eax
    2437:	ff 75 f4             	pushl  -0xc(%ebp)
    243a:	ff 75 08             	pushl  0x8(%ebp)
    243d:	e8 1d fc ff ff       	call   205f <getColor>
    2442:	83 c4 10             	add    $0x10,%esp
    2445:	89 45 e8             	mov    %eax,-0x18(%ebp)
    RGB *Color3 = getColor(src, y + 1, x + 1, &flag[3]);
    2448:	8b 45 f8             	mov    -0x8(%ebp),%eax
    244b:	8d 50 01             	lea    0x1(%eax),%edx
    244e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2451:	83 c0 01             	add    $0x1,%eax
    2454:	8d 4d bc             	lea    -0x44(%ebp),%ecx
    2457:	83 c1 0c             	add    $0xc,%ecx
    245a:	51                   	push   %ecx
    245b:	52                   	push   %edx
    245c:	50                   	push   %eax
    245d:	ff 75 08             	pushl  0x8(%ebp)
    2460:	e8 fa fb ff ff       	call   205f <getColor>
    2465:	83 c4 10             	add    $0x10,%esp
    2468:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    unsigned int u_8 = (x_16 & 0xFFFF) >> 8;
    246b:	8b 45 10             	mov    0x10(%ebp),%eax
    246e:	0f b7 c0             	movzwl %ax,%eax
    2471:	c1 f8 08             	sar    $0x8,%eax
    2474:	89 45 e0             	mov    %eax,-0x20(%ebp)
    unsigned int v_8 = (y_16 & 0xFFFF) >> 8;
    2477:	8b 45 0c             	mov    0xc(%ebp),%eax
    247a:	0f b7 c0             	movzwl %ax,%eax
    247d:	c1 f8 08             	sar    $0x8,%eax
    2480:	89 45 dc             	mov    %eax,-0x24(%ebp)

    unsigned int pm3_16 = (u_8 * v_8);
    2483:	8b 45 e0             	mov    -0x20(%ebp),%eax
    2486:	0f af 45 dc          	imul   -0x24(%ebp),%eax
    248a:	89 45 d8             	mov    %eax,-0x28(%ebp)
    unsigned int pm2_16 = (u_8 * (255 - v_8));
    248d:	b8 ff 00 00 00       	mov    $0xff,%eax
    2492:	2b 45 dc             	sub    -0x24(%ebp),%eax
    2495:	0f af 45 e0          	imul   -0x20(%ebp),%eax
    2499:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    unsigned int pm1_16 = ((255 - u_8) * v_8);
    249c:	b8 ff 00 00 00       	mov    $0xff,%eax
    24a1:	2b 45 e0             	sub    -0x20(%ebp),%eax
    24a4:	0f af 45 dc          	imul   -0x24(%ebp),%eax
    24a8:	89 45 d0             	mov    %eax,-0x30(%ebp)
    unsigned int pm0_16 = ((255 - u_8) * (255 - v_8));
    24ab:	b8 ff 00 00 00       	mov    $0xff,%eax
    24b0:	2b 45 e0             	sub    -0x20(%ebp),%eax
    24b3:	89 c2                	mov    %eax,%edx
    24b5:	b8 ff 00 00 00       	mov    $0xff,%eax
    24ba:	2b 45 dc             	sub    -0x24(%ebp),%eax
    24bd:	0f af c2             	imul   %edx,%eax
    24c0:	89 45 cc             	mov    %eax,-0x34(%ebp)

    dst->R = ((pm0_16 * Color0->R * flag[0] + pm1_16 * Color1->R * flag[1] + pm2_16 * Color2->R * flag[2] + pm3_16 * Color3->R * flag[3]) >> 16);
    24c3:	8b 45 f0             	mov    -0x10(%ebp),%eax
    24c6:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    24ca:	0f b6 c0             	movzbl %al,%eax
    24cd:	0f af 45 cc          	imul   -0x34(%ebp),%eax
    24d1:	8b 55 bc             	mov    -0x44(%ebp),%edx
    24d4:	0f af d0             	imul   %eax,%edx
    24d7:	8b 45 ec             	mov    -0x14(%ebp),%eax
    24da:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    24de:	0f b6 c0             	movzbl %al,%eax
    24e1:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    24e5:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    24e8:	0f af c1             	imul   %ecx,%eax
    24eb:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    24ee:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    24f1:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    24f5:	0f b6 c0             	movzbl %al,%eax
    24f8:	0f af 45 d8          	imul   -0x28(%ebp),%eax
    24fc:	8b 55 c8             	mov    -0x38(%ebp),%edx
    24ff:	0f af d0             	imul   %eax,%edx
    2502:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2505:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2509:	0f b6 c0             	movzbl %al,%eax
    250c:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    2510:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    2513:	0f af c1             	imul   %ecx,%eax
    2516:	01 d0                	add    %edx,%eax
    2518:	01 d8                	add    %ebx,%eax
    251a:	c1 e8 10             	shr    $0x10,%eax
    251d:	89 c2                	mov    %eax,%edx
    251f:	8b 45 14             	mov    0x14(%ebp),%eax
    2522:	88 50 02             	mov    %dl,0x2(%eax)
    dst->G = ((pm0_16 * Color0->G * flag[0] + pm1_16 * Color1->G * flag[1] + pm2_16 * Color2->G * flag[2] + pm3_16 * Color3->G * flag[3]) >> 16);
    2525:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2528:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    252c:	0f b6 c0             	movzbl %al,%eax
    252f:	0f af 45 cc          	imul   -0x34(%ebp),%eax
    2533:	8b 55 bc             	mov    -0x44(%ebp),%edx
    2536:	0f af d0             	imul   %eax,%edx
    2539:	8b 45 ec             	mov    -0x14(%ebp),%eax
    253c:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2540:	0f b6 c0             	movzbl %al,%eax
    2543:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    2547:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    254a:	0f af c1             	imul   %ecx,%eax
    254d:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    2550:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2553:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2557:	0f b6 c0             	movzbl %al,%eax
    255a:	0f af 45 d8          	imul   -0x28(%ebp),%eax
    255e:	8b 55 c8             	mov    -0x38(%ebp),%edx
    2561:	0f af d0             	imul   %eax,%edx
    2564:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2567:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    256b:	0f b6 c0             	movzbl %al,%eax
    256e:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    2572:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    2575:	0f af c1             	imul   %ecx,%eax
    2578:	01 d0                	add    %edx,%eax
    257a:	01 d8                	add    %ebx,%eax
    257c:	c1 e8 10             	shr    $0x10,%eax
    257f:	89 c2                	mov    %eax,%edx
    2581:	8b 45 14             	mov    0x14(%ebp),%eax
    2584:	88 50 01             	mov    %dl,0x1(%eax)
    dst->B = ((pm0_16 * Color0->B * flag[0] + pm1_16 * Color1->B * flag[1] + pm2_16 * Color2->B * flag[2] + pm3_16 * Color3->B * flag[3]) >> 16);
    2587:	8b 45 f0             	mov    -0x10(%ebp),%eax
    258a:	0f b6 00             	movzbl (%eax),%eax
    258d:	0f b6 c0             	movzbl %al,%eax
    2590:	0f af 45 cc          	imul   -0x34(%ebp),%eax
    2594:	8b 55 bc             	mov    -0x44(%ebp),%edx
    2597:	0f af d0             	imul   %eax,%edx
    259a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    259d:	0f b6 00             	movzbl (%eax),%eax
    25a0:	0f b6 c0             	movzbl %al,%eax
    25a3:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    25a7:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    25aa:	0f af c1             	imul   %ecx,%eax
    25ad:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    25b0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    25b3:	0f b6 00             	movzbl (%eax),%eax
    25b6:	0f b6 c0             	movzbl %al,%eax
    25b9:	0f af 45 d8          	imul   -0x28(%ebp),%eax
    25bd:	8b 55 c8             	mov    -0x38(%ebp),%edx
    25c0:	0f af d0             	imul   %eax,%edx
    25c3:	8b 45 e8             	mov    -0x18(%ebp),%eax
    25c6:	0f b6 00             	movzbl (%eax),%eax
    25c9:	0f b6 c0             	movzbl %al,%eax
    25cc:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    25d0:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    25d3:	0f af c1             	imul   %ecx,%eax
    25d6:	01 d0                	add    %edx,%eax
    25d8:	01 d8                	add    %ebx,%eax
    25da:	c1 e8 10             	shr    $0x10,%eax
    25dd:	89 c2                	mov    %eax,%edx
    25df:	8b 45 14             	mov    0x14(%ebp),%eax
    25e2:	88 10                	mov    %dl,(%eax)
}
    25e4:	90                   	nop
    25e5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    25e8:	c9                   	leave  
    25e9:	c3                   	ret    

000025ea <picScale>:

int picScale(PBitmap *src, PBitmap *dst)
{
    25ea:	55                   	push   %ebp
    25eb:	89 e5                	mov    %esp,%ebp
    25ed:	53                   	push   %ebx
    25ee:	83 ec 20             	sub    $0x20,%esp
    // float xScale = (float)src->width / (float)dst->width;
    // float yScale = (float)src->height / (float)dst->height;

    int xrIntFloat_16 = ((src->width)<<16)/dst->width+1;
    25f1:	8b 45 08             	mov    0x8(%ebp),%eax
    25f4:	8b 00                	mov    (%eax),%eax
    25f6:	c1 e0 10             	shl    $0x10,%eax
    25f9:	89 c1                	mov    %eax,%ecx
    25fb:	8b 45 0c             	mov    0xc(%ebp),%eax
    25fe:	8b 18                	mov    (%eax),%ebx
    2600:	89 c8                	mov    %ecx,%eax
    2602:	99                   	cltd   
    2603:	f7 fb                	idiv   %ebx
    2605:	83 c0 01             	add    $0x1,%eax
    2608:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int yrIntFloat_16 = ((src->height)<<16)/dst->height+1;
    260b:	8b 45 08             	mov    0x8(%ebp),%eax
    260e:	8b 40 04             	mov    0x4(%eax),%eax
    2611:	c1 e0 10             	shl    $0x10,%eax
    2614:	89 c1                	mov    %eax,%ecx
    2616:	8b 45 0c             	mov    0xc(%ebp),%eax
    2619:	8b 58 04             	mov    0x4(%eax),%ebx
    261c:	89 c8                	mov    %ecx,%eax
    261e:	99                   	cltd   
    261f:	f7 fb                	idiv   %ebx
    2621:	83 c0 01             	add    $0x1,%eax
    2624:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    const int csdErrorX = -(1<<15)+(xrIntFloat_16>>1);
    2627:	8b 45 e8             	mov    -0x18(%ebp),%eax
    262a:	d1 f8                	sar    %eax
    262c:	2d 00 80 00 00       	sub    $0x8000,%eax
    2631:	89 45 e0             	mov    %eax,-0x20(%ebp)
    const int csdErrorY = -(1<<15)+(yrIntFloat_16>>1);
    2634:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2637:	d1 f8                	sar    %eax
    2639:	2d 00 80 00 00       	sub    $0x8000,%eax
    263e:	89 45 dc             	mov    %eax,-0x24(%ebp)

    int srcy_16=csdErrorY;
    2641:	8b 45 dc             	mov    -0x24(%ebp),%eax
    2644:	89 45 f8             	mov    %eax,-0x8(%ebp)
    for (int y = 0; y < dst->height; y++)
    2647:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    264e:	eb 5d                	jmp    26ad <picScale+0xc3>
    {
        int srcx_16=csdErrorX;
    2650:	8b 45 e0             	mov    -0x20(%ebp),%eax
    2653:	89 45 f0             	mov    %eax,-0x10(%ebp)
        for (int x = 0; x < dst->width; x++)
    2656:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    265d:	eb 3a                	jmp    2699 <picScale+0xaf>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            mixColorInt(src, srcy_16, srcx_16, dst->data + y * dst->width + x);
    265f:	8b 45 0c             	mov    0xc(%ebp),%eax
    2662:	8b 48 08             	mov    0x8(%eax),%ecx
    2665:	8b 45 0c             	mov    0xc(%ebp),%eax
    2668:	8b 00                	mov    (%eax),%eax
    266a:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    266e:	89 c2                	mov    %eax,%edx
    2670:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2673:	01 c2                	add    %eax,%edx
    2675:	89 d0                	mov    %edx,%eax
    2677:	01 c0                	add    %eax,%eax
    2679:	01 d0                	add    %edx,%eax
    267b:	01 c8                	add    %ecx,%eax
    267d:	50                   	push   %eax
    267e:	ff 75 f0             	pushl  -0x10(%ebp)
    2681:	ff 75 f8             	pushl  -0x8(%ebp)
    2684:	ff 75 08             	pushl  0x8(%ebp)
    2687:	e8 4d fd ff ff       	call   23d9 <mixColorInt>
    268c:	83 c4 10             	add    $0x10,%esp
            srcx_16+=xrIntFloat_16;
    268f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2692:	01 45 f0             	add    %eax,-0x10(%ebp)

    int srcy_16=csdErrorY;
    for (int y = 0; y < dst->height; y++)
    {
        int srcx_16=csdErrorX;
        for (int x = 0; x < dst->width; x++)
    2695:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    2699:	8b 45 0c             	mov    0xc(%ebp),%eax
    269c:	8b 00                	mov    (%eax),%eax
    269e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    26a1:	7f bc                	jg     265f <picScale+0x75>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            mixColorInt(src, srcy_16, srcx_16, dst->data + y * dst->width + x);
            srcx_16+=xrIntFloat_16;
        }
        srcy_16+=yrIntFloat_16;
    26a3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    26a6:	01 45 f8             	add    %eax,-0x8(%ebp)
    int yrIntFloat_16 = ((src->height)<<16)/dst->height+1;
    const int csdErrorX = -(1<<15)+(xrIntFloat_16>>1);
    const int csdErrorY = -(1<<15)+(yrIntFloat_16>>1);

    int srcy_16=csdErrorY;
    for (int y = 0; y < dst->height; y++)
    26a9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    26ad:	8b 45 0c             	mov    0xc(%ebp),%eax
    26b0:	8b 40 04             	mov    0x4(%eax),%eax
    26b3:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    26b6:	7f 98                	jg     2650 <picScale+0x66>
            srcx_16+=xrIntFloat_16;
        }
        srcy_16+=yrIntFloat_16;
    }

    return 1;
    26b8:	b8 01 00 00 00       	mov    $0x1,%eax
}
    26bd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    26c0:	c9                   	leave  
    26c1:	c3                   	ret    

000026c2 <picFastScale>:

int picFastScale(PBitmap *src, PBitmap *dst)
{
    26c2:	55                   	push   %ebp
    26c3:	89 e5                	mov    %esp,%ebp
    26c5:	83 ec 1c             	sub    $0x1c,%esp
    float xScale = (float)src->width / (float)dst->width;
    26c8:	8b 45 08             	mov    0x8(%ebp),%eax
    26cb:	8b 00                	mov    (%eax),%eax
    26cd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    26d0:	db 45 e4             	fildl  -0x1c(%ebp)
    26d3:	8b 45 0c             	mov    0xc(%ebp),%eax
    26d6:	8b 00                	mov    (%eax),%eax
    26d8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    26db:	db 45 e4             	fildl  -0x1c(%ebp)
    26de:	de f9                	fdivrp %st,%st(1)
    26e0:	d9 5d f4             	fstps  -0xc(%ebp)
    float yScale = (float)src->height / (float)dst->height;
    26e3:	8b 45 08             	mov    0x8(%ebp),%eax
    26e6:	8b 40 04             	mov    0x4(%eax),%eax
    26e9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    26ec:	db 45 e4             	fildl  -0x1c(%ebp)
    26ef:	8b 45 0c             	mov    0xc(%ebp),%eax
    26f2:	8b 40 04             	mov    0x4(%eax),%eax
    26f5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    26f8:	db 45 e4             	fildl  -0x1c(%ebp)
    26fb:	de f9                	fdivrp %st,%st(1)
    26fd:	d9 5d f0             	fstps  -0x10(%ebp)

    for (int y = 0; y < dst->height; y++)
    2700:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    2707:	eb 5e                	jmp    2767 <picFastScale+0xa5>
    {
        for (int x = 0; x < dst->width; x++)
    2709:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    2710:	eb 47                	jmp    2759 <picFastScale+0x97>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            dst = getColor(src, (int)(y*yScale), (int)(x*xScale), 0);
    2712:	db 45 f8             	fildl  -0x8(%ebp)
    2715:	d8 4d f4             	fmuls  -0xc(%ebp)
    2718:	d9 7d ee             	fnstcw -0x12(%ebp)
    271b:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
    271f:	b4 0c                	mov    $0xc,%ah
    2721:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    2725:	d9 6d ec             	fldcw  -0x14(%ebp)
    2728:	db 5d e8             	fistpl -0x18(%ebp)
    272b:	d9 6d ee             	fldcw  -0x12(%ebp)
    272e:	8b 55 e8             	mov    -0x18(%ebp),%edx
    2731:	db 45 fc             	fildl  -0x4(%ebp)
    2734:	d8 4d f0             	fmuls  -0x10(%ebp)
    2737:	d9 6d ec             	fldcw  -0x14(%ebp)
    273a:	db 5d e8             	fistpl -0x18(%ebp)
    273d:	d9 6d ee             	fldcw  -0x12(%ebp)
    2740:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2743:	6a 00                	push   $0x0
    2745:	52                   	push   %edx
    2746:	50                   	push   %eax
    2747:	ff 75 08             	pushl  0x8(%ebp)
    274a:	e8 10 f9 ff ff       	call   205f <getColor>
    274f:	83 c4 10             	add    $0x10,%esp
    2752:	89 45 0c             	mov    %eax,0xc(%ebp)
    float xScale = (float)src->width / (float)dst->width;
    float yScale = (float)src->height / (float)dst->height;

    for (int y = 0; y < dst->height; y++)
    {
        for (int x = 0; x < dst->width; x++)
    2755:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    2759:	8b 45 0c             	mov    0xc(%ebp),%eax
    275c:	8b 00                	mov    (%eax),%eax
    275e:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    2761:	7f af                	jg     2712 <picFastScale+0x50>
int picFastScale(PBitmap *src, PBitmap *dst)
{
    float xScale = (float)src->width / (float)dst->width;
    float yScale = (float)src->height / (float)dst->height;

    for (int y = 0; y < dst->height; y++)
    2763:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    2767:	8b 45 0c             	mov    0xc(%ebp),%eax
    276a:	8b 40 04             	mov    0x4(%eax),%eax
    276d:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    2770:	7f 97                	jg     2709 <picFastScale+0x47>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            dst = getColor(src, (int)(y*yScale), (int)(x*xScale), 0);
        }
    }
    return 1;
    2772:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2777:	c9                   	leave  
    2778:	c3                   	ret    

00002779 <getTurnSize>:

int getTurnSize(int *width, int *height, float angle)
{
    2779:	55                   	push   %ebp
    277a:	89 e5                	mov    %esp,%ebp
    277c:	83 ec 28             	sub    $0x28,%esp
    int w = (int)(*width * abs(cos(angle)) + *height * abs(sin(angle)));
    277f:	8b 45 08             	mov    0x8(%ebp),%eax
    2782:	8b 00                	mov    (%eax),%eax
    2784:	89 45 e0             	mov    %eax,-0x20(%ebp)
    2787:	db 45 e0             	fildl  -0x20(%ebp)
    278a:	d9 5d e0             	fstps  -0x20(%ebp)
    278d:	83 ec 0c             	sub    $0xc,%esp
    2790:	ff 75 10             	pushl  0x10(%ebp)
    2793:	e8 6b e2 ff ff       	call   a03 <cos>
    2798:	83 c4 10             	add    $0x10,%esp
    279b:	d9 5d dc             	fstps  -0x24(%ebp)
    279e:	8b 45 dc             	mov    -0x24(%ebp),%eax
    27a1:	83 ec 0c             	sub    $0xc,%esp
    27a4:	50                   	push   %eax
    27a5:	e8 90 e1 ff ff       	call   93a <abs>
    27aa:	83 c4 10             	add    $0x10,%esp
    27ad:	d8 4d e0             	fmuls  -0x20(%ebp)
    27b0:	d9 5d e0             	fstps  -0x20(%ebp)
    27b3:	8b 45 0c             	mov    0xc(%ebp),%eax
    27b6:	8b 00                	mov    (%eax),%eax
    27b8:	89 45 dc             	mov    %eax,-0x24(%ebp)
    27bb:	db 45 dc             	fildl  -0x24(%ebp)
    27be:	d9 5d dc             	fstps  -0x24(%ebp)
    27c1:	83 ec 0c             	sub    $0xc,%esp
    27c4:	ff 75 10             	pushl  0x10(%ebp)
    27c7:	e8 da e3 ff ff       	call   ba6 <sin>
    27cc:	83 c4 10             	add    $0x10,%esp
    27cf:	d9 5d d8             	fstps  -0x28(%ebp)
    27d2:	8b 45 d8             	mov    -0x28(%ebp),%eax
    27d5:	83 ec 0c             	sub    $0xc,%esp
    27d8:	50                   	push   %eax
    27d9:	e8 5c e1 ff ff       	call   93a <abs>
    27de:	83 c4 10             	add    $0x10,%esp
    27e1:	d8 4d dc             	fmuls  -0x24(%ebp)
    27e4:	d8 45 e0             	fadds  -0x20(%ebp)
    27e7:	d9 7d e6             	fnstcw -0x1a(%ebp)
    27ea:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
    27ee:	b4 0c                	mov    $0xc,%ah
    27f0:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    27f4:	d9 6d e4             	fldcw  -0x1c(%ebp)
    27f7:	db 5d f4             	fistpl -0xc(%ebp)
    27fa:	d9 6d e6             	fldcw  -0x1a(%ebp)
    int h = (int)(*width * abs(sin(angle)) + *height * abs(cos(angle)));
    27fd:	8b 45 08             	mov    0x8(%ebp),%eax
    2800:	8b 00                	mov    (%eax),%eax
    2802:	89 45 e0             	mov    %eax,-0x20(%ebp)
    2805:	db 45 e0             	fildl  -0x20(%ebp)
    2808:	d9 5d e0             	fstps  -0x20(%ebp)
    280b:	83 ec 0c             	sub    $0xc,%esp
    280e:	ff 75 10             	pushl  0x10(%ebp)
    2811:	e8 90 e3 ff ff       	call   ba6 <sin>
    2816:	83 c4 10             	add    $0x10,%esp
    2819:	d9 5d dc             	fstps  -0x24(%ebp)
    281c:	8b 45 dc             	mov    -0x24(%ebp),%eax
    281f:	83 ec 0c             	sub    $0xc,%esp
    2822:	50                   	push   %eax
    2823:	e8 12 e1 ff ff       	call   93a <abs>
    2828:	83 c4 10             	add    $0x10,%esp
    282b:	d8 4d e0             	fmuls  -0x20(%ebp)
    282e:	d9 5d e0             	fstps  -0x20(%ebp)
    2831:	8b 45 0c             	mov    0xc(%ebp),%eax
    2834:	8b 00                	mov    (%eax),%eax
    2836:	89 45 dc             	mov    %eax,-0x24(%ebp)
    2839:	db 45 dc             	fildl  -0x24(%ebp)
    283c:	d9 5d dc             	fstps  -0x24(%ebp)
    283f:	83 ec 0c             	sub    $0xc,%esp
    2842:	ff 75 10             	pushl  0x10(%ebp)
    2845:	e8 b9 e1 ff ff       	call   a03 <cos>
    284a:	83 c4 10             	add    $0x10,%esp
    284d:	d9 5d d8             	fstps  -0x28(%ebp)
    2850:	8b 45 d8             	mov    -0x28(%ebp),%eax
    2853:	83 ec 0c             	sub    $0xc,%esp
    2856:	50                   	push   %eax
    2857:	e8 de e0 ff ff       	call   93a <abs>
    285c:	83 c4 10             	add    $0x10,%esp
    285f:	d8 4d dc             	fmuls  -0x24(%ebp)
    2862:	d8 45 e0             	fadds  -0x20(%ebp)
    2865:	d9 7d e6             	fnstcw -0x1a(%ebp)
    2868:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
    286c:	b4 0c                	mov    $0xc,%ah
    286e:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    2872:	d9 6d e4             	fldcw  -0x1c(%ebp)
    2875:	db 5d f0             	fistpl -0x10(%ebp)
    2878:	d9 6d e6             	fldcw  -0x1a(%ebp)

    *height = h;
    287b:	8b 45 0c             	mov    0xc(%ebp),%eax
    287e:	8b 55 f0             	mov    -0x10(%ebp),%edx
    2881:	89 10                	mov    %edx,(%eax)
    *width = w;
    2883:	8b 45 08             	mov    0x8(%ebp),%eax
    2886:	8b 55 f4             	mov    -0xc(%ebp),%edx
    2889:	89 10                	mov    %edx,(%eax)
    return 1;
    288b:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2890:	c9                   	leave  
    2891:	c3                   	ret    

00002892 <picTurn>:

int picTurn(PBitmap *src, PBitmap *dst, float angle)
{
    2892:	55                   	push   %ebp
    2893:	89 e5                	mov    %esp,%ebp
    2895:	83 ec 48             	sub    $0x48,%esp

    // 以中心为旋转中心，要找到目标图中的旋转中心
    const float my = (float)src->height / 2;
    2898:	8b 45 08             	mov    0x8(%ebp),%eax
    289b:	8b 40 04             	mov    0x4(%eax),%eax
    289e:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    28a1:	db 45 c4             	fildl  -0x3c(%ebp)
    28a4:	d9 05 84 9d 01 00    	flds   0x19d84
    28aa:	de f9                	fdivrp %st,%st(1)
    28ac:	d9 5d ec             	fstps  -0x14(%ebp)
    const float mx = (float)src->width / 2;
    28af:	8b 45 08             	mov    0x8(%ebp),%eax
    28b2:	8b 00                	mov    (%eax),%eax
    28b4:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    28b7:	db 45 c4             	fildl  -0x3c(%ebp)
    28ba:	d9 05 84 9d 01 00    	flds   0x19d84
    28c0:	de f9                	fdivrp %st,%st(1)
    28c2:	d9 5d e8             	fstps  -0x18(%ebp)

    const float dy = (float)(dst->height - src->height) / 2;
    28c5:	8b 45 0c             	mov    0xc(%ebp),%eax
    28c8:	8b 50 04             	mov    0x4(%eax),%edx
    28cb:	8b 45 08             	mov    0x8(%ebp),%eax
    28ce:	8b 40 04             	mov    0x4(%eax),%eax
    28d1:	29 c2                	sub    %eax,%edx
    28d3:	89 d0                	mov    %edx,%eax
    28d5:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    28d8:	db 45 c4             	fildl  -0x3c(%ebp)
    28db:	d9 05 84 9d 01 00    	flds   0x19d84
    28e1:	de f9                	fdivrp %st,%st(1)
    28e3:	d9 5d e4             	fstps  -0x1c(%ebp)
    const float dx = (float)(dst->width - src->width) / 2;
    28e6:	8b 45 0c             	mov    0xc(%ebp),%eax
    28e9:	8b 10                	mov    (%eax),%edx
    28eb:	8b 45 08             	mov    0x8(%ebp),%eax
    28ee:	8b 00                	mov    (%eax),%eax
    28f0:	29 c2                	sub    %eax,%edx
    28f2:	89 d0                	mov    %edx,%eax
    28f4:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    28f7:	db 45 c4             	fildl  -0x3c(%ebp)
    28fa:	d9 05 84 9d 01 00    	flds   0x19d84
    2900:	de f9                	fdivrp %st,%st(1)
    2902:	d9 5d e0             	fstps  -0x20(%ebp)

    const float COSX = cos(-angle);
    2905:	d9 45 10             	flds   0x10(%ebp)
    2908:	d9 e0                	fchs   
    290a:	83 ec 0c             	sub    $0xc,%esp
    290d:	8d 64 24 fc          	lea    -0x4(%esp),%esp
    2911:	d9 1c 24             	fstps  (%esp)
    2914:	e8 ea e0 ff ff       	call   a03 <cos>
    2919:	83 c4 10             	add    $0x10,%esp
    291c:	d9 5d c4             	fstps  -0x3c(%ebp)
    291f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2922:	89 45 dc             	mov    %eax,-0x24(%ebp)
    const float SINX = sin(-angle);
    2925:	d9 45 10             	flds   0x10(%ebp)
    2928:	d9 e0                	fchs   
    292a:	83 ec 0c             	sub    $0xc,%esp
    292d:	8d 64 24 fc          	lea    -0x4(%esp),%esp
    2931:	d9 1c 24             	fstps  (%esp)
    2934:	e8 6d e2 ff ff       	call   ba6 <sin>
    2939:	83 c4 10             	add    $0x10,%esp
    293c:	d9 5d c4             	fstps  -0x3c(%ebp)
    293f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2942:	89 45 d8             	mov    %eax,-0x28(%ebp)

    float srcI = 0;
    2945:	d9 ee                	fldz   
    2947:	d9 5d d4             	fstps  -0x2c(%ebp)
    float srcJ = 0;
    294a:	d9 ee                	fldz   
    294c:	d9 5d d0             	fstps  -0x30(%ebp)

    for (int i = 0; i < dst->height; i++)
    294f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2956:	e9 28 01 00 00       	jmp    2a83 <picTurn+0x1f1>
    {
        for (int j = 0; j < dst->width; j++)
    295b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    2962:	e9 0a 01 00 00       	jmp    2a71 <picTurn+0x1df>
        {
            srcI = ((float)i - dy - my) * COSX + ((float)j - dx - mx) * SINX + my;
    2967:	db 45 f4             	fildl  -0xc(%ebp)
    296a:	d8 65 e4             	fsubs  -0x1c(%ebp)
    296d:	d8 65 ec             	fsubs  -0x14(%ebp)
    2970:	d8 4d dc             	fmuls  -0x24(%ebp)
    2973:	db 45 f0             	fildl  -0x10(%ebp)
    2976:	d8 65 e0             	fsubs  -0x20(%ebp)
    2979:	d8 65 e8             	fsubs  -0x18(%ebp)
    297c:	d8 4d d8             	fmuls  -0x28(%ebp)
    297f:	de c1                	faddp  %st,%st(1)
    2981:	d8 45 ec             	fadds  -0x14(%ebp)
    2984:	d9 5d d4             	fstps  -0x2c(%ebp)
            srcJ = ((float)j - dx - mx) * COSX - ((float)i - dy - my) * SINX + mx;
    2987:	db 45 f0             	fildl  -0x10(%ebp)
    298a:	d8 65 e0             	fsubs  -0x20(%ebp)
    298d:	d8 65 e8             	fsubs  -0x18(%ebp)
    2990:	d8 4d dc             	fmuls  -0x24(%ebp)
    2993:	db 45 f4             	fildl  -0xc(%ebp)
    2996:	d8 65 e4             	fsubs  -0x1c(%ebp)
    2999:	d8 65 ec             	fsubs  -0x14(%ebp)
    299c:	d8 4d d8             	fmuls  -0x28(%ebp)
    299f:	de e9                	fsubrp %st,%st(1)
    29a1:	d8 45 e8             	fadds  -0x18(%ebp)
    29a4:	d9 5d d0             	fstps  -0x30(%ebp)
            if (!(srcI >= 0 && srcI < src->height && srcJ >= 0 && srcJ < src->width))
    29a7:	d9 45 d4             	flds   -0x2c(%ebp)
    29aa:	d9 ee                	fldz   
    29ac:	d9 c9                	fxch   %st(1)
    29ae:	df e9                	fucomip %st(1),%st
    29b0:	dd d8                	fstp   %st(0)
    29b2:	0f 93 c0             	setae  %al
    29b5:	83 f0 01             	xor    $0x1,%eax
    29b8:	84 c0                	test   %al,%al
    29ba:	75 52                	jne    2a0e <picTurn+0x17c>
    29bc:	8b 45 08             	mov    0x8(%ebp),%eax
    29bf:	8b 40 04             	mov    0x4(%eax),%eax
    29c2:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    29c5:	db 45 c4             	fildl  -0x3c(%ebp)
    29c8:	d9 45 d4             	flds   -0x2c(%ebp)
    29cb:	d9 c9                	fxch   %st(1)
    29cd:	df e9                	fucomip %st(1),%st
    29cf:	dd d8                	fstp   %st(0)
    29d1:	0f 97 c0             	seta   %al
    29d4:	83 f0 01             	xor    $0x1,%eax
    29d7:	84 c0                	test   %al,%al
    29d9:	75 33                	jne    2a0e <picTurn+0x17c>
    29db:	d9 45 d0             	flds   -0x30(%ebp)
    29de:	d9 ee                	fldz   
    29e0:	d9 c9                	fxch   %st(1)
    29e2:	df e9                	fucomip %st(1),%st
    29e4:	dd d8                	fstp   %st(0)
    29e6:	0f 93 c0             	setae  %al
    29e9:	83 f0 01             	xor    $0x1,%eax
    29ec:	84 c0                	test   %al,%al
    29ee:	75 1e                	jne    2a0e <picTurn+0x17c>
    29f0:	8b 45 08             	mov    0x8(%ebp),%eax
    29f3:	8b 00                	mov    (%eax),%eax
    29f5:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    29f8:	db 45 c4             	fildl  -0x3c(%ebp)
    29fb:	d9 45 d0             	flds   -0x30(%ebp)
    29fe:	d9 c9                	fxch   %st(1)
    2a00:	df e9                	fucomip %st(1),%st
    2a02:	dd d8                	fstp   %st(0)
    2a04:	0f 97 c0             	seta   %al
    2a07:	83 f0 01             	xor    $0x1,%eax
    2a0a:	84 c0                	test   %al,%al
    2a0c:	74 2f                	je     2a3d <picTurn+0x1ab>
            {
                setColor(&whiteRGB, (dst->data + i * dst->width + j));
    2a0e:	8b 45 0c             	mov    0xc(%ebp),%eax
    2a11:	8b 48 08             	mov    0x8(%eax),%ecx
    2a14:	8b 45 0c             	mov    0xc(%ebp),%eax
    2a17:	8b 00                	mov    (%eax),%eax
    2a19:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    2a1d:	89 c2                	mov    %eax,%edx
    2a1f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2a22:	01 c2                	add    %eax,%edx
    2a24:	89 d0                	mov    %edx,%eax
    2a26:	01 c0                	add    %eax,%eax
    2a28:	01 d0                	add    %edx,%eax
    2a2a:	01 c8                	add    %ecx,%eax
    2a2c:	83 ec 08             	sub    $0x8,%esp
    2a2f:	50                   	push   %eax
    2a30:	68 d1 e1 01 00       	push   $0x1e1d1
    2a35:	e8 9f f6 ff ff       	call   20d9 <setColor>
    2a3a:	83 c4 10             	add    $0x10,%esp
            }
            mixColor(src, srcI, srcJ, (dst->data + i * dst->width + j));
    2a3d:	8b 45 0c             	mov    0xc(%ebp),%eax
    2a40:	8b 48 08             	mov    0x8(%eax),%ecx
    2a43:	8b 45 0c             	mov    0xc(%ebp),%eax
    2a46:	8b 00                	mov    (%eax),%eax
    2a48:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    2a4c:	89 c2                	mov    %eax,%edx
    2a4e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2a51:	01 c2                	add    %eax,%edx
    2a53:	89 d0                	mov    %edx,%eax
    2a55:	01 c0                	add    %eax,%eax
    2a57:	01 d0                	add    %edx,%eax
    2a59:	01 c8                	add    %ecx,%eax
    2a5b:	50                   	push   %eax
    2a5c:	ff 75 d0             	pushl  -0x30(%ebp)
    2a5f:	ff 75 d4             	pushl  -0x2c(%ebp)
    2a62:	ff 75 08             	pushl  0x8(%ebp)
    2a65:	e8 9e f6 ff ff       	call   2108 <mixColor>
    2a6a:	83 c4 10             	add    $0x10,%esp
    float srcI = 0;
    float srcJ = 0;

    for (int i = 0; i < dst->height; i++)
    {
        for (int j = 0; j < dst->width; j++)
    2a6d:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    2a71:	8b 45 0c             	mov    0xc(%ebp),%eax
    2a74:	8b 00                	mov    (%eax),%eax
    2a76:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    2a79:	0f 8f e8 fe ff ff    	jg     2967 <picTurn+0xd5>
    const float SINX = sin(-angle);

    float srcI = 0;
    float srcJ = 0;

    for (int i = 0; i < dst->height; i++)
    2a7f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2a83:	8b 45 0c             	mov    0xc(%ebp),%eax
    2a86:	8b 40 04             	mov    0x4(%eax),%eax
    2a89:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    2a8c:	0f 8f c9 fe ff ff    	jg     295b <picTurn+0xc9>
            }
            mixColor(src, srcI, srcJ, (dst->data + i * dst->width + j));
        }
    }

    return 1;
    2a92:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2a97:	c9                   	leave  
    2a98:	c3                   	ret    

00002a99 <picRollingOver>:

// （上下）翻转
int picRollingOver(PBitmap *src, PBitmap *dst)
{
    2a99:	55                   	push   %ebp
    2a9a:	89 e5                	mov    %esp,%ebp
    2a9c:	53                   	push   %ebx
    2a9d:	83 ec 10             	sub    $0x10,%esp
    // 如果原图与目标图尺寸不一样，则返回 0；
    if (src->width != dst->width || src->height != dst->height)
    2aa0:	8b 45 08             	mov    0x8(%ebp),%eax
    2aa3:	8b 10                	mov    (%eax),%edx
    2aa5:	8b 45 0c             	mov    0xc(%ebp),%eax
    2aa8:	8b 00                	mov    (%eax),%eax
    2aaa:	39 c2                	cmp    %eax,%edx
    2aac:	75 10                	jne    2abe <picRollingOver+0x25>
    2aae:	8b 45 08             	mov    0x8(%ebp),%eax
    2ab1:	8b 50 04             	mov    0x4(%eax),%edx
    2ab4:	8b 45 0c             	mov    0xc(%ebp),%eax
    2ab7:	8b 40 04             	mov    0x4(%eax),%eax
    2aba:	39 c2                	cmp    %eax,%edx
    2abc:	74 0a                	je     2ac8 <picRollingOver+0x2f>
        return 0;
    2abe:	b8 00 00 00 00       	mov    $0x0,%eax
    2ac3:	e9 88 00 00 00       	jmp    2b50 <picRollingOver+0xb7>

    int h = src->height;
    2ac8:	8b 45 08             	mov    0x8(%ebp),%eax
    2acb:	8b 40 04             	mov    0x4(%eax),%eax
    2ace:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int w = src->width;
    2ad1:	8b 45 08             	mov    0x8(%ebp),%eax
    2ad4:	8b 00                	mov    (%eax),%eax
    2ad6:	89 45 ec             	mov    %eax,-0x14(%ebp)

    for (int i = 0; i < h; i++)
    2ad9:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    2ae0:	eb 61                	jmp    2b43 <picRollingOver+0xaa>
    {
        for (int j = 0; j < w; j++)
    2ae2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2ae9:	eb 4c                	jmp    2b37 <picRollingOver+0x9e>
        {
            setColor((src->data + i * w + j), (dst->data + (h - i - 1) * w + j));
    2aeb:	8b 45 0c             	mov    0xc(%ebp),%eax
    2aee:	8b 48 08             	mov    0x8(%eax),%ecx
    2af1:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2af4:	2b 45 f8             	sub    -0x8(%ebp),%eax
    2af7:	83 e8 01             	sub    $0x1,%eax
    2afa:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    2afe:	89 c2                	mov    %eax,%edx
    2b00:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2b03:	01 c2                	add    %eax,%edx
    2b05:	89 d0                	mov    %edx,%eax
    2b07:	01 c0                	add    %eax,%eax
    2b09:	01 d0                	add    %edx,%eax
    2b0b:	01 c1                	add    %eax,%ecx
    2b0d:	8b 45 08             	mov    0x8(%ebp),%eax
    2b10:	8b 58 08             	mov    0x8(%eax),%ebx
    2b13:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2b16:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    2b1a:	89 c2                	mov    %eax,%edx
    2b1c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2b1f:	01 c2                	add    %eax,%edx
    2b21:	89 d0                	mov    %edx,%eax
    2b23:	01 c0                	add    %eax,%eax
    2b25:	01 d0                	add    %edx,%eax
    2b27:	01 d8                	add    %ebx,%eax
    2b29:	51                   	push   %ecx
    2b2a:	50                   	push   %eax
    2b2b:	e8 a9 f5 ff ff       	call   20d9 <setColor>
    2b30:	83 c4 08             	add    $0x8,%esp
    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    {
        for (int j = 0; j < w; j++)
    2b33:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2b37:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2b3a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    2b3d:	7c ac                	jl     2aeb <picRollingOver+0x52>
        return 0;

    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    2b3f:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    2b43:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2b46:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    2b49:	7c 97                	jl     2ae2 <picRollingOver+0x49>
        {
            setColor((src->data + i * w + j), (dst->data + (h - i - 1) * w + j));
        }
    }

    return 1;
    2b4b:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2b50:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    2b53:	c9                   	leave  
    2b54:	c3                   	ret    

00002b55 <picTurnAround>:

int picTurnAround(PBitmap *src, PBitmap *dst)
{
    2b55:	55                   	push   %ebp
    2b56:	89 e5                	mov    %esp,%ebp
    2b58:	53                   	push   %ebx
    2b59:	83 ec 10             	sub    $0x10,%esp
    // 如果原图与目标图尺寸不一样，则返回 0；
    if (src->width != dst->width || src->height != dst->height)
    2b5c:	8b 45 08             	mov    0x8(%ebp),%eax
    2b5f:	8b 10                	mov    (%eax),%edx
    2b61:	8b 45 0c             	mov    0xc(%ebp),%eax
    2b64:	8b 00                	mov    (%eax),%eax
    2b66:	39 c2                	cmp    %eax,%edx
    2b68:	75 10                	jne    2b7a <picTurnAround+0x25>
    2b6a:	8b 45 08             	mov    0x8(%ebp),%eax
    2b6d:	8b 50 04             	mov    0x4(%eax),%edx
    2b70:	8b 45 0c             	mov    0xc(%ebp),%eax
    2b73:	8b 40 04             	mov    0x4(%eax),%eax
    2b76:	39 c2                	cmp    %eax,%edx
    2b78:	74 0a                	je     2b84 <picTurnAround+0x2f>
        return 0;
    2b7a:	b8 00 00 00 00       	mov    $0x0,%eax
    2b7f:	e9 88 00 00 00       	jmp    2c0c <picTurnAround+0xb7>

    int h = src->height;
    2b84:	8b 45 08             	mov    0x8(%ebp),%eax
    2b87:	8b 40 04             	mov    0x4(%eax),%eax
    2b8a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int w = src->width;
    2b8d:	8b 45 08             	mov    0x8(%ebp),%eax
    2b90:	8b 00                	mov    (%eax),%eax
    2b92:	89 45 ec             	mov    %eax,-0x14(%ebp)

    for (int i = 0; i < h; i++)
    2b95:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    2b9c:	eb 61                	jmp    2bff <picTurnAround+0xaa>
    {
        for (int j = 0; j < w; j++)
    2b9e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2ba5:	eb 4c                	jmp    2bf3 <picTurnAround+0x9e>
        {
            setColor((src->data + i * w + j), (dst->data + i * w + (w - j - 1)));
    2ba7:	8b 45 0c             	mov    0xc(%ebp),%eax
    2baa:	8b 48 08             	mov    0x8(%eax),%ecx
    2bad:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2bb0:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    2bb4:	89 c2                	mov    %eax,%edx
    2bb6:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2bb9:	2b 45 f4             	sub    -0xc(%ebp),%eax
    2bbc:	01 c2                	add    %eax,%edx
    2bbe:	89 d0                	mov    %edx,%eax
    2bc0:	01 c0                	add    %eax,%eax
    2bc2:	01 d0                	add    %edx,%eax
    2bc4:	83 e8 03             	sub    $0x3,%eax
    2bc7:	01 c1                	add    %eax,%ecx
    2bc9:	8b 45 08             	mov    0x8(%ebp),%eax
    2bcc:	8b 58 08             	mov    0x8(%eax),%ebx
    2bcf:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2bd2:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    2bd6:	89 c2                	mov    %eax,%edx
    2bd8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2bdb:	01 c2                	add    %eax,%edx
    2bdd:	89 d0                	mov    %edx,%eax
    2bdf:	01 c0                	add    %eax,%eax
    2be1:	01 d0                	add    %edx,%eax
    2be3:	01 d8                	add    %ebx,%eax
    2be5:	51                   	push   %ecx
    2be6:	50                   	push   %eax
    2be7:	e8 ed f4 ff ff       	call   20d9 <setColor>
    2bec:	83 c4 08             	add    $0x8,%esp
    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    {
        for (int j = 0; j < w; j++)
    2bef:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2bf3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2bf6:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    2bf9:	7c ac                	jl     2ba7 <picTurnAround+0x52>
        return 0;

    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    2bfb:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    2bff:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2c02:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    2c05:	7c 97                	jl     2b9e <picTurnAround+0x49>
        {
            setColor((src->data + i * w + j), (dst->data + i * w + (w - j - 1)));
        }
    }

    return 1;
    2c07:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2c0c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    2c0f:	c9                   	leave  
    2c10:	c3                   	ret    

00002c11 <type>:
#include "loader.h"
#include "fcntl.h"
#include "loadjpeg.h"
#include "loadpng.h"

int type(char* filename){
    2c11:	55                   	push   %ebp
    2c12:	89 e5                	mov    %esp,%ebp
    2c14:	83 ec 18             	sub    $0x18,%esp
    int len=strlen(filename);
    2c17:	83 ec 0c             	sub    $0xc,%esp
    2c1a:	ff 75 08             	pushl  0x8(%ebp)
    2c1d:	e8 c5 d5 ff ff       	call   1e7 <strlen>
    2c22:	83 c4 10             	add    $0x10,%esp
    2c25:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(filename[len-1]=='g'&&filename[len-2]=='p'&&filename[len-3]=='j') return JPG;
    2c28:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2c2b:	8d 50 ff             	lea    -0x1(%eax),%edx
    2c2e:	8b 45 08             	mov    0x8(%ebp),%eax
    2c31:	01 d0                	add    %edx,%eax
    2c33:	0f b6 00             	movzbl (%eax),%eax
    2c36:	3c 67                	cmp    $0x67,%al
    2c38:	75 2b                	jne    2c65 <type+0x54>
    2c3a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2c3d:	8d 50 fe             	lea    -0x2(%eax),%edx
    2c40:	8b 45 08             	mov    0x8(%ebp),%eax
    2c43:	01 d0                	add    %edx,%eax
    2c45:	0f b6 00             	movzbl (%eax),%eax
    2c48:	3c 70                	cmp    $0x70,%al
    2c4a:	75 19                	jne    2c65 <type+0x54>
    2c4c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2c4f:	8d 50 fd             	lea    -0x3(%eax),%edx
    2c52:	8b 45 08             	mov    0x8(%ebp),%eax
    2c55:	01 d0                	add    %edx,%eax
    2c57:	0f b6 00             	movzbl (%eax),%eax
    2c5a:	3c 6a                	cmp    $0x6a,%al
    2c5c:	75 07                	jne    2c65 <type+0x54>
    2c5e:	b8 00 00 00 00       	mov    $0x0,%eax
    2c63:	eb 7f                	jmp    2ce4 <type+0xd3>
    if(filename[len-1]=='p'&&filename[len-2]=='m'&&filename[len-3]=='b') return BMP;
    2c65:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2c68:	8d 50 ff             	lea    -0x1(%eax),%edx
    2c6b:	8b 45 08             	mov    0x8(%ebp),%eax
    2c6e:	01 d0                	add    %edx,%eax
    2c70:	0f b6 00             	movzbl (%eax),%eax
    2c73:	3c 70                	cmp    $0x70,%al
    2c75:	75 2b                	jne    2ca2 <type+0x91>
    2c77:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2c7a:	8d 50 fe             	lea    -0x2(%eax),%edx
    2c7d:	8b 45 08             	mov    0x8(%ebp),%eax
    2c80:	01 d0                	add    %edx,%eax
    2c82:	0f b6 00             	movzbl (%eax),%eax
    2c85:	3c 6d                	cmp    $0x6d,%al
    2c87:	75 19                	jne    2ca2 <type+0x91>
    2c89:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2c8c:	8d 50 fd             	lea    -0x3(%eax),%edx
    2c8f:	8b 45 08             	mov    0x8(%ebp),%eax
    2c92:	01 d0                	add    %edx,%eax
    2c94:	0f b6 00             	movzbl (%eax),%eax
    2c97:	3c 62                	cmp    $0x62,%al
    2c99:	75 07                	jne    2ca2 <type+0x91>
    2c9b:	b8 01 00 00 00       	mov    $0x1,%eax
    2ca0:	eb 42                	jmp    2ce4 <type+0xd3>
    if(filename[len-1]=='g'&&filename[len-2]=='n'&&filename[len-3]=='p') return PNG;
    2ca2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2ca5:	8d 50 ff             	lea    -0x1(%eax),%edx
    2ca8:	8b 45 08             	mov    0x8(%ebp),%eax
    2cab:	01 d0                	add    %edx,%eax
    2cad:	0f b6 00             	movzbl (%eax),%eax
    2cb0:	3c 67                	cmp    $0x67,%al
    2cb2:	75 2b                	jne    2cdf <type+0xce>
    2cb4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2cb7:	8d 50 fe             	lea    -0x2(%eax),%edx
    2cba:	8b 45 08             	mov    0x8(%ebp),%eax
    2cbd:	01 d0                	add    %edx,%eax
    2cbf:	0f b6 00             	movzbl (%eax),%eax
    2cc2:	3c 6e                	cmp    $0x6e,%al
    2cc4:	75 19                	jne    2cdf <type+0xce>
    2cc6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2cc9:	8d 50 fd             	lea    -0x3(%eax),%edx
    2ccc:	8b 45 08             	mov    0x8(%ebp),%eax
    2ccf:	01 d0                	add    %edx,%eax
    2cd1:	0f b6 00             	movzbl (%eax),%eax
    2cd4:	3c 70                	cmp    $0x70,%al
    2cd6:	75 07                	jne    2cdf <type+0xce>
    2cd8:	b8 02 00 00 00       	mov    $0x2,%eax
    2cdd:	eb 05                	jmp    2ce4 <type+0xd3>
    else return NONE;
    2cdf:	b8 03 00 00 00       	mov    $0x3,%eax
}
    2ce4:	c9                   	leave  
    2ce5:	c3                   	ret    

00002ce6 <LoadBmp>:

PBitmap LoadBmp(char* filename){
    2ce6:	55                   	push   %ebp
    2ce7:	89 e5                	mov    %esp,%ebp
    2ce9:	56                   	push   %esi
    2cea:	53                   	push   %ebx
    2ceb:	83 c4 80             	add    $0xffffff80,%esp
    PBitmap bmp = {0, 0, 0};
    2cee:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
    2cf5:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
    2cfc:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
    int fd;
    if((fd = open(filename, O_RDONLY)) < 0){
    2d03:	83 ec 08             	sub    $0x8,%esp
    2d06:	6a 00                	push   $0x0
    2d08:	ff 75 0c             	pushl  0xc(%ebp)
    2d0b:	e8 d9 d6 ff ff       	call   3e9 <open>
    2d10:	83 c4 10             	add    $0x10,%esp
    2d13:	89 45 ec             	mov    %eax,-0x14(%ebp)
    2d16:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    2d1a:	79 2c                	jns    2d48 <LoadBmp+0x62>
        printf("Can't open %s\n", filename);
    2d1c:	83 ec 08             	sub    $0x8,%esp
    2d1f:	ff 75 0c             	pushl  0xc(%ebp)
    2d22:	68 88 9d 01 00       	push   $0x19d88
    2d27:	e8 24 d8 ff ff       	call   550 <printf>
    2d2c:	83 c4 10             	add    $0x10,%esp
        return bmp;
    2d2f:	8b 45 08             	mov    0x8(%ebp),%eax
    2d32:	8b 55 b8             	mov    -0x48(%ebp),%edx
    2d35:	89 10                	mov    %edx,(%eax)
    2d37:	8b 55 bc             	mov    -0x44(%ebp),%edx
    2d3a:	89 50 04             	mov    %edx,0x4(%eax)
    2d3d:	8b 55 c0             	mov    -0x40(%ebp),%edx
    2d40:	89 50 08             	mov    %edx,0x8(%eax)
    2d43:	e9 2d 02 00 00       	jmp    2f75 <LoadBmp+0x28f>
    }
    PBitmapFileHeader fileHeader;
    read(fd, (char*)&fileHeader, sizeof(fileHeader));
    2d48:	83 ec 04             	sub    $0x4,%esp
    2d4b:	6a 0e                	push   $0xe
    2d4d:	8d 45 aa             	lea    -0x56(%ebp),%eax
    2d50:	50                   	push   %eax
    2d51:	ff 75 ec             	pushl  -0x14(%ebp)
    2d54:	e8 68 d6 ff ff       	call   3c1 <read>
    2d59:	83 c4 10             	add    $0x10,%esp
    
    PBitmapInfoHeader infoHeader;
    read(fd, (char*)&infoHeader, sizeof(infoHeader));
    2d5c:	83 ec 04             	sub    $0x4,%esp
    2d5f:	6a 28                	push   $0x28
    2d61:	8d 45 82             	lea    -0x7e(%ebp),%eax
    2d64:	50                   	push   %eax
    2d65:	ff 75 ec             	pushl  -0x14(%ebp)
    2d68:	e8 54 d6 ff ff       	call   3c1 <read>
    2d6d:	83 c4 10             	add    $0x10,%esp
    printf("\n info: %x %d %d %d %d, totalsize %d\n", fileHeader.bfType, fileHeader.bfSize,
    fileHeader.bfOffBits, fileHeader.bfReserved1, fileHeader.bfReserved2,sizeof(fileHeader)+sizeof(infoHeader));
    2d70:	0f b7 45 b2          	movzwl -0x4e(%ebp),%eax
    PBitmapFileHeader fileHeader;
    read(fd, (char*)&fileHeader, sizeof(fileHeader));
    
    PBitmapInfoHeader infoHeader;
    read(fd, (char*)&infoHeader, sizeof(infoHeader));
    printf("\n info: %x %d %d %d %d, totalsize %d\n", fileHeader.bfType, fileHeader.bfSize,
    2d74:	0f b7 f0             	movzwl %ax,%esi
    fileHeader.bfOffBits, fileHeader.bfReserved1, fileHeader.bfReserved2,sizeof(fileHeader)+sizeof(infoHeader));
    2d77:	0f b7 45 b0          	movzwl -0x50(%ebp),%eax
    PBitmapFileHeader fileHeader;
    read(fd, (char*)&fileHeader, sizeof(fileHeader));
    
    PBitmapInfoHeader infoHeader;
    read(fd, (char*)&infoHeader, sizeof(infoHeader));
    printf("\n info: %x %d %d %d %d, totalsize %d\n", fileHeader.bfType, fileHeader.bfSize,
    2d7b:	0f b7 d8             	movzwl %ax,%ebx
    2d7e:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
    2d81:	8b 55 ac             	mov    -0x54(%ebp),%edx
    2d84:	0f b7 45 aa          	movzwl -0x56(%ebp),%eax
    2d88:	0f b7 c0             	movzwl %ax,%eax
    2d8b:	83 ec 04             	sub    $0x4,%esp
    2d8e:	6a 36                	push   $0x36
    2d90:	56                   	push   %esi
    2d91:	53                   	push   %ebx
    2d92:	51                   	push   %ecx
    2d93:	52                   	push   %edx
    2d94:	50                   	push   %eax
    2d95:	68 98 9d 01 00       	push   $0x19d98
    2d9a:	e8 b1 d7 ff ff       	call   550 <printf>
    2d9f:	83 c4 20             	add    $0x20,%esp
    fileHeader.bfOffBits, fileHeader.bfReserved1, fileHeader.bfReserved2,sizeof(fileHeader)+sizeof(infoHeader));
    
    bmp.width = infoHeader.biWidth;
    2da2:	8b 45 86             	mov    -0x7a(%ebp),%eax
    2da5:	89 45 b8             	mov    %eax,-0x48(%ebp)
    bmp.height = infoHeader.biHeight;
    2da8:	8b 45 8a             	mov    -0x76(%ebp),%eax
    2dab:	89 45 bc             	mov    %eax,-0x44(%ebp)
    bmp.data = (RGB*)malloc(bmp.width * bmp.height * sizeof(RGB));
    2dae:	8b 55 b8             	mov    -0x48(%ebp),%edx
    2db1:	8b 45 bc             	mov    -0x44(%ebp),%eax
    2db4:	0f af c2             	imul   %edx,%eax
    2db7:	89 c2                	mov    %eax,%edx
    2db9:	89 d0                	mov    %edx,%eax
    2dbb:	01 c0                	add    %eax,%eax
    2dbd:	01 d0                	add    %edx,%eax
    2dbf:	83 ec 0c             	sub    $0xc,%esp
    2dc2:	50                   	push   %eax
    2dc3:	e8 5b da ff ff       	call   823 <malloc>
    2dc8:	83 c4 10             	add    $0x10,%esp
    2dcb:	89 45 c0             	mov    %eax,-0x40(%ebp)
    
    int count = infoHeader.biBitCount;
    2dce:	0f b7 45 90          	movzwl -0x70(%ebp),%eax
    2dd2:	0f b7 c0             	movzwl %ax,%eax
    2dd5:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int length = (((bmp.width * count) + 31) >> 5) << 2;
    2dd8:	8b 45 b8             	mov    -0x48(%ebp),%eax
    2ddb:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    2ddf:	83 c0 1f             	add    $0x1f,%eax
    2de2:	c1 f8 05             	sar    $0x5,%eax
    2de5:	c1 e0 02             	shl    $0x2,%eax
    2de8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    int size = length * bmp.height;
    2deb:	8b 45 bc             	mov    -0x44(%ebp),%eax
    2dee:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
    2df2:	89 45 e0             	mov    %eax,-0x20(%ebp)
    printf("load bitmap l: %d s: %d c: %d width: %d height: %d\n",length,size,count,bmp.width,bmp.height);
    2df5:	8b 55 bc             	mov    -0x44(%ebp),%edx
    2df8:	8b 45 b8             	mov    -0x48(%ebp),%eax
    2dfb:	83 ec 08             	sub    $0x8,%esp
    2dfe:	52                   	push   %edx
    2dff:	50                   	push   %eax
    2e00:	ff 75 e8             	pushl  -0x18(%ebp)
    2e03:	ff 75 e0             	pushl  -0x20(%ebp)
    2e06:	ff 75 e4             	pushl  -0x1c(%ebp)
    2e09:	68 c0 9d 01 00       	push   $0x19dc0
    2e0e:	e8 3d d7 ff ff       	call   550 <printf>
    2e13:	83 c4 20             	add    $0x20,%esp

    int wastedLen = fileHeader.bfOffBits - sizeof(fileHeader) - sizeof(infoHeader);
    2e16:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    2e19:	83 e8 36             	sub    $0x36,%eax
    2e1c:	89 45 dc             	mov    %eax,-0x24(%ebp)
    uchar* waste  = (uchar*)malloc(sizeof(uchar) * wastedLen);
    2e1f:	8b 45 dc             	mov    -0x24(%ebp),%eax
    2e22:	83 ec 0c             	sub    $0xc,%esp
    2e25:	50                   	push   %eax
    2e26:	e8 f8 d9 ff ff       	call   823 <malloc>
    2e2b:	83 c4 10             	add    $0x10,%esp
    2e2e:	89 45 d8             	mov    %eax,-0x28(%ebp)
    read(fd, (char*)waste, wastedLen);
    2e31:	83 ec 04             	sub    $0x4,%esp
    2e34:	ff 75 dc             	pushl  -0x24(%ebp)
    2e37:	ff 75 d8             	pushl  -0x28(%ebp)
    2e3a:	ff 75 ec             	pushl  -0x14(%ebp)
    2e3d:	e8 7f d5 ff ff       	call   3c1 <read>
    2e42:	83 c4 10             	add    $0x10,%esp

    uchar* data = (uchar*)malloc(sizeof(uchar) * fileHeader.bfSize);
    2e45:	8b 45 ac             	mov    -0x54(%ebp),%eax
    2e48:	83 ec 0c             	sub    $0xc,%esp
    2e4b:	50                   	push   %eax
    2e4c:	e8 d2 d9 ff ff       	call   823 <malloc>
    2e51:	83 c4 10             	add    $0x10,%esp
    2e54:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    read(fd, (char*)data, sizeof(uchar) * fileHeader.bfSize);
    2e57:	8b 45 ac             	mov    -0x54(%ebp),%eax
    2e5a:	83 ec 04             	sub    $0x4,%esp
    2e5d:	50                   	push   %eax
    2e5e:	ff 75 d4             	pushl  -0x2c(%ebp)
    2e61:	ff 75 ec             	pushl  -0x14(%ebp)
    2e64:	e8 58 d5 ff ff       	call   3c1 <read>
    2e69:	83 c4 10             	add    $0x10,%esp

    int bits = infoHeader.biBitCount / 8;
    2e6c:	0f b7 45 90          	movzwl -0x70(%ebp),%eax
    2e70:	66 c1 e8 03          	shr    $0x3,%ax
    2e74:	0f b7 c0             	movzwl %ax,%eax
    2e77:	89 45 d0             	mov    %eax,-0x30(%ebp)
    for(int j=0; j<bmp.height; ++j){
    2e7a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2e81:	e9 c1 00 00 00       	jmp    2f47 <LoadBmp+0x261>
        int offset = (bmp.height - j - 1) * bmp.width;
    2e86:	8b 45 bc             	mov    -0x44(%ebp),%eax
    2e89:	2b 45 f4             	sub    -0xc(%ebp),%eax
    2e8c:	8d 50 ff             	lea    -0x1(%eax),%edx
    2e8f:	8b 45 b8             	mov    -0x48(%ebp),%eax
    2e92:	0f af c2             	imul   %edx,%eax
    2e95:	89 45 cc             	mov    %eax,-0x34(%ebp)
        int dataOffset = j * length;
    2e98:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2e9b:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
    2e9f:	89 45 c8             	mov    %eax,-0x38(%ebp)
        for(int i=0; i<bmp.width; ++i){
    2ea2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    2ea9:	e9 89 00 00 00       	jmp    2f37 <LoadBmp+0x251>
            int specOffset = dataOffset + bits * (i + 1);
    2eae:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2eb1:	83 c0 01             	add    $0x1,%eax
    2eb4:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    2eb8:	89 c2                	mov    %eax,%edx
    2eba:	8b 45 c8             	mov    -0x38(%ebp),%eax
    2ebd:	01 d0                	add    %edx,%eax
    2ebf:	89 45 c4             	mov    %eax,-0x3c(%ebp)
            bmp.data[offset+i].R = (int)data[specOffset - 1];
    2ec2:	8b 55 c0             	mov    -0x40(%ebp),%edx
    2ec5:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    2ec8:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2ecb:	01 c8                	add    %ecx,%eax
    2ecd:	89 c1                	mov    %eax,%ecx
    2ecf:	89 c8                	mov    %ecx,%eax
    2ed1:	01 c0                	add    %eax,%eax
    2ed3:	01 c8                	add    %ecx,%eax
    2ed5:	01 c2                	add    %eax,%edx
    2ed7:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2eda:	8d 48 ff             	lea    -0x1(%eax),%ecx
    2edd:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    2ee0:	01 c8                	add    %ecx,%eax
    2ee2:	0f b6 00             	movzbl (%eax),%eax
    2ee5:	88 42 02             	mov    %al,0x2(%edx)
            bmp.data[offset+i].G = (int)data[specOffset - 2];
    2ee8:	8b 55 c0             	mov    -0x40(%ebp),%edx
    2eeb:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    2eee:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2ef1:	01 c8                	add    %ecx,%eax
    2ef3:	89 c1                	mov    %eax,%ecx
    2ef5:	89 c8                	mov    %ecx,%eax
    2ef7:	01 c0                	add    %eax,%eax
    2ef9:	01 c8                	add    %ecx,%eax
    2efb:	01 c2                	add    %eax,%edx
    2efd:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2f00:	8d 48 fe             	lea    -0x2(%eax),%ecx
    2f03:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    2f06:	01 c8                	add    %ecx,%eax
    2f08:	0f b6 00             	movzbl (%eax),%eax
    2f0b:	88 42 01             	mov    %al,0x1(%edx)
            bmp.data[offset+i].B = (int)data[specOffset - 3];
    2f0e:	8b 55 c0             	mov    -0x40(%ebp),%edx
    2f11:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    2f14:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2f17:	01 c8                	add    %ecx,%eax
    2f19:	89 c1                	mov    %eax,%ecx
    2f1b:	89 c8                	mov    %ecx,%eax
    2f1d:	01 c0                	add    %eax,%eax
    2f1f:	01 c8                	add    %ecx,%eax
    2f21:	01 c2                	add    %eax,%edx
    2f23:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2f26:	8d 48 fd             	lea    -0x3(%eax),%ecx
    2f29:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    2f2c:	01 c8                	add    %ecx,%eax
    2f2e:	0f b6 00             	movzbl (%eax),%eax
    2f31:	88 02                	mov    %al,(%edx)

    int bits = infoHeader.biBitCount / 8;
    for(int j=0; j<bmp.height; ++j){
        int offset = (bmp.height - j - 1) * bmp.width;
        int dataOffset = j * length;
        for(int i=0; i<bmp.width; ++i){
    2f33:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    2f37:	8b 45 b8             	mov    -0x48(%ebp),%eax
    2f3a:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    2f3d:	0f 8f 6b ff ff ff    	jg     2eae <LoadBmp+0x1c8>

    uchar* data = (uchar*)malloc(sizeof(uchar) * fileHeader.bfSize);
    read(fd, (char*)data, sizeof(uchar) * fileHeader.bfSize);

    int bits = infoHeader.biBitCount / 8;
    for(int j=0; j<bmp.height; ++j){
    2f43:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2f47:	8b 45 bc             	mov    -0x44(%ebp),%eax
    2f4a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    2f4d:	0f 8f 33 ff ff ff    	jg     2e86 <LoadBmp+0x1a0>
            bmp.data[offset+i].R = (int)data[specOffset - 1];
            bmp.data[offset+i].G = (int)data[specOffset - 2];
            bmp.data[offset+i].B = (int)data[specOffset - 3];
        }
    }
    close(fd);
    2f53:	83 ec 0c             	sub    $0xc,%esp
    2f56:	ff 75 ec             	pushl  -0x14(%ebp)
    2f59:	e8 73 d4 ff ff       	call   3d1 <close>
    2f5e:	83 c4 10             	add    $0x10,%esp
    return bmp;
    2f61:	8b 45 08             	mov    0x8(%ebp),%eax
    2f64:	8b 55 b8             	mov    -0x48(%ebp),%edx
    2f67:	89 10                	mov    %edx,(%eax)
    2f69:	8b 55 bc             	mov    -0x44(%ebp),%edx
    2f6c:	89 50 04             	mov    %edx,0x4(%eax)
    2f6f:	8b 55 c0             	mov    -0x40(%ebp),%edx
    2f72:	89 50 08             	mov    %edx,0x8(%eax)
}
    2f75:	8b 45 08             	mov    0x8(%ebp),%eax
    2f78:	8d 65 f8             	lea    -0x8(%ebp),%esp
    2f7b:	5b                   	pop    %ebx
    2f7c:	5e                   	pop    %esi
    2f7d:	5d                   	pop    %ebp
    2f7e:	c2 04 00             	ret    $0x4

00002f81 <LoadJpeg>:

PBitmap LoadJpeg(char* filename){
    2f81:	55                   	push   %ebp
    2f82:	89 e5                	mov    %esp,%ebp
    2f84:	53                   	push   %ebx
    2f85:	83 ec 74             	sub    $0x74,%esp
    char ZZ[64] = { 0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18,
    2f88:	c6 45 9c 00          	movb   $0x0,-0x64(%ebp)
    2f8c:	c6 45 9d 01          	movb   $0x1,-0x63(%ebp)
    2f90:	c6 45 9e 08          	movb   $0x8,-0x62(%ebp)
    2f94:	c6 45 9f 10          	movb   $0x10,-0x61(%ebp)
    2f98:	c6 45 a0 09          	movb   $0x9,-0x60(%ebp)
    2f9c:	c6 45 a1 02          	movb   $0x2,-0x5f(%ebp)
    2fa0:	c6 45 a2 03          	movb   $0x3,-0x5e(%ebp)
    2fa4:	c6 45 a3 0a          	movb   $0xa,-0x5d(%ebp)
    2fa8:	c6 45 a4 11          	movb   $0x11,-0x5c(%ebp)
    2fac:	c6 45 a5 18          	movb   $0x18,-0x5b(%ebp)
    2fb0:	c6 45 a6 20          	movb   $0x20,-0x5a(%ebp)
    2fb4:	c6 45 a7 19          	movb   $0x19,-0x59(%ebp)
    2fb8:	c6 45 a8 12          	movb   $0x12,-0x58(%ebp)
    2fbc:	c6 45 a9 0b          	movb   $0xb,-0x57(%ebp)
    2fc0:	c6 45 aa 04          	movb   $0x4,-0x56(%ebp)
    2fc4:	c6 45 ab 05          	movb   $0x5,-0x55(%ebp)
    2fc8:	c6 45 ac 0c          	movb   $0xc,-0x54(%ebp)
    2fcc:	c6 45 ad 13          	movb   $0x13,-0x53(%ebp)
    2fd0:	c6 45 ae 1a          	movb   $0x1a,-0x52(%ebp)
    2fd4:	c6 45 af 21          	movb   $0x21,-0x51(%ebp)
    2fd8:	c6 45 b0 28          	movb   $0x28,-0x50(%ebp)
    2fdc:	c6 45 b1 30          	movb   $0x30,-0x4f(%ebp)
    2fe0:	c6 45 b2 29          	movb   $0x29,-0x4e(%ebp)
    2fe4:	c6 45 b3 22          	movb   $0x22,-0x4d(%ebp)
    2fe8:	c6 45 b4 1b          	movb   $0x1b,-0x4c(%ebp)
    2fec:	c6 45 b5 14          	movb   $0x14,-0x4b(%ebp)
    2ff0:	c6 45 b6 0d          	movb   $0xd,-0x4a(%ebp)
    2ff4:	c6 45 b7 06          	movb   $0x6,-0x49(%ebp)
    2ff8:	c6 45 b8 07          	movb   $0x7,-0x48(%ebp)
    2ffc:	c6 45 b9 0e          	movb   $0xe,-0x47(%ebp)
    3000:	c6 45 ba 15          	movb   $0x15,-0x46(%ebp)
    3004:	c6 45 bb 1c          	movb   $0x1c,-0x45(%ebp)
    3008:	c6 45 bc 23          	movb   $0x23,-0x44(%ebp)
    300c:	c6 45 bd 2a          	movb   $0x2a,-0x43(%ebp)
    3010:	c6 45 be 31          	movb   $0x31,-0x42(%ebp)
    3014:	c6 45 bf 38          	movb   $0x38,-0x41(%ebp)
    3018:	c6 45 c0 39          	movb   $0x39,-0x40(%ebp)
    301c:	c6 45 c1 32          	movb   $0x32,-0x3f(%ebp)
    3020:	c6 45 c2 2b          	movb   $0x2b,-0x3e(%ebp)
    3024:	c6 45 c3 24          	movb   $0x24,-0x3d(%ebp)
    3028:	c6 45 c4 1d          	movb   $0x1d,-0x3c(%ebp)
    302c:	c6 45 c5 16          	movb   $0x16,-0x3b(%ebp)
    3030:	c6 45 c6 0f          	movb   $0xf,-0x3a(%ebp)
    3034:	c6 45 c7 17          	movb   $0x17,-0x39(%ebp)
    3038:	c6 45 c8 1e          	movb   $0x1e,-0x38(%ebp)
    303c:	c6 45 c9 25          	movb   $0x25,-0x37(%ebp)
    3040:	c6 45 ca 2c          	movb   $0x2c,-0x36(%ebp)
    3044:	c6 45 cb 33          	movb   $0x33,-0x35(%ebp)
    3048:	c6 45 cc 3a          	movb   $0x3a,-0x34(%ebp)
    304c:	c6 45 cd 3b          	movb   $0x3b,-0x33(%ebp)
    3050:	c6 45 ce 34          	movb   $0x34,-0x32(%ebp)
    3054:	c6 45 cf 2d          	movb   $0x2d,-0x31(%ebp)
    3058:	c6 45 d0 26          	movb   $0x26,-0x30(%ebp)
    305c:	c6 45 d1 1f          	movb   $0x1f,-0x2f(%ebp)
    3060:	c6 45 d2 27          	movb   $0x27,-0x2e(%ebp)
    3064:	c6 45 d3 2e          	movb   $0x2e,-0x2d(%ebp)
    3068:	c6 45 d4 35          	movb   $0x35,-0x2c(%ebp)
    306c:	c6 45 d5 3c          	movb   $0x3c,-0x2b(%ebp)
    3070:	c6 45 d6 3d          	movb   $0x3d,-0x2a(%ebp)
    3074:	c6 45 d7 36          	movb   $0x36,-0x29(%ebp)
    3078:	c6 45 d8 2f          	movb   $0x2f,-0x28(%ebp)
    307c:	c6 45 d9 37          	movb   $0x37,-0x27(%ebp)
    3080:	c6 45 da 3e          	movb   $0x3e,-0x26(%ebp)
    3084:	c6 45 db 3f          	movb   $0x3f,-0x25(%ebp)
        11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35,
        42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45,
        38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63 };
    Context* ctx=malloc(sizeof(Context));
    3088:	83 ec 0c             	sub    $0xc,%esp
    308b:	68 c8 02 08 00       	push   $0x802c8
    3090:	e8 8e d7 ff ff       	call   823 <malloc>
    3095:	83 c4 10             	add    $0x10,%esp
    3098:	89 45 f0             	mov    %eax,-0x10(%ebp)
    memset(ctx, 0, sizeof(Context));
    309b:	83 ec 04             	sub    $0x4,%esp
    309e:	68 c8 02 08 00       	push   $0x802c8
    30a3:	6a 00                	push   $0x0
    30a5:	ff 75 f0             	pushl  -0x10(%ebp)
    30a8:	e8 61 d1 ff ff       	call   20e <memset>
    30ad:	83 c4 10             	add    $0x10,%esp

    int fd;
    fd = open(filename, O_RDONLY);
    30b0:	83 ec 08             	sub    $0x8,%esp
    30b3:	6a 00                	push   $0x0
    30b5:	ff 75 0c             	pushl  0xc(%ebp)
    30b8:	e8 2c d3 ff ff       	call   3e9 <open>
    30bd:	83 c4 10             	add    $0x10,%esp
    30c0:	89 45 ec             	mov    %eax,-0x14(%ebp)
    uchar* buf = (uchar*)malloc(MAX_JPEG_SIZE);
    30c3:	83 ec 0c             	sub    $0xc,%esp
    30c6:	68 40 42 0f 00       	push   $0xf4240
    30cb:	e8 53 d7 ff ff       	call   823 <malloc>
    30d0:	83 c4 10             	add    $0x10,%esp
    30d3:	89 45 e8             	mov    %eax,-0x18(%ebp)

    read(fd, buf, MAX_JPEG_SIZE);
    30d6:	83 ec 04             	sub    $0x4,%esp
    30d9:	68 40 42 0f 00       	push   $0xf4240
    30de:	ff 75 e8             	pushl  -0x18(%ebp)
    30e1:	ff 75 ec             	pushl  -0x14(%ebp)
    30e4:	e8 d8 d2 ff ff       	call   3c1 <read>
    30e9:	83 c4 10             	add    $0x10,%esp
    
    close(fd);
    30ec:	83 ec 0c             	sub    $0xc,%esp
    30ef:	ff 75 ec             	pushl  -0x14(%ebp)
    30f2:	e8 da d2 ff ff       	call   3d1 <close>
    30f7:	83 c4 10             	add    $0x10,%esp

    _DecodeJPEG(ctx, ZZ, buf, MAX_JPEG_SIZE);
    30fa:	68 40 42 0f 00       	push   $0xf4240
    30ff:	ff 75 e8             	pushl  -0x18(%ebp)
    3102:	8d 45 9c             	lea    -0x64(%ebp),%eax
    3105:	50                   	push   %eax
    3106:	ff 75 f0             	pushl  -0x10(%ebp)
    3109:	e8 5e 0c 01 00       	call   13d6c <_DecodeJPEG>
    310e:	83 c4 10             	add    $0x10,%esp

   
    PBitmap bmp;
    bmp.height=0;
    3111:	c7 45 94 00 00 00 00 	movl   $0x0,-0x6c(%ebp)
    bmp.width=0;
    3118:	c7 45 90 00 00 00 00 	movl   $0x0,-0x70(%ebp)
    bmp.data=0;
    311f:	c7 45 98 00 00 00 00 	movl   $0x0,-0x68(%ebp)
    
    int imgsize = GetImageSize(ctx);
    3126:	83 ec 0c             	sub    $0xc,%esp
    3129:	ff 75 f0             	pushl  -0x10(%ebp)
    312c:	e8 29 0b 01 00       	call   13c5a <GetImageSize>
    3131:	83 c4 10             	add    $0x10,%esp
    3134:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    uchar* c = GetImage(ctx);
    3137:	83 ec 0c             	sub    $0xc,%esp
    313a:	ff 75 f0             	pushl  -0x10(%ebp)
    313d:	e8 e1 0a 01 00       	call   13c23 <GetImage>
    3142:	83 c4 10             	add    $0x10,%esp
    3145:	89 45 e0             	mov    %eax,-0x20(%ebp)
    bmp.width = GetWidth(ctx);
    3148:	83 ec 0c             	sub    $0xc,%esp
    314b:	ff 75 f0             	pushl  -0x10(%ebp)
    314e:	e8 f1 0a 01 00       	call   13c44 <GetWidth>
    3153:	83 c4 10             	add    $0x10,%esp
    3156:	89 45 90             	mov    %eax,-0x70(%ebp)
    bmp.height = GetHeight(ctx);
    3159:	83 ec 0c             	sub    $0xc,%esp
    315c:	ff 75 f0             	pushl  -0x10(%ebp)
    315f:	e8 eb 0a 01 00       	call   13c4f <GetHeight>
    3164:	83 c4 10             	add    $0x10,%esp
    3167:	89 45 94             	mov    %eax,-0x6c(%ebp)
    int n = bmp.width * bmp.height;
    316a:	8b 55 90             	mov    -0x70(%ebp),%edx
    316d:	8b 45 94             	mov    -0x6c(%ebp),%eax
    3170:	0f af c2             	imul   %edx,%eax
    3173:	89 45 dc             	mov    %eax,-0x24(%ebp)
    bmp.data = (RGB*)malloc(n * sizeof(RGB));
    3176:	8b 55 dc             	mov    -0x24(%ebp),%edx
    3179:	89 d0                	mov    %edx,%eax
    317b:	01 c0                	add    %eax,%eax
    317d:	01 d0                	add    %edx,%eax
    317f:	83 ec 0c             	sub    $0xc,%esp
    3182:	50                   	push   %eax
    3183:	e8 9b d6 ff ff       	call   823 <malloc>
    3188:	83 c4 10             	add    $0x10,%esp
    318b:	89 45 98             	mov    %eax,-0x68(%ebp)
    for(int i=0; i<imgsize; i+=3){
    318e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    3195:	e9 9c 00 00 00       	jmp    3236 <LoadJpeg+0x2b5>
        bmp.data[i/3].R = c[i];
    319a:	8b 5d 98             	mov    -0x68(%ebp),%ebx
    319d:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    31a0:	ba 56 55 55 55       	mov    $0x55555556,%edx
    31a5:	89 c8                	mov    %ecx,%eax
    31a7:	f7 ea                	imul   %edx
    31a9:	89 c8                	mov    %ecx,%eax
    31ab:	c1 f8 1f             	sar    $0x1f,%eax
    31ae:	29 c2                	sub    %eax,%edx
    31b0:	89 d0                	mov    %edx,%eax
    31b2:	89 c2                	mov    %eax,%edx
    31b4:	89 d0                	mov    %edx,%eax
    31b6:	01 c0                	add    %eax,%eax
    31b8:	01 d0                	add    %edx,%eax
    31ba:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    31bd:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    31c0:	8b 45 e0             	mov    -0x20(%ebp),%eax
    31c3:	01 c8                	add    %ecx,%eax
    31c5:	0f b6 00             	movzbl (%eax),%eax
    31c8:	88 42 02             	mov    %al,0x2(%edx)
        bmp.data[i/3].G = c[i+1];
    31cb:	8b 5d 98             	mov    -0x68(%ebp),%ebx
    31ce:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    31d1:	ba 56 55 55 55       	mov    $0x55555556,%edx
    31d6:	89 c8                	mov    %ecx,%eax
    31d8:	f7 ea                	imul   %edx
    31da:	89 c8                	mov    %ecx,%eax
    31dc:	c1 f8 1f             	sar    $0x1f,%eax
    31df:	29 c2                	sub    %eax,%edx
    31e1:	89 d0                	mov    %edx,%eax
    31e3:	89 c2                	mov    %eax,%edx
    31e5:	89 d0                	mov    %edx,%eax
    31e7:	01 c0                	add    %eax,%eax
    31e9:	01 d0                	add    %edx,%eax
    31eb:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    31ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
    31f1:	8d 48 01             	lea    0x1(%eax),%ecx
    31f4:	8b 45 e0             	mov    -0x20(%ebp),%eax
    31f7:	01 c8                	add    %ecx,%eax
    31f9:	0f b6 00             	movzbl (%eax),%eax
    31fc:	88 42 01             	mov    %al,0x1(%edx)
        bmp.data[i/3].B = c[i+2];
    31ff:	8b 5d 98             	mov    -0x68(%ebp),%ebx
    3202:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    3205:	ba 56 55 55 55       	mov    $0x55555556,%edx
    320a:	89 c8                	mov    %ecx,%eax
    320c:	f7 ea                	imul   %edx
    320e:	89 c8                	mov    %ecx,%eax
    3210:	c1 f8 1f             	sar    $0x1f,%eax
    3213:	29 c2                	sub    %eax,%edx
    3215:	89 d0                	mov    %edx,%eax
    3217:	89 c2                	mov    %eax,%edx
    3219:	89 d0                	mov    %edx,%eax
    321b:	01 c0                	add    %eax,%eax
    321d:	01 d0                	add    %edx,%eax
    321f:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    3222:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3225:	8d 48 02             	lea    0x2(%eax),%ecx
    3228:	8b 45 e0             	mov    -0x20(%ebp),%eax
    322b:	01 c8                	add    %ecx,%eax
    322d:	0f b6 00             	movzbl (%eax),%eax
    3230:	88 02                	mov    %al,(%edx)
    uchar* c = GetImage(ctx);
    bmp.width = GetWidth(ctx);
    bmp.height = GetHeight(ctx);
    int n = bmp.width * bmp.height;
    bmp.data = (RGB*)malloc(n * sizeof(RGB));
    for(int i=0; i<imgsize; i+=3){
    3232:	83 45 f4 03          	addl   $0x3,-0xc(%ebp)
    3236:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3239:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    323c:	0f 8c 58 ff ff ff    	jl     319a <LoadJpeg+0x219>
        bmp.data[i/3].R = c[i];
        bmp.data[i/3].G = c[i+1];
        bmp.data[i/3].B = c[i+2];
    }
    return bmp;
    3242:	8b 45 08             	mov    0x8(%ebp),%eax
    3245:	8b 55 90             	mov    -0x70(%ebp),%edx
    3248:	89 10                	mov    %edx,(%eax)
    324a:	8b 55 94             	mov    -0x6c(%ebp),%edx
    324d:	89 50 04             	mov    %edx,0x4(%eax)
    3250:	8b 55 98             	mov    -0x68(%ebp),%edx
    3253:	89 50 08             	mov    %edx,0x8(%eax)
}
    3256:	8b 45 08             	mov    0x8(%ebp),%eax
    3259:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    325c:	c9                   	leave  
    325d:	c2 04 00             	ret    $0x4

00003260 <LoadPng>:

PBitmap LoadPng(char* filename){
    3260:	55                   	push   %ebp
    3261:	89 e5                	mov    %esp,%ebp
    3263:	83 ec 38             	sub    $0x38,%esp
    unsigned char* image = 0;
    3266:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    unsigned width, height;
    lodepng_decode24_file(&image, &width, &height, filename);
    326d:	ff 75 0c             	pushl  0xc(%ebp)
    3270:	8d 45 e0             	lea    -0x20(%ebp),%eax
    3273:	50                   	push   %eax
    3274:	8d 45 e4             	lea    -0x1c(%ebp),%eax
    3277:	50                   	push   %eax
    3278:	8d 45 e8             	lea    -0x18(%ebp),%eax
    327b:	50                   	push   %eax
    327c:	e8 d3 d3 00 00       	call   10654 <lodepng_decode24_file>
    3281:	83 c4 10             	add    $0x10,%esp
    PBitmap bmp;
    bmp.height=height;
    3284:	8b 45 e0             	mov    -0x20(%ebp),%eax
    3287:	89 45 d8             	mov    %eax,-0x28(%ebp)
    bmp.width=width;
    328a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    328d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    bmp.data=0;
    3290:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)

    // int imgsize = width * height;
    int n = bmp.width * bmp.height;
    3297:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    329a:	8b 45 d8             	mov    -0x28(%ebp),%eax
    329d:	0f af c2             	imul   %edx,%eax
    32a0:	89 45 f0             	mov    %eax,-0x10(%ebp)
    bmp.data = (RGB *)malloc(sizeof(RGB) * n);
    32a3:	8b 55 f0             	mov    -0x10(%ebp),%edx
    32a6:	89 d0                	mov    %edx,%eax
    32a8:	01 c0                	add    %eax,%eax
    32aa:	01 d0                	add    %edx,%eax
    32ac:	83 ec 0c             	sub    $0xc,%esp
    32af:	50                   	push   %eax
    32b0:	e8 6e d5 ff ff       	call   823 <malloc>
    32b5:	83 c4 10             	add    $0x10,%esp
    32b8:	89 45 dc             	mov    %eax,-0x24(%ebp)
    //这里是用decode24,所以是3个3个的读取
    for (int i = 0; i < n; i += 1)
    32bb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    32c2:	e9 87 00 00 00       	jmp    334e <LoadPng+0xee>
    {
        unsigned char R = image[i*3];
    32c7:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    32ca:	8b 55 f4             	mov    -0xc(%ebp),%edx
    32cd:	89 d0                	mov    %edx,%eax
    32cf:	01 c0                	add    %eax,%eax
    32d1:	01 d0                	add    %edx,%eax
    32d3:	01 c8                	add    %ecx,%eax
    32d5:	0f b6 00             	movzbl (%eax),%eax
    32d8:	88 45 ef             	mov    %al,-0x11(%ebp)
        unsigned char G = image[i*3 + 1];
    32db:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    32de:	8b 55 f4             	mov    -0xc(%ebp),%edx
    32e1:	89 d0                	mov    %edx,%eax
    32e3:	01 c0                	add    %eax,%eax
    32e5:	01 d0                	add    %edx,%eax
    32e7:	83 c0 01             	add    $0x1,%eax
    32ea:	01 c8                	add    %ecx,%eax
    32ec:	0f b6 00             	movzbl (%eax),%eax
    32ef:	88 45 ee             	mov    %al,-0x12(%ebp)
        unsigned char B = image[i*3 + 2];
    32f2:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    32f5:	8b 55 f4             	mov    -0xc(%ebp),%edx
    32f8:	89 d0                	mov    %edx,%eax
    32fa:	01 c0                	add    %eax,%eax
    32fc:	01 d0                	add    %edx,%eax
    32fe:	83 c0 02             	add    $0x2,%eax
    3301:	01 c8                	add    %ecx,%eax
    3303:	0f b6 00             	movzbl (%eax),%eax
    3306:	88 45 ed             	mov    %al,-0x13(%ebp)
        bmp.data[i].R = R;
    3309:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    330c:	8b 55 f4             	mov    -0xc(%ebp),%edx
    330f:	89 d0                	mov    %edx,%eax
    3311:	01 c0                	add    %eax,%eax
    3313:	01 d0                	add    %edx,%eax
    3315:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    3318:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
    331c:	88 42 02             	mov    %al,0x2(%edx)
        bmp.data[i].G = G;
    331f:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    3322:	8b 55 f4             	mov    -0xc(%ebp),%edx
    3325:	89 d0                	mov    %edx,%eax
    3327:	01 c0                	add    %eax,%eax
    3329:	01 d0                	add    %edx,%eax
    332b:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    332e:	0f b6 45 ee          	movzbl -0x12(%ebp),%eax
    3332:	88 42 01             	mov    %al,0x1(%edx)
        bmp.data[i].B = B;
    3335:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    3338:	8b 55 f4             	mov    -0xc(%ebp),%edx
    333b:	89 d0                	mov    %edx,%eax
    333d:	01 c0                	add    %eax,%eax
    333f:	01 d0                	add    %edx,%eax
    3341:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    3344:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
    3348:	88 02                	mov    %al,(%edx)

    // int imgsize = width * height;
    int n = bmp.width * bmp.height;
    bmp.data = (RGB *)malloc(sizeof(RGB) * n);
    //这里是用decode24,所以是3个3个的读取
    for (int i = 0; i < n; i += 1)
    334a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    334e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3351:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    3354:	0f 8c 6d ff ff ff    	jl     32c7 <LoadPng+0x67>
        bmp.data[i].G = G;
        bmp.data[i].B = B;

    }
    // printf(1, "read all png data.\n");
    free(image);
    335a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    335d:	83 ec 0c             	sub    $0xc,%esp
    3360:	50                   	push   %eax
    3361:	e8 7b d3 ff ff       	call   6e1 <free>
    3366:	83 c4 10             	add    $0x10,%esp
    return bmp;
    3369:	8b 45 08             	mov    0x8(%ebp),%eax
    336c:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    336f:	89 10                	mov    %edx,(%eax)
    3371:	8b 55 d8             	mov    -0x28(%ebp),%edx
    3374:	89 50 04             	mov    %edx,0x4(%eax)
    3377:	8b 55 dc             	mov    -0x24(%ebp),%edx
    337a:	89 50 08             	mov    %edx,0x8(%eax)

}
    337d:	8b 45 08             	mov    0x8(%ebp),%eax
    3380:	c9                   	leave  
    3381:	c2 04 00             	ret    $0x4

00003384 <LoadImg>:

PBitmap LoadImg(char* filename){
    3384:	55                   	push   %ebp
    3385:	89 e5                	mov    %esp,%ebp
    3387:	83 ec 18             	sub    $0x18,%esp
    int t = type(filename);
    338a:	83 ec 0c             	sub    $0xc,%esp
    338d:	ff 75 0c             	pushl  0xc(%ebp)
    3390:	e8 7c f8 ff ff       	call   2c11 <type>
    3395:	83 c4 10             	add    $0x10,%esp
    3398:	89 45 f4             	mov    %eax,-0xc(%ebp)
    PBitmap bmp;
    switch(t){
    339b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    339e:	83 f8 01             	cmp    $0x1,%eax
    33a1:	74 1d                	je     33c0 <LoadImg+0x3c>
    33a3:	83 f8 02             	cmp    $0x2,%eax
    33a6:	74 2c                	je     33d4 <LoadImg+0x50>
    33a8:	85 c0                	test   %eax,%eax
    33aa:	75 3c                	jne    33e8 <LoadImg+0x64>
        case JPG: return LoadJpeg(filename);
    33ac:	8b 45 08             	mov    0x8(%ebp),%eax
    33af:	83 ec 08             	sub    $0x8,%esp
    33b2:	ff 75 0c             	pushl  0xc(%ebp)
    33b5:	50                   	push   %eax
    33b6:	e8 c6 fb ff ff       	call   2f81 <LoadJpeg>
    33bb:	83 c4 0c             	add    $0xc,%esp
    33be:	eb 3c                	jmp    33fc <LoadImg+0x78>
        case BMP: return LoadBmp(filename);
    33c0:	8b 45 08             	mov    0x8(%ebp),%eax
    33c3:	83 ec 08             	sub    $0x8,%esp
    33c6:	ff 75 0c             	pushl  0xc(%ebp)
    33c9:	50                   	push   %eax
    33ca:	e8 17 f9 ff ff       	call   2ce6 <LoadBmp>
    33cf:	83 c4 0c             	add    $0xc,%esp
    33d2:	eb 28                	jmp    33fc <LoadImg+0x78>
        case PNG: return LoadPng(filename);
    33d4:	8b 45 08             	mov    0x8(%ebp),%eax
    33d7:	83 ec 08             	sub    $0x8,%esp
    33da:	ff 75 0c             	pushl  0xc(%ebp)
    33dd:	50                   	push   %eax
    33de:	e8 7d fe ff ff       	call   3260 <LoadPng>
    33e3:	83 c4 0c             	add    $0xc,%esp
    33e6:	eb 14                	jmp    33fc <LoadImg+0x78>

        default: return bmp;
    33e8:	8b 45 08             	mov    0x8(%ebp),%eax
    33eb:	8b 55 e8             	mov    -0x18(%ebp),%edx
    33ee:	89 10                	mov    %edx,(%eax)
    33f0:	8b 55 ec             	mov    -0x14(%ebp),%edx
    33f3:	89 50 04             	mov    %edx,0x4(%eax)
    33f6:	8b 55 f0             	mov    -0x10(%ebp),%edx
    33f9:	89 50 08             	mov    %edx,0x8(%eax)
    }
}
    33fc:	8b 45 08             	mov    0x8(%ebp),%eax
    33ff:	c9                   	leave  
    3400:	c2 04 00             	ret    $0x4

00003403 <lodepng_malloc>:
define them in your own project's source files without needing to change
lodepng source code. Don't forget to remove "static" if you copypaste them
from here.*/

#ifdef LODEPNG_COMPILE_ALLOCATORS
static void* lodepng_malloc(size_t size) {
    3403:	55                   	push   %ebp
    3404:	89 e5                	mov    %esp,%ebp
    3406:	83 ec 08             	sub    $0x8,%esp
#ifdef LODEPNG_MAX_ALLOC
  if(size > LODEPNG_MAX_ALLOC) return 0;
#endif
  return malloc(size);
    3409:	8b 45 08             	mov    0x8(%ebp),%eax
    340c:	83 ec 0c             	sub    $0xc,%esp
    340f:	50                   	push   %eax
    3410:	e8 0e d4 ff ff       	call   823 <malloc>
    3415:	83 c4 10             	add    $0x10,%esp
}
    3418:	c9                   	leave  
    3419:	c3                   	ret    

0000341a <lodepng_realloc>:

/* NOTE: when realloc returns NULL, it leaves the original memory untouched */
static void* lodepng_realloc(void* ptr, size_t new_size) {
    341a:	55                   	push   %ebp
    341b:	89 e5                	mov    %esp,%ebp
#ifdef LODEPNG_MAX_ALLOC
  if(new_size > LODEPNG_MAX_ALLOC) return 0;
#endif
  // return realloc(ptr, new_size);
  return -1;
    341d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
    3422:	5d                   	pop    %ebp
    3423:	c3                   	ret    

00003424 <lodepng_free>:

static void lodepng_free(void* ptr) {
    3424:	55                   	push   %ebp
    3425:	89 e5                	mov    %esp,%ebp
    3427:	83 ec 08             	sub    $0x8,%esp
  if(ptr)
    342a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    342e:	74 0e                	je     343e <lodepng_free+0x1a>
    free(ptr);
    3430:	83 ec 0c             	sub    $0xc,%esp
    3433:	ff 75 08             	pushl  0x8(%ebp)
    3436:	e8 a6 d2 ff ff       	call   6e1 <free>
    343b:	83 c4 10             	add    $0x10,%esp
}
    343e:	90                   	nop
    343f:	c9                   	leave  
    3440:	c3                   	ret    

00003441 <lodepng_memcpy>:
/* Replacements for C library functions such as memcpy and strlen, to support platforms
where a full C library is not available. The compiler can recognize them and compile
to something as fast. */

static void lodepng_memcpy(void* LODEPNG_RESTRICT dst,
                           const void* LODEPNG_RESTRICT src, size_t size) {
    3441:	55                   	push   %ebp
    3442:	89 e5                	mov    %esp,%ebp
    3444:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i < size; i++) ((char*)dst)[i] = ((const char*)src)[i];
    3447:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    344e:	eb 19                	jmp    3469 <lodepng_memcpy+0x28>
    3450:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3453:	8b 45 08             	mov    0x8(%ebp),%eax
    3456:	01 c2                	add    %eax,%edx
    3458:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    345b:	8b 45 0c             	mov    0xc(%ebp),%eax
    345e:	01 c8                	add    %ecx,%eax
    3460:	0f b6 00             	movzbl (%eax),%eax
    3463:	88 02                	mov    %al,(%edx)
    3465:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    3469:	8b 45 fc             	mov    -0x4(%ebp),%eax
    346c:	3b 45 10             	cmp    0x10(%ebp),%eax
    346f:	7c df                	jl     3450 <lodepng_memcpy+0xf>
}
    3471:	90                   	nop
    3472:	c9                   	leave  
    3473:	c3                   	ret    

00003474 <lodepng_memset>:

static void lodepng_memset(void* LODEPNG_RESTRICT dst,
                           int value, size_t num) {
    3474:	55                   	push   %ebp
    3475:	89 e5                	mov    %esp,%ebp
    3477:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i < num; i++) ((char*)dst)[i] = (char)value;
    347a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    3481:	eb 11                	jmp    3494 <lodepng_memset+0x20>
    3483:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3486:	8b 45 08             	mov    0x8(%ebp),%eax
    3489:	01 d0                	add    %edx,%eax
    348b:	8b 55 0c             	mov    0xc(%ebp),%edx
    348e:	88 10                	mov    %dl,(%eax)
    3490:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    3494:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3497:	3b 45 10             	cmp    0x10(%ebp),%eax
    349a:	7c e7                	jl     3483 <lodepng_memset+0xf>
}
    349c:	90                   	nop
    349d:	c9                   	leave  
    349e:	c3                   	ret    

0000349f <lodepng_strlen>:

/* does not check memory out of bounds, do not use on untrusted data */
static size_t lodepng_strlen(const char* a) {
    349f:	55                   	push   %ebp
    34a0:	89 e5                	mov    %esp,%ebp
    34a2:	83 ec 10             	sub    $0x10,%esp
  const char* orig = a;
    34a5:	8b 45 08             	mov    0x8(%ebp),%eax
    34a8:	89 45 fc             	mov    %eax,-0x4(%ebp)
  /* avoid warning about unused function in case of disabled COMPILE... macros */
  (void)(&lodepng_strlen);
  while(*a) a++;
    34ab:	eb 04                	jmp    34b1 <lodepng_strlen+0x12>
    34ad:	83 45 08 01          	addl   $0x1,0x8(%ebp)
    34b1:	8b 45 08             	mov    0x8(%ebp),%eax
    34b4:	0f b6 00             	movzbl (%eax),%eax
    34b7:	84 c0                	test   %al,%al
    34b9:	75 f2                	jne    34ad <lodepng_strlen+0xe>
  return (size_t)(a - orig);
    34bb:	8b 55 08             	mov    0x8(%ebp),%edx
    34be:	8b 45 fc             	mov    -0x4(%ebp),%eax
    34c1:	29 c2                	sub    %eax,%edx
    34c3:	89 d0                	mov    %edx,%eax
}
    34c5:	c9                   	leave  
    34c6:	c3                   	ret    

000034c7 <lodepng_addofl>:
#define LODEPNG_ABS(x) ((x) < 0 ? -(x) : (x))

#if defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_DECODER)
/* Safely check if adding two integers will overflow (no undefined
behavior, compiler removing the code, etc...) and output result. */
static int lodepng_addofl(size_t a, size_t b, size_t* result) {
    34c7:	55                   	push   %ebp
    34c8:	89 e5                	mov    %esp,%ebp
  *result = a + b; /* Unsigned addition is well defined and safe in C90 */
    34ca:	8b 55 08             	mov    0x8(%ebp),%edx
    34cd:	8b 45 0c             	mov    0xc(%ebp),%eax
    34d0:	01 c2                	add    %eax,%edx
    34d2:	8b 45 10             	mov    0x10(%ebp),%eax
    34d5:	89 10                	mov    %edx,(%eax)
  return *result < a;
    34d7:	8b 45 10             	mov    0x10(%ebp),%eax
    34da:	8b 00                	mov    (%eax),%eax
    34dc:	3b 45 08             	cmp    0x8(%ebp),%eax
    34df:	0f 9c c0             	setl   %al
    34e2:	0f b6 c0             	movzbl %al,%eax
}
    34e5:	5d                   	pop    %ebp
    34e6:	c3                   	ret    

000034e7 <lodepng_mulofl>:
#endif /*defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_DECODER)*/

#ifdef LODEPNG_COMPILE_DECODER
/* Safely check if multiplying two integers will overflow (no undefined
behavior, compiler removing the code, etc...) and output result. */
static int lodepng_mulofl(size_t a, size_t b, size_t* result) {
    34e7:	55                   	push   %ebp
    34e8:	89 e5                	mov    %esp,%ebp
  *result = a * b; /* Unsigned multiplication is well defined and safe in C90 */
    34ea:	8b 45 08             	mov    0x8(%ebp),%eax
    34ed:	0f af 45 0c          	imul   0xc(%ebp),%eax
    34f1:	89 c2                	mov    %eax,%edx
    34f3:	8b 45 10             	mov    0x10(%ebp),%eax
    34f6:	89 10                	mov    %edx,(%eax)
  return (a != 0 && *result / a != b);
    34f8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    34fc:	74 15                	je     3513 <lodepng_mulofl+0x2c>
    34fe:	8b 45 10             	mov    0x10(%ebp),%eax
    3501:	8b 00                	mov    (%eax),%eax
    3503:	99                   	cltd   
    3504:	f7 7d 08             	idivl  0x8(%ebp)
    3507:	3b 45 0c             	cmp    0xc(%ebp),%eax
    350a:	74 07                	je     3513 <lodepng_mulofl+0x2c>
    350c:	b8 01 00 00 00       	mov    $0x1,%eax
    3511:	eb 05                	jmp    3518 <lodepng_mulofl+0x31>
    3513:	b8 00 00 00 00       	mov    $0x0,%eax
}
    3518:	5d                   	pop    %ebp
    3519:	c3                   	ret    

0000351a <lodepng_gtofl>:

#ifdef LODEPNG_COMPILE_ZLIB
/* Safely check if a + b > c, even if overflow could happen. */
static int lodepng_gtofl(size_t a, size_t b, size_t c) {
    351a:	55                   	push   %ebp
    351b:	89 e5                	mov    %esp,%ebp
    351d:	83 ec 10             	sub    $0x10,%esp
  size_t d;
  if(lodepng_addofl(a, b, &d)) return 1;
    3520:	8d 45 fc             	lea    -0x4(%ebp),%eax
    3523:	50                   	push   %eax
    3524:	ff 75 0c             	pushl  0xc(%ebp)
    3527:	ff 75 08             	pushl  0x8(%ebp)
    352a:	e8 98 ff ff ff       	call   34c7 <lodepng_addofl>
    352f:	83 c4 0c             	add    $0xc,%esp
    3532:	85 c0                	test   %eax,%eax
    3534:	74 07                	je     353d <lodepng_gtofl+0x23>
    3536:	b8 01 00 00 00       	mov    $0x1,%eax
    353b:	eb 0c                	jmp    3549 <lodepng_gtofl+0x2f>
  return d > c;
    353d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3540:	3b 45 10             	cmp    0x10(%ebp),%eax
    3543:	0f 9f c0             	setg   %al
    3546:	0f b6 c0             	movzbl %al,%eax
}
    3549:	c9                   	leave  
    354a:	c3                   	ret    

0000354b <uivector_cleanup>:
  unsigned* data;
  size_t size; /*size in number of unsigned longs*/
  size_t allocsize; /*allocated size in bytes*/
} uivector;

static void uivector_cleanup(void* p) {
    354b:	55                   	push   %ebp
    354c:	89 e5                	mov    %esp,%ebp
    354e:	83 ec 08             	sub    $0x8,%esp
  ((uivector*)p)->size = ((uivector*)p)->allocsize = 0;
    3551:	8b 45 08             	mov    0x8(%ebp),%eax
    3554:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    355b:	8b 45 08             	mov    0x8(%ebp),%eax
    355e:	8b 50 08             	mov    0x8(%eax),%edx
    3561:	8b 45 08             	mov    0x8(%ebp),%eax
    3564:	89 50 04             	mov    %edx,0x4(%eax)
  lodepng_free(((uivector*)p)->data);
    3567:	8b 45 08             	mov    0x8(%ebp),%eax
    356a:	8b 00                	mov    (%eax),%eax
    356c:	83 ec 0c             	sub    $0xc,%esp
    356f:	50                   	push   %eax
    3570:	e8 af fe ff ff       	call   3424 <lodepng_free>
    3575:	83 c4 10             	add    $0x10,%esp
  ((uivector*)p)->data = NULL;
    3578:	8b 45 08             	mov    0x8(%ebp),%eax
    357b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
    3581:	90                   	nop
    3582:	c9                   	leave  
    3583:	c3                   	ret    

00003584 <uivector_resize>:

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned uivector_resize(uivector* p, size_t size) {
    3584:	55                   	push   %ebp
    3585:	89 e5                	mov    %esp,%ebp
    3587:	83 ec 10             	sub    $0x10,%esp
  size_t allocsize = size * sizeof(unsigned);
    358a:	8b 45 0c             	mov    0xc(%ebp),%eax
    358d:	c1 e0 02             	shl    $0x2,%eax
    3590:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if(allocsize > p->allocsize) {
    3593:	8b 45 08             	mov    0x8(%ebp),%eax
    3596:	8b 40 08             	mov    0x8(%eax),%eax
    3599:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    359c:	7d 46                	jge    35e4 <uivector_resize+0x60>
    size_t newsize = allocsize + (p->allocsize >> 1u);
    359e:	8b 45 08             	mov    0x8(%ebp),%eax
    35a1:	8b 40 08             	mov    0x8(%eax),%eax
    35a4:	d1 f8                	sar    %eax
    35a6:	89 c2                	mov    %eax,%edx
    35a8:	8b 45 fc             	mov    -0x4(%ebp),%eax
    35ab:	01 d0                	add    %edx,%eax
    35ad:	89 45 f8             	mov    %eax,-0x8(%ebp)
    void* data = lodepng_realloc(p->data, newsize);
    35b0:	8b 45 08             	mov    0x8(%ebp),%eax
    35b3:	8b 00                	mov    (%eax),%eax
    35b5:	ff 75 f8             	pushl  -0x8(%ebp)
    35b8:	50                   	push   %eax
    35b9:	e8 5c fe ff ff       	call   341a <lodepng_realloc>
    35be:	83 c4 08             	add    $0x8,%esp
    35c1:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(data) {
    35c4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    35c8:	74 13                	je     35dd <uivector_resize+0x59>
      p->allocsize = newsize;
    35ca:	8b 45 08             	mov    0x8(%ebp),%eax
    35cd:	8b 55 f8             	mov    -0x8(%ebp),%edx
    35d0:	89 50 08             	mov    %edx,0x8(%eax)
      p->data = (unsigned*)data;
    35d3:	8b 45 08             	mov    0x8(%ebp),%eax
    35d6:	8b 55 f4             	mov    -0xc(%ebp),%edx
    35d9:	89 10                	mov    %edx,(%eax)
    35db:	eb 07                	jmp    35e4 <uivector_resize+0x60>
    }
    else return 0; /*error: not enough memory*/
    35dd:	b8 00 00 00 00       	mov    $0x0,%eax
    35e2:	eb 0e                	jmp    35f2 <uivector_resize+0x6e>
  }
  p->size = size;
    35e4:	8b 45 08             	mov    0x8(%ebp),%eax
    35e7:	8b 55 0c             	mov    0xc(%ebp),%edx
    35ea:	89 50 04             	mov    %edx,0x4(%eax)
  return 1; /*success*/
    35ed:	b8 01 00 00 00       	mov    $0x1,%eax
}
    35f2:	c9                   	leave  
    35f3:	c3                   	ret    

000035f4 <uivector_init>:

static void uivector_init(uivector* p) {
    35f4:	55                   	push   %ebp
    35f5:	89 e5                	mov    %esp,%ebp
  p->data = NULL;
    35f7:	8b 45 08             	mov    0x8(%ebp),%eax
    35fa:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  p->size = p->allocsize = 0;
    3600:	8b 45 08             	mov    0x8(%ebp),%eax
    3603:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    360a:	8b 45 08             	mov    0x8(%ebp),%eax
    360d:	8b 50 08             	mov    0x8(%eax),%edx
    3610:	8b 45 08             	mov    0x8(%ebp),%eax
    3613:	89 50 04             	mov    %edx,0x4(%eax)
}
    3616:	90                   	nop
    3617:	5d                   	pop    %ebp
    3618:	c3                   	ret    

00003619 <uivector_push_back>:

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned uivector_push_back(uivector* p, unsigned c) {
    3619:	55                   	push   %ebp
    361a:	89 e5                	mov    %esp,%ebp
  if(!uivector_resize(p, p->size + 1)) return 0;
    361c:	8b 45 08             	mov    0x8(%ebp),%eax
    361f:	8b 40 04             	mov    0x4(%eax),%eax
    3622:	83 c0 01             	add    $0x1,%eax
    3625:	50                   	push   %eax
    3626:	ff 75 08             	pushl  0x8(%ebp)
    3629:	e8 56 ff ff ff       	call   3584 <uivector_resize>
    362e:	83 c4 08             	add    $0x8,%esp
    3631:	85 c0                	test   %eax,%eax
    3633:	75 07                	jne    363c <uivector_push_back+0x23>
    3635:	b8 00 00 00 00       	mov    $0x0,%eax
    363a:	eb 1f                	jmp    365b <uivector_push_back+0x42>
  p->data[p->size - 1] = c;
    363c:	8b 45 08             	mov    0x8(%ebp),%eax
    363f:	8b 10                	mov    (%eax),%edx
    3641:	8b 45 08             	mov    0x8(%ebp),%eax
    3644:	8b 40 04             	mov    0x4(%eax),%eax
    3647:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    364c:	c1 e0 02             	shl    $0x2,%eax
    364f:	01 c2                	add    %eax,%edx
    3651:	8b 45 0c             	mov    0xc(%ebp),%eax
    3654:	89 02                	mov    %eax,(%edx)
  return 1;
    3656:	b8 01 00 00 00       	mov    $0x1,%eax
}
    365b:	c9                   	leave  
    365c:	c3                   	ret    

0000365d <ucvector_resize>:
  size_t size; /*used size*/
  size_t allocsize; /*allocated size*/
} ucvector;

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned ucvector_resize(ucvector* p, size_t size) {
    365d:	55                   	push   %ebp
    365e:	89 e5                	mov    %esp,%ebp
    3660:	83 ec 10             	sub    $0x10,%esp
  if(size > p->allocsize) {
    3663:	8b 45 08             	mov    0x8(%ebp),%eax
    3666:	8b 40 08             	mov    0x8(%eax),%eax
    3669:	3b 45 0c             	cmp    0xc(%ebp),%eax
    366c:	7d 46                	jge    36b4 <ucvector_resize+0x57>
    size_t newsize = size + (p->allocsize >> 1u);
    366e:	8b 45 08             	mov    0x8(%ebp),%eax
    3671:	8b 40 08             	mov    0x8(%eax),%eax
    3674:	d1 f8                	sar    %eax
    3676:	89 c2                	mov    %eax,%edx
    3678:	8b 45 0c             	mov    0xc(%ebp),%eax
    367b:	01 d0                	add    %edx,%eax
    367d:	89 45 fc             	mov    %eax,-0x4(%ebp)
    void* data = lodepng_realloc(p->data, newsize);
    3680:	8b 45 08             	mov    0x8(%ebp),%eax
    3683:	8b 00                	mov    (%eax),%eax
    3685:	ff 75 fc             	pushl  -0x4(%ebp)
    3688:	50                   	push   %eax
    3689:	e8 8c fd ff ff       	call   341a <lodepng_realloc>
    368e:	83 c4 08             	add    $0x8,%esp
    3691:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(data) {
    3694:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    3698:	74 13                	je     36ad <ucvector_resize+0x50>
      p->allocsize = newsize;
    369a:	8b 45 08             	mov    0x8(%ebp),%eax
    369d:	8b 55 fc             	mov    -0x4(%ebp),%edx
    36a0:	89 50 08             	mov    %edx,0x8(%eax)
      p->data = (unsigned char*)data;
    36a3:	8b 45 08             	mov    0x8(%ebp),%eax
    36a6:	8b 55 f8             	mov    -0x8(%ebp),%edx
    36a9:	89 10                	mov    %edx,(%eax)
    36ab:	eb 07                	jmp    36b4 <ucvector_resize+0x57>
    }
    else return 0; /*error: not enough memory*/
    36ad:	b8 00 00 00 00       	mov    $0x0,%eax
    36b2:	eb 0e                	jmp    36c2 <ucvector_resize+0x65>
  }
  p->size = size;
    36b4:	8b 45 08             	mov    0x8(%ebp),%eax
    36b7:	8b 55 0c             	mov    0xc(%ebp),%edx
    36ba:	89 50 04             	mov    %edx,0x4(%eax)
  return 1; /*success*/
    36bd:	b8 01 00 00 00       	mov    $0x1,%eax
}
    36c2:	c9                   	leave  
    36c3:	c3                   	ret    

000036c4 <ucvector_init>:

static ucvector ucvector_init(unsigned char* buffer, size_t size) {
    36c4:	55                   	push   %ebp
    36c5:	89 e5                	mov    %esp,%ebp
    36c7:	83 ec 10             	sub    $0x10,%esp
  ucvector v;
  v.data = buffer;
    36ca:	8b 45 0c             	mov    0xc(%ebp),%eax
    36cd:	89 45 f4             	mov    %eax,-0xc(%ebp)
  v.allocsize = v.size = size;
    36d0:	8b 45 10             	mov    0x10(%ebp),%eax
    36d3:	89 45 f8             	mov    %eax,-0x8(%ebp)
    36d6:	8b 45 f8             	mov    -0x8(%ebp),%eax
    36d9:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return v;
    36dc:	8b 45 08             	mov    0x8(%ebp),%eax
    36df:	8b 55 f4             	mov    -0xc(%ebp),%edx
    36e2:	89 10                	mov    %edx,(%eax)
    36e4:	8b 55 f8             	mov    -0x8(%ebp),%edx
    36e7:	89 50 04             	mov    %edx,0x4(%eax)
    36ea:	8b 55 fc             	mov    -0x4(%ebp),%edx
    36ed:	89 50 08             	mov    %edx,0x8(%eax)
}
    36f0:	8b 45 08             	mov    0x8(%ebp),%eax
    36f3:	c9                   	leave  
    36f4:	c2 04 00             	ret    $0x4

000036f7 <string_cleanup>:

#ifdef LODEPNG_COMPILE_PNG
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

/*free string pointer and set it to NULL*/
static void string_cleanup(char** out) {
    36f7:	55                   	push   %ebp
    36f8:	89 e5                	mov    %esp,%ebp
    36fa:	83 ec 08             	sub    $0x8,%esp
  lodepng_free(*out);
    36fd:	8b 45 08             	mov    0x8(%ebp),%eax
    3700:	8b 00                	mov    (%eax),%eax
    3702:	83 ec 0c             	sub    $0xc,%esp
    3705:	50                   	push   %eax
    3706:	e8 19 fd ff ff       	call   3424 <lodepng_free>
    370b:	83 c4 10             	add    $0x10,%esp
  *out = NULL;
    370e:	8b 45 08             	mov    0x8(%ebp),%eax
    3711:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
    3717:	90                   	nop
    3718:	c9                   	leave  
    3719:	c3                   	ret    

0000371a <alloc_string_sized>:

/*also appends null termination character*/
static char* alloc_string_sized(const char* in, size_t insize) {
    371a:	55                   	push   %ebp
    371b:	89 e5                	mov    %esp,%ebp
    371d:	83 ec 18             	sub    $0x18,%esp
  char* out = (char*)lodepng_malloc(insize + 1);
    3720:	8b 45 0c             	mov    0xc(%ebp),%eax
    3723:	83 c0 01             	add    $0x1,%eax
    3726:	83 ec 0c             	sub    $0xc,%esp
    3729:	50                   	push   %eax
    372a:	e8 d4 fc ff ff       	call   3403 <lodepng_malloc>
    372f:	83 c4 10             	add    $0x10,%esp
    3732:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(out) {
    3735:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    3739:	74 1f                	je     375a <alloc_string_sized+0x40>
    lodepng_memcpy(out, in, insize);
    373b:	83 ec 04             	sub    $0x4,%esp
    373e:	ff 75 0c             	pushl  0xc(%ebp)
    3741:	ff 75 08             	pushl  0x8(%ebp)
    3744:	ff 75 f4             	pushl  -0xc(%ebp)
    3747:	e8 f5 fc ff ff       	call   3441 <lodepng_memcpy>
    374c:	83 c4 10             	add    $0x10,%esp
    out[insize] = 0;
    374f:	8b 55 0c             	mov    0xc(%ebp),%edx
    3752:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3755:	01 d0                	add    %edx,%eax
    3757:	c6 00 00             	movb   $0x0,(%eax)
  }
  return out;
    375a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    375d:	c9                   	leave  
    375e:	c3                   	ret    

0000375f <alloc_string>:

/* dynamically allocates a new string with a copy of the null terminated input text */
static char* alloc_string(const char* in) {
    375f:	55                   	push   %ebp
    3760:	89 e5                	mov    %esp,%ebp
    3762:	83 ec 08             	sub    $0x8,%esp
  return alloc_string_sized(in, lodepng_strlen(in));
    3765:	ff 75 08             	pushl  0x8(%ebp)
    3768:	e8 32 fd ff ff       	call   349f <lodepng_strlen>
    376d:	83 c4 04             	add    $0x4,%esp
    3770:	83 ec 08             	sub    $0x8,%esp
    3773:	50                   	push   %eax
    3774:	ff 75 08             	pushl  0x8(%ebp)
    3777:	e8 9e ff ff ff       	call   371a <alloc_string_sized>
    377c:	83 c4 10             	add    $0x10,%esp
}
    377f:	c9                   	leave  
    3780:	c3                   	ret    

00003781 <lodepng_read32bitInt>:
#endif /*LODEPNG_COMPILE_PNG*/

/* ////////////////////////////////////////////////////////////////////////// */

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)
static unsigned lodepng_read32bitInt(const unsigned char* buffer) {
    3781:	55                   	push   %ebp
    3782:	89 e5                	mov    %esp,%ebp
  return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |
    3784:	8b 45 08             	mov    0x8(%ebp),%eax
    3787:	0f b6 00             	movzbl (%eax),%eax
    378a:	0f b6 c0             	movzbl %al,%eax
    378d:	c1 e0 18             	shl    $0x18,%eax
    3790:	89 c2                	mov    %eax,%edx
    3792:	8b 45 08             	mov    0x8(%ebp),%eax
    3795:	83 c0 01             	add    $0x1,%eax
    3798:	0f b6 00             	movzbl (%eax),%eax
    379b:	0f b6 c0             	movzbl %al,%eax
    379e:	c1 e0 10             	shl    $0x10,%eax
    37a1:	09 c2                	or     %eax,%edx
         ((unsigned)buffer[2] << 8u) | (unsigned)buffer[3]);
    37a3:	8b 45 08             	mov    0x8(%ebp),%eax
    37a6:	83 c0 02             	add    $0x2,%eax
    37a9:	0f b6 00             	movzbl (%eax),%eax
    37ac:	0f b6 c0             	movzbl %al,%eax
    37af:	c1 e0 08             	shl    $0x8,%eax

/* ////////////////////////////////////////////////////////////////////////// */

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)
static unsigned lodepng_read32bitInt(const unsigned char* buffer) {
  return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |
    37b2:	09 c2                	or     %eax,%edx
         ((unsigned)buffer[2] << 8u) | (unsigned)buffer[3]);
    37b4:	8b 45 08             	mov    0x8(%ebp),%eax
    37b7:	83 c0 03             	add    $0x3,%eax
    37ba:	0f b6 00             	movzbl (%eax),%eax
    37bd:	0f b6 c0             	movzbl %al,%eax

/* ////////////////////////////////////////////////////////////////////////// */

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)
static unsigned lodepng_read32bitInt(const unsigned char* buffer) {
  return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |
    37c0:	09 d0                	or     %edx,%eax
         ((unsigned)buffer[2] << 8u) | (unsigned)buffer[3]);
}
    37c2:	5d                   	pop    %ebp
    37c3:	c3                   	ret    

000037c4 <lodepng_set32bitInt>:
#endif /*defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)*/

#if defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_ENCODER)
/*buffer must have at least 4 allocated bytes available*/
static void lodepng_set32bitInt(unsigned char* buffer, unsigned value) {
    37c4:	55                   	push   %ebp
    37c5:	89 e5                	mov    %esp,%ebp
  buffer[0] = (unsigned char)((value >> 24) & 0xff);
    37c7:	8b 45 0c             	mov    0xc(%ebp),%eax
    37ca:	c1 e8 18             	shr    $0x18,%eax
    37cd:	89 c2                	mov    %eax,%edx
    37cf:	8b 45 08             	mov    0x8(%ebp),%eax
    37d2:	88 10                	mov    %dl,(%eax)
  buffer[1] = (unsigned char)((value >> 16) & 0xff);
    37d4:	8b 45 08             	mov    0x8(%ebp),%eax
    37d7:	83 c0 01             	add    $0x1,%eax
    37da:	8b 55 0c             	mov    0xc(%ebp),%edx
    37dd:	c1 ea 10             	shr    $0x10,%edx
    37e0:	88 10                	mov    %dl,(%eax)
  buffer[2] = (unsigned char)((value >>  8) & 0xff);
    37e2:	8b 45 08             	mov    0x8(%ebp),%eax
    37e5:	83 c0 02             	add    $0x2,%eax
    37e8:	8b 55 0c             	mov    0xc(%ebp),%edx
    37eb:	c1 ea 08             	shr    $0x8,%edx
    37ee:	88 10                	mov    %dl,(%eax)
  buffer[3] = (unsigned char)((value      ) & 0xff);
    37f0:	8b 45 08             	mov    0x8(%ebp),%eax
    37f3:	83 c0 03             	add    $0x3,%eax
    37f6:	8b 55 0c             	mov    0xc(%ebp),%edx
    37f9:	88 10                	mov    %dl,(%eax)
}
    37fb:	90                   	nop
    37fc:	5d                   	pop    %ebp
    37fd:	c3                   	ret    

000037fe <lodepng_filesize>:
/* ////////////////////////////////////////////////////////////////////////// */

#ifdef LODEPNG_COMPILE_DISK

/* returns negative value on error. This should be pure C compatible, so no fstat. */
static long lodepng_filesize(const char* filename) {
    37fe:	55                   	push   %ebp
    37ff:	89 e5                	mov    %esp,%ebp
    3801:	83 ec 28             	sub    $0x28,%esp
  // if(size == LONG_MAX) size = -1;

  // fclose(file);
  // return size;
  struct stat s;
  stat(filename, &s);
    3804:	83 ec 08             	sub    $0x8,%esp
    3807:	8d 45 e4             	lea    -0x1c(%ebp),%eax
    380a:	50                   	push   %eax
    380b:	ff 75 08             	pushl  0x8(%ebp)
    380e:	e8 b7 ca ff ff       	call   2ca <stat>
    3813:	83 c4 10             	add    $0x10,%esp
  return s.size;
    3816:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    3819:	c9                   	leave  
    381a:	c3                   	ret    

0000381b <lodepng_buffer_file>:

/* load file into buffer that already has the correct allocated size. Returns error code.*/
static unsigned lodepng_buffer_file(unsigned char* out, size_t size, const char* filename) {
    381b:	55                   	push   %ebp
    381c:	89 e5                	mov    %esp,%ebp
    381e:	83 ec 18             	sub    $0x18,%esp
  // readsize = fread(out, 1, size, file);
  // fclose(file);

  // if(readsize != size) return 78;
  // return 0;
  int file = open(filename,  O_RDONLY);
    3821:	83 ec 08             	sub    $0x8,%esp
    3824:	6a 00                	push   $0x0
    3826:	ff 75 10             	pushl  0x10(%ebp)
    3829:	e8 bb cb ff ff       	call   3e9 <open>
    382e:	83 c4 10             	add    $0x10,%esp
    3831:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (file<0)
    3834:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    3838:	79 07                	jns    3841 <lodepng_buffer_file+0x26>
  {
      return -1;
    383a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    383f:	eb 19                	jmp    385a <lodepng_buffer_file+0x3f>
  }
  read(file, out, size);
    3841:	83 ec 04             	sub    $0x4,%esp
    3844:	ff 75 0c             	pushl  0xc(%ebp)
    3847:	ff 75 08             	pushl  0x8(%ebp)
    384a:	ff 75 f4             	pushl  -0xc(%ebp)
    384d:	e8 6f cb ff ff       	call   3c1 <read>
    3852:	83 c4 10             	add    $0x10,%esp
  return 0;
    3855:	b8 00 00 00 00       	mov    $0x0,%eax
}
    385a:	c9                   	leave  
    385b:	c3                   	ret    

0000385c <lodepng_load_file>:

unsigned lodepng_load_file(unsigned char** out, size_t* outsize, const char* filename) {
    385c:	55                   	push   %ebp
    385d:	89 e5                	mov    %esp,%ebp
    385f:	83 ec 18             	sub    $0x18,%esp
  long size = lodepng_filesize(filename);
    3862:	83 ec 0c             	sub    $0xc,%esp
    3865:	ff 75 10             	pushl  0x10(%ebp)
    3868:	e8 91 ff ff ff       	call   37fe <lodepng_filesize>
    386d:	83 c4 10             	add    $0x10,%esp
    3870:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(size < 0) return 78;
    3873:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    3877:	79 07                	jns    3880 <lodepng_load_file+0x24>
    3879:	b8 4e 00 00 00       	mov    $0x4e,%eax
    387e:	eb 4a                	jmp    38ca <lodepng_load_file+0x6e>
  *outsize = (size_t)size;
    3880:	8b 45 0c             	mov    0xc(%ebp),%eax
    3883:	8b 55 f4             	mov    -0xc(%ebp),%edx
    3886:	89 10                	mov    %edx,(%eax)

  *out = (unsigned char*)lodepng_malloc((size_t)size);
    3888:	83 ec 0c             	sub    $0xc,%esp
    388b:	ff 75 f4             	pushl  -0xc(%ebp)
    388e:	e8 70 fb ff ff       	call   3403 <lodepng_malloc>
    3893:	83 c4 10             	add    $0x10,%esp
    3896:	89 c2                	mov    %eax,%edx
    3898:	8b 45 08             	mov    0x8(%ebp),%eax
    389b:	89 10                	mov    %edx,(%eax)
  if(!(*out) && size > 0) return 83; /*the above malloc failed*/
    389d:	8b 45 08             	mov    0x8(%ebp),%eax
    38a0:	8b 00                	mov    (%eax),%eax
    38a2:	85 c0                	test   %eax,%eax
    38a4:	75 0d                	jne    38b3 <lodepng_load_file+0x57>
    38a6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    38aa:	7e 07                	jle    38b3 <lodepng_load_file+0x57>
    38ac:	b8 53 00 00 00       	mov    $0x53,%eax
    38b1:	eb 17                	jmp    38ca <lodepng_load_file+0x6e>

  return lodepng_buffer_file(*out, (size_t)size, filename);
    38b3:	8b 45 08             	mov    0x8(%ebp),%eax
    38b6:	8b 00                	mov    (%eax),%eax
    38b8:	83 ec 04             	sub    $0x4,%esp
    38bb:	ff 75 10             	pushl  0x10(%ebp)
    38be:	ff 75 f4             	pushl  -0xc(%ebp)
    38c1:	50                   	push   %eax
    38c2:	e8 54 ff ff ff       	call   381b <lodepng_buffer_file>
    38c7:	83 c4 10             	add    $0x10,%esp
}
    38ca:	c9                   	leave  
    38cb:	c3                   	ret    

000038cc <lodepng_save_file>:

/*write given buffer to the file, overwriting the file, it doesn't append to it.*/
unsigned lodepng_save_file(const unsigned char* buffer, size_t buffersize, const char* filename) {
    38cc:	55                   	push   %ebp
    38cd:	89 e5                	mov    %esp,%ebp
  // file = fopen(filename, "wb" );
  // if(!file) return 79;
  // fwrite(buffer, 1, buffersize, file);
  // fclose(file);
  // return 0;
  return -1;
    38cf:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
    38d4:	5d                   	pop    %ebp
    38d5:	c3                   	ret    

000038d6 <LodePNGBitWriter_init>:
typedef struct {
  ucvector* data;
  unsigned char bp; /*ok to overflow, indicates bit pos inside byte*/
} LodePNGBitWriter;

static void LodePNGBitWriter_init(LodePNGBitWriter* writer, ucvector* data) {
    38d6:	55                   	push   %ebp
    38d7:	89 e5                	mov    %esp,%ebp
  writer->data = data;
    38d9:	8b 45 08             	mov    0x8(%ebp),%eax
    38dc:	8b 55 0c             	mov    0xc(%ebp),%edx
    38df:	89 10                	mov    %edx,(%eax)
  writer->bp = 0;
    38e1:	8b 45 08             	mov    0x8(%ebp),%eax
    38e4:	c6 40 04 00          	movb   $0x0,0x4(%eax)
}
    38e8:	90                   	nop
    38e9:	5d                   	pop    %ebp
    38ea:	c3                   	ret    

000038eb <writeBits>:
  (writer->data->data[writer->data->size - 1]) |= (bit << ((writer->bp) & 7u));\
  ++writer->bp;\
}

/* LSB of value is written first, and LSB of bytes is used first */
static void writeBits(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
    38eb:	55                   	push   %ebp
    38ec:	89 e5                	mov    %esp,%ebp
    38ee:	56                   	push   %esi
    38ef:	53                   	push   %ebx
    38f0:	83 ec 14             	sub    $0x14,%esp
  if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */
    38f3:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    38f7:	0f 85 aa 00 00 00    	jne    39a7 <writeBits+0xbc>
    WRITEBIT(writer, value);
    38fd:	8b 45 08             	mov    0x8(%ebp),%eax
    3900:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3904:	0f b6 c0             	movzbl %al,%eax
    3907:	83 e0 07             	and    $0x7,%eax
    390a:	85 c0                	test   %eax,%eax
    390c:	75 39                	jne    3947 <writeBits+0x5c>
    390e:	8b 45 08             	mov    0x8(%ebp),%eax
    3911:	8b 00                	mov    (%eax),%eax
    3913:	8b 40 04             	mov    0x4(%eax),%eax
    3916:	8d 50 01             	lea    0x1(%eax),%edx
    3919:	8b 45 08             	mov    0x8(%ebp),%eax
    391c:	8b 00                	mov    (%eax),%eax
    391e:	52                   	push   %edx
    391f:	50                   	push   %eax
    3920:	e8 38 fd ff ff       	call   365d <ucvector_resize>
    3925:	83 c4 08             	add    $0x8,%esp
    3928:	85 c0                	test   %eax,%eax
    392a:	0f 84 44 01 00 00    	je     3a74 <writeBits+0x189>
    3930:	8b 45 08             	mov    0x8(%ebp),%eax
    3933:	8b 00                	mov    (%eax),%eax
    3935:	8b 10                	mov    (%eax),%edx
    3937:	8b 45 08             	mov    0x8(%ebp),%eax
    393a:	8b 00                	mov    (%eax),%eax
    393c:	8b 40 04             	mov    0x4(%eax),%eax
    393f:	83 e8 01             	sub    $0x1,%eax
    3942:	01 d0                	add    %edx,%eax
    3944:	c6 00 00             	movb   $0x0,(%eax)
    3947:	8b 45 08             	mov    0x8(%ebp),%eax
    394a:	8b 00                	mov    (%eax),%eax
    394c:	8b 10                	mov    (%eax),%edx
    394e:	8b 45 08             	mov    0x8(%ebp),%eax
    3951:	8b 00                	mov    (%eax),%eax
    3953:	8b 40 04             	mov    0x4(%eax),%eax
    3956:	83 e8 01             	sub    $0x1,%eax
    3959:	01 c2                	add    %eax,%edx
    395b:	8b 45 08             	mov    0x8(%ebp),%eax
    395e:	8b 00                	mov    (%eax),%eax
    3960:	8b 08                	mov    (%eax),%ecx
    3962:	8b 45 08             	mov    0x8(%ebp),%eax
    3965:	8b 00                	mov    (%eax),%eax
    3967:	8b 40 04             	mov    0x4(%eax),%eax
    396a:	83 e8 01             	sub    $0x1,%eax
    396d:	01 c8                	add    %ecx,%eax
    396f:	0f b6 00             	movzbl (%eax),%eax
    3972:	88 45 e7             	mov    %al,-0x19(%ebp)
    3975:	8b 45 08             	mov    0x8(%ebp),%eax
    3978:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    397c:	0f b6 c0             	movzbl %al,%eax
    397f:	83 e0 07             	and    $0x7,%eax
    3982:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    3985:	89 de                	mov    %ebx,%esi
    3987:	89 c1                	mov    %eax,%ecx
    3989:	d3 e6                	shl    %cl,%esi
    398b:	89 f0                	mov    %esi,%eax
    398d:	0a 45 e7             	or     -0x19(%ebp),%al
    3990:	88 02                	mov    %al,(%edx)
    3992:	8b 45 08             	mov    0x8(%ebp),%eax
    3995:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3999:	8d 50 01             	lea    0x1(%eax),%edx
    399c:	8b 45 08             	mov    0x8(%ebp),%eax
    399f:	88 50 04             	mov    %dl,0x4(%eax)
    39a2:	e9 d1 00 00 00       	jmp    3a78 <writeBits+0x18d>
  } else {
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    size_t i;
    for(i = 0; i != nbits; ++i) {
    39a7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    39ae:	e9 b3 00 00 00       	jmp    3a66 <writeBits+0x17b>
      WRITEBIT(writer, (unsigned char)((value >> i) & 1));
    39b3:	8b 45 08             	mov    0x8(%ebp),%eax
    39b6:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    39ba:	0f b6 c0             	movzbl %al,%eax
    39bd:	83 e0 07             	and    $0x7,%eax
    39c0:	85 c0                	test   %eax,%eax
    39c2:	75 39                	jne    39fd <writeBits+0x112>
    39c4:	8b 45 08             	mov    0x8(%ebp),%eax
    39c7:	8b 00                	mov    (%eax),%eax
    39c9:	8b 40 04             	mov    0x4(%eax),%eax
    39cc:	8d 50 01             	lea    0x1(%eax),%edx
    39cf:	8b 45 08             	mov    0x8(%ebp),%eax
    39d2:	8b 00                	mov    (%eax),%eax
    39d4:	52                   	push   %edx
    39d5:	50                   	push   %eax
    39d6:	e8 82 fc ff ff       	call   365d <ucvector_resize>
    39db:	83 c4 08             	add    $0x8,%esp
    39de:	85 c0                	test   %eax,%eax
    39e0:	0f 84 91 00 00 00    	je     3a77 <writeBits+0x18c>
    39e6:	8b 45 08             	mov    0x8(%ebp),%eax
    39e9:	8b 00                	mov    (%eax),%eax
    39eb:	8b 10                	mov    (%eax),%edx
    39ed:	8b 45 08             	mov    0x8(%ebp),%eax
    39f0:	8b 00                	mov    (%eax),%eax
    39f2:	8b 40 04             	mov    0x4(%eax),%eax
    39f5:	83 e8 01             	sub    $0x1,%eax
    39f8:	01 d0                	add    %edx,%eax
    39fa:	c6 00 00             	movb   $0x0,(%eax)
    39fd:	8b 45 08             	mov    0x8(%ebp),%eax
    3a00:	8b 00                	mov    (%eax),%eax
    3a02:	8b 10                	mov    (%eax),%edx
    3a04:	8b 45 08             	mov    0x8(%ebp),%eax
    3a07:	8b 00                	mov    (%eax),%eax
    3a09:	8b 40 04             	mov    0x4(%eax),%eax
    3a0c:	83 e8 01             	sub    $0x1,%eax
    3a0f:	01 c2                	add    %eax,%edx
    3a11:	8b 45 08             	mov    0x8(%ebp),%eax
    3a14:	8b 00                	mov    (%eax),%eax
    3a16:	8b 08                	mov    (%eax),%ecx
    3a18:	8b 45 08             	mov    0x8(%ebp),%eax
    3a1b:	8b 00                	mov    (%eax),%eax
    3a1d:	8b 40 04             	mov    0x4(%eax),%eax
    3a20:	83 e8 01             	sub    $0x1,%eax
    3a23:	01 c8                	add    %ecx,%eax
    3a25:	0f b6 00             	movzbl (%eax),%eax
    3a28:	89 c6                	mov    %eax,%esi
    3a2a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3a2d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    3a30:	89 c1                	mov    %eax,%ecx
    3a32:	d3 eb                	shr    %cl,%ebx
    3a34:	89 d8                	mov    %ebx,%eax
    3a36:	83 e0 01             	and    $0x1,%eax
    3a39:	89 c3                	mov    %eax,%ebx
    3a3b:	8b 45 08             	mov    0x8(%ebp),%eax
    3a3e:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3a42:	0f b6 c0             	movzbl %al,%eax
    3a45:	83 e0 07             	and    $0x7,%eax
    3a48:	89 c1                	mov    %eax,%ecx
    3a4a:	d3 e3                	shl    %cl,%ebx
    3a4c:	89 d8                	mov    %ebx,%eax
    3a4e:	09 f0                	or     %esi,%eax
    3a50:	88 02                	mov    %al,(%edx)
    3a52:	8b 45 08             	mov    0x8(%ebp),%eax
    3a55:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3a59:	8d 50 01             	lea    0x1(%eax),%edx
    3a5c:	8b 45 08             	mov    0x8(%ebp),%eax
    3a5f:	88 50 04             	mov    %dl,0x4(%eax)
  if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */
    WRITEBIT(writer, value);
  } else {
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    size_t i;
    for(i = 0; i != nbits; ++i) {
    3a62:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    3a66:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3a69:	3b 45 10             	cmp    0x10(%ebp),%eax
    3a6c:	0f 85 41 ff ff ff    	jne    39b3 <writeBits+0xc8>
    3a72:	eb 04                	jmp    3a78 <writeBits+0x18d>
}

/* LSB of value is written first, and LSB of bytes is used first */
static void writeBits(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
  if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */
    WRITEBIT(writer, value);
    3a74:	90                   	nop
    3a75:	eb 01                	jmp    3a78 <writeBits+0x18d>
  } else {
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    size_t i;
    for(i = 0; i != nbits; ++i) {
      WRITEBIT(writer, (unsigned char)((value >> i) & 1));
    3a77:	90                   	nop
    }
  }
}
    3a78:	8d 65 f8             	lea    -0x8(%ebp),%esp
    3a7b:	5b                   	pop    %ebx
    3a7c:	5e                   	pop    %esi
    3a7d:	5d                   	pop    %ebp
    3a7e:	c3                   	ret    

00003a7f <writeBitsReversed>:

/* This one is to use for adding huffman symbol, the value bits are written MSB first */
static void writeBitsReversed(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
    3a7f:	55                   	push   %ebp
    3a80:	89 e5                	mov    %esp,%ebp
    3a82:	56                   	push   %esi
    3a83:	53                   	push   %ebx
    3a84:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i != nbits; ++i) {
    3a87:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    3a8e:	e9 bd 00 00 00       	jmp    3b50 <writeBitsReversed+0xd1>
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    WRITEBIT(writer, (unsigned char)((value >> (nbits - 1u - i)) & 1u));
    3a93:	8b 45 08             	mov    0x8(%ebp),%eax
    3a96:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3a9a:	0f b6 c0             	movzbl %al,%eax
    3a9d:	83 e0 07             	and    $0x7,%eax
    3aa0:	85 c0                	test   %eax,%eax
    3aa2:	75 39                	jne    3add <writeBitsReversed+0x5e>
    3aa4:	8b 45 08             	mov    0x8(%ebp),%eax
    3aa7:	8b 00                	mov    (%eax),%eax
    3aa9:	8b 40 04             	mov    0x4(%eax),%eax
    3aac:	8d 50 01             	lea    0x1(%eax),%edx
    3aaf:	8b 45 08             	mov    0x8(%ebp),%eax
    3ab2:	8b 00                	mov    (%eax),%eax
    3ab4:	52                   	push   %edx
    3ab5:	50                   	push   %eax
    3ab6:	e8 a2 fb ff ff       	call   365d <ucvector_resize>
    3abb:	83 c4 08             	add    $0x8,%esp
    3abe:	85 c0                	test   %eax,%eax
    3ac0:	0f 84 98 00 00 00    	je     3b5e <writeBitsReversed+0xdf>
    3ac6:	8b 45 08             	mov    0x8(%ebp),%eax
    3ac9:	8b 00                	mov    (%eax),%eax
    3acb:	8b 10                	mov    (%eax),%edx
    3acd:	8b 45 08             	mov    0x8(%ebp),%eax
    3ad0:	8b 00                	mov    (%eax),%eax
    3ad2:	8b 40 04             	mov    0x4(%eax),%eax
    3ad5:	83 e8 01             	sub    $0x1,%eax
    3ad8:	01 d0                	add    %edx,%eax
    3ada:	c6 00 00             	movb   $0x0,(%eax)
    3add:	8b 45 08             	mov    0x8(%ebp),%eax
    3ae0:	8b 00                	mov    (%eax),%eax
    3ae2:	8b 10                	mov    (%eax),%edx
    3ae4:	8b 45 08             	mov    0x8(%ebp),%eax
    3ae7:	8b 00                	mov    (%eax),%eax
    3ae9:	8b 40 04             	mov    0x4(%eax),%eax
    3aec:	83 e8 01             	sub    $0x1,%eax
    3aef:	01 c2                	add    %eax,%edx
    3af1:	8b 45 08             	mov    0x8(%ebp),%eax
    3af4:	8b 00                	mov    (%eax),%eax
    3af6:	8b 08                	mov    (%eax),%ecx
    3af8:	8b 45 08             	mov    0x8(%ebp),%eax
    3afb:	8b 00                	mov    (%eax),%eax
    3afd:	8b 40 04             	mov    0x4(%eax),%eax
    3b00:	83 e8 01             	sub    $0x1,%eax
    3b03:	01 c8                	add    %ecx,%eax
    3b05:	0f b6 00             	movzbl (%eax),%eax
    3b08:	89 c6                	mov    %eax,%esi
    3b0a:	8b 4d 10             	mov    0x10(%ebp),%ecx
    3b0d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3b10:	29 c1                	sub    %eax,%ecx
    3b12:	89 c8                	mov    %ecx,%eax
    3b14:	83 e8 01             	sub    $0x1,%eax
    3b17:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    3b1a:	89 c1                	mov    %eax,%ecx
    3b1c:	d3 eb                	shr    %cl,%ebx
    3b1e:	89 d8                	mov    %ebx,%eax
    3b20:	83 e0 01             	and    $0x1,%eax
    3b23:	89 c3                	mov    %eax,%ebx
    3b25:	8b 45 08             	mov    0x8(%ebp),%eax
    3b28:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3b2c:	0f b6 c0             	movzbl %al,%eax
    3b2f:	83 e0 07             	and    $0x7,%eax
    3b32:	89 c1                	mov    %eax,%ecx
    3b34:	d3 e3                	shl    %cl,%ebx
    3b36:	89 d8                	mov    %ebx,%eax
    3b38:	09 f0                	or     %esi,%eax
    3b3a:	88 02                	mov    %al,(%edx)
    3b3c:	8b 45 08             	mov    0x8(%ebp),%eax
    3b3f:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3b43:	8d 50 01             	lea    0x1(%eax),%edx
    3b46:	8b 45 08             	mov    0x8(%ebp),%eax
    3b49:	88 50 04             	mov    %dl,0x4(%eax)
}

/* This one is to use for adding huffman symbol, the value bits are written MSB first */
static void writeBitsReversed(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
  size_t i;
  for(i = 0; i != nbits; ++i) {
    3b4c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    3b50:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3b53:	3b 45 10             	cmp    0x10(%ebp),%eax
    3b56:	0f 85 37 ff ff ff    	jne    3a93 <writeBitsReversed+0x14>
    3b5c:	eb 01                	jmp    3b5f <writeBitsReversed+0xe0>
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    WRITEBIT(writer, (unsigned char)((value >> (nbits - 1u - i)) & 1u));
    3b5e:	90                   	nop
  }
}
    3b5f:	8d 65 f8             	lea    -0x8(%ebp),%esp
    3b62:	5b                   	pop    %ebx
    3b63:	5e                   	pop    %esi
    3b64:	5d                   	pop    %ebp
    3b65:	c3                   	ret    

00003b66 <LodePNGBitReader_init>:
  size_t bp;
  unsigned buffer; /*buffer for reading bits. NOTE: 'unsigned' must support at least 32 bits*/
} LodePNGBitReader;

/* data size argument is in bytes. Returns error if size too large causing overflow */
static unsigned LodePNGBitReader_init(LodePNGBitReader* reader, const unsigned char* data, size_t size) {
    3b66:	55                   	push   %ebp
    3b67:	89 e5                	mov    %esp,%ebp
    3b69:	83 ec 10             	sub    $0x10,%esp
  size_t temp;
  reader->data = data;
    3b6c:	8b 45 08             	mov    0x8(%ebp),%eax
    3b6f:	8b 55 0c             	mov    0xc(%ebp),%edx
    3b72:	89 10                	mov    %edx,(%eax)
  reader->size = size;
    3b74:	8b 45 08             	mov    0x8(%ebp),%eax
    3b77:	8b 55 10             	mov    0x10(%ebp),%edx
    3b7a:	89 50 04             	mov    %edx,0x4(%eax)
  /* size in bits, return error if overflow (if size_t is 32 bit this supports up to 500MB)  */
  if(lodepng_mulofl(size, 8u, &reader->bitsize)) return 105;
    3b7d:	8b 45 08             	mov    0x8(%ebp),%eax
    3b80:	83 c0 08             	add    $0x8,%eax
    3b83:	50                   	push   %eax
    3b84:	6a 08                	push   $0x8
    3b86:	ff 75 10             	pushl  0x10(%ebp)
    3b89:	e8 59 f9 ff ff       	call   34e7 <lodepng_mulofl>
    3b8e:	83 c4 0c             	add    $0xc,%esp
    3b91:	85 c0                	test   %eax,%eax
    3b93:	74 07                	je     3b9c <LodePNGBitReader_init+0x36>
    3b95:	b8 69 00 00 00       	mov    $0x69,%eax
    3b9a:	eb 39                	jmp    3bd5 <LodePNGBitReader_init+0x6f>
  /*ensure incremented bp can be compared to bitsize without overflow even when it would be incremented 32 too much and
  trying to ensure 32 more bits*/
  if(lodepng_addofl(reader->bitsize, 64u, &temp)) return 105;
    3b9c:	8b 45 08             	mov    0x8(%ebp),%eax
    3b9f:	8b 40 08             	mov    0x8(%eax),%eax
    3ba2:	8d 55 fc             	lea    -0x4(%ebp),%edx
    3ba5:	52                   	push   %edx
    3ba6:	6a 40                	push   $0x40
    3ba8:	50                   	push   %eax
    3ba9:	e8 19 f9 ff ff       	call   34c7 <lodepng_addofl>
    3bae:	83 c4 0c             	add    $0xc,%esp
    3bb1:	85 c0                	test   %eax,%eax
    3bb3:	74 07                	je     3bbc <LodePNGBitReader_init+0x56>
    3bb5:	b8 69 00 00 00       	mov    $0x69,%eax
    3bba:	eb 19                	jmp    3bd5 <LodePNGBitReader_init+0x6f>
  reader->bp = 0;
    3bbc:	8b 45 08             	mov    0x8(%ebp),%eax
    3bbf:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  reader->buffer = 0;
    3bc6:	8b 45 08             	mov    0x8(%ebp),%eax
    3bc9:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  return 0; /*ok*/
    3bd0:	b8 00 00 00 00       	mov    $0x0,%eax
}
    3bd5:	c9                   	leave  
    3bd6:	c3                   	ret    

00003bd7 <ensureBits9>:
  reader->buffer = (unsigned)reader->data[reader->bp >> 3u] >> (reader->bp & 7u);
  return 1;
}*/

/*See ensureBits documentation above. This one ensures up to 9 bits */
static unsigned ensureBits9(LodePNGBitReader* reader, size_t nbits) {
    3bd7:	55                   	push   %ebp
    3bd8:	89 e5                	mov    %esp,%ebp
    3bda:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    3bdd:	8b 45 08             	mov    0x8(%ebp),%eax
    3be0:	8b 40 0c             	mov    0xc(%eax),%eax
    3be3:	c1 f8 03             	sar    $0x3,%eax
    3be6:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t size = reader->size;
    3be9:	8b 45 08             	mov    0x8(%ebp),%eax
    3bec:	8b 40 04             	mov    0x4(%eax),%eax
    3bef:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(start + 1u < size) {
    3bf2:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3bf5:	8d 50 01             	lea    0x1(%eax),%edx
    3bf8:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3bfb:	39 c2                	cmp    %eax,%edx
    3bfd:	73 4e                	jae    3c4d <ensureBits9+0x76>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u);
    3bff:	8b 45 08             	mov    0x8(%ebp),%eax
    3c02:	8b 10                	mov    (%eax),%edx
    3c04:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3c07:	01 d0                	add    %edx,%eax
    3c09:	0f b6 00             	movzbl (%eax),%eax
    3c0c:	0f b6 d0             	movzbl %al,%edx
    3c0f:	8b 45 08             	mov    0x8(%ebp),%eax
    3c12:	8b 00                	mov    (%eax),%eax
    3c14:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3c17:	83 c1 01             	add    $0x1,%ecx
    3c1a:	01 c8                	add    %ecx,%eax
    3c1c:	0f b6 00             	movzbl (%eax),%eax
    3c1f:	0f b6 c0             	movzbl %al,%eax
    3c22:	c1 e0 08             	shl    $0x8,%eax
    3c25:	09 c2                	or     %eax,%edx
    3c27:	8b 45 08             	mov    0x8(%ebp),%eax
    3c2a:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    3c2d:	8b 45 08             	mov    0x8(%ebp),%eax
    3c30:	8b 50 10             	mov    0x10(%eax),%edx
    3c33:	8b 45 08             	mov    0x8(%ebp),%eax
    3c36:	8b 40 0c             	mov    0xc(%eax),%eax
    3c39:	83 e0 07             	and    $0x7,%eax
    3c3c:	89 c1                	mov    %eax,%ecx
    3c3e:	d3 ea                	shr    %cl,%edx
    3c40:	8b 45 08             	mov    0x8(%ebp),%eax
    3c43:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    3c46:	b8 01 00 00 00       	mov    $0x1,%eax
    3c4b:	eb 64                	jmp    3cb1 <ensureBits9+0xda>
  } else {
    reader->buffer = 0;
    3c4d:	8b 45 08             	mov    0x8(%ebp),%eax
    3c50:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    3c57:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3c5a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3c5d:	39 c2                	cmp    %eax,%edx
    3c5f:	73 1e                	jae    3c7f <ensureBits9+0xa8>
    3c61:	8b 45 08             	mov    0x8(%ebp),%eax
    3c64:	8b 50 10             	mov    0x10(%eax),%edx
    3c67:	8b 45 08             	mov    0x8(%ebp),%eax
    3c6a:	8b 08                	mov    (%eax),%ecx
    3c6c:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3c6f:	01 c8                	add    %ecx,%eax
    3c71:	0f b6 00             	movzbl (%eax),%eax
    3c74:	0f b6 c0             	movzbl %al,%eax
    3c77:	09 c2                	or     %eax,%edx
    3c79:	8b 45 08             	mov    0x8(%ebp),%eax
    3c7c:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    3c7f:	8b 45 08             	mov    0x8(%ebp),%eax
    3c82:	8b 50 10             	mov    0x10(%eax),%edx
    3c85:	8b 45 08             	mov    0x8(%ebp),%eax
    3c88:	8b 40 0c             	mov    0xc(%eax),%eax
    3c8b:	83 e0 07             	and    $0x7,%eax
    3c8e:	89 c1                	mov    %eax,%ecx
    3c90:	d3 ea                	shr    %cl,%edx
    3c92:	8b 45 08             	mov    0x8(%ebp),%eax
    3c95:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    3c98:	8b 45 08             	mov    0x8(%ebp),%eax
    3c9b:	8b 50 0c             	mov    0xc(%eax),%edx
    3c9e:	8b 45 0c             	mov    0xc(%ebp),%eax
    3ca1:	01 c2                	add    %eax,%edx
    3ca3:	8b 45 08             	mov    0x8(%ebp),%eax
    3ca6:	8b 40 08             	mov    0x8(%eax),%eax
    3ca9:	39 c2                	cmp    %eax,%edx
    3cab:	0f 9e c0             	setle  %al
    3cae:	0f b6 c0             	movzbl %al,%eax
  }
}
    3cb1:	c9                   	leave  
    3cb2:	c3                   	ret    

00003cb3 <ensureBits17>:

/*See ensureBits documentation above. This one ensures up to 17 bits */
static unsigned ensureBits17(LodePNGBitReader* reader, size_t nbits) {
    3cb3:	55                   	push   %ebp
    3cb4:	89 e5                	mov    %esp,%ebp
    3cb6:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    3cb9:	8b 45 08             	mov    0x8(%ebp),%eax
    3cbc:	8b 40 0c             	mov    0xc(%eax),%eax
    3cbf:	c1 f8 03             	sar    $0x3,%eax
    3cc2:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t size = reader->size;
    3cc5:	8b 45 08             	mov    0x8(%ebp),%eax
    3cc8:	8b 40 04             	mov    0x4(%eax),%eax
    3ccb:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(start + 2u < size) {
    3cce:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3cd1:	8d 50 02             	lea    0x2(%eax),%edx
    3cd4:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3cd7:	39 c2                	cmp    %eax,%edx
    3cd9:	73 6d                	jae    3d48 <ensureBits17+0x95>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3cdb:	8b 45 08             	mov    0x8(%ebp),%eax
    3cde:	8b 10                	mov    (%eax),%edx
    3ce0:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3ce3:	01 d0                	add    %edx,%eax
    3ce5:	0f b6 00             	movzbl (%eax),%eax
    3ce8:	0f b6 d0             	movzbl %al,%edx
    3ceb:	8b 45 08             	mov    0x8(%ebp),%eax
    3cee:	8b 00                	mov    (%eax),%eax
    3cf0:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3cf3:	83 c1 01             	add    $0x1,%ecx
    3cf6:	01 c8                	add    %ecx,%eax
    3cf8:	0f b6 00             	movzbl (%eax),%eax
    3cfb:	0f b6 c0             	movzbl %al,%eax
    3cfe:	c1 e0 08             	shl    $0x8,%eax
    3d01:	89 d1                	mov    %edx,%ecx
    3d03:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u);
    3d05:	8b 45 08             	mov    0x8(%ebp),%eax
    3d08:	8b 00                	mov    (%eax),%eax
    3d0a:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3d0d:	83 c2 02             	add    $0x2,%edx
    3d10:	01 d0                	add    %edx,%eax
    3d12:	0f b6 00             	movzbl (%eax),%eax
    3d15:	0f b6 c0             	movzbl %al,%eax
    3d18:	c1 e0 10             	shl    $0x10,%eax
/*See ensureBits documentation above. This one ensures up to 17 bits */
static unsigned ensureBits17(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 2u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3d1b:	09 c1                	or     %eax,%ecx
    3d1d:	89 ca                	mov    %ecx,%edx
    3d1f:	8b 45 08             	mov    0x8(%ebp),%eax
    3d22:	89 50 10             	mov    %edx,0x10(%eax)
                     ((unsigned)reader->data[start + 2] << 16u);
    reader->buffer >>= (reader->bp & 7u);
    3d25:	8b 45 08             	mov    0x8(%ebp),%eax
    3d28:	8b 50 10             	mov    0x10(%eax),%edx
    3d2b:	8b 45 08             	mov    0x8(%ebp),%eax
    3d2e:	8b 40 0c             	mov    0xc(%eax),%eax
    3d31:	83 e0 07             	and    $0x7,%eax
    3d34:	89 c1                	mov    %eax,%ecx
    3d36:	d3 ea                	shr    %cl,%edx
    3d38:	8b 45 08             	mov    0x8(%ebp),%eax
    3d3b:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    3d3e:	b8 01 00 00 00       	mov    $0x1,%eax
    3d43:	e9 95 00 00 00       	jmp    3ddd <ensureBits17+0x12a>
  } else {
    reader->buffer = 0;
    3d48:	8b 45 08             	mov    0x8(%ebp),%eax
    3d4b:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    3d52:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3d55:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3d58:	39 c2                	cmp    %eax,%edx
    3d5a:	73 1e                	jae    3d7a <ensureBits17+0xc7>
    3d5c:	8b 45 08             	mov    0x8(%ebp),%eax
    3d5f:	8b 50 10             	mov    0x10(%eax),%edx
    3d62:	8b 45 08             	mov    0x8(%ebp),%eax
    3d65:	8b 08                	mov    (%eax),%ecx
    3d67:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3d6a:	01 c8                	add    %ecx,%eax
    3d6c:	0f b6 00             	movzbl (%eax),%eax
    3d6f:	0f b6 c0             	movzbl %al,%eax
    3d72:	09 c2                	or     %eax,%edx
    3d74:	8b 45 08             	mov    0x8(%ebp),%eax
    3d77:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
    3d7a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3d7d:	8d 50 01             	lea    0x1(%eax),%edx
    3d80:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3d83:	39 c2                	cmp    %eax,%edx
    3d85:	73 24                	jae    3dab <ensureBits17+0xf8>
    3d87:	8b 45 08             	mov    0x8(%ebp),%eax
    3d8a:	8b 50 10             	mov    0x10(%eax),%edx
    3d8d:	8b 45 08             	mov    0x8(%ebp),%eax
    3d90:	8b 00                	mov    (%eax),%eax
    3d92:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3d95:	83 c1 01             	add    $0x1,%ecx
    3d98:	01 c8                	add    %ecx,%eax
    3d9a:	0f b6 00             	movzbl (%eax),%eax
    3d9d:	0f b6 c0             	movzbl %al,%eax
    3da0:	c1 e0 08             	shl    $0x8,%eax
    3da3:	09 c2                	or     %eax,%edx
    3da5:	8b 45 08             	mov    0x8(%ebp),%eax
    3da8:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    3dab:	8b 45 08             	mov    0x8(%ebp),%eax
    3dae:	8b 50 10             	mov    0x10(%eax),%edx
    3db1:	8b 45 08             	mov    0x8(%ebp),%eax
    3db4:	8b 40 0c             	mov    0xc(%eax),%eax
    3db7:	83 e0 07             	and    $0x7,%eax
    3dba:	89 c1                	mov    %eax,%ecx
    3dbc:	d3 ea                	shr    %cl,%edx
    3dbe:	8b 45 08             	mov    0x8(%ebp),%eax
    3dc1:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    3dc4:	8b 45 08             	mov    0x8(%ebp),%eax
    3dc7:	8b 50 0c             	mov    0xc(%eax),%edx
    3dca:	8b 45 0c             	mov    0xc(%ebp),%eax
    3dcd:	01 c2                	add    %eax,%edx
    3dcf:	8b 45 08             	mov    0x8(%ebp),%eax
    3dd2:	8b 40 08             	mov    0x8(%eax),%eax
    3dd5:	39 c2                	cmp    %eax,%edx
    3dd7:	0f 9e c0             	setle  %al
    3dda:	0f b6 c0             	movzbl %al,%eax
  }
}
    3ddd:	c9                   	leave  
    3dde:	c3                   	ret    

00003ddf <ensureBits25>:

/*See ensureBits documentation above. This one ensures up to 25 bits */
static LODEPNG_INLINE unsigned ensureBits25(LodePNGBitReader* reader, size_t nbits) {
    3ddf:	55                   	push   %ebp
    3de0:	89 e5                	mov    %esp,%ebp
    3de2:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    3de5:	8b 45 08             	mov    0x8(%ebp),%eax
    3de8:	8b 40 0c             	mov    0xc(%eax),%eax
    3deb:	c1 f8 03             	sar    $0x3,%eax
    3dee:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t size = reader->size;
    3df1:	8b 45 08             	mov    0x8(%ebp),%eax
    3df4:	8b 40 04             	mov    0x4(%eax),%eax
    3df7:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(start + 3u < size) {
    3dfa:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3dfd:	8d 50 03             	lea    0x3(%eax),%edx
    3e00:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3e03:	39 c2                	cmp    %eax,%edx
    3e05:	0f 83 85 00 00 00    	jae    3e90 <ensureBits25+0xb1>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3e0b:	8b 45 08             	mov    0x8(%ebp),%eax
    3e0e:	8b 10                	mov    (%eax),%edx
    3e10:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3e13:	01 d0                	add    %edx,%eax
    3e15:	0f b6 00             	movzbl (%eax),%eax
    3e18:	0f b6 d0             	movzbl %al,%edx
    3e1b:	8b 45 08             	mov    0x8(%ebp),%eax
    3e1e:	8b 00                	mov    (%eax),%eax
    3e20:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3e23:	83 c1 01             	add    $0x1,%ecx
    3e26:	01 c8                	add    %ecx,%eax
    3e28:	0f b6 00             	movzbl (%eax),%eax
    3e2b:	0f b6 c0             	movzbl %al,%eax
    3e2e:	c1 e0 08             	shl    $0x8,%eax
    3e31:	89 d1                	mov    %edx,%ecx
    3e33:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    3e35:	8b 45 08             	mov    0x8(%ebp),%eax
    3e38:	8b 00                	mov    (%eax),%eax
    3e3a:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3e3d:	83 c2 02             	add    $0x2,%edx
    3e40:	01 d0                	add    %edx,%eax
    3e42:	0f b6 00             	movzbl (%eax),%eax
    3e45:	0f b6 c0             	movzbl %al,%eax
    3e48:	c1 e0 10             	shl    $0x10,%eax
/*See ensureBits documentation above. This one ensures up to 25 bits */
static LODEPNG_INLINE unsigned ensureBits25(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 3u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3e4b:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    3e4d:	8b 45 08             	mov    0x8(%ebp),%eax
    3e50:	8b 00                	mov    (%eax),%eax
    3e52:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3e55:	83 c2 03             	add    $0x3,%edx
    3e58:	01 d0                	add    %edx,%eax
    3e5a:	0f b6 00             	movzbl (%eax),%eax
    3e5d:	0f b6 c0             	movzbl %al,%eax
    3e60:	c1 e0 18             	shl    $0x18,%eax
    3e63:	09 c1                	or     %eax,%ecx
    3e65:	89 ca                	mov    %ecx,%edx
/*See ensureBits documentation above. This one ensures up to 25 bits */
static LODEPNG_INLINE unsigned ensureBits25(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 3u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3e67:	8b 45 08             	mov    0x8(%ebp),%eax
    3e6a:	89 50 10             	mov    %edx,0x10(%eax)
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    reader->buffer >>= (reader->bp & 7u);
    3e6d:	8b 45 08             	mov    0x8(%ebp),%eax
    3e70:	8b 50 10             	mov    0x10(%eax),%edx
    3e73:	8b 45 08             	mov    0x8(%ebp),%eax
    3e76:	8b 40 0c             	mov    0xc(%eax),%eax
    3e79:	83 e0 07             	and    $0x7,%eax
    3e7c:	89 c1                	mov    %eax,%ecx
    3e7e:	d3 ea                	shr    %cl,%edx
    3e80:	8b 45 08             	mov    0x8(%ebp),%eax
    3e83:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    3e86:	b8 01 00 00 00       	mov    $0x1,%eax
    3e8b:	e9 c6 00 00 00       	jmp    3f56 <ensureBits25+0x177>
  } else {
    reader->buffer = 0;
    3e90:	8b 45 08             	mov    0x8(%ebp),%eax
    3e93:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    3e9a:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3e9d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3ea0:	39 c2                	cmp    %eax,%edx
    3ea2:	73 1e                	jae    3ec2 <ensureBits25+0xe3>
    3ea4:	8b 45 08             	mov    0x8(%ebp),%eax
    3ea7:	8b 50 10             	mov    0x10(%eax),%edx
    3eaa:	8b 45 08             	mov    0x8(%ebp),%eax
    3ead:	8b 08                	mov    (%eax),%ecx
    3eaf:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3eb2:	01 c8                	add    %ecx,%eax
    3eb4:	0f b6 00             	movzbl (%eax),%eax
    3eb7:	0f b6 c0             	movzbl %al,%eax
    3eba:	09 c2                	or     %eax,%edx
    3ebc:	8b 45 08             	mov    0x8(%ebp),%eax
    3ebf:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
    3ec2:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3ec5:	8d 50 01             	lea    0x1(%eax),%edx
    3ec8:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3ecb:	39 c2                	cmp    %eax,%edx
    3ecd:	73 24                	jae    3ef3 <ensureBits25+0x114>
    3ecf:	8b 45 08             	mov    0x8(%ebp),%eax
    3ed2:	8b 50 10             	mov    0x10(%eax),%edx
    3ed5:	8b 45 08             	mov    0x8(%ebp),%eax
    3ed8:	8b 00                	mov    (%eax),%eax
    3eda:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3edd:	83 c1 01             	add    $0x1,%ecx
    3ee0:	01 c8                	add    %ecx,%eax
    3ee2:	0f b6 00             	movzbl (%eax),%eax
    3ee5:	0f b6 c0             	movzbl %al,%eax
    3ee8:	c1 e0 08             	shl    $0x8,%eax
    3eeb:	09 c2                	or     %eax,%edx
    3eed:	8b 45 08             	mov    0x8(%ebp),%eax
    3ef0:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 2u < size) reader->buffer |= ((unsigned)reader->data[start + 2] << 16u);
    3ef3:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3ef6:	8d 50 02             	lea    0x2(%eax),%edx
    3ef9:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3efc:	39 c2                	cmp    %eax,%edx
    3efe:	73 24                	jae    3f24 <ensureBits25+0x145>
    3f00:	8b 45 08             	mov    0x8(%ebp),%eax
    3f03:	8b 50 10             	mov    0x10(%eax),%edx
    3f06:	8b 45 08             	mov    0x8(%ebp),%eax
    3f09:	8b 00                	mov    (%eax),%eax
    3f0b:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3f0e:	83 c1 02             	add    $0x2,%ecx
    3f11:	01 c8                	add    %ecx,%eax
    3f13:	0f b6 00             	movzbl (%eax),%eax
    3f16:	0f b6 c0             	movzbl %al,%eax
    3f19:	c1 e0 10             	shl    $0x10,%eax
    3f1c:	09 c2                	or     %eax,%edx
    3f1e:	8b 45 08             	mov    0x8(%ebp),%eax
    3f21:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    3f24:	8b 45 08             	mov    0x8(%ebp),%eax
    3f27:	8b 50 10             	mov    0x10(%eax),%edx
    3f2a:	8b 45 08             	mov    0x8(%ebp),%eax
    3f2d:	8b 40 0c             	mov    0xc(%eax),%eax
    3f30:	83 e0 07             	and    $0x7,%eax
    3f33:	89 c1                	mov    %eax,%ecx
    3f35:	d3 ea                	shr    %cl,%edx
    3f37:	8b 45 08             	mov    0x8(%ebp),%eax
    3f3a:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    3f3d:	8b 45 08             	mov    0x8(%ebp),%eax
    3f40:	8b 50 0c             	mov    0xc(%eax),%edx
    3f43:	8b 45 0c             	mov    0xc(%ebp),%eax
    3f46:	01 c2                	add    %eax,%edx
    3f48:	8b 45 08             	mov    0x8(%ebp),%eax
    3f4b:	8b 40 08             	mov    0x8(%eax),%eax
    3f4e:	39 c2                	cmp    %eax,%edx
    3f50:	0f 9e c0             	setle  %al
    3f53:	0f b6 c0             	movzbl %al,%eax
  }
}
    3f56:	c9                   	leave  
    3f57:	c3                   	ret    

00003f58 <ensureBits32>:

/*See ensureBits documentation above. This one ensures up to 32 bits */
static LODEPNG_INLINE unsigned ensureBits32(LodePNGBitReader* reader, size_t nbits) {
    3f58:	55                   	push   %ebp
    3f59:	89 e5                	mov    %esp,%ebp
    3f5b:	53                   	push   %ebx
    3f5c:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    3f5f:	8b 45 08             	mov    0x8(%ebp),%eax
    3f62:	8b 40 0c             	mov    0xc(%eax),%eax
    3f65:	c1 f8 03             	sar    $0x3,%eax
    3f68:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t size = reader->size;
    3f6b:	8b 45 08             	mov    0x8(%ebp),%eax
    3f6e:	8b 40 04             	mov    0x4(%eax),%eax
    3f71:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(start + 4u < size) {
    3f74:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3f77:	8d 50 04             	lea    0x4(%eax),%edx
    3f7a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3f7d:	39 c2                	cmp    %eax,%edx
    3f7f:	0f 83 c3 00 00 00    	jae    4048 <ensureBits32+0xf0>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3f85:	8b 45 08             	mov    0x8(%ebp),%eax
    3f88:	8b 10                	mov    (%eax),%edx
    3f8a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3f8d:	01 d0                	add    %edx,%eax
    3f8f:	0f b6 00             	movzbl (%eax),%eax
    3f92:	0f b6 d0             	movzbl %al,%edx
    3f95:	8b 45 08             	mov    0x8(%ebp),%eax
    3f98:	8b 00                	mov    (%eax),%eax
    3f9a:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    3f9d:	83 c1 01             	add    $0x1,%ecx
    3fa0:	01 c8                	add    %ecx,%eax
    3fa2:	0f b6 00             	movzbl (%eax),%eax
    3fa5:	0f b6 c0             	movzbl %al,%eax
    3fa8:	c1 e0 08             	shl    $0x8,%eax
    3fab:	89 d1                	mov    %edx,%ecx
    3fad:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    3faf:	8b 45 08             	mov    0x8(%ebp),%eax
    3fb2:	8b 00                	mov    (%eax),%eax
    3fb4:	8b 55 f8             	mov    -0x8(%ebp),%edx
    3fb7:	83 c2 02             	add    $0x2,%edx
    3fba:	01 d0                	add    %edx,%eax
    3fbc:	0f b6 00             	movzbl (%eax),%eax
    3fbf:	0f b6 c0             	movzbl %al,%eax
    3fc2:	c1 e0 10             	shl    $0x10,%eax
/*See ensureBits documentation above. This one ensures up to 32 bits */
static LODEPNG_INLINE unsigned ensureBits32(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 4u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3fc5:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    3fc7:	8b 45 08             	mov    0x8(%ebp),%eax
    3fca:	8b 00                	mov    (%eax),%eax
    3fcc:	8b 55 f8             	mov    -0x8(%ebp),%edx
    3fcf:	83 c2 03             	add    $0x3,%edx
    3fd2:	01 d0                	add    %edx,%eax
    3fd4:	0f b6 00             	movzbl (%eax),%eax
    3fd7:	0f b6 c0             	movzbl %al,%eax
    3fda:	c1 e0 18             	shl    $0x18,%eax
    3fdd:	09 c1                	or     %eax,%ecx
    3fdf:	89 ca                	mov    %ecx,%edx
/*See ensureBits documentation above. This one ensures up to 32 bits */
static LODEPNG_INLINE unsigned ensureBits32(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 4u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3fe1:	8b 45 08             	mov    0x8(%ebp),%eax
    3fe4:	89 50 10             	mov    %edx,0x10(%eax)
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    reader->buffer >>= (reader->bp & 7u);
    3fe7:	8b 45 08             	mov    0x8(%ebp),%eax
    3fea:	8b 50 10             	mov    0x10(%eax),%edx
    3fed:	8b 45 08             	mov    0x8(%ebp),%eax
    3ff0:	8b 40 0c             	mov    0xc(%eax),%eax
    3ff3:	83 e0 07             	and    $0x7,%eax
    3ff6:	89 c1                	mov    %eax,%ecx
    3ff8:	d3 ea                	shr    %cl,%edx
    3ffa:	8b 45 08             	mov    0x8(%ebp),%eax
    3ffd:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer |= (((unsigned)reader->data[start + 4] << 24u) << (8u - (reader->bp & 7u)));
    4000:	8b 45 08             	mov    0x8(%ebp),%eax
    4003:	8b 50 10             	mov    0x10(%eax),%edx
    4006:	8b 45 08             	mov    0x8(%ebp),%eax
    4009:	8b 00                	mov    (%eax),%eax
    400b:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    400e:	83 c1 04             	add    $0x4,%ecx
    4011:	01 c8                	add    %ecx,%eax
    4013:	0f b6 00             	movzbl (%eax),%eax
    4016:	0f b6 c0             	movzbl %al,%eax
    4019:	c1 e0 18             	shl    $0x18,%eax
    401c:	89 c3                	mov    %eax,%ebx
    401e:	8b 45 08             	mov    0x8(%ebp),%eax
    4021:	8b 40 0c             	mov    0xc(%eax),%eax
    4024:	83 e0 07             	and    $0x7,%eax
    4027:	b9 08 00 00 00       	mov    $0x8,%ecx
    402c:	29 c1                	sub    %eax,%ecx
    402e:	89 c8                	mov    %ecx,%eax
    4030:	89 c1                	mov    %eax,%ecx
    4032:	d3 e3                	shl    %cl,%ebx
    4034:	89 d8                	mov    %ebx,%eax
    4036:	09 c2                	or     %eax,%edx
    4038:	8b 45 08             	mov    0x8(%ebp),%eax
    403b:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    403e:	b8 01 00 00 00       	mov    $0x1,%eax
    4043:	e9 f7 00 00 00       	jmp    413f <ensureBits32+0x1e7>
  } else {
    reader->buffer = 0;
    4048:	8b 45 08             	mov    0x8(%ebp),%eax
    404b:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    4052:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4055:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4058:	39 c2                	cmp    %eax,%edx
    405a:	73 1e                	jae    407a <ensureBits32+0x122>
    405c:	8b 45 08             	mov    0x8(%ebp),%eax
    405f:	8b 50 10             	mov    0x10(%eax),%edx
    4062:	8b 45 08             	mov    0x8(%ebp),%eax
    4065:	8b 08                	mov    (%eax),%ecx
    4067:	8b 45 f8             	mov    -0x8(%ebp),%eax
    406a:	01 c8                	add    %ecx,%eax
    406c:	0f b6 00             	movzbl (%eax),%eax
    406f:	0f b6 c0             	movzbl %al,%eax
    4072:	09 c2                	or     %eax,%edx
    4074:	8b 45 08             	mov    0x8(%ebp),%eax
    4077:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
    407a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    407d:	8d 50 01             	lea    0x1(%eax),%edx
    4080:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4083:	39 c2                	cmp    %eax,%edx
    4085:	73 24                	jae    40ab <ensureBits32+0x153>
    4087:	8b 45 08             	mov    0x8(%ebp),%eax
    408a:	8b 50 10             	mov    0x10(%eax),%edx
    408d:	8b 45 08             	mov    0x8(%ebp),%eax
    4090:	8b 00                	mov    (%eax),%eax
    4092:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    4095:	83 c1 01             	add    $0x1,%ecx
    4098:	01 c8                	add    %ecx,%eax
    409a:	0f b6 00             	movzbl (%eax),%eax
    409d:	0f b6 c0             	movzbl %al,%eax
    40a0:	c1 e0 08             	shl    $0x8,%eax
    40a3:	09 c2                	or     %eax,%edx
    40a5:	8b 45 08             	mov    0x8(%ebp),%eax
    40a8:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 2u < size) reader->buffer |= ((unsigned)reader->data[start + 2] << 16u);
    40ab:	8b 45 f8             	mov    -0x8(%ebp),%eax
    40ae:	8d 50 02             	lea    0x2(%eax),%edx
    40b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    40b4:	39 c2                	cmp    %eax,%edx
    40b6:	73 24                	jae    40dc <ensureBits32+0x184>
    40b8:	8b 45 08             	mov    0x8(%ebp),%eax
    40bb:	8b 50 10             	mov    0x10(%eax),%edx
    40be:	8b 45 08             	mov    0x8(%ebp),%eax
    40c1:	8b 00                	mov    (%eax),%eax
    40c3:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    40c6:	83 c1 02             	add    $0x2,%ecx
    40c9:	01 c8                	add    %ecx,%eax
    40cb:	0f b6 00             	movzbl (%eax),%eax
    40ce:	0f b6 c0             	movzbl %al,%eax
    40d1:	c1 e0 10             	shl    $0x10,%eax
    40d4:	09 c2                	or     %eax,%edx
    40d6:	8b 45 08             	mov    0x8(%ebp),%eax
    40d9:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 3u < size) reader->buffer |= ((unsigned)reader->data[start + 3] << 24u);
    40dc:	8b 45 f8             	mov    -0x8(%ebp),%eax
    40df:	8d 50 03             	lea    0x3(%eax),%edx
    40e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    40e5:	39 c2                	cmp    %eax,%edx
    40e7:	73 24                	jae    410d <ensureBits32+0x1b5>
    40e9:	8b 45 08             	mov    0x8(%ebp),%eax
    40ec:	8b 50 10             	mov    0x10(%eax),%edx
    40ef:	8b 45 08             	mov    0x8(%ebp),%eax
    40f2:	8b 00                	mov    (%eax),%eax
    40f4:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    40f7:	83 c1 03             	add    $0x3,%ecx
    40fa:	01 c8                	add    %ecx,%eax
    40fc:	0f b6 00             	movzbl (%eax),%eax
    40ff:	0f b6 c0             	movzbl %al,%eax
    4102:	c1 e0 18             	shl    $0x18,%eax
    4105:	09 c2                	or     %eax,%edx
    4107:	8b 45 08             	mov    0x8(%ebp),%eax
    410a:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    410d:	8b 45 08             	mov    0x8(%ebp),%eax
    4110:	8b 50 10             	mov    0x10(%eax),%edx
    4113:	8b 45 08             	mov    0x8(%ebp),%eax
    4116:	8b 40 0c             	mov    0xc(%eax),%eax
    4119:	83 e0 07             	and    $0x7,%eax
    411c:	89 c1                	mov    %eax,%ecx
    411e:	d3 ea                	shr    %cl,%edx
    4120:	8b 45 08             	mov    0x8(%ebp),%eax
    4123:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    4126:	8b 45 08             	mov    0x8(%ebp),%eax
    4129:	8b 50 0c             	mov    0xc(%eax),%edx
    412c:	8b 45 0c             	mov    0xc(%ebp),%eax
    412f:	01 c2                	add    %eax,%edx
    4131:	8b 45 08             	mov    0x8(%ebp),%eax
    4134:	8b 40 08             	mov    0x8(%eax),%eax
    4137:	39 c2                	cmp    %eax,%edx
    4139:	0f 9e c0             	setle  %al
    413c:	0f b6 c0             	movzbl %al,%eax
  }
}
    413f:	83 c4 10             	add    $0x10,%esp
    4142:	5b                   	pop    %ebx
    4143:	5d                   	pop    %ebp
    4144:	c3                   	ret    

00004145 <peekBits>:

/* Get bits without advancing the bit pointer. Must have enough bits available with ensureBits. Max nbits is 31. */
static unsigned peekBits(LodePNGBitReader* reader, size_t nbits) {
    4145:	55                   	push   %ebp
    4146:	89 e5                	mov    %esp,%ebp
    4148:	53                   	push   %ebx
  /* The shift allows nbits to be only up to 31. */
  return reader->buffer & ((1u << nbits) - 1u);
    4149:	8b 45 08             	mov    0x8(%ebp),%eax
    414c:	8b 50 10             	mov    0x10(%eax),%edx
    414f:	8b 45 0c             	mov    0xc(%ebp),%eax
    4152:	bb 01 00 00 00       	mov    $0x1,%ebx
    4157:	89 c1                	mov    %eax,%ecx
    4159:	d3 e3                	shl    %cl,%ebx
    415b:	89 d8                	mov    %ebx,%eax
    415d:	83 e8 01             	sub    $0x1,%eax
    4160:	21 d0                	and    %edx,%eax
}
    4162:	5b                   	pop    %ebx
    4163:	5d                   	pop    %ebp
    4164:	c3                   	ret    

00004165 <advanceBits>:

/* Must have enough bits available with ensureBits */
static void advanceBits(LodePNGBitReader* reader, size_t nbits) {
    4165:	55                   	push   %ebp
    4166:	89 e5                	mov    %esp,%ebp
  reader->buffer >>= nbits;
    4168:	8b 45 08             	mov    0x8(%ebp),%eax
    416b:	8b 50 10             	mov    0x10(%eax),%edx
    416e:	8b 45 0c             	mov    0xc(%ebp),%eax
    4171:	89 c1                	mov    %eax,%ecx
    4173:	d3 ea                	shr    %cl,%edx
    4175:	8b 45 08             	mov    0x8(%ebp),%eax
    4178:	89 50 10             	mov    %edx,0x10(%eax)
  reader->bp += nbits;
    417b:	8b 45 08             	mov    0x8(%ebp),%eax
    417e:	8b 50 0c             	mov    0xc(%eax),%edx
    4181:	8b 45 0c             	mov    0xc(%ebp),%eax
    4184:	01 c2                	add    %eax,%edx
    4186:	8b 45 08             	mov    0x8(%ebp),%eax
    4189:	89 50 0c             	mov    %edx,0xc(%eax)
}
    418c:	90                   	nop
    418d:	5d                   	pop    %ebp
    418e:	c3                   	ret    

0000418f <readBits>:

/* Must have enough bits available with ensureBits */
static unsigned readBits(LodePNGBitReader* reader, size_t nbits) {
    418f:	55                   	push   %ebp
    4190:	89 e5                	mov    %esp,%ebp
    4192:	83 ec 10             	sub    $0x10,%esp
  unsigned result = peekBits(reader, nbits);
    4195:	ff 75 0c             	pushl  0xc(%ebp)
    4198:	ff 75 08             	pushl  0x8(%ebp)
    419b:	e8 a5 ff ff ff       	call   4145 <peekBits>
    41a0:	83 c4 08             	add    $0x8,%esp
    41a3:	89 45 fc             	mov    %eax,-0x4(%ebp)
  advanceBits(reader, nbits);
    41a6:	ff 75 0c             	pushl  0xc(%ebp)
    41a9:	ff 75 08             	pushl  0x8(%ebp)
    41ac:	e8 b4 ff ff ff       	call   4165 <advanceBits>
    41b1:	83 c4 08             	add    $0x8,%esp
  return result;
    41b4:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    41b7:	c9                   	leave  
    41b8:	c3                   	ret    

000041b9 <lode_png_test_bitreader>:

/* Public for testing only. steps and result must have numsteps values. */
unsigned lode_png_test_bitreader(const unsigned char* data, size_t size,
                                 size_t numsteps, const size_t* steps, unsigned* result) {
    41b9:	55                   	push   %ebp
    41ba:	89 e5                	mov    %esp,%ebp
    41bc:	53                   	push   %ebx
    41bd:	83 ec 30             	sub    $0x30,%esp
  size_t i;
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, data, size);
    41c0:	ff 75 0c             	pushl  0xc(%ebp)
    41c3:	ff 75 08             	pushl  0x8(%ebp)
    41c6:	8d 45 d8             	lea    -0x28(%ebp),%eax
    41c9:	50                   	push   %eax
    41ca:	e8 97 f9 ff ff       	call   3b66 <LodePNGBitReader_init>
    41cf:	83 c4 0c             	add    $0xc,%esp
    41d2:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if(error) return 0;
    41d5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    41d9:	74 0a                	je     41e5 <lode_png_test_bitreader+0x2c>
    41db:	b8 00 00 00 00       	mov    $0x0,%eax
    41e0:	e9 c3 00 00 00       	jmp    42a8 <lode_png_test_bitreader+0xef>
  for(i = 0; i < numsteps; i++) {
    41e5:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    41ec:	e9 a6 00 00 00       	jmp    4297 <lode_png_test_bitreader+0xde>
    size_t step = steps[i];
    41f1:	8b 45 f8             	mov    -0x8(%ebp),%eax
    41f4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    41fb:	8b 45 14             	mov    0x14(%ebp),%eax
    41fe:	01 d0                	add    %edx,%eax
    4200:	8b 00                	mov    (%eax),%eax
    4202:	89 45 ec             	mov    %eax,-0x14(%ebp)
    unsigned ok;
    if(step > 25) ok = ensureBits32(&reader, step);
    4205:	83 7d ec 19          	cmpl   $0x19,-0x14(%ebp)
    4209:	7e 14                	jle    421f <lode_png_test_bitreader+0x66>
    420b:	ff 75 ec             	pushl  -0x14(%ebp)
    420e:	8d 45 d8             	lea    -0x28(%ebp),%eax
    4211:	50                   	push   %eax
    4212:	e8 41 fd ff ff       	call   3f58 <ensureBits32>
    4217:	83 c4 08             	add    $0x8,%esp
    421a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    421d:	eb 46                	jmp    4265 <lode_png_test_bitreader+0xac>
    else if(step > 17) ok = ensureBits25(&reader, step);
    421f:	83 7d ec 11          	cmpl   $0x11,-0x14(%ebp)
    4223:	7e 14                	jle    4239 <lode_png_test_bitreader+0x80>
    4225:	ff 75 ec             	pushl  -0x14(%ebp)
    4228:	8d 45 d8             	lea    -0x28(%ebp),%eax
    422b:	50                   	push   %eax
    422c:	e8 ae fb ff ff       	call   3ddf <ensureBits25>
    4231:	83 c4 08             	add    $0x8,%esp
    4234:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4237:	eb 2c                	jmp    4265 <lode_png_test_bitreader+0xac>
    else if(step > 9) ok = ensureBits17(&reader, step);
    4239:	83 7d ec 09          	cmpl   $0x9,-0x14(%ebp)
    423d:	7e 14                	jle    4253 <lode_png_test_bitreader+0x9a>
    423f:	ff 75 ec             	pushl  -0x14(%ebp)
    4242:	8d 45 d8             	lea    -0x28(%ebp),%eax
    4245:	50                   	push   %eax
    4246:	e8 68 fa ff ff       	call   3cb3 <ensureBits17>
    424b:	83 c4 08             	add    $0x8,%esp
    424e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4251:	eb 12                	jmp    4265 <lode_png_test_bitreader+0xac>
    else ok = ensureBits9(&reader, step);
    4253:	ff 75 ec             	pushl  -0x14(%ebp)
    4256:	8d 45 d8             	lea    -0x28(%ebp),%eax
    4259:	50                   	push   %eax
    425a:	e8 78 f9 ff ff       	call   3bd7 <ensureBits9>
    425f:	83 c4 08             	add    $0x8,%esp
    4262:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(!ok) return 0;
    4265:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4269:	75 07                	jne    4272 <lode_png_test_bitreader+0xb9>
    426b:	b8 00 00 00 00       	mov    $0x0,%eax
    4270:	eb 36                	jmp    42a8 <lode_png_test_bitreader+0xef>
    result[i] = readBits(&reader, step);
    4272:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4275:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    427c:	8b 45 18             	mov    0x18(%ebp),%eax
    427f:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    4282:	ff 75 ec             	pushl  -0x14(%ebp)
    4285:	8d 45 d8             	lea    -0x28(%ebp),%eax
    4288:	50                   	push   %eax
    4289:	e8 01 ff ff ff       	call   418f <readBits>
    428e:	83 c4 08             	add    $0x8,%esp
    4291:	89 03                	mov    %eax,(%ebx)
                                 size_t numsteps, const size_t* steps, unsigned* result) {
  size_t i;
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, data, size);
  if(error) return 0;
  for(i = 0; i < numsteps; i++) {
    4293:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    4297:	8b 45 f8             	mov    -0x8(%ebp),%eax
    429a:	3b 45 10             	cmp    0x10(%ebp),%eax
    429d:	0f 8c 4e ff ff ff    	jl     41f1 <lode_png_test_bitreader+0x38>
    else if(step > 9) ok = ensureBits17(&reader, step);
    else ok = ensureBits9(&reader, step);
    if(!ok) return 0;
    result[i] = readBits(&reader, step);
  }
  return 1;
    42a3:	b8 01 00 00 00       	mov    $0x1,%eax
}
    42a8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    42ab:	c9                   	leave  
    42ac:	c3                   	ret    

000042ad <reverseBits>:
#endif /*LODEPNG_COMPILE_DECODER*/

static unsigned reverseBits(unsigned bits, unsigned num) {
    42ad:	55                   	push   %ebp
    42ae:	89 e5                	mov    %esp,%ebp
    42b0:	83 ec 10             	sub    $0x10,%esp
  /*TODO: implement faster lookup table based version when needed*/
  unsigned i, result = 0;
    42b3:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  for(i = 0; i < num; i++) result |= ((bits >> (num - i - 1u)) & 1u) << i;
    42ba:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    42c1:	eb 27                	jmp    42ea <reverseBits+0x3d>
    42c3:	8b 45 0c             	mov    0xc(%ebp),%eax
    42c6:	2b 45 fc             	sub    -0x4(%ebp),%eax
    42c9:	83 e8 01             	sub    $0x1,%eax
    42cc:	8b 55 08             	mov    0x8(%ebp),%edx
    42cf:	89 c1                	mov    %eax,%ecx
    42d1:	d3 ea                	shr    %cl,%edx
    42d3:	89 d0                	mov    %edx,%eax
    42d5:	83 e0 01             	and    $0x1,%eax
    42d8:	89 c2                	mov    %eax,%edx
    42da:	8b 45 fc             	mov    -0x4(%ebp),%eax
    42dd:	89 c1                	mov    %eax,%ecx
    42df:	d3 e2                	shl    %cl,%edx
    42e1:	89 d0                	mov    %edx,%eax
    42e3:	09 45 f8             	or     %eax,-0x8(%ebp)
    42e6:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    42ea:	8b 45 fc             	mov    -0x4(%ebp),%eax
    42ed:	3b 45 0c             	cmp    0xc(%ebp),%eax
    42f0:	72 d1                	jb     42c3 <reverseBits+0x16>
  return result;
    42f2:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
    42f5:	c9                   	leave  
    42f6:	c3                   	ret    

000042f7 <HuffmanTree_init>:
  /* for reading only */
  unsigned char* table_len; /*length of symbol from lookup table, or max length if secondary lookup needed*/
  unsigned short* table_value; /*value of symbol from lookup table, or pointer to secondary table if needed*/
} HuffmanTree;

static void HuffmanTree_init(HuffmanTree* tree) {
    42f7:	55                   	push   %ebp
    42f8:	89 e5                	mov    %esp,%ebp
  tree->codes = 0;
    42fa:	8b 45 08             	mov    0x8(%ebp),%eax
    42fd:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  tree->lengths = 0;
    4303:	8b 45 08             	mov    0x8(%ebp),%eax
    4306:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  tree->table_len = 0;
    430d:	8b 45 08             	mov    0x8(%ebp),%eax
    4310:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  tree->table_value = 0;
    4317:	8b 45 08             	mov    0x8(%ebp),%eax
    431a:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
}
    4321:	90                   	nop
    4322:	5d                   	pop    %ebp
    4323:	c3                   	ret    

00004324 <HuffmanTree_cleanup>:

static void HuffmanTree_cleanup(HuffmanTree* tree) {
    4324:	55                   	push   %ebp
    4325:	89 e5                	mov    %esp,%ebp
    4327:	83 ec 08             	sub    $0x8,%esp
  lodepng_free(tree->codes);
    432a:	8b 45 08             	mov    0x8(%ebp),%eax
    432d:	8b 00                	mov    (%eax),%eax
    432f:	83 ec 0c             	sub    $0xc,%esp
    4332:	50                   	push   %eax
    4333:	e8 ec f0 ff ff       	call   3424 <lodepng_free>
    4338:	83 c4 10             	add    $0x10,%esp
  lodepng_free(tree->lengths);
    433b:	8b 45 08             	mov    0x8(%ebp),%eax
    433e:	8b 40 04             	mov    0x4(%eax),%eax
    4341:	83 ec 0c             	sub    $0xc,%esp
    4344:	50                   	push   %eax
    4345:	e8 da f0 ff ff       	call   3424 <lodepng_free>
    434a:	83 c4 10             	add    $0x10,%esp
  lodepng_free(tree->table_len);
    434d:	8b 45 08             	mov    0x8(%ebp),%eax
    4350:	8b 40 10             	mov    0x10(%eax),%eax
    4353:	83 ec 0c             	sub    $0xc,%esp
    4356:	50                   	push   %eax
    4357:	e8 c8 f0 ff ff       	call   3424 <lodepng_free>
    435c:	83 c4 10             	add    $0x10,%esp
  lodepng_free(tree->table_value);
    435f:	8b 45 08             	mov    0x8(%ebp),%eax
    4362:	8b 40 14             	mov    0x14(%eax),%eax
    4365:	83 ec 0c             	sub    $0xc,%esp
    4368:	50                   	push   %eax
    4369:	e8 b6 f0 ff ff       	call   3424 <lodepng_free>
    436e:	83 c4 10             	add    $0x10,%esp
}
    4371:	90                   	nop
    4372:	c9                   	leave  
    4373:	c3                   	ret    

00004374 <HuffmanTree_makeTable>:
/* a symbol value too big to represent any valid symbol, to indicate reading disallowed huffman bits combination,
which is possible in case of only 0 or 1 present symbols. */
#define INVALIDSYMBOL 65535u

/* make table for huffman decoding */
static unsigned HuffmanTree_makeTable(HuffmanTree* tree) {
    4374:	55                   	push   %ebp
    4375:	89 e5                	mov    %esp,%ebp
    4377:	83 ec 68             	sub    $0x68,%esp
  static const unsigned headsize = 1u << FIRSTBITS; /*size of the first table*/
  static const unsigned mask = (1u << FIRSTBITS) /*headsize*/ - 1u;
  size_t i, numpresent, pointer, size; /*total table size*/
  unsigned* maxlens = (unsigned*)lodepng_malloc(headsize * sizeof(unsigned));
    437a:	a1 a8 b6 01 00       	mov    0x1b6a8,%eax
    437f:	c1 e0 02             	shl    $0x2,%eax
    4382:	83 ec 0c             	sub    $0xc,%esp
    4385:	50                   	push   %eax
    4386:	e8 78 f0 ff ff       	call   3403 <lodepng_malloc>
    438b:	83 c4 10             	add    $0x10,%esp
    438e:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if(!maxlens) return 83; /*alloc fail*/
    4391:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    4395:	75 0a                	jne    43a1 <HuffmanTree_makeTable+0x2d>
    4397:	b8 53 00 00 00       	mov    $0x53,%eax
    439c:	e9 61 04 00 00       	jmp    4802 <HuffmanTree_makeTable+0x48e>

  /* compute maxlens: max total bit length of symbols sharing prefix in the first table*/
  lodepng_memset(maxlens, 0, headsize * sizeof(*maxlens));
    43a1:	a1 a8 b6 01 00       	mov    0x1b6a8,%eax
    43a6:	c1 e0 02             	shl    $0x2,%eax
    43a9:	83 ec 04             	sub    $0x4,%esp
    43ac:	50                   	push   %eax
    43ad:	6a 00                	push   $0x0
    43af:	ff 75 dc             	pushl  -0x24(%ebp)
    43b2:	e8 bd f0 ff ff       	call   3474 <lodepng_memset>
    43b7:	83 c4 10             	add    $0x10,%esp
  for(i = 0; i < tree->numcodes; i++) {
    43ba:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    43c1:	eb 7d                	jmp    4440 <HuffmanTree_makeTable+0xcc>
    unsigned symbol = tree->codes[i];
    43c3:	8b 45 08             	mov    0x8(%ebp),%eax
    43c6:	8b 00                	mov    (%eax),%eax
    43c8:	8b 55 f4             	mov    -0xc(%ebp),%edx
    43cb:	c1 e2 02             	shl    $0x2,%edx
    43ce:	01 d0                	add    %edx,%eax
    43d0:	8b 00                	mov    (%eax),%eax
    43d2:	89 45 d8             	mov    %eax,-0x28(%ebp)
    unsigned l = tree->lengths[i];
    43d5:	8b 45 08             	mov    0x8(%ebp),%eax
    43d8:	8b 40 04             	mov    0x4(%eax),%eax
    43db:	8b 55 f4             	mov    -0xc(%ebp),%edx
    43de:	c1 e2 02             	shl    $0x2,%edx
    43e1:	01 d0                	add    %edx,%eax
    43e3:	8b 00                	mov    (%eax),%eax
    43e5:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    unsigned index;
    if(l <= FIRSTBITS) continue; /*symbols that fit in first table don't increase secondary table size*/
    43e8:	83 7d d4 09          	cmpl   $0x9,-0x2c(%ebp)
    43ec:	76 4d                	jbe    443b <HuffmanTree_makeTable+0xc7>
    /*get the FIRSTBITS MSBs, the MSBs of the symbol are encoded first. See later comment about the reversing*/
    index = reverseBits(symbol >> (l - FIRSTBITS), FIRSTBITS);
    43ee:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    43f1:	83 e8 09             	sub    $0x9,%eax
    43f4:	8b 55 d8             	mov    -0x28(%ebp),%edx
    43f7:	89 c1                	mov    %eax,%ecx
    43f9:	d3 ea                	shr    %cl,%edx
    43fb:	89 d0                	mov    %edx,%eax
    43fd:	83 ec 08             	sub    $0x8,%esp
    4400:	6a 09                	push   $0x9
    4402:	50                   	push   %eax
    4403:	e8 a5 fe ff ff       	call   42ad <reverseBits>
    4408:	83 c4 10             	add    $0x10,%esp
    440b:	89 45 d0             	mov    %eax,-0x30(%ebp)
    maxlens[index] = LODEPNG_MAX(maxlens[index], l);
    440e:	8b 45 d0             	mov    -0x30(%ebp),%eax
    4411:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4418:	8b 45 dc             	mov    -0x24(%ebp),%eax
    441b:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    441e:	8b 45 d0             	mov    -0x30(%ebp),%eax
    4421:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4428:	8b 45 dc             	mov    -0x24(%ebp),%eax
    442b:	01 d0                	add    %edx,%eax
    442d:	8b 10                	mov    (%eax),%edx
    442f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    4432:	39 c2                	cmp    %eax,%edx
    4434:	0f 43 c2             	cmovae %edx,%eax
    4437:	89 01                	mov    %eax,(%ecx)
    4439:	eb 01                	jmp    443c <HuffmanTree_makeTable+0xc8>
  lodepng_memset(maxlens, 0, headsize * sizeof(*maxlens));
  for(i = 0; i < tree->numcodes; i++) {
    unsigned symbol = tree->codes[i];
    unsigned l = tree->lengths[i];
    unsigned index;
    if(l <= FIRSTBITS) continue; /*symbols that fit in first table don't increase secondary table size*/
    443b:	90                   	nop
  unsigned* maxlens = (unsigned*)lodepng_malloc(headsize * sizeof(unsigned));
  if(!maxlens) return 83; /*alloc fail*/

  /* compute maxlens: max total bit length of symbols sharing prefix in the first table*/
  lodepng_memset(maxlens, 0, headsize * sizeof(*maxlens));
  for(i = 0; i < tree->numcodes; i++) {
    443c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4440:	8b 45 08             	mov    0x8(%ebp),%eax
    4443:	8b 50 0c             	mov    0xc(%eax),%edx
    4446:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4449:	39 c2                	cmp    %eax,%edx
    444b:	0f 87 72 ff ff ff    	ja     43c3 <HuffmanTree_makeTable+0x4f>
    /*get the FIRSTBITS MSBs, the MSBs of the symbol are encoded first. See later comment about the reversing*/
    index = reverseBits(symbol >> (l - FIRSTBITS), FIRSTBITS);
    maxlens[index] = LODEPNG_MAX(maxlens[index], l);
  }
  /* compute total table size: size of first table plus all secondary tables for symbols longer than FIRSTBITS */
  size = headsize;
    4451:	a1 a8 b6 01 00       	mov    0x1b6a8,%eax
    4456:	89 45 e8             	mov    %eax,-0x18(%ebp)
  for(i = 0; i < headsize; ++i) {
    4459:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4460:	eb 35                	jmp    4497 <HuffmanTree_makeTable+0x123>
    unsigned l = maxlens[i];
    4462:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4465:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    446c:	8b 45 dc             	mov    -0x24(%ebp),%eax
    446f:	01 d0                	add    %edx,%eax
    4471:	8b 00                	mov    (%eax),%eax
    4473:	89 45 cc             	mov    %eax,-0x34(%ebp)
    if(l > FIRSTBITS) size += (1u << (l - FIRSTBITS));
    4476:	83 7d cc 09          	cmpl   $0x9,-0x34(%ebp)
    447a:	76 17                	jbe    4493 <HuffmanTree_makeTable+0x11f>
    447c:	8b 45 cc             	mov    -0x34(%ebp),%eax
    447f:	83 e8 09             	sub    $0x9,%eax
    4482:	ba 01 00 00 00       	mov    $0x1,%edx
    4487:	89 c1                	mov    %eax,%ecx
    4489:	d3 e2                	shl    %cl,%edx
    448b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    448e:	01 d0                	add    %edx,%eax
    4490:	89 45 e8             	mov    %eax,-0x18(%ebp)
    index = reverseBits(symbol >> (l - FIRSTBITS), FIRSTBITS);
    maxlens[index] = LODEPNG_MAX(maxlens[index], l);
  }
  /* compute total table size: size of first table plus all secondary tables for symbols longer than FIRSTBITS */
  size = headsize;
  for(i = 0; i < headsize; ++i) {
    4493:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4497:	8b 55 f4             	mov    -0xc(%ebp),%edx
    449a:	a1 a8 b6 01 00       	mov    0x1b6a8,%eax
    449f:	39 c2                	cmp    %eax,%edx
    44a1:	72 bf                	jb     4462 <HuffmanTree_makeTable+0xee>
    unsigned l = maxlens[i];
    if(l > FIRSTBITS) size += (1u << (l - FIRSTBITS));
  }
  tree->table_len = (unsigned char*)lodepng_malloc(size * sizeof(*tree->table_len));
    44a3:	83 ec 0c             	sub    $0xc,%esp
    44a6:	ff 75 e8             	pushl  -0x18(%ebp)
    44a9:	e8 55 ef ff ff       	call   3403 <lodepng_malloc>
    44ae:	83 c4 10             	add    $0x10,%esp
    44b1:	89 c2                	mov    %eax,%edx
    44b3:	8b 45 08             	mov    0x8(%ebp),%eax
    44b6:	89 50 10             	mov    %edx,0x10(%eax)
  tree->table_value = (unsigned short*)lodepng_malloc(size * sizeof(*tree->table_value));
    44b9:	8b 45 e8             	mov    -0x18(%ebp),%eax
    44bc:	01 c0                	add    %eax,%eax
    44be:	83 ec 0c             	sub    $0xc,%esp
    44c1:	50                   	push   %eax
    44c2:	e8 3c ef ff ff       	call   3403 <lodepng_malloc>
    44c7:	83 c4 10             	add    $0x10,%esp
    44ca:	89 c2                	mov    %eax,%edx
    44cc:	8b 45 08             	mov    0x8(%ebp),%eax
    44cf:	89 50 14             	mov    %edx,0x14(%eax)
  if(!tree->table_len || !tree->table_value) {
    44d2:	8b 45 08             	mov    0x8(%ebp),%eax
    44d5:	8b 40 10             	mov    0x10(%eax),%eax
    44d8:	85 c0                	test   %eax,%eax
    44da:	74 0a                	je     44e6 <HuffmanTree_makeTable+0x172>
    44dc:	8b 45 08             	mov    0x8(%ebp),%eax
    44df:	8b 40 14             	mov    0x14(%eax),%eax
    44e2:	85 c0                	test   %eax,%eax
    44e4:	75 18                	jne    44fe <HuffmanTree_makeTable+0x18a>
    lodepng_free(maxlens);
    44e6:	83 ec 0c             	sub    $0xc,%esp
    44e9:	ff 75 dc             	pushl  -0x24(%ebp)
    44ec:	e8 33 ef ff ff       	call   3424 <lodepng_free>
    44f1:	83 c4 10             	add    $0x10,%esp
    /* freeing tree->table values is done at a higher scope */
    return 83; /*alloc fail*/
    44f4:	b8 53 00 00 00       	mov    $0x53,%eax
    44f9:	e9 04 03 00 00       	jmp    4802 <HuffmanTree_makeTable+0x48e>
  }
  /*initialize with an invalid length to indicate unused entries*/
  for(i = 0; i < size; ++i) tree->table_len[i] = 16;
    44fe:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4505:	eb 12                	jmp    4519 <HuffmanTree_makeTable+0x1a5>
    4507:	8b 45 08             	mov    0x8(%ebp),%eax
    450a:	8b 50 10             	mov    0x10(%eax),%edx
    450d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4510:	01 d0                	add    %edx,%eax
    4512:	c6 00 10             	movb   $0x10,(%eax)
    4515:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4519:	8b 45 f4             	mov    -0xc(%ebp),%eax
    451c:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    451f:	7c e6                	jl     4507 <HuffmanTree_makeTable+0x193>

  /*fill in the first table for long symbols: max prefix size and pointer to secondary tables*/
  pointer = headsize;
    4521:	a1 a8 b6 01 00       	mov    0x1b6a8,%eax
    4526:	89 45 ec             	mov    %eax,-0x14(%ebp)
  for(i = 0; i < headsize; ++i) {
    4529:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4530:	eb 5b                	jmp    458d <HuffmanTree_makeTable+0x219>
    unsigned l = maxlens[i];
    4532:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4535:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    453c:	8b 45 dc             	mov    -0x24(%ebp),%eax
    453f:	01 d0                	add    %edx,%eax
    4541:	8b 00                	mov    (%eax),%eax
    4543:	89 45 c8             	mov    %eax,-0x38(%ebp)
    if(l <= FIRSTBITS) continue;
    4546:	83 7d c8 09          	cmpl   $0x9,-0x38(%ebp)
    454a:	76 3c                	jbe    4588 <HuffmanTree_makeTable+0x214>
    tree->table_len[i] = l;
    454c:	8b 45 08             	mov    0x8(%ebp),%eax
    454f:	8b 50 10             	mov    0x10(%eax),%edx
    4552:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4555:	01 d0                	add    %edx,%eax
    4557:	8b 55 c8             	mov    -0x38(%ebp),%edx
    455a:	88 10                	mov    %dl,(%eax)
    tree->table_value[i] = pointer;
    455c:	8b 45 08             	mov    0x8(%ebp),%eax
    455f:	8b 40 14             	mov    0x14(%eax),%eax
    4562:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4565:	01 d2                	add    %edx,%edx
    4567:	01 d0                	add    %edx,%eax
    4569:	8b 55 ec             	mov    -0x14(%ebp),%edx
    456c:	66 89 10             	mov    %dx,(%eax)
    pointer += (1u << (l - FIRSTBITS));
    456f:	8b 45 c8             	mov    -0x38(%ebp),%eax
    4572:	83 e8 09             	sub    $0x9,%eax
    4575:	ba 01 00 00 00       	mov    $0x1,%edx
    457a:	89 c1                	mov    %eax,%ecx
    457c:	d3 e2                	shl    %cl,%edx
    457e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4581:	01 d0                	add    %edx,%eax
    4583:	89 45 ec             	mov    %eax,-0x14(%ebp)
    4586:	eb 01                	jmp    4589 <HuffmanTree_makeTable+0x215>

  /*fill in the first table for long symbols: max prefix size and pointer to secondary tables*/
  pointer = headsize;
  for(i = 0; i < headsize; ++i) {
    unsigned l = maxlens[i];
    if(l <= FIRSTBITS) continue;
    4588:	90                   	nop
  /*initialize with an invalid length to indicate unused entries*/
  for(i = 0; i < size; ++i) tree->table_len[i] = 16;

  /*fill in the first table for long symbols: max prefix size and pointer to secondary tables*/
  pointer = headsize;
  for(i = 0; i < headsize; ++i) {
    4589:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    458d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4590:	a1 a8 b6 01 00       	mov    0x1b6a8,%eax
    4595:	39 c2                	cmp    %eax,%edx
    4597:	72 99                	jb     4532 <HuffmanTree_makeTable+0x1be>
    if(l <= FIRSTBITS) continue;
    tree->table_len[i] = l;
    tree->table_value[i] = pointer;
    pointer += (1u << (l - FIRSTBITS));
  }
  lodepng_free(maxlens);
    4599:	83 ec 0c             	sub    $0xc,%esp
    459c:	ff 75 dc             	pushl  -0x24(%ebp)
    459f:	e8 80 ee ff ff       	call   3424 <lodepng_free>
    45a4:	83 c4 10             	add    $0x10,%esp

  /*fill in the first table for short symbols, or secondary table for long symbols*/
  numpresent = 0;
    45a7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  for(i = 0; i < tree->numcodes; ++i) {
    45ae:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    45b5:	e9 9d 01 00 00       	jmp    4757 <HuffmanTree_makeTable+0x3e3>
    unsigned l = tree->lengths[i];
    45ba:	8b 45 08             	mov    0x8(%ebp),%eax
    45bd:	8b 40 04             	mov    0x4(%eax),%eax
    45c0:	8b 55 f4             	mov    -0xc(%ebp),%edx
    45c3:	c1 e2 02             	shl    $0x2,%edx
    45c6:	01 d0                	add    %edx,%eax
    45c8:	8b 00                	mov    (%eax),%eax
    45ca:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    unsigned symbol = tree->codes[i]; /*the huffman bit pattern. i itself is the value.*/
    45cd:	8b 45 08             	mov    0x8(%ebp),%eax
    45d0:	8b 00                	mov    (%eax),%eax
    45d2:	8b 55 f4             	mov    -0xc(%ebp),%edx
    45d5:	c1 e2 02             	shl    $0x2,%edx
    45d8:	01 d0                	add    %edx,%eax
    45da:	8b 00                	mov    (%eax),%eax
    45dc:	89 45 c0             	mov    %eax,-0x40(%ebp)
    /*reverse bits, because the huffman bits are given in MSB first order but the bit reader reads LSB first*/
    unsigned reverse = reverseBits(symbol, l);
    45df:	83 ec 08             	sub    $0x8,%esp
    45e2:	ff 75 c4             	pushl  -0x3c(%ebp)
    45e5:	ff 75 c0             	pushl  -0x40(%ebp)
    45e8:	e8 c0 fc ff ff       	call   42ad <reverseBits>
    45ed:	83 c4 10             	add    $0x10,%esp
    45f0:	89 45 bc             	mov    %eax,-0x44(%ebp)
    if(l == 0) continue;
    45f3:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
    45f7:	0f 84 55 01 00 00    	je     4752 <HuffmanTree_makeTable+0x3de>
    numpresent++;
    45fd:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)

    if(l <= FIRSTBITS) {
    4601:	83 7d c4 09          	cmpl   $0x9,-0x3c(%ebp)
    4605:	0f 87 81 00 00 00    	ja     468c <HuffmanTree_makeTable+0x318>
      /*short symbol, fully in first table, replicated num times if l < FIRSTBITS*/
      unsigned num = 1u << (FIRSTBITS - l);
    460b:	b8 09 00 00 00       	mov    $0x9,%eax
    4610:	2b 45 c4             	sub    -0x3c(%ebp),%eax
    4613:	ba 01 00 00 00       	mov    $0x1,%edx
    4618:	89 c1                	mov    %eax,%ecx
    461a:	d3 e2                	shl    %cl,%edx
    461c:	89 d0                	mov    %edx,%eax
    461e:	89 45 9c             	mov    %eax,-0x64(%ebp)
      unsigned j;
      for(j = 0; j < num; ++j) {
    4621:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    4628:	eb 55                	jmp    467f <HuffmanTree_makeTable+0x30b>
        /*bit reader will read the l bits of symbol first, the remaining FIRSTBITS - l bits go to the MSB's*/
        unsigned index = reverse | (j << l);
    462a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    462d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    4630:	89 c1                	mov    %eax,%ecx
    4632:	d3 e2                	shl    %cl,%edx
    4634:	89 d0                	mov    %edx,%eax
    4636:	0b 45 bc             	or     -0x44(%ebp),%eax
    4639:	89 45 98             	mov    %eax,-0x68(%ebp)
        if(tree->table_len[index] != 16) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
    463c:	8b 45 08             	mov    0x8(%ebp),%eax
    463f:	8b 50 10             	mov    0x10(%eax),%edx
    4642:	8b 45 98             	mov    -0x68(%ebp),%eax
    4645:	01 d0                	add    %edx,%eax
    4647:	0f b6 00             	movzbl (%eax),%eax
    464a:	3c 10                	cmp    $0x10,%al
    464c:	74 0a                	je     4658 <HuffmanTree_makeTable+0x2e4>
    464e:	b8 37 00 00 00       	mov    $0x37,%eax
    4653:	e9 aa 01 00 00       	jmp    4802 <HuffmanTree_makeTable+0x48e>
        tree->table_len[index] = l;
    4658:	8b 45 08             	mov    0x8(%ebp),%eax
    465b:	8b 50 10             	mov    0x10(%eax),%edx
    465e:	8b 45 98             	mov    -0x68(%ebp),%eax
    4661:	01 d0                	add    %edx,%eax
    4663:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    4666:	88 10                	mov    %dl,(%eax)
        tree->table_value[index] = i;
    4668:	8b 45 08             	mov    0x8(%ebp),%eax
    466b:	8b 40 14             	mov    0x14(%eax),%eax
    466e:	8b 55 98             	mov    -0x68(%ebp),%edx
    4671:	01 d2                	add    %edx,%edx
    4673:	01 d0                	add    %edx,%eax
    4675:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4678:	66 89 10             	mov    %dx,(%eax)

    if(l <= FIRSTBITS) {
      /*short symbol, fully in first table, replicated num times if l < FIRSTBITS*/
      unsigned num = 1u << (FIRSTBITS - l);
      unsigned j;
      for(j = 0; j < num; ++j) {
    467b:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
    467f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4682:	3b 45 9c             	cmp    -0x64(%ebp),%eax
    4685:	72 a3                	jb     462a <HuffmanTree_makeTable+0x2b6>
    4687:	e9 c7 00 00 00       	jmp    4753 <HuffmanTree_makeTable+0x3df>
        tree->table_value[index] = i;
      }
    } else {
      /*long symbol, shares prefix with other long symbols in first lookup table, needs second lookup*/
      /*the FIRSTBITS MSBs of the symbol are the first table index*/
      unsigned index = reverse & mask;
    468c:	a1 ac b6 01 00       	mov    0x1b6ac,%eax
    4691:	23 45 bc             	and    -0x44(%ebp),%eax
    4694:	89 45 b8             	mov    %eax,-0x48(%ebp)
      unsigned maxlen = tree->table_len[index];
    4697:	8b 45 08             	mov    0x8(%ebp),%eax
    469a:	8b 50 10             	mov    0x10(%eax),%edx
    469d:	8b 45 b8             	mov    -0x48(%ebp),%eax
    46a0:	01 d0                	add    %edx,%eax
    46a2:	0f b6 00             	movzbl (%eax),%eax
    46a5:	0f b6 c0             	movzbl %al,%eax
    46a8:	89 45 b4             	mov    %eax,-0x4c(%ebp)
      /*log2 of secondary table length, should be >= l - FIRSTBITS*/
      unsigned tablelen = maxlen - FIRSTBITS;
    46ab:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    46ae:	83 e8 09             	sub    $0x9,%eax
    46b1:	89 45 b0             	mov    %eax,-0x50(%ebp)
      unsigned start = tree->table_value[index]; /*starting index in secondary table*/
    46b4:	8b 45 08             	mov    0x8(%ebp),%eax
    46b7:	8b 40 14             	mov    0x14(%eax),%eax
    46ba:	8b 55 b8             	mov    -0x48(%ebp),%edx
    46bd:	01 d2                	add    %edx,%edx
    46bf:	01 d0                	add    %edx,%eax
    46c1:	0f b7 00             	movzwl (%eax),%eax
    46c4:	0f b7 c0             	movzwl %ax,%eax
    46c7:	89 45 ac             	mov    %eax,-0x54(%ebp)
      unsigned num = 1u << (tablelen - (l - FIRSTBITS)); /*amount of entries of this symbol in secondary table*/
    46ca:	8b 45 b0             	mov    -0x50(%ebp),%eax
    46cd:	2b 45 c4             	sub    -0x3c(%ebp),%eax
    46d0:	83 c0 09             	add    $0x9,%eax
    46d3:	ba 01 00 00 00       	mov    $0x1,%edx
    46d8:	89 c1                	mov    %eax,%ecx
    46da:	d3 e2                	shl    %cl,%edx
    46dc:	89 d0                	mov    %edx,%eax
    46de:	89 45 a8             	mov    %eax,-0x58(%ebp)
      unsigned j;
      if(maxlen < l) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
    46e1:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    46e4:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
    46e7:	73 0a                	jae    46f3 <HuffmanTree_makeTable+0x37f>
    46e9:	b8 37 00 00 00       	mov    $0x37,%eax
    46ee:	e9 0f 01 00 00       	jmp    4802 <HuffmanTree_makeTable+0x48e>
      for(j = 0; j < num; ++j) {
    46f3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    46fa:	eb 4c                	jmp    4748 <HuffmanTree_makeTable+0x3d4>
        unsigned reverse2 = reverse >> FIRSTBITS; /* l - FIRSTBITS bits */
    46fc:	8b 45 bc             	mov    -0x44(%ebp),%eax
    46ff:	c1 e8 09             	shr    $0x9,%eax
    4702:	89 45 a4             	mov    %eax,-0x5c(%ebp)
        unsigned index2 = start + (reverse2 | (j << (l - FIRSTBITS)));
    4705:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    4708:	83 e8 09             	sub    $0x9,%eax
    470b:	8b 55 e0             	mov    -0x20(%ebp),%edx
    470e:	89 c1                	mov    %eax,%ecx
    4710:	d3 e2                	shl    %cl,%edx
    4712:	89 d0                	mov    %edx,%eax
    4714:	0b 45 a4             	or     -0x5c(%ebp),%eax
    4717:	89 c2                	mov    %eax,%edx
    4719:	8b 45 ac             	mov    -0x54(%ebp),%eax
    471c:	01 d0                	add    %edx,%eax
    471e:	89 45 a0             	mov    %eax,-0x60(%ebp)
        tree->table_len[index2] = l;
    4721:	8b 45 08             	mov    0x8(%ebp),%eax
    4724:	8b 50 10             	mov    0x10(%eax),%edx
    4727:	8b 45 a0             	mov    -0x60(%ebp),%eax
    472a:	01 d0                	add    %edx,%eax
    472c:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    472f:	88 10                	mov    %dl,(%eax)
        tree->table_value[index2] = i;
    4731:	8b 45 08             	mov    0x8(%ebp),%eax
    4734:	8b 40 14             	mov    0x14(%eax),%eax
    4737:	8b 55 a0             	mov    -0x60(%ebp),%edx
    473a:	01 d2                	add    %edx,%edx
    473c:	01 d0                	add    %edx,%eax
    473e:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4741:	66 89 10             	mov    %dx,(%eax)
      unsigned tablelen = maxlen - FIRSTBITS;
      unsigned start = tree->table_value[index]; /*starting index in secondary table*/
      unsigned num = 1u << (tablelen - (l - FIRSTBITS)); /*amount of entries of this symbol in secondary table*/
      unsigned j;
      if(maxlen < l) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
      for(j = 0; j < num; ++j) {
    4744:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
    4748:	8b 45 e0             	mov    -0x20(%ebp),%eax
    474b:	3b 45 a8             	cmp    -0x58(%ebp),%eax
    474e:	72 ac                	jb     46fc <HuffmanTree_makeTable+0x388>
    4750:	eb 01                	jmp    4753 <HuffmanTree_makeTable+0x3df>
  for(i = 0; i < tree->numcodes; ++i) {
    unsigned l = tree->lengths[i];
    unsigned symbol = tree->codes[i]; /*the huffman bit pattern. i itself is the value.*/
    /*reverse bits, because the huffman bits are given in MSB first order but the bit reader reads LSB first*/
    unsigned reverse = reverseBits(symbol, l);
    if(l == 0) continue;
    4752:	90                   	nop
  }
  lodepng_free(maxlens);

  /*fill in the first table for short symbols, or secondary table for long symbols*/
  numpresent = 0;
  for(i = 0; i < tree->numcodes; ++i) {
    4753:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4757:	8b 45 08             	mov    0x8(%ebp),%eax
    475a:	8b 50 0c             	mov    0xc(%eax),%edx
    475d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4760:	39 c2                	cmp    %eax,%edx
    4762:	0f 87 52 fe ff ff    	ja     45ba <HuffmanTree_makeTable+0x246>
        tree->table_value[index2] = i;
      }
    }
  }

  if(numpresent < 2) {
    4768:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
    476c:	7f 61                	jg     47cf <HuffmanTree_makeTable+0x45b>
    but deflate uses 1 bit instead. In case of 0 symbols, no symbols can
    appear at all, but such huffman tree could still exist (e.g. if distance
    codes are never used). In both cases, not all symbols of the table will be
    filled in. Fill them in with an invalid symbol value so returning them from
    huffmanDecodeSymbol will cause error. */
    for(i = 0; i < size; ++i) {
    476e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4775:	eb 4e                	jmp    47c5 <HuffmanTree_makeTable+0x451>
      if(tree->table_len[i] == 16) {
    4777:	8b 45 08             	mov    0x8(%ebp),%eax
    477a:	8b 50 10             	mov    0x10(%eax),%edx
    477d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4780:	01 d0                	add    %edx,%eax
    4782:	0f b6 00             	movzbl (%eax),%eax
    4785:	3c 10                	cmp    $0x10,%al
    4787:	75 38                	jne    47c1 <HuffmanTree_makeTable+0x44d>
        /* As length, use a value smaller than FIRSTBITS for the head table,
        and a value larger than FIRSTBITS for the secondary table, to ensure
        valid behavior for advanceBits when reading this symbol. */
        tree->table_len[i] = (i < headsize) ? 1 : (FIRSTBITS + 1);
    4789:	8b 45 08             	mov    0x8(%ebp),%eax
    478c:	8b 50 10             	mov    0x10(%eax),%edx
    478f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4792:	01 d0                	add    %edx,%eax
    4794:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    4797:	8b 15 a8 b6 01 00    	mov    0x1b6a8,%edx
    479d:	39 d1                	cmp    %edx,%ecx
    479f:	73 07                	jae    47a8 <HuffmanTree_makeTable+0x434>
    47a1:	ba 01 00 00 00       	mov    $0x1,%edx
    47a6:	eb 05                	jmp    47ad <HuffmanTree_makeTable+0x439>
    47a8:	ba 0a 00 00 00       	mov    $0xa,%edx
    47ad:	88 10                	mov    %dl,(%eax)
        tree->table_value[i] = INVALIDSYMBOL;
    47af:	8b 45 08             	mov    0x8(%ebp),%eax
    47b2:	8b 40 14             	mov    0x14(%eax),%eax
    47b5:	8b 55 f4             	mov    -0xc(%ebp),%edx
    47b8:	01 d2                	add    %edx,%edx
    47ba:	01 d0                	add    %edx,%eax
    47bc:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
    but deflate uses 1 bit instead. In case of 0 symbols, no symbols can
    appear at all, but such huffman tree could still exist (e.g. if distance
    codes are never used). In both cases, not all symbols of the table will be
    filled in. Fill them in with an invalid symbol value so returning them from
    huffmanDecodeSymbol will cause error. */
    for(i = 0; i < size; ++i) {
    47c1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    47c5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    47c8:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    47cb:	7c aa                	jl     4777 <HuffmanTree_makeTable+0x403>
    47cd:	eb 2e                	jmp    47fd <HuffmanTree_makeTable+0x489>
  } else {
    /* A good huffman tree has N * 2 - 1 nodes, of which N - 1 are internal nodes.
    If that is not the case (due to too long length codes), the table will not
    have been fully used, and this is an error (not all bit combinations can be
    decoded): an oversubscribed huffman tree, indicated by error 55. */
    for(i = 0; i < size; ++i) {
    47cf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    47d6:	eb 1d                	jmp    47f5 <HuffmanTree_makeTable+0x481>
      if(tree->table_len[i] == 16) return 55;
    47d8:	8b 45 08             	mov    0x8(%ebp),%eax
    47db:	8b 50 10             	mov    0x10(%eax),%edx
    47de:	8b 45 f4             	mov    -0xc(%ebp),%eax
    47e1:	01 d0                	add    %edx,%eax
    47e3:	0f b6 00             	movzbl (%eax),%eax
    47e6:	3c 10                	cmp    $0x10,%al
    47e8:	75 07                	jne    47f1 <HuffmanTree_makeTable+0x47d>
    47ea:	b8 37 00 00 00       	mov    $0x37,%eax
    47ef:	eb 11                	jmp    4802 <HuffmanTree_makeTable+0x48e>
  } else {
    /* A good huffman tree has N * 2 - 1 nodes, of which N - 1 are internal nodes.
    If that is not the case (due to too long length codes), the table will not
    have been fully used, and this is an error (not all bit combinations can be
    decoded): an oversubscribed huffman tree, indicated by error 55. */
    for(i = 0; i < size; ++i) {
    47f1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    47f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    47f8:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    47fb:	7c db                	jl     47d8 <HuffmanTree_makeTable+0x464>
      if(tree->table_len[i] == 16) return 55;
    }
  }

  return 0;
    47fd:	b8 00 00 00 00       	mov    $0x0,%eax
}
    4802:	c9                   	leave  
    4803:	c3                   	ret    

00004804 <HuffmanTree_makeFromLengths2>:
/*
Second step for the ...makeFromLengths and ...makeFromFrequencies functions.
numcodes, lengths and maxbitlen must already be filled in correctly. return
value is error.
*/
static unsigned HuffmanTree_makeFromLengths2(HuffmanTree* tree) {
    4804:	55                   	push   %ebp
    4805:	89 e5                	mov    %esp,%ebp
    4807:	56                   	push   %esi
    4808:	53                   	push   %ebx
    4809:	83 ec 20             	sub    $0x20,%esp
  unsigned* blcount;
  unsigned* nextcode;
  unsigned error = 0;
    480c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned bits, n;

  tree->codes = (unsigned*)lodepng_malloc(tree->numcodes * sizeof(unsigned));
    4813:	8b 45 08             	mov    0x8(%ebp),%eax
    4816:	8b 40 0c             	mov    0xc(%eax),%eax
    4819:	c1 e0 02             	shl    $0x2,%eax
    481c:	83 ec 0c             	sub    $0xc,%esp
    481f:	50                   	push   %eax
    4820:	e8 de eb ff ff       	call   3403 <lodepng_malloc>
    4825:	83 c4 10             	add    $0x10,%esp
    4828:	89 c2                	mov    %eax,%edx
    482a:	8b 45 08             	mov    0x8(%ebp),%eax
    482d:	89 10                	mov    %edx,(%eax)
  blcount = (unsigned*)lodepng_malloc((tree->maxbitlen + 1) * sizeof(unsigned));
    482f:	8b 45 08             	mov    0x8(%ebp),%eax
    4832:	8b 40 08             	mov    0x8(%eax),%eax
    4835:	83 c0 01             	add    $0x1,%eax
    4838:	c1 e0 02             	shl    $0x2,%eax
    483b:	83 ec 0c             	sub    $0xc,%esp
    483e:	50                   	push   %eax
    483f:	e8 bf eb ff ff       	call   3403 <lodepng_malloc>
    4844:	83 c4 10             	add    $0x10,%esp
    4847:	89 45 e8             	mov    %eax,-0x18(%ebp)
  nextcode = (unsigned*)lodepng_malloc((tree->maxbitlen + 1) * sizeof(unsigned));
    484a:	8b 45 08             	mov    0x8(%ebp),%eax
    484d:	8b 40 08             	mov    0x8(%eax),%eax
    4850:	83 c0 01             	add    $0x1,%eax
    4853:	c1 e0 02             	shl    $0x2,%eax
    4856:	83 ec 0c             	sub    $0xc,%esp
    4859:	50                   	push   %eax
    485a:	e8 a4 eb ff ff       	call   3403 <lodepng_malloc>
    485f:	83 c4 10             	add    $0x10,%esp
    4862:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(!tree->codes || !blcount || !nextcode) error = 83; /*alloc fail*/
    4865:	8b 45 08             	mov    0x8(%ebp),%eax
    4868:	8b 00                	mov    (%eax),%eax
    486a:	85 c0                	test   %eax,%eax
    486c:	74 0c                	je     487a <HuffmanTree_makeFromLengths2+0x76>
    486e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    4872:	74 06                	je     487a <HuffmanTree_makeFromLengths2+0x76>
    4874:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    4878:	75 07                	jne    4881 <HuffmanTree_makeFromLengths2+0x7d>
    487a:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)

  if(!error) {
    4881:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4885:	0f 85 7d 01 00 00    	jne    4a08 <HuffmanTree_makeFromLengths2+0x204>
    for(n = 0; n != tree->maxbitlen + 1; n++) blcount[n] = nextcode[n] = 0;
    488b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    4892:	eb 2c                	jmp    48c0 <HuffmanTree_makeFromLengths2+0xbc>
    4894:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4897:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    489e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    48a1:	01 c2                	add    %eax,%edx
    48a3:	8b 45 ec             	mov    -0x14(%ebp),%eax
    48a6:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    48ad:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    48b0:	01 c8                	add    %ecx,%eax
    48b2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    48b8:	8b 00                	mov    (%eax),%eax
    48ba:	89 02                	mov    %eax,(%edx)
    48bc:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    48c0:	8b 45 08             	mov    0x8(%ebp),%eax
    48c3:	8b 40 08             	mov    0x8(%eax),%eax
    48c6:	83 c0 01             	add    $0x1,%eax
    48c9:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    48cc:	75 c6                	jne    4894 <HuffmanTree_makeFromLengths2+0x90>
    /*step 1: count number of instances of each code length*/
    for(bits = 0; bits != tree->numcodes; ++bits) ++blcount[tree->lengths[bits]];
    48ce:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    48d5:	eb 27                	jmp    48fe <HuffmanTree_makeFromLengths2+0xfa>
    48d7:	8b 45 08             	mov    0x8(%ebp),%eax
    48da:	8b 40 04             	mov    0x4(%eax),%eax
    48dd:	8b 55 f0             	mov    -0x10(%ebp),%edx
    48e0:	c1 e2 02             	shl    $0x2,%edx
    48e3:	01 d0                	add    %edx,%eax
    48e5:	8b 00                	mov    (%eax),%eax
    48e7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    48ee:	8b 45 e8             	mov    -0x18(%ebp),%eax
    48f1:	01 d0                	add    %edx,%eax
    48f3:	8b 10                	mov    (%eax),%edx
    48f5:	83 c2 01             	add    $0x1,%edx
    48f8:	89 10                	mov    %edx,(%eax)
    48fa:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    48fe:	8b 45 08             	mov    0x8(%ebp),%eax
    4901:	8b 40 0c             	mov    0xc(%eax),%eax
    4904:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    4907:	75 ce                	jne    48d7 <HuffmanTree_makeFromLengths2+0xd3>
    /*step 2: generate the nextcode values*/
    for(bits = 1; bits <= tree->maxbitlen; ++bits) {
    4909:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    4910:	eb 47                	jmp    4959 <HuffmanTree_makeFromLengths2+0x155>
      nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1u;
    4912:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4915:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    491c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    491f:	01 d0                	add    %edx,%eax
    4921:	8b 55 f0             	mov    -0x10(%ebp),%edx
    4924:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    492a:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    4931:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    4934:	01 ca                	add    %ecx,%edx
    4936:	8b 0a                	mov    (%edx),%ecx
    4938:	8b 55 f0             	mov    -0x10(%ebp),%edx
    493b:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    4941:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
    4948:	8b 55 e8             	mov    -0x18(%ebp),%edx
    494b:	01 da                	add    %ebx,%edx
    494d:	8b 12                	mov    (%edx),%edx
    494f:	01 ca                	add    %ecx,%edx
    4951:	01 d2                	add    %edx,%edx
    4953:	89 10                	mov    %edx,(%eax)
  if(!error) {
    for(n = 0; n != tree->maxbitlen + 1; n++) blcount[n] = nextcode[n] = 0;
    /*step 1: count number of instances of each code length*/
    for(bits = 0; bits != tree->numcodes; ++bits) ++blcount[tree->lengths[bits]];
    /*step 2: generate the nextcode values*/
    for(bits = 1; bits <= tree->maxbitlen; ++bits) {
    4955:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    4959:	8b 45 08             	mov    0x8(%ebp),%eax
    495c:	8b 40 08             	mov    0x8(%eax),%eax
    495f:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    4962:	73 ae                	jae    4912 <HuffmanTree_makeFromLengths2+0x10e>
      nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1u;
    }
    /*step 3: generate all the codes*/
    for(n = 0; n != tree->numcodes; ++n) {
    4964:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    496b:	e9 89 00 00 00       	jmp    49f9 <HuffmanTree_makeFromLengths2+0x1f5>
      if(tree->lengths[n] != 0) {
    4970:	8b 45 08             	mov    0x8(%ebp),%eax
    4973:	8b 40 04             	mov    0x4(%eax),%eax
    4976:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4979:	c1 e2 02             	shl    $0x2,%edx
    497c:	01 d0                	add    %edx,%eax
    497e:	8b 00                	mov    (%eax),%eax
    4980:	85 c0                	test   %eax,%eax
    4982:	74 71                	je     49f5 <HuffmanTree_makeFromLengths2+0x1f1>
        tree->codes[n] = nextcode[tree->lengths[n]]++;
    4984:	8b 45 08             	mov    0x8(%ebp),%eax
    4987:	8b 00                	mov    (%eax),%eax
    4989:	8b 55 ec             	mov    -0x14(%ebp),%edx
    498c:	c1 e2 02             	shl    $0x2,%edx
    498f:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    4992:	8b 45 08             	mov    0x8(%ebp),%eax
    4995:	8b 40 04             	mov    0x4(%eax),%eax
    4998:	8b 55 ec             	mov    -0x14(%ebp),%edx
    499b:	c1 e2 02             	shl    $0x2,%edx
    499e:	01 d0                	add    %edx,%eax
    49a0:	8b 00                	mov    (%eax),%eax
    49a2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    49a9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    49ac:	01 c2                	add    %eax,%edx
    49ae:	8b 02                	mov    (%edx),%eax
    49b0:	8d 48 01             	lea    0x1(%eax),%ecx
    49b3:	89 0a                	mov    %ecx,(%edx)
    49b5:	89 03                	mov    %eax,(%ebx)
        /*remove superfluous bits from the code*/
        tree->codes[n] &= ((1u << tree->lengths[n]) - 1u);
    49b7:	8b 45 08             	mov    0x8(%ebp),%eax
    49ba:	8b 00                	mov    (%eax),%eax
    49bc:	8b 55 ec             	mov    -0x14(%ebp),%edx
    49bf:	c1 e2 02             	shl    $0x2,%edx
    49c2:	01 c2                	add    %eax,%edx
    49c4:	8b 45 08             	mov    0x8(%ebp),%eax
    49c7:	8b 00                	mov    (%eax),%eax
    49c9:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    49cc:	c1 e1 02             	shl    $0x2,%ecx
    49cf:	01 c8                	add    %ecx,%eax
    49d1:	8b 18                	mov    (%eax),%ebx
    49d3:	8b 45 08             	mov    0x8(%ebp),%eax
    49d6:	8b 40 04             	mov    0x4(%eax),%eax
    49d9:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    49dc:	c1 e1 02             	shl    $0x2,%ecx
    49df:	01 c8                	add    %ecx,%eax
    49e1:	8b 00                	mov    (%eax),%eax
    49e3:	be 01 00 00 00       	mov    $0x1,%esi
    49e8:	89 c1                	mov    %eax,%ecx
    49ea:	d3 e6                	shl    %cl,%esi
    49ec:	89 f0                	mov    %esi,%eax
    49ee:	83 e8 01             	sub    $0x1,%eax
    49f1:	21 d8                	and    %ebx,%eax
    49f3:	89 02                	mov    %eax,(%edx)
    /*step 2: generate the nextcode values*/
    for(bits = 1; bits <= tree->maxbitlen; ++bits) {
      nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1u;
    }
    /*step 3: generate all the codes*/
    for(n = 0; n != tree->numcodes; ++n) {
    49f5:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    49f9:	8b 45 08             	mov    0x8(%ebp),%eax
    49fc:	8b 40 0c             	mov    0xc(%eax),%eax
    49ff:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    4a02:	0f 85 68 ff ff ff    	jne    4970 <HuffmanTree_makeFromLengths2+0x16c>
        tree->codes[n] &= ((1u << tree->lengths[n]) - 1u);
      }
    }
  }

  lodepng_free(blcount);
    4a08:	83 ec 0c             	sub    $0xc,%esp
    4a0b:	ff 75 e8             	pushl  -0x18(%ebp)
    4a0e:	e8 11 ea ff ff       	call   3424 <lodepng_free>
    4a13:	83 c4 10             	add    $0x10,%esp
  lodepng_free(nextcode);
    4a16:	83 ec 0c             	sub    $0xc,%esp
    4a19:	ff 75 e4             	pushl  -0x1c(%ebp)
    4a1c:	e8 03 ea ff ff       	call   3424 <lodepng_free>
    4a21:	83 c4 10             	add    $0x10,%esp

  if(!error) error = HuffmanTree_makeTable(tree);
    4a24:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4a28:	75 11                	jne    4a3b <HuffmanTree_makeFromLengths2+0x237>
    4a2a:	83 ec 0c             	sub    $0xc,%esp
    4a2d:	ff 75 08             	pushl  0x8(%ebp)
    4a30:	e8 3f f9 ff ff       	call   4374 <HuffmanTree_makeTable>
    4a35:	83 c4 10             	add    $0x10,%esp
    4a38:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return error;
    4a3b:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    4a3e:	8d 65 f8             	lea    -0x8(%ebp),%esp
    4a41:	5b                   	pop    %ebx
    4a42:	5e                   	pop    %esi
    4a43:	5d                   	pop    %ebp
    4a44:	c3                   	ret    

00004a45 <HuffmanTree_makeFromLengths>:
given the code lengths (as stored in the PNG file), generate the tree as defined
by Deflate. maxbitlen is the maximum bits that a code in the tree can have.
return value is error.
*/
static unsigned HuffmanTree_makeFromLengths(HuffmanTree* tree, const unsigned* bitlen,
                                            size_t numcodes, unsigned maxbitlen) {
    4a45:	55                   	push   %ebp
    4a46:	89 e5                	mov    %esp,%ebp
    4a48:	83 ec 18             	sub    $0x18,%esp
  unsigned i;
  tree->lengths = (unsigned*)lodepng_malloc(numcodes * sizeof(unsigned));
    4a4b:	8b 45 10             	mov    0x10(%ebp),%eax
    4a4e:	c1 e0 02             	shl    $0x2,%eax
    4a51:	83 ec 0c             	sub    $0xc,%esp
    4a54:	50                   	push   %eax
    4a55:	e8 a9 e9 ff ff       	call   3403 <lodepng_malloc>
    4a5a:	83 c4 10             	add    $0x10,%esp
    4a5d:	89 c2                	mov    %eax,%edx
    4a5f:	8b 45 08             	mov    0x8(%ebp),%eax
    4a62:	89 50 04             	mov    %edx,0x4(%eax)
  if(!tree->lengths) return 83; /*alloc fail*/
    4a65:	8b 45 08             	mov    0x8(%ebp),%eax
    4a68:	8b 40 04             	mov    0x4(%eax),%eax
    4a6b:	85 c0                	test   %eax,%eax
    4a6d:	75 07                	jne    4a76 <HuffmanTree_makeFromLengths+0x31>
    4a6f:	b8 53 00 00 00       	mov    $0x53,%eax
    4a74:	eb 56                	jmp    4acc <HuffmanTree_makeFromLengths+0x87>
  for(i = 0; i != numcodes; ++i) tree->lengths[i] = bitlen[i];
    4a76:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4a7d:	eb 25                	jmp    4aa4 <HuffmanTree_makeFromLengths+0x5f>
    4a7f:	8b 45 08             	mov    0x8(%ebp),%eax
    4a82:	8b 40 04             	mov    0x4(%eax),%eax
    4a85:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4a88:	c1 e2 02             	shl    $0x2,%edx
    4a8b:	01 c2                	add    %eax,%edx
    4a8d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4a90:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    4a97:	8b 45 0c             	mov    0xc(%ebp),%eax
    4a9a:	01 c8                	add    %ecx,%eax
    4a9c:	8b 00                	mov    (%eax),%eax
    4a9e:	89 02                	mov    %eax,(%edx)
    4aa0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4aa4:	8b 45 10             	mov    0x10(%ebp),%eax
    4aa7:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    4aaa:	75 d3                	jne    4a7f <HuffmanTree_makeFromLengths+0x3a>
  tree->numcodes = (unsigned)numcodes; /*number of symbols*/
    4aac:	8b 55 10             	mov    0x10(%ebp),%edx
    4aaf:	8b 45 08             	mov    0x8(%ebp),%eax
    4ab2:	89 50 0c             	mov    %edx,0xc(%eax)
  tree->maxbitlen = maxbitlen;
    4ab5:	8b 45 08             	mov    0x8(%ebp),%eax
    4ab8:	8b 55 14             	mov    0x14(%ebp),%edx
    4abb:	89 50 08             	mov    %edx,0x8(%eax)
  return HuffmanTree_makeFromLengths2(tree);
    4abe:	83 ec 0c             	sub    $0xc,%esp
    4ac1:	ff 75 08             	pushl  0x8(%ebp)
    4ac4:	e8 3b fd ff ff       	call   4804 <HuffmanTree_makeFromLengths2>
    4ac9:	83 c4 10             	add    $0x10,%esp
}
    4acc:	c9                   	leave  
    4acd:	c3                   	ret    

00004ace <bpmnode_create>:
  BPMNode** chains0;
  BPMNode** chains1;
} BPMLists;

/*creates a new chain node with the given parameters, from the memory in the lists */
static BPMNode* bpmnode_create(BPMLists* lists, int weight, unsigned index, BPMNode* tail) {
    4ace:	55                   	push   %ebp
    4acf:	89 e5                	mov    %esp,%ebp
    4ad1:	53                   	push   %ebx
    4ad2:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  BPMNode* result;

  /*memory full, so garbage collect*/
  if(lists->nextfree >= lists->numfree) {
    4ad5:	8b 45 08             	mov    0x8(%ebp),%eax
    4ad8:	8b 50 0c             	mov    0xc(%eax),%edx
    4adb:	8b 45 08             	mov    0x8(%ebp),%eax
    4ade:	8b 40 08             	mov    0x8(%eax),%eax
    4ae1:	39 c2                	cmp    %eax,%edx
    4ae3:	0f 82 0b 01 00 00    	jb     4bf4 <bpmnode_create+0x126>
    /*mark only those that are in use*/
    for(i = 0; i != lists->memsize; ++i) lists->memory[i].in_use = 0;
    4ae9:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    4af0:	eb 19                	jmp    4b0b <bpmnode_create+0x3d>
    4af2:	8b 45 08             	mov    0x8(%ebp),%eax
    4af5:	8b 40 04             	mov    0x4(%eax),%eax
    4af8:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4afb:	c1 e2 04             	shl    $0x4,%edx
    4afe:	01 d0                	add    %edx,%eax
    4b00:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    4b07:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    4b0b:	8b 45 08             	mov    0x8(%ebp),%eax
    4b0e:	8b 00                	mov    (%eax),%eax
    4b10:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    4b13:	75 dd                	jne    4af2 <bpmnode_create+0x24>
    for(i = 0; i != lists->listsize; ++i) {
    4b15:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    4b1c:	eb 60                	jmp    4b7e <bpmnode_create+0xb0>
      BPMNode* node;
      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;
    4b1e:	8b 45 08             	mov    0x8(%ebp),%eax
    4b21:	8b 40 18             	mov    0x18(%eax),%eax
    4b24:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4b27:	c1 e2 02             	shl    $0x2,%edx
    4b2a:	01 d0                	add    %edx,%eax
    4b2c:	8b 00                	mov    (%eax),%eax
    4b2e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4b31:	eb 13                	jmp    4b46 <bpmnode_create+0x78>
    4b33:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4b36:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
    4b3d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4b40:	8b 40 08             	mov    0x8(%eax),%eax
    4b43:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4b46:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4b4a:	75 e7                	jne    4b33 <bpmnode_create+0x65>
      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;
    4b4c:	8b 45 08             	mov    0x8(%ebp),%eax
    4b4f:	8b 40 1c             	mov    0x1c(%eax),%eax
    4b52:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4b55:	c1 e2 02             	shl    $0x2,%edx
    4b58:	01 d0                	add    %edx,%eax
    4b5a:	8b 00                	mov    (%eax),%eax
    4b5c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4b5f:	eb 13                	jmp    4b74 <bpmnode_create+0xa6>
    4b61:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4b64:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
    4b6b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4b6e:	8b 40 08             	mov    0x8(%eax),%eax
    4b71:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4b74:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4b78:	75 e7                	jne    4b61 <bpmnode_create+0x93>

  /*memory full, so garbage collect*/
  if(lists->nextfree >= lists->numfree) {
    /*mark only those that are in use*/
    for(i = 0; i != lists->memsize; ++i) lists->memory[i].in_use = 0;
    for(i = 0; i != lists->listsize; ++i) {
    4b7a:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    4b7e:	8b 45 08             	mov    0x8(%ebp),%eax
    4b81:	8b 40 14             	mov    0x14(%eax),%eax
    4b84:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    4b87:	75 95                	jne    4b1e <bpmnode_create+0x50>
      BPMNode* node;
      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;
      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;
    }
    /*collect those that are free*/
    lists->numfree = 0;
    4b89:	8b 45 08             	mov    0x8(%ebp),%eax
    4b8c:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    for(i = 0; i != lists->memsize; ++i) {
    4b93:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    4b9a:	eb 44                	jmp    4be0 <bpmnode_create+0x112>
      if(!lists->memory[i].in_use) lists->freelist[lists->numfree++] = &lists->memory[i];
    4b9c:	8b 45 08             	mov    0x8(%ebp),%eax
    4b9f:	8b 40 04             	mov    0x4(%eax),%eax
    4ba2:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4ba5:	c1 e2 04             	shl    $0x4,%edx
    4ba8:	01 d0                	add    %edx,%eax
    4baa:	8b 40 0c             	mov    0xc(%eax),%eax
    4bad:	85 c0                	test   %eax,%eax
    4baf:	75 2b                	jne    4bdc <bpmnode_create+0x10e>
    4bb1:	8b 45 08             	mov    0x8(%ebp),%eax
    4bb4:	8b 58 10             	mov    0x10(%eax),%ebx
    4bb7:	8b 45 08             	mov    0x8(%ebp),%eax
    4bba:	8b 40 08             	mov    0x8(%eax),%eax
    4bbd:	8d 48 01             	lea    0x1(%eax),%ecx
    4bc0:	8b 55 08             	mov    0x8(%ebp),%edx
    4bc3:	89 4a 08             	mov    %ecx,0x8(%edx)
    4bc6:	c1 e0 02             	shl    $0x2,%eax
    4bc9:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    4bcc:	8b 45 08             	mov    0x8(%ebp),%eax
    4bcf:	8b 40 04             	mov    0x4(%eax),%eax
    4bd2:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    4bd5:	c1 e1 04             	shl    $0x4,%ecx
    4bd8:	01 c8                	add    %ecx,%eax
    4bda:	89 02                	mov    %eax,(%edx)
      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;
      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;
    }
    /*collect those that are free*/
    lists->numfree = 0;
    for(i = 0; i != lists->memsize; ++i) {
    4bdc:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    4be0:	8b 45 08             	mov    0x8(%ebp),%eax
    4be3:	8b 00                	mov    (%eax),%eax
    4be5:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    4be8:	75 b2                	jne    4b9c <bpmnode_create+0xce>
      if(!lists->memory[i].in_use) lists->freelist[lists->numfree++] = &lists->memory[i];
    }
    lists->nextfree = 0;
    4bea:	8b 45 08             	mov    0x8(%ebp),%eax
    4bed:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  }

  result = lists->freelist[lists->nextfree++];
    4bf4:	8b 45 08             	mov    0x8(%ebp),%eax
    4bf7:	8b 58 10             	mov    0x10(%eax),%ebx
    4bfa:	8b 45 08             	mov    0x8(%ebp),%eax
    4bfd:	8b 40 0c             	mov    0xc(%eax),%eax
    4c00:	8d 48 01             	lea    0x1(%eax),%ecx
    4c03:	8b 55 08             	mov    0x8(%ebp),%edx
    4c06:	89 4a 0c             	mov    %ecx,0xc(%edx)
    4c09:	c1 e0 02             	shl    $0x2,%eax
    4c0c:	01 d8                	add    %ebx,%eax
    4c0e:	8b 00                	mov    (%eax),%eax
    4c10:	89 45 f0             	mov    %eax,-0x10(%ebp)
  result->weight = weight;
    4c13:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4c16:	8b 55 0c             	mov    0xc(%ebp),%edx
    4c19:	89 10                	mov    %edx,(%eax)
  result->index = index;
    4c1b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4c1e:	8b 55 10             	mov    0x10(%ebp),%edx
    4c21:	89 50 04             	mov    %edx,0x4(%eax)
  result->tail = tail;
    4c24:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4c27:	8b 55 14             	mov    0x14(%ebp),%edx
    4c2a:	89 50 08             	mov    %edx,0x8(%eax)
  return result;
    4c2d:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    4c30:	83 c4 10             	add    $0x10,%esp
    4c33:	5b                   	pop    %ebx
    4c34:	5d                   	pop    %ebp
    4c35:	c3                   	ret    

00004c36 <bpmnode_sort>:

/*sort the leaves with stable mergesort*/
static void bpmnode_sort(BPMNode* leaves, size_t num) {
    4c36:	55                   	push   %ebp
    4c37:	89 e5                	mov    %esp,%ebp
    4c39:	83 ec 38             	sub    $0x38,%esp
  BPMNode* mem = (BPMNode*)lodepng_malloc(sizeof(*leaves) * num);
    4c3c:	8b 45 0c             	mov    0xc(%ebp),%eax
    4c3f:	c1 e0 04             	shl    $0x4,%eax
    4c42:	83 ec 0c             	sub    $0xc,%esp
    4c45:	50                   	push   %eax
    4c46:	e8 b8 e7 ff ff       	call   3403 <lodepng_malloc>
    4c4b:	83 c4 10             	add    $0x10,%esp
    4c4e:	89 45 dc             	mov    %eax,-0x24(%ebp)
  size_t width, counter = 0;
    4c51:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  for(width = 1; width < num; width *= 2) {
    4c58:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
    4c5f:	e9 41 01 00 00       	jmp    4da5 <bpmnode_sort+0x16f>
    BPMNode* a = (counter & 1) ? mem : leaves;
    4c64:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4c67:	83 e0 01             	and    $0x1,%eax
    4c6a:	85 c0                	test   %eax,%eax
    4c6c:	74 05                	je     4c73 <bpmnode_sort+0x3d>
    4c6e:	8b 45 dc             	mov    -0x24(%ebp),%eax
    4c71:	eb 03                	jmp    4c76 <bpmnode_sort+0x40>
    4c73:	8b 45 08             	mov    0x8(%ebp),%eax
    4c76:	89 45 d8             	mov    %eax,-0x28(%ebp)
    BPMNode* b = (counter & 1) ? leaves : mem;
    4c79:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4c7c:	83 e0 01             	and    $0x1,%eax
    4c7f:	85 c0                	test   %eax,%eax
    4c81:	74 05                	je     4c88 <bpmnode_sort+0x52>
    4c83:	8b 45 08             	mov    0x8(%ebp),%eax
    4c86:	eb 03                	jmp    4c8b <bpmnode_sort+0x55>
    4c88:	8b 45 dc             	mov    -0x24(%ebp),%eax
    4c8b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    size_t p;
    for(p = 0; p < num; p += 2 * width) {
    4c8e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    4c95:	e9 f8 00 00 00       	jmp    4d92 <bpmnode_sort+0x15c>
      size_t q = (p + width > num) ? num : (p + width);
    4c9a:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4c9d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4ca0:	01 c2                	add    %eax,%edx
    4ca2:	8b 45 0c             	mov    0xc(%ebp),%eax
    4ca5:	39 c2                	cmp    %eax,%edx
    4ca7:	0f 4e c2             	cmovle %edx,%eax
    4caa:	89 45 d0             	mov    %eax,-0x30(%ebp)
      size_t r = (p + 2 * width > num) ? num : (p + 2 * width);
    4cad:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4cb0:	8d 14 00             	lea    (%eax,%eax,1),%edx
    4cb3:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4cb6:	01 c2                	add    %eax,%edx
    4cb8:	8b 45 0c             	mov    0xc(%ebp),%eax
    4cbb:	39 c2                	cmp    %eax,%edx
    4cbd:	0f 4e c2             	cmovle %edx,%eax
    4cc0:	89 45 cc             	mov    %eax,-0x34(%ebp)
      size_t i = p, j = q, k;
    4cc3:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4cc6:	89 45 e8             	mov    %eax,-0x18(%ebp)
    4cc9:	8b 45 d0             	mov    -0x30(%ebp),%eax
    4ccc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      for(k = p; k < r; k++) {
    4ccf:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4cd2:	89 45 e0             	mov    %eax,-0x20(%ebp)
    4cd5:	e9 a4 00 00 00       	jmp    4d7e <bpmnode_sort+0x148>
        if(i < q && (j >= r || a[i].weight <= a[j].weight)) b[k] = a[i++];
    4cda:	8b 45 e8             	mov    -0x18(%ebp),%eax
    4cdd:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    4ce0:	7d 62                	jge    4d44 <bpmnode_sort+0x10e>
    4ce2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4ce5:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    4ce8:	7d 22                	jge    4d0c <bpmnode_sort+0xd6>
    4cea:	8b 45 e8             	mov    -0x18(%ebp),%eax
    4ced:	c1 e0 04             	shl    $0x4,%eax
    4cf0:	89 c2                	mov    %eax,%edx
    4cf2:	8b 45 d8             	mov    -0x28(%ebp),%eax
    4cf5:	01 d0                	add    %edx,%eax
    4cf7:	8b 10                	mov    (%eax),%edx
    4cf9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4cfc:	c1 e0 04             	shl    $0x4,%eax
    4cff:	89 c1                	mov    %eax,%ecx
    4d01:	8b 45 d8             	mov    -0x28(%ebp),%eax
    4d04:	01 c8                	add    %ecx,%eax
    4d06:	8b 00                	mov    (%eax),%eax
    4d08:	39 c2                	cmp    %eax,%edx
    4d0a:	7f 38                	jg     4d44 <bpmnode_sort+0x10e>
    4d0c:	8b 45 e0             	mov    -0x20(%ebp),%eax
    4d0f:	c1 e0 04             	shl    $0x4,%eax
    4d12:	89 c2                	mov    %eax,%edx
    4d14:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    4d17:	01 d0                	add    %edx,%eax
    4d19:	8b 55 e8             	mov    -0x18(%ebp),%edx
    4d1c:	8d 4a 01             	lea    0x1(%edx),%ecx
    4d1f:	89 4d e8             	mov    %ecx,-0x18(%ebp)
    4d22:	89 d1                	mov    %edx,%ecx
    4d24:	c1 e1 04             	shl    $0x4,%ecx
    4d27:	8b 55 d8             	mov    -0x28(%ebp),%edx
    4d2a:	01 ca                	add    %ecx,%edx
    4d2c:	8b 0a                	mov    (%edx),%ecx
    4d2e:	89 08                	mov    %ecx,(%eax)
    4d30:	8b 4a 04             	mov    0x4(%edx),%ecx
    4d33:	89 48 04             	mov    %ecx,0x4(%eax)
    4d36:	8b 4a 08             	mov    0x8(%edx),%ecx
    4d39:	89 48 08             	mov    %ecx,0x8(%eax)
    4d3c:	8b 52 0c             	mov    0xc(%edx),%edx
    4d3f:	89 50 0c             	mov    %edx,0xc(%eax)
    4d42:	eb 36                	jmp    4d7a <bpmnode_sort+0x144>
        else b[k] = a[j++];
    4d44:	8b 45 e0             	mov    -0x20(%ebp),%eax
    4d47:	c1 e0 04             	shl    $0x4,%eax
    4d4a:	89 c2                	mov    %eax,%edx
    4d4c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    4d4f:	01 d0                	add    %edx,%eax
    4d51:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    4d54:	8d 4a 01             	lea    0x1(%edx),%ecx
    4d57:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
    4d5a:	89 d1                	mov    %edx,%ecx
    4d5c:	c1 e1 04             	shl    $0x4,%ecx
    4d5f:	8b 55 d8             	mov    -0x28(%ebp),%edx
    4d62:	01 ca                	add    %ecx,%edx
    4d64:	8b 0a                	mov    (%edx),%ecx
    4d66:	89 08                	mov    %ecx,(%eax)
    4d68:	8b 4a 04             	mov    0x4(%edx),%ecx
    4d6b:	89 48 04             	mov    %ecx,0x4(%eax)
    4d6e:	8b 4a 08             	mov    0x8(%edx),%ecx
    4d71:	89 48 08             	mov    %ecx,0x8(%eax)
    4d74:	8b 52 0c             	mov    0xc(%edx),%edx
    4d77:	89 50 0c             	mov    %edx,0xc(%eax)
    size_t p;
    for(p = 0; p < num; p += 2 * width) {
      size_t q = (p + width > num) ? num : (p + width);
      size_t r = (p + 2 * width > num) ? num : (p + 2 * width);
      size_t i = p, j = q, k;
      for(k = p; k < r; k++) {
    4d7a:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
    4d7e:	8b 45 e0             	mov    -0x20(%ebp),%eax
    4d81:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    4d84:	0f 8c 50 ff ff ff    	jl     4cda <bpmnode_sort+0xa4>
  size_t width, counter = 0;
  for(width = 1; width < num; width *= 2) {
    BPMNode* a = (counter & 1) ? mem : leaves;
    BPMNode* b = (counter & 1) ? leaves : mem;
    size_t p;
    for(p = 0; p < num; p += 2 * width) {
    4d8a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4d8d:	01 c0                	add    %eax,%eax
    4d8f:	01 45 ec             	add    %eax,-0x14(%ebp)
    4d92:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4d95:	3b 45 0c             	cmp    0xc(%ebp),%eax
    4d98:	0f 8c fc fe ff ff    	jl     4c9a <bpmnode_sort+0x64>
      for(k = p; k < r; k++) {
        if(i < q && (j >= r || a[i].weight <= a[j].weight)) b[k] = a[i++];
        else b[k] = a[j++];
      }
    }
    counter++;
    4d9e:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)

/*sort the leaves with stable mergesort*/
static void bpmnode_sort(BPMNode* leaves, size_t num) {
  BPMNode* mem = (BPMNode*)lodepng_malloc(sizeof(*leaves) * num);
  size_t width, counter = 0;
  for(width = 1; width < num; width *= 2) {
    4da2:	d1 65 f4             	shll   -0xc(%ebp)
    4da5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4da8:	3b 45 0c             	cmp    0xc(%ebp),%eax
    4dab:	0f 8c b3 fe ff ff    	jl     4c64 <bpmnode_sort+0x2e>
        else b[k] = a[j++];
      }
    }
    counter++;
  }
  if(counter & 1) lodepng_memcpy(leaves, mem, sizeof(*leaves) * num);
    4db1:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4db4:	83 e0 01             	and    $0x1,%eax
    4db7:	85 c0                	test   %eax,%eax
    4db9:	74 18                	je     4dd3 <bpmnode_sort+0x19d>
    4dbb:	8b 45 0c             	mov    0xc(%ebp),%eax
    4dbe:	c1 e0 04             	shl    $0x4,%eax
    4dc1:	83 ec 04             	sub    $0x4,%esp
    4dc4:	50                   	push   %eax
    4dc5:	ff 75 dc             	pushl  -0x24(%ebp)
    4dc8:	ff 75 08             	pushl  0x8(%ebp)
    4dcb:	e8 71 e6 ff ff       	call   3441 <lodepng_memcpy>
    4dd0:	83 c4 10             	add    $0x10,%esp
  lodepng_free(mem);
    4dd3:	83 ec 0c             	sub    $0xc,%esp
    4dd6:	ff 75 dc             	pushl  -0x24(%ebp)
    4dd9:	e8 46 e6 ff ff       	call   3424 <lodepng_free>
    4dde:	83 c4 10             	add    $0x10,%esp
}
    4de1:	90                   	nop
    4de2:	c9                   	leave  
    4de3:	c3                   	ret    

00004de4 <boundaryPM>:

/*Boundary Package Merge step, numpresent is the amount of leaves, and c is the current chain.*/
static void boundaryPM(BPMLists* lists, BPMNode* leaves, size_t numpresent, int c, int num) {
    4de4:	55                   	push   %ebp
    4de5:	89 e5                	mov    %esp,%ebp
    4de7:	56                   	push   %esi
    4de8:	53                   	push   %ebx
    4de9:	83 ec 10             	sub    $0x10,%esp
  unsigned lastindex = lists->chains1[c]->index;
    4dec:	8b 45 08             	mov    0x8(%ebp),%eax
    4def:	8b 40 1c             	mov    0x1c(%eax),%eax
    4df2:	8b 55 14             	mov    0x14(%ebp),%edx
    4df5:	c1 e2 02             	shl    $0x2,%edx
    4df8:	01 d0                	add    %edx,%eax
    4dfa:	8b 00                	mov    (%eax),%eax
    4dfc:	8b 40 04             	mov    0x4(%eax),%eax
    4dff:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(c == 0) {
    4e02:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    4e06:	75 66                	jne    4e6e <boundaryPM+0x8a>
    if(lastindex >= numpresent) return;
    4e08:	8b 45 10             	mov    0x10(%ebp),%eax
    4e0b:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    4e0e:	0f 83 a0 01 00 00    	jae    4fb4 <boundaryPM+0x1d0>
    lists->chains0[c] = lists->chains1[c];
    4e14:	8b 45 08             	mov    0x8(%ebp),%eax
    4e17:	8b 40 18             	mov    0x18(%eax),%eax
    4e1a:	8b 55 14             	mov    0x14(%ebp),%edx
    4e1d:	c1 e2 02             	shl    $0x2,%edx
    4e20:	01 c2                	add    %eax,%edx
    4e22:	8b 45 08             	mov    0x8(%ebp),%eax
    4e25:	8b 40 1c             	mov    0x1c(%eax),%eax
    4e28:	8b 4d 14             	mov    0x14(%ebp),%ecx
    4e2b:	c1 e1 02             	shl    $0x2,%ecx
    4e2e:	01 c8                	add    %ecx,%eax
    4e30:	8b 00                	mov    (%eax),%eax
    4e32:	89 02                	mov    %eax,(%edx)
    lists->chains1[c] = bpmnode_create(lists, leaves[lastindex].weight, lastindex + 1, 0);
    4e34:	8b 45 08             	mov    0x8(%ebp),%eax
    4e37:	8b 40 1c             	mov    0x1c(%eax),%eax
    4e3a:	8b 55 14             	mov    0x14(%ebp),%edx
    4e3d:	c1 e2 02             	shl    $0x2,%edx
    4e40:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    4e43:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4e46:	8d 50 01             	lea    0x1(%eax),%edx
    4e49:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4e4c:	c1 e0 04             	shl    $0x4,%eax
    4e4f:	89 c1                	mov    %eax,%ecx
    4e51:	8b 45 0c             	mov    0xc(%ebp),%eax
    4e54:	01 c8                	add    %ecx,%eax
    4e56:	8b 00                	mov    (%eax),%eax
    4e58:	6a 00                	push   $0x0
    4e5a:	52                   	push   %edx
    4e5b:	50                   	push   %eax
    4e5c:	ff 75 08             	pushl  0x8(%ebp)
    4e5f:	e8 6a fc ff ff       	call   4ace <bpmnode_create>
    4e64:	83 c4 10             	add    $0x10,%esp
    4e67:	89 03                	mov    %eax,(%ebx)
    4e69:	e9 47 01 00 00       	jmp    4fb5 <boundaryPM+0x1d1>
  } else {
    /*sum of the weights of the head nodes of the previous lookahead chains.*/
    int sum = lists->chains0[c - 1]->weight + lists->chains1[c - 1]->weight;
    4e6e:	8b 45 08             	mov    0x8(%ebp),%eax
    4e71:	8b 40 18             	mov    0x18(%eax),%eax
    4e74:	8b 55 14             	mov    0x14(%ebp),%edx
    4e77:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    4e7d:	c1 e2 02             	shl    $0x2,%edx
    4e80:	01 d0                	add    %edx,%eax
    4e82:	8b 00                	mov    (%eax),%eax
    4e84:	8b 10                	mov    (%eax),%edx
    4e86:	8b 45 08             	mov    0x8(%ebp),%eax
    4e89:	8b 40 1c             	mov    0x1c(%eax),%eax
    4e8c:	8b 4d 14             	mov    0x14(%ebp),%ecx
    4e8f:	81 c1 ff ff ff 3f    	add    $0x3fffffff,%ecx
    4e95:	c1 e1 02             	shl    $0x2,%ecx
    4e98:	01 c8                	add    %ecx,%eax
    4e9a:	8b 00                	mov    (%eax),%eax
    4e9c:	8b 00                	mov    (%eax),%eax
    4e9e:	01 d0                	add    %edx,%eax
    4ea0:	89 45 f0             	mov    %eax,-0x10(%ebp)
    lists->chains0[c] = lists->chains1[c];
    4ea3:	8b 45 08             	mov    0x8(%ebp),%eax
    4ea6:	8b 40 18             	mov    0x18(%eax),%eax
    4ea9:	8b 55 14             	mov    0x14(%ebp),%edx
    4eac:	c1 e2 02             	shl    $0x2,%edx
    4eaf:	01 c2                	add    %eax,%edx
    4eb1:	8b 45 08             	mov    0x8(%ebp),%eax
    4eb4:	8b 40 1c             	mov    0x1c(%eax),%eax
    4eb7:	8b 4d 14             	mov    0x14(%ebp),%ecx
    4eba:	c1 e1 02             	shl    $0x2,%ecx
    4ebd:	01 c8                	add    %ecx,%eax
    4ebf:	8b 00                	mov    (%eax),%eax
    4ec1:	89 02                	mov    %eax,(%edx)
    if(lastindex < numpresent && sum > leaves[lastindex].weight) {
    4ec3:	8b 45 10             	mov    0x10(%ebp),%eax
    4ec6:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    4ec9:	73 60                	jae    4f2b <boundaryPM+0x147>
    4ecb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4ece:	c1 e0 04             	shl    $0x4,%eax
    4ed1:	89 c2                	mov    %eax,%edx
    4ed3:	8b 45 0c             	mov    0xc(%ebp),%eax
    4ed6:	01 d0                	add    %edx,%eax
    4ed8:	8b 00                	mov    (%eax),%eax
    4eda:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    4edd:	7d 4c                	jge    4f2b <boundaryPM+0x147>
      lists->chains1[c] = bpmnode_create(lists, leaves[lastindex].weight, lastindex + 1, lists->chains1[c]->tail);
    4edf:	8b 45 08             	mov    0x8(%ebp),%eax
    4ee2:	8b 40 1c             	mov    0x1c(%eax),%eax
    4ee5:	8b 55 14             	mov    0x14(%ebp),%edx
    4ee8:	c1 e2 02             	shl    $0x2,%edx
    4eeb:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    4eee:	8b 45 08             	mov    0x8(%ebp),%eax
    4ef1:	8b 40 1c             	mov    0x1c(%eax),%eax
    4ef4:	8b 55 14             	mov    0x14(%ebp),%edx
    4ef7:	c1 e2 02             	shl    $0x2,%edx
    4efa:	01 d0                	add    %edx,%eax
    4efc:	8b 00                	mov    (%eax),%eax
    4efe:	8b 50 08             	mov    0x8(%eax),%edx
    4f01:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4f04:	8d 48 01             	lea    0x1(%eax),%ecx
    4f07:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4f0a:	c1 e0 04             	shl    $0x4,%eax
    4f0d:	89 c6                	mov    %eax,%esi
    4f0f:	8b 45 0c             	mov    0xc(%ebp),%eax
    4f12:	01 f0                	add    %esi,%eax
    4f14:	8b 00                	mov    (%eax),%eax
    4f16:	52                   	push   %edx
    4f17:	51                   	push   %ecx
    4f18:	50                   	push   %eax
    4f19:	ff 75 08             	pushl  0x8(%ebp)
    4f1c:	e8 ad fb ff ff       	call   4ace <bpmnode_create>
    4f21:	83 c4 10             	add    $0x10,%esp
    4f24:	89 03                	mov    %eax,(%ebx)
      return;
    4f26:	e9 8a 00 00 00       	jmp    4fb5 <boundaryPM+0x1d1>
    }
    lists->chains1[c] = bpmnode_create(lists, sum, lastindex, lists->chains1[c - 1]);
    4f2b:	8b 45 08             	mov    0x8(%ebp),%eax
    4f2e:	8b 40 1c             	mov    0x1c(%eax),%eax
    4f31:	8b 55 14             	mov    0x14(%ebp),%edx
    4f34:	c1 e2 02             	shl    $0x2,%edx
    4f37:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    4f3a:	8b 45 08             	mov    0x8(%ebp),%eax
    4f3d:	8b 40 1c             	mov    0x1c(%eax),%eax
    4f40:	8b 55 14             	mov    0x14(%ebp),%edx
    4f43:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    4f49:	c1 e2 02             	shl    $0x2,%edx
    4f4c:	01 d0                	add    %edx,%eax
    4f4e:	8b 00                	mov    (%eax),%eax
    4f50:	50                   	push   %eax
    4f51:	ff 75 f4             	pushl  -0xc(%ebp)
    4f54:	ff 75 f0             	pushl  -0x10(%ebp)
    4f57:	ff 75 08             	pushl  0x8(%ebp)
    4f5a:	e8 6f fb ff ff       	call   4ace <bpmnode_create>
    4f5f:	83 c4 10             	add    $0x10,%esp
    4f62:	89 03                	mov    %eax,(%ebx)
    /*in the end we are only interested in the chain of the last list, so no
    need to recurse if we're at the last one (this gives measurable speedup)*/
    if(num + 1 < (int)(2 * numpresent - 2)) {
    4f64:	8b 45 18             	mov    0x18(%ebp),%eax
    4f67:	8d 50 01             	lea    0x1(%eax),%edx
    4f6a:	8b 45 10             	mov    0x10(%ebp),%eax
    4f6d:	83 e8 01             	sub    $0x1,%eax
    4f70:	01 c0                	add    %eax,%eax
    4f72:	39 c2                	cmp    %eax,%edx
    4f74:	7d 3f                	jge    4fb5 <boundaryPM+0x1d1>
      boundaryPM(lists, leaves, numpresent, c - 1, num);
    4f76:	8b 45 14             	mov    0x14(%ebp),%eax
    4f79:	83 e8 01             	sub    $0x1,%eax
    4f7c:	83 ec 0c             	sub    $0xc,%esp
    4f7f:	ff 75 18             	pushl  0x18(%ebp)
    4f82:	50                   	push   %eax
    4f83:	ff 75 10             	pushl  0x10(%ebp)
    4f86:	ff 75 0c             	pushl  0xc(%ebp)
    4f89:	ff 75 08             	pushl  0x8(%ebp)
    4f8c:	e8 53 fe ff ff       	call   4de4 <boundaryPM>
    4f91:	83 c4 20             	add    $0x20,%esp
      boundaryPM(lists, leaves, numpresent, c - 1, num);
    4f94:	8b 45 14             	mov    0x14(%ebp),%eax
    4f97:	83 e8 01             	sub    $0x1,%eax
    4f9a:	83 ec 0c             	sub    $0xc,%esp
    4f9d:	ff 75 18             	pushl  0x18(%ebp)
    4fa0:	50                   	push   %eax
    4fa1:	ff 75 10             	pushl  0x10(%ebp)
    4fa4:	ff 75 0c             	pushl  0xc(%ebp)
    4fa7:	ff 75 08             	pushl  0x8(%ebp)
    4faa:	e8 35 fe ff ff       	call   4de4 <boundaryPM>
    4faf:	83 c4 20             	add    $0x20,%esp
    4fb2:	eb 01                	jmp    4fb5 <boundaryPM+0x1d1>
/*Boundary Package Merge step, numpresent is the amount of leaves, and c is the current chain.*/
static void boundaryPM(BPMLists* lists, BPMNode* leaves, size_t numpresent, int c, int num) {
  unsigned lastindex = lists->chains1[c]->index;

  if(c == 0) {
    if(lastindex >= numpresent) return;
    4fb4:	90                   	nop
    if(num + 1 < (int)(2 * numpresent - 2)) {
      boundaryPM(lists, leaves, numpresent, c - 1, num);
      boundaryPM(lists, leaves, numpresent, c - 1, num);
    }
  }
}
    4fb5:	8d 65 f8             	lea    -0x8(%ebp),%esp
    4fb8:	5b                   	pop    %ebx
    4fb9:	5e                   	pop    %esi
    4fba:	5d                   	pop    %ebp
    4fbb:	c3                   	ret    

00004fbc <lodepng_huffman_code_lengths>:

unsigned lodepng_huffman_code_lengths(unsigned* lengths, const unsigned* frequencies,
                                      size_t numcodes, unsigned maxbitlen) {
    4fbc:	55                   	push   %ebp
    4fbd:	89 e5                	mov    %esp,%ebp
    4fbf:	83 ec 48             	sub    $0x48,%esp
  unsigned error = 0;
    4fc2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned i;
  size_t numpresent = 0; /*number of symbols with non-zero frequency*/
    4fc9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  BPMNode* leaves; /*the symbols, only those with > 0 frequency*/

  if(numcodes == 0) return 80; /*error: a tree of 0 symbols is not supposed to be made*/
    4fd0:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    4fd4:	75 0a                	jne    4fe0 <lodepng_huffman_code_lengths+0x24>
    4fd6:	b8 50 00 00 00       	mov    $0x50,%eax
    4fdb:	e9 4d 03 00 00       	jmp    532d <lodepng_huffman_code_lengths+0x371>
  if((1u << maxbitlen) < (unsigned)numcodes) return 80; /*error: represent all symbols*/
    4fe0:	8b 45 14             	mov    0x14(%ebp),%eax
    4fe3:	ba 01 00 00 00       	mov    $0x1,%edx
    4fe8:	89 c1                	mov    %eax,%ecx
    4fea:	d3 e2                	shl    %cl,%edx
    4fec:	8b 45 10             	mov    0x10(%ebp),%eax
    4fef:	39 c2                	cmp    %eax,%edx
    4ff1:	73 0a                	jae    4ffd <lodepng_huffman_code_lengths+0x41>
    4ff3:	b8 50 00 00 00       	mov    $0x50,%eax
    4ff8:	e9 30 03 00 00       	jmp    532d <lodepng_huffman_code_lengths+0x371>

  leaves = (BPMNode*)lodepng_malloc(numcodes * sizeof(*leaves));
    4ffd:	8b 45 10             	mov    0x10(%ebp),%eax
    5000:	c1 e0 04             	shl    $0x4,%eax
    5003:	83 ec 0c             	sub    $0xc,%esp
    5006:	50                   	push   %eax
    5007:	e8 f7 e3 ff ff       	call   3403 <lodepng_malloc>
    500c:	83 c4 10             	add    $0x10,%esp
    500f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(!leaves) return 83; /*alloc fail*/
    5012:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    5016:	75 0a                	jne    5022 <lodepng_huffman_code_lengths+0x66>
    5018:	b8 53 00 00 00       	mov    $0x53,%eax
    501d:	e9 0b 03 00 00       	jmp    532d <lodepng_huffman_code_lengths+0x371>

  for(i = 0; i != numcodes; ++i) {
    5022:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    5029:	eb 50                	jmp    507b <lodepng_huffman_code_lengths+0xbf>
    if(frequencies[i] > 0) {
    502b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    502e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5035:	8b 45 0c             	mov    0xc(%ebp),%eax
    5038:	01 d0                	add    %edx,%eax
    503a:	8b 00                	mov    (%eax),%eax
    503c:	85 c0                	test   %eax,%eax
    503e:	74 37                	je     5077 <lodepng_huffman_code_lengths+0xbb>
      leaves[numpresent].weight = (int)frequencies[i];
    5040:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5043:	c1 e0 04             	shl    $0x4,%eax
    5046:	89 c2                	mov    %eax,%edx
    5048:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    504b:	01 d0                	add    %edx,%eax
    504d:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5050:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    5057:	8b 55 0c             	mov    0xc(%ebp),%edx
    505a:	01 ca                	add    %ecx,%edx
    505c:	8b 12                	mov    (%edx),%edx
    505e:	89 10                	mov    %edx,(%eax)
      leaves[numpresent].index = i;
    5060:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5063:	c1 e0 04             	shl    $0x4,%eax
    5066:	89 c2                	mov    %eax,%edx
    5068:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    506b:	01 c2                	add    %eax,%edx
    506d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5070:	89 42 04             	mov    %eax,0x4(%edx)
      ++numpresent;
    5073:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
  if((1u << maxbitlen) < (unsigned)numcodes) return 80; /*error: represent all symbols*/

  leaves = (BPMNode*)lodepng_malloc(numcodes * sizeof(*leaves));
  if(!leaves) return 83; /*alloc fail*/

  for(i = 0; i != numcodes; ++i) {
    5077:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    507b:	8b 45 10             	mov    0x10(%ebp),%eax
    507e:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    5081:	75 a8                	jne    502b <lodepng_huffman_code_lengths+0x6f>
      leaves[numpresent].index = i;
      ++numpresent;
    }
  }

  lodepng_memset(lengths, 0, numcodes * sizeof(*lengths));
    5083:	8b 45 10             	mov    0x10(%ebp),%eax
    5086:	c1 e0 02             	shl    $0x2,%eax
    5089:	83 ec 04             	sub    $0x4,%esp
    508c:	50                   	push   %eax
    508d:	6a 00                	push   $0x0
    508f:	ff 75 08             	pushl  0x8(%ebp)
    5092:	e8 dd e3 ff ff       	call   3474 <lodepng_memset>
    5097:	83 c4 10             	add    $0x10,%esp
  /*ensure at least two present symbols. There should be at least one symbol
  according to RFC 1951 section 3.2.7. Some decoders incorrectly require two. To
  make these work as well ensure there are at least two symbols. The
  Package-Merge code below also doesn't work correctly if there's only one
  symbol, it'd give it the theoretical 0 bits but in practice zlib wants 1 bit*/
  if(numpresent == 0) {
    509a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    509e:	75 18                	jne    50b8 <lodepng_huffman_code_lengths+0xfc>
    lengths[0] = lengths[1] = 1; /*note that for RFC 1951 section 3.2.7, only lengths[0] = 1 is needed*/
    50a0:	8b 45 08             	mov    0x8(%ebp),%eax
    50a3:	83 c0 04             	add    $0x4,%eax
    50a6:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    50ac:	8b 10                	mov    (%eax),%edx
    50ae:	8b 45 08             	mov    0x8(%ebp),%eax
    50b1:	89 10                	mov    %edx,(%eax)
    50b3:	e9 64 02 00 00       	jmp    531c <lodepng_huffman_code_lengths+0x360>
  } else if(numpresent == 1) {
    50b8:	83 7d ec 01          	cmpl   $0x1,-0x14(%ebp)
    50bc:	75 3e                	jne    50fc <lodepng_huffman_code_lengths+0x140>
    lengths[leaves[0].index] = 1;
    50be:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    50c1:	8b 40 04             	mov    0x4(%eax),%eax
    50c4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    50cb:	8b 45 08             	mov    0x8(%ebp),%eax
    50ce:	01 d0                	add    %edx,%eax
    50d0:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    lengths[leaves[0].index == 0 ? 1 : 0] = 1;
    50d6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    50d9:	8b 40 04             	mov    0x4(%eax),%eax
    50dc:	85 c0                	test   %eax,%eax
    50de:	75 07                	jne    50e7 <lodepng_huffman_code_lengths+0x12b>
    50e0:	ba 04 00 00 00       	mov    $0x4,%edx
    50e5:	eb 05                	jmp    50ec <lodepng_huffman_code_lengths+0x130>
    50e7:	ba 00 00 00 00       	mov    $0x0,%edx
    50ec:	8b 45 08             	mov    0x8(%ebp),%eax
    50ef:	01 d0                	add    %edx,%eax
    50f1:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    50f7:	e9 20 02 00 00       	jmp    531c <lodepng_huffman_code_lengths+0x360>
  } else {
    BPMLists lists;
    BPMNode* node;

    bpmnode_sort(leaves, numpresent);
    50fc:	83 ec 08             	sub    $0x8,%esp
    50ff:	ff 75 ec             	pushl  -0x14(%ebp)
    5102:	ff 75 e4             	pushl  -0x1c(%ebp)
    5105:	e8 2c fb ff ff       	call   4c36 <bpmnode_sort>
    510a:	83 c4 10             	add    $0x10,%esp

    lists.listsize = maxbitlen;
    510d:	8b 45 14             	mov    0x14(%ebp),%eax
    5110:	89 45 d8             	mov    %eax,-0x28(%ebp)
    lists.memsize = 2 * maxbitlen * (maxbitlen + 1);
    5113:	8b 45 14             	mov    0x14(%ebp),%eax
    5116:	83 c0 01             	add    $0x1,%eax
    5119:	0f af 45 14          	imul   0x14(%ebp),%eax
    511d:	01 c0                	add    %eax,%eax
    511f:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    lists.nextfree = 0;
    5122:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
    lists.numfree = lists.memsize;
    5129:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    512c:	89 45 cc             	mov    %eax,-0x34(%ebp)
    lists.memory = (BPMNode*)lodepng_malloc(lists.memsize * sizeof(*lists.memory));
    512f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    5132:	c1 e0 04             	shl    $0x4,%eax
    5135:	83 ec 0c             	sub    $0xc,%esp
    5138:	50                   	push   %eax
    5139:	e8 c5 e2 ff ff       	call   3403 <lodepng_malloc>
    513e:	83 c4 10             	add    $0x10,%esp
    5141:	89 45 c8             	mov    %eax,-0x38(%ebp)
    lists.freelist = (BPMNode**)lodepng_malloc(lists.memsize * sizeof(BPMNode*));
    5144:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    5147:	c1 e0 02             	shl    $0x2,%eax
    514a:	83 ec 0c             	sub    $0xc,%esp
    514d:	50                   	push   %eax
    514e:	e8 b0 e2 ff ff       	call   3403 <lodepng_malloc>
    5153:	83 c4 10             	add    $0x10,%esp
    5156:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    lists.chains0 = (BPMNode**)lodepng_malloc(lists.listsize * sizeof(BPMNode*));
    5159:	8b 45 d8             	mov    -0x28(%ebp),%eax
    515c:	c1 e0 02             	shl    $0x2,%eax
    515f:	83 ec 0c             	sub    $0xc,%esp
    5162:	50                   	push   %eax
    5163:	e8 9b e2 ff ff       	call   3403 <lodepng_malloc>
    5168:	83 c4 10             	add    $0x10,%esp
    516b:	89 45 dc             	mov    %eax,-0x24(%ebp)
    lists.chains1 = (BPMNode**)lodepng_malloc(lists.listsize * sizeof(BPMNode*));
    516e:	8b 45 d8             	mov    -0x28(%ebp),%eax
    5171:	c1 e0 02             	shl    $0x2,%eax
    5174:	83 ec 0c             	sub    $0xc,%esp
    5177:	50                   	push   %eax
    5178:	e8 86 e2 ff ff       	call   3403 <lodepng_malloc>
    517d:	83 c4 10             	add    $0x10,%esp
    5180:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(!lists.memory || !lists.freelist || !lists.chains0 || !lists.chains1) error = 83; /*alloc fail*/
    5183:	8b 45 c8             	mov    -0x38(%ebp),%eax
    5186:	85 c0                	test   %eax,%eax
    5188:	74 15                	je     519f <lodepng_huffman_code_lengths+0x1e3>
    518a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    518d:	85 c0                	test   %eax,%eax
    518f:	74 0e                	je     519f <lodepng_huffman_code_lengths+0x1e3>
    5191:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5194:	85 c0                	test   %eax,%eax
    5196:	74 07                	je     519f <lodepng_huffman_code_lengths+0x1e3>
    5198:	8b 45 e0             	mov    -0x20(%ebp),%eax
    519b:	85 c0                	test   %eax,%eax
    519d:	75 07                	jne    51a6 <lodepng_huffman_code_lengths+0x1ea>
    519f:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)

    if(!error) {
    51a6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    51aa:	0f 85 30 01 00 00    	jne    52e0 <lodepng_huffman_code_lengths+0x324>
      for(i = 0; i != lists.memsize; ++i) lists.freelist[i] = &lists.memory[i];
    51b0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    51b7:	eb 1c                	jmp    51d5 <lodepng_huffman_code_lengths+0x219>
    51b9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    51bc:	8b 55 f0             	mov    -0x10(%ebp),%edx
    51bf:	c1 e2 02             	shl    $0x2,%edx
    51c2:	01 d0                	add    %edx,%eax
    51c4:	8b 55 c8             	mov    -0x38(%ebp),%edx
    51c7:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    51ca:	c1 e1 04             	shl    $0x4,%ecx
    51cd:	01 ca                	add    %ecx,%edx
    51cf:	89 10                	mov    %edx,(%eax)
    51d1:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    51d5:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    51d8:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    51db:	75 dc                	jne    51b9 <lodepng_huffman_code_lengths+0x1fd>

      bpmnode_create(&lists, leaves[0].weight, 1, 0);
    51dd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    51e0:	8b 00                	mov    (%eax),%eax
    51e2:	6a 00                	push   $0x0
    51e4:	6a 01                	push   $0x1
    51e6:	50                   	push   %eax
    51e7:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    51ea:	50                   	push   %eax
    51eb:	e8 de f8 ff ff       	call   4ace <bpmnode_create>
    51f0:	83 c4 10             	add    $0x10,%esp
      bpmnode_create(&lists, leaves[1].weight, 2, 0);
    51f3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    51f6:	83 c0 10             	add    $0x10,%eax
    51f9:	8b 00                	mov    (%eax),%eax
    51fb:	6a 00                	push   $0x0
    51fd:	6a 02                	push   $0x2
    51ff:	50                   	push   %eax
    5200:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    5203:	50                   	push   %eax
    5204:	e8 c5 f8 ff ff       	call   4ace <bpmnode_create>
    5209:	83 c4 10             	add    $0x10,%esp

      for(i = 0; i != lists.listsize; ++i) {
    520c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    5213:	eb 27                	jmp    523c <lodepng_huffman_code_lengths+0x280>
        lists.chains0[i] = &lists.memory[0];
    5215:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5218:	8b 55 f0             	mov    -0x10(%ebp),%edx
    521b:	c1 e2 02             	shl    $0x2,%edx
    521e:	01 c2                	add    %eax,%edx
    5220:	8b 45 c8             	mov    -0x38(%ebp),%eax
    5223:	89 02                	mov    %eax,(%edx)
        lists.chains1[i] = &lists.memory[1];
    5225:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5228:	8b 55 f0             	mov    -0x10(%ebp),%edx
    522b:	c1 e2 02             	shl    $0x2,%edx
    522e:	01 d0                	add    %edx,%eax
    5230:	8b 55 c8             	mov    -0x38(%ebp),%edx
    5233:	83 c2 10             	add    $0x10,%edx
    5236:	89 10                	mov    %edx,(%eax)
      for(i = 0; i != lists.memsize; ++i) lists.freelist[i] = &lists.memory[i];

      bpmnode_create(&lists, leaves[0].weight, 1, 0);
      bpmnode_create(&lists, leaves[1].weight, 2, 0);

      for(i = 0; i != lists.listsize; ++i) {
    5238:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    523c:	8b 45 d8             	mov    -0x28(%ebp),%eax
    523f:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    5242:	75 d1                	jne    5215 <lodepng_huffman_code_lengths+0x259>
        lists.chains0[i] = &lists.memory[0];
        lists.chains1[i] = &lists.memory[1];
      }

      /*each boundaryPM call adds one chain to the last list, and we need 2 * numpresent - 2 chains.*/
      for(i = 2; i != 2 * numpresent - 2; ++i) boundaryPM(&lists, leaves, numpresent, (int)maxbitlen - 1, (int)i);
    5244:	c7 45 f0 02 00 00 00 	movl   $0x2,-0x10(%ebp)
    524b:	eb 24                	jmp    5271 <lodepng_huffman_code_lengths+0x2b5>
    524d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5250:	8b 55 14             	mov    0x14(%ebp),%edx
    5253:	83 ea 01             	sub    $0x1,%edx
    5256:	83 ec 0c             	sub    $0xc,%esp
    5259:	50                   	push   %eax
    525a:	52                   	push   %edx
    525b:	ff 75 ec             	pushl  -0x14(%ebp)
    525e:	ff 75 e4             	pushl  -0x1c(%ebp)
    5261:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    5264:	50                   	push   %eax
    5265:	e8 7a fb ff ff       	call   4de4 <boundaryPM>
    526a:	83 c4 20             	add    $0x20,%esp
    526d:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5271:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5274:	83 e8 01             	sub    $0x1,%eax
    5277:	01 c0                	add    %eax,%eax
    5279:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    527c:	75 cf                	jne    524d <lodepng_huffman_code_lengths+0x291>

      for(node = lists.chains1[maxbitlen - 1]; node; node = node->tail) {
    527e:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5281:	8b 55 14             	mov    0x14(%ebp),%edx
    5284:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    528a:	c1 e2 02             	shl    $0x2,%edx
    528d:	01 d0                	add    %edx,%eax
    528f:	8b 00                	mov    (%eax),%eax
    5291:	89 45 e8             	mov    %eax,-0x18(%ebp)
    5294:	eb 44                	jmp    52da <lodepng_huffman_code_lengths+0x31e>
        for(i = 0; i != node->index; ++i) ++lengths[leaves[i].index];
    5296:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    529d:	eb 27                	jmp    52c6 <lodepng_huffman_code_lengths+0x30a>
    529f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    52a2:	c1 e0 04             	shl    $0x4,%eax
    52a5:	89 c2                	mov    %eax,%edx
    52a7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    52aa:	01 d0                	add    %edx,%eax
    52ac:	8b 40 04             	mov    0x4(%eax),%eax
    52af:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    52b6:	8b 45 08             	mov    0x8(%ebp),%eax
    52b9:	01 d0                	add    %edx,%eax
    52bb:	8b 10                	mov    (%eax),%edx
    52bd:	83 c2 01             	add    $0x1,%edx
    52c0:	89 10                	mov    %edx,(%eax)
    52c2:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    52c6:	8b 45 e8             	mov    -0x18(%ebp),%eax
    52c9:	8b 40 04             	mov    0x4(%eax),%eax
    52cc:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    52cf:	75 ce                	jne    529f <lodepng_huffman_code_lengths+0x2e3>
      }

      /*each boundaryPM call adds one chain to the last list, and we need 2 * numpresent - 2 chains.*/
      for(i = 2; i != 2 * numpresent - 2; ++i) boundaryPM(&lists, leaves, numpresent, (int)maxbitlen - 1, (int)i);

      for(node = lists.chains1[maxbitlen - 1]; node; node = node->tail) {
    52d1:	8b 45 e8             	mov    -0x18(%ebp),%eax
    52d4:	8b 40 08             	mov    0x8(%eax),%eax
    52d7:	89 45 e8             	mov    %eax,-0x18(%ebp)
    52da:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    52de:	75 b6                	jne    5296 <lodepng_huffman_code_lengths+0x2da>
        for(i = 0; i != node->index; ++i) ++lengths[leaves[i].index];
      }
    }

    lodepng_free(lists.memory);
    52e0:	8b 45 c8             	mov    -0x38(%ebp),%eax
    52e3:	83 ec 0c             	sub    $0xc,%esp
    52e6:	50                   	push   %eax
    52e7:	e8 38 e1 ff ff       	call   3424 <lodepng_free>
    52ec:	83 c4 10             	add    $0x10,%esp
    lodepng_free(lists.freelist);
    52ef:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    52f2:	83 ec 0c             	sub    $0xc,%esp
    52f5:	50                   	push   %eax
    52f6:	e8 29 e1 ff ff       	call   3424 <lodepng_free>
    52fb:	83 c4 10             	add    $0x10,%esp
    lodepng_free(lists.chains0);
    52fe:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5301:	83 ec 0c             	sub    $0xc,%esp
    5304:	50                   	push   %eax
    5305:	e8 1a e1 ff ff       	call   3424 <lodepng_free>
    530a:	83 c4 10             	add    $0x10,%esp
    lodepng_free(lists.chains1);
    530d:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5310:	83 ec 0c             	sub    $0xc,%esp
    5313:	50                   	push   %eax
    5314:	e8 0b e1 ff ff       	call   3424 <lodepng_free>
    5319:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(leaves);
    531c:	83 ec 0c             	sub    $0xc,%esp
    531f:	ff 75 e4             	pushl  -0x1c(%ebp)
    5322:	e8 fd e0 ff ff       	call   3424 <lodepng_free>
    5327:	83 c4 10             	add    $0x10,%esp
  return error;
    532a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    532d:	c9                   	leave  
    532e:	c3                   	ret    

0000532f <HuffmanTree_makeFromFrequencies>:

/*Create the Huffman tree given the symbol frequencies*/
static unsigned HuffmanTree_makeFromFrequencies(HuffmanTree* tree, const unsigned* frequencies,
                                                size_t mincodes, size_t numcodes, unsigned maxbitlen) {
    532f:	55                   	push   %ebp
    5330:	89 e5                	mov    %esp,%ebp
    5332:	83 ec 18             	sub    $0x18,%esp
  unsigned error = 0;
    5335:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  while(!frequencies[numcodes - 1] && numcodes > mincodes) --numcodes; /*trim zeroes*/
    533c:	eb 04                	jmp    5342 <HuffmanTree_makeFromFrequencies+0x13>
    533e:	83 6d 14 01          	subl   $0x1,0x14(%ebp)
    5342:	8b 45 14             	mov    0x14(%ebp),%eax
    5345:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    534a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5351:	8b 45 0c             	mov    0xc(%ebp),%eax
    5354:	01 d0                	add    %edx,%eax
    5356:	8b 00                	mov    (%eax),%eax
    5358:	85 c0                	test   %eax,%eax
    535a:	75 08                	jne    5364 <HuffmanTree_makeFromFrequencies+0x35>
    535c:	8b 45 14             	mov    0x14(%ebp),%eax
    535f:	3b 45 10             	cmp    0x10(%ebp),%eax
    5362:	7f da                	jg     533e <HuffmanTree_makeFromFrequencies+0xf>
  tree->lengths = (unsigned*)lodepng_malloc(numcodes * sizeof(unsigned));
    5364:	8b 45 14             	mov    0x14(%ebp),%eax
    5367:	c1 e0 02             	shl    $0x2,%eax
    536a:	83 ec 0c             	sub    $0xc,%esp
    536d:	50                   	push   %eax
    536e:	e8 90 e0 ff ff       	call   3403 <lodepng_malloc>
    5373:	83 c4 10             	add    $0x10,%esp
    5376:	89 c2                	mov    %eax,%edx
    5378:	8b 45 08             	mov    0x8(%ebp),%eax
    537b:	89 50 04             	mov    %edx,0x4(%eax)
  if(!tree->lengths) return 83; /*alloc fail*/
    537e:	8b 45 08             	mov    0x8(%ebp),%eax
    5381:	8b 40 04             	mov    0x4(%eax),%eax
    5384:	85 c0                	test   %eax,%eax
    5386:	75 07                	jne    538f <HuffmanTree_makeFromFrequencies+0x60>
    5388:	b8 53 00 00 00       	mov    $0x53,%eax
    538d:	eb 47                	jmp    53d6 <HuffmanTree_makeFromFrequencies+0xa7>
  tree->maxbitlen = maxbitlen;
    538f:	8b 45 08             	mov    0x8(%ebp),%eax
    5392:	8b 55 18             	mov    0x18(%ebp),%edx
    5395:	89 50 08             	mov    %edx,0x8(%eax)
  tree->numcodes = (unsigned)numcodes; /*number of symbols*/
    5398:	8b 55 14             	mov    0x14(%ebp),%edx
    539b:	8b 45 08             	mov    0x8(%ebp),%eax
    539e:	89 50 0c             	mov    %edx,0xc(%eax)

  error = lodepng_huffman_code_lengths(tree->lengths, frequencies, numcodes, maxbitlen);
    53a1:	8b 45 08             	mov    0x8(%ebp),%eax
    53a4:	8b 40 04             	mov    0x4(%eax),%eax
    53a7:	ff 75 18             	pushl  0x18(%ebp)
    53aa:	ff 75 14             	pushl  0x14(%ebp)
    53ad:	ff 75 0c             	pushl  0xc(%ebp)
    53b0:	50                   	push   %eax
    53b1:	e8 06 fc ff ff       	call   4fbc <lodepng_huffman_code_lengths>
    53b6:	83 c4 10             	add    $0x10,%esp
    53b9:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = HuffmanTree_makeFromLengths2(tree);
    53bc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    53c0:	75 11                	jne    53d3 <HuffmanTree_makeFromFrequencies+0xa4>
    53c2:	83 ec 0c             	sub    $0xc,%esp
    53c5:	ff 75 08             	pushl  0x8(%ebp)
    53c8:	e8 37 f4 ff ff       	call   4804 <HuffmanTree_makeFromLengths2>
    53cd:	83 c4 10             	add    $0x10,%esp
    53d0:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return error;
    53d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    53d6:	c9                   	leave  
    53d7:	c3                   	ret    

000053d8 <generateFixedLitLenTree>:
#endif /*LODEPNG_COMPILE_ENCODER*/

/*get the literal and length code tree of a deflated block with fixed tree, as per the deflate specification*/
static unsigned generateFixedLitLenTree(HuffmanTree* tree) {
    53d8:	55                   	push   %ebp
    53d9:	89 e5                	mov    %esp,%ebp
    53db:	83 ec 18             	sub    $0x18,%esp
  unsigned i, error = 0;
    53de:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  unsigned* bitlen = (unsigned*)lodepng_malloc(NUM_DEFLATE_CODE_SYMBOLS * sizeof(unsigned));
    53e5:	83 ec 0c             	sub    $0xc,%esp
    53e8:	68 80 04 00 00       	push   $0x480
    53ed:	e8 11 e0 ff ff       	call   3403 <lodepng_malloc>
    53f2:	83 c4 10             	add    $0x10,%esp
    53f5:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(!bitlen) return 83; /*alloc fail*/
    53f8:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    53fc:	75 0a                	jne    5408 <generateFixedLitLenTree+0x30>
    53fe:	b8 53 00 00 00       	mov    $0x53,%eax
    5403:	e9 d5 00 00 00       	jmp    54dd <generateFixedLitLenTree+0x105>

  /*288 possible codes: 0-255=literals, 256=endcode, 257-285=lengthcodes, 286-287=unused*/
  for(i =   0; i <= 143; ++i) bitlen[i] = 8;
    5408:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    540f:	eb 19                	jmp    542a <generateFixedLitLenTree+0x52>
    5411:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5414:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    541b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    541e:	01 d0                	add    %edx,%eax
    5420:	c7 00 08 00 00 00    	movl   $0x8,(%eax)
    5426:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    542a:	81 7d f4 8f 00 00 00 	cmpl   $0x8f,-0xc(%ebp)
    5431:	76 de                	jbe    5411 <generateFixedLitLenTree+0x39>
  for(i = 144; i <= 255; ++i) bitlen[i] = 9;
    5433:	c7 45 f4 90 00 00 00 	movl   $0x90,-0xc(%ebp)
    543a:	eb 19                	jmp    5455 <generateFixedLitLenTree+0x7d>
    543c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    543f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5446:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5449:	01 d0                	add    %edx,%eax
    544b:	c7 00 09 00 00 00    	movl   $0x9,(%eax)
    5451:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    5455:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
    545c:	76 de                	jbe    543c <generateFixedLitLenTree+0x64>
  for(i = 256; i <= 279; ++i) bitlen[i] = 7;
    545e:	c7 45 f4 00 01 00 00 	movl   $0x100,-0xc(%ebp)
    5465:	eb 19                	jmp    5480 <generateFixedLitLenTree+0xa8>
    5467:	8b 45 f4             	mov    -0xc(%ebp),%eax
    546a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5471:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5474:	01 d0                	add    %edx,%eax
    5476:	c7 00 07 00 00 00    	movl   $0x7,(%eax)
    547c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    5480:	81 7d f4 17 01 00 00 	cmpl   $0x117,-0xc(%ebp)
    5487:	76 de                	jbe    5467 <generateFixedLitLenTree+0x8f>
  for(i = 280; i <= 287; ++i) bitlen[i] = 8;
    5489:	c7 45 f4 18 01 00 00 	movl   $0x118,-0xc(%ebp)
    5490:	eb 19                	jmp    54ab <generateFixedLitLenTree+0xd3>
    5492:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5495:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    549c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    549f:	01 d0                	add    %edx,%eax
    54a1:	c7 00 08 00 00 00    	movl   $0x8,(%eax)
    54a7:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    54ab:	81 7d f4 1f 01 00 00 	cmpl   $0x11f,-0xc(%ebp)
    54b2:	76 de                	jbe    5492 <generateFixedLitLenTree+0xba>

  error = HuffmanTree_makeFromLengths(tree, bitlen, NUM_DEFLATE_CODE_SYMBOLS, 15);
    54b4:	6a 0f                	push   $0xf
    54b6:	68 20 01 00 00       	push   $0x120
    54bb:	ff 75 ec             	pushl  -0x14(%ebp)
    54be:	ff 75 08             	pushl  0x8(%ebp)
    54c1:	e8 7f f5 ff ff       	call   4a45 <HuffmanTree_makeFromLengths>
    54c6:	83 c4 10             	add    $0x10,%esp
    54c9:	89 45 f0             	mov    %eax,-0x10(%ebp)

  lodepng_free(bitlen);
    54cc:	83 ec 0c             	sub    $0xc,%esp
    54cf:	ff 75 ec             	pushl  -0x14(%ebp)
    54d2:	e8 4d df ff ff       	call   3424 <lodepng_free>
    54d7:	83 c4 10             	add    $0x10,%esp
  return error;
    54da:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    54dd:	c9                   	leave  
    54de:	c3                   	ret    

000054df <generateFixedDistanceTree>:

/*get the distance code tree of a deflated block with fixed tree, as specified in the deflate specification*/
static unsigned generateFixedDistanceTree(HuffmanTree* tree) {
    54df:	55                   	push   %ebp
    54e0:	89 e5                	mov    %esp,%ebp
    54e2:	83 ec 18             	sub    $0x18,%esp
  unsigned i, error = 0;
    54e5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  unsigned* bitlen = (unsigned*)lodepng_malloc(NUM_DISTANCE_SYMBOLS * sizeof(unsigned));
    54ec:	83 ec 0c             	sub    $0xc,%esp
    54ef:	68 80 00 00 00       	push   $0x80
    54f4:	e8 0a df ff ff       	call   3403 <lodepng_malloc>
    54f9:	83 c4 10             	add    $0x10,%esp
    54fc:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(!bitlen) return 83; /*alloc fail*/
    54ff:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    5503:	75 07                	jne    550c <generateFixedDistanceTree+0x2d>
    5505:	b8 53 00 00 00       	mov    $0x53,%eax
    550a:	eb 4e                	jmp    555a <generateFixedDistanceTree+0x7b>

  /*there are 32 distance codes, but 30-31 are unused*/
  for(i = 0; i != NUM_DISTANCE_SYMBOLS; ++i) bitlen[i] = 5;
    550c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    5513:	eb 19                	jmp    552e <generateFixedDistanceTree+0x4f>
    5515:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5518:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    551f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5522:	01 d0                	add    %edx,%eax
    5524:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
    552a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    552e:	83 7d f4 20          	cmpl   $0x20,-0xc(%ebp)
    5532:	75 e1                	jne    5515 <generateFixedDistanceTree+0x36>
  error = HuffmanTree_makeFromLengths(tree, bitlen, NUM_DISTANCE_SYMBOLS, 15);
    5534:	6a 0f                	push   $0xf
    5536:	6a 20                	push   $0x20
    5538:	ff 75 ec             	pushl  -0x14(%ebp)
    553b:	ff 75 08             	pushl  0x8(%ebp)
    553e:	e8 02 f5 ff ff       	call   4a45 <HuffmanTree_makeFromLengths>
    5543:	83 c4 10             	add    $0x10,%esp
    5546:	89 45 f0             	mov    %eax,-0x10(%ebp)

  lodepng_free(bitlen);
    5549:	83 ec 0c             	sub    $0xc,%esp
    554c:	ff 75 ec             	pushl  -0x14(%ebp)
    554f:	e8 d0 de ff ff       	call   3424 <lodepng_free>
    5554:	83 c4 10             	add    $0x10,%esp
  return error;
    5557:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    555a:	c9                   	leave  
    555b:	c3                   	ret    

0000555c <huffmanDecodeSymbol>:
#ifdef LODEPNG_COMPILE_DECODER

/*
returns the code. The bit reader must already have been ensured at least 15 bits
*/
static unsigned huffmanDecodeSymbol(LodePNGBitReader* reader, const HuffmanTree* codetree) {
    555c:	55                   	push   %ebp
    555d:	89 e5                	mov    %esp,%ebp
    555f:	53                   	push   %ebx
    5560:	83 ec 10             	sub    $0x10,%esp
  unsigned short code = peekBits(reader, FIRSTBITS);
    5563:	6a 09                	push   $0x9
    5565:	ff 75 08             	pushl  0x8(%ebp)
    5568:	e8 d8 eb ff ff       	call   4145 <peekBits>
    556d:	83 c4 08             	add    $0x8,%esp
    5570:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
  unsigned short l = codetree->table_len[code];
    5574:	8b 45 0c             	mov    0xc(%ebp),%eax
    5577:	8b 50 10             	mov    0x10(%eax),%edx
    557a:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
    557e:	01 d0                	add    %edx,%eax
    5580:	0f b6 00             	movzbl (%eax),%eax
    5583:	0f b6 c0             	movzbl %al,%eax
    5586:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
  unsigned short value = codetree->table_value[code];
    558a:	8b 45 0c             	mov    0xc(%ebp),%eax
    558d:	8b 40 14             	mov    0x14(%eax),%eax
    5590:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
    5594:	01 d2                	add    %edx,%edx
    5596:	01 d0                	add    %edx,%eax
    5598:	0f b7 00             	movzwl (%eax),%eax
    559b:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
  if(l <= FIRSTBITS) {
    559f:	66 83 7d f8 09       	cmpw   $0x9,-0x8(%ebp)
    55a4:	77 16                	ja     55bc <huffmanDecodeSymbol+0x60>
    advanceBits(reader, l);
    55a6:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
    55aa:	50                   	push   %eax
    55ab:	ff 75 08             	pushl  0x8(%ebp)
    55ae:	e8 b2 eb ff ff       	call   4165 <advanceBits>
    55b3:	83 c4 08             	add    $0x8,%esp
    return value;
    55b6:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
    55ba:	eb 5c                	jmp    5618 <huffmanDecodeSymbol+0xbc>
  } else {
    unsigned index2;
    advanceBits(reader, FIRSTBITS);
    55bc:	6a 09                	push   $0x9
    55be:	ff 75 08             	pushl  0x8(%ebp)
    55c1:	e8 9f eb ff ff       	call   4165 <advanceBits>
    55c6:	83 c4 08             	add    $0x8,%esp
    index2 = value + peekBits(reader, l - FIRSTBITS);
    55c9:	0f b7 5d f6          	movzwl -0xa(%ebp),%ebx
    55cd:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
    55d1:	83 e8 09             	sub    $0x9,%eax
    55d4:	50                   	push   %eax
    55d5:	ff 75 08             	pushl  0x8(%ebp)
    55d8:	e8 68 eb ff ff       	call   4145 <peekBits>
    55dd:	83 c4 08             	add    $0x8,%esp
    55e0:	01 d8                	add    %ebx,%eax
    55e2:	89 45 f0             	mov    %eax,-0x10(%ebp)
    advanceBits(reader, codetree->table_len[index2] - FIRSTBITS);
    55e5:	8b 45 0c             	mov    0xc(%ebp),%eax
    55e8:	8b 50 10             	mov    0x10(%eax),%edx
    55eb:	8b 45 f0             	mov    -0x10(%ebp),%eax
    55ee:	01 d0                	add    %edx,%eax
    55f0:	0f b6 00             	movzbl (%eax),%eax
    55f3:	0f b6 c0             	movzbl %al,%eax
    55f6:	83 e8 09             	sub    $0x9,%eax
    55f9:	50                   	push   %eax
    55fa:	ff 75 08             	pushl  0x8(%ebp)
    55fd:	e8 63 eb ff ff       	call   4165 <advanceBits>
    5602:	83 c4 08             	add    $0x8,%esp
    return codetree->table_value[index2];
    5605:	8b 45 0c             	mov    0xc(%ebp),%eax
    5608:	8b 40 14             	mov    0x14(%eax),%eax
    560b:	8b 55 f0             	mov    -0x10(%ebp),%edx
    560e:	01 d2                	add    %edx,%edx
    5610:	01 d0                	add    %edx,%eax
    5612:	0f b7 00             	movzwl (%eax),%eax
    5615:	0f b7 c0             	movzwl %ax,%eax
  }
}
    5618:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    561b:	c9                   	leave  
    561c:	c3                   	ret    

0000561d <getTreeInflateFixed>:
/* / Inflator (Decompressor)                                                / */
/* ////////////////////////////////////////////////////////////////////////// */

/*get the tree of a deflated block with fixed tree, as specified in the deflate specification
Returns error code.*/
static unsigned getTreeInflateFixed(HuffmanTree* tree_ll, HuffmanTree* tree_d) {
    561d:	55                   	push   %ebp
    561e:	89 e5                	mov    %esp,%ebp
    5620:	83 ec 18             	sub    $0x18,%esp
  unsigned error = generateFixedLitLenTree(tree_ll);
    5623:	83 ec 0c             	sub    $0xc,%esp
    5626:	ff 75 08             	pushl  0x8(%ebp)
    5629:	e8 aa fd ff ff       	call   53d8 <generateFixedLitLenTree>
    562e:	83 c4 10             	add    $0x10,%esp
    5631:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(error) return error;
    5634:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5638:	74 05                	je     563f <getTreeInflateFixed+0x22>
    563a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    563d:	eb 0e                	jmp    564d <getTreeInflateFixed+0x30>
  return generateFixedDistanceTree(tree_d);
    563f:	83 ec 0c             	sub    $0xc,%esp
    5642:	ff 75 0c             	pushl  0xc(%ebp)
    5645:	e8 95 fe ff ff       	call   54df <generateFixedDistanceTree>
    564a:	83 c4 10             	add    $0x10,%esp
}
    564d:	c9                   	leave  
    564e:	c3                   	ret    

0000564f <getTreeInflateDynamic>:

/*get the tree of a deflated block with dynamic tree, the tree itself is also Huffman compressed with a known tree*/
static unsigned getTreeInflateDynamic(HuffmanTree* tree_ll, HuffmanTree* tree_d,
                                      LodePNGBitReader* reader) {
    564f:	55                   	push   %ebp
    5650:	89 e5                	mov    %esp,%ebp
    5652:	53                   	push   %ebx
    5653:	83 ec 54             	sub    $0x54,%esp
  /*make sure that length values that aren't filled in will be 0, or a wrong tree will be generated*/
  unsigned error = 0;
    5656:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned n, HLIT, HDIST, HCLEN, i;

  /*see comments in deflateDynamic for explanation of the context and these variables, it is analogous*/
  unsigned* bitlen_ll = 0; /*lit,len code lengths*/
    565d:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  unsigned* bitlen_d = 0; /*dist code lengths*/
    5664:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  /*code length code lengths ("clcl"), the bit lengths of the huffman tree used to compress bitlen_ll and bitlen_d*/
  unsigned* bitlen_cl = 0;
    566b:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  HuffmanTree tree_cl; /*the code tree for code length codes (the huffman tree for compressed huffman trees)*/

  if(!ensureBits17(reader, 14)) return 49; /*error: the bit pointer is or will go past the memory*/
    5672:	6a 0e                	push   $0xe
    5674:	ff 75 10             	pushl  0x10(%ebp)
    5677:	e8 37 e6 ff ff       	call   3cb3 <ensureBits17>
    567c:	83 c4 08             	add    $0x8,%esp
    567f:	85 c0                	test   %eax,%eax
    5681:	75 0a                	jne    568d <getTreeInflateDynamic+0x3e>
    5683:	b8 31 00 00 00       	mov    $0x31,%eax
    5688:	e9 ec 04 00 00       	jmp    5b79 <getTreeInflateDynamic+0x52a>

  /*number of literal/length codes + 257. Unlike the spec, the value 257 is added to it here already*/
  HLIT =  readBits(reader, 5) + 257;
    568d:	6a 05                	push   $0x5
    568f:	ff 75 10             	pushl  0x10(%ebp)
    5692:	e8 f8 ea ff ff       	call   418f <readBits>
    5697:	83 c4 08             	add    $0x8,%esp
    569a:	05 01 01 00 00       	add    $0x101,%eax
    569f:	89 45 d8             	mov    %eax,-0x28(%ebp)
  /*number of distance codes. Unlike the spec, the value 1 is added to it here already*/
  HDIST = readBits(reader, 5) + 1;
    56a2:	6a 05                	push   $0x5
    56a4:	ff 75 10             	pushl  0x10(%ebp)
    56a7:	e8 e3 ea ff ff       	call   418f <readBits>
    56ac:	83 c4 08             	add    $0x8,%esp
    56af:	83 c0 01             	add    $0x1,%eax
    56b2:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  /*number of code length codes. Unlike the spec, the value 4 is added to it here already*/
  HCLEN = readBits(reader, 4) + 4;
    56b5:	6a 04                	push   $0x4
    56b7:	ff 75 10             	pushl  0x10(%ebp)
    56ba:	e8 d0 ea ff ff       	call   418f <readBits>
    56bf:	83 c4 08             	add    $0x8,%esp
    56c2:	83 c0 04             	add    $0x4,%eax
    56c5:	89 45 d0             	mov    %eax,-0x30(%ebp)

  bitlen_cl = (unsigned*)lodepng_malloc(NUM_CODE_LENGTH_CODES * sizeof(unsigned));
    56c8:	83 ec 0c             	sub    $0xc,%esp
    56cb:	6a 4c                	push   $0x4c
    56cd:	e8 31 dd ff ff       	call   3403 <lodepng_malloc>
    56d2:	83 c4 10             	add    $0x10,%esp
    56d5:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if(!bitlen_cl) return 83 /*alloc fail*/;
    56d8:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    56dc:	75 0a                	jne    56e8 <getTreeInflateDynamic+0x99>
    56de:	b8 53 00 00 00       	mov    $0x53,%eax
    56e3:	e9 91 04 00 00       	jmp    5b79 <getTreeInflateDynamic+0x52a>

  HuffmanTree_init(&tree_cl);
    56e8:	83 ec 0c             	sub    $0xc,%esp
    56eb:	8d 45 a8             	lea    -0x58(%ebp),%eax
    56ee:	50                   	push   %eax
    56ef:	e8 03 ec ff ff       	call   42f7 <HuffmanTree_init>
    56f4:	83 c4 10             	add    $0x10,%esp

  while(!error) {
    56f7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    56fb:	0f 85 3c 04 00 00    	jne    5b3d <getTreeInflateDynamic+0x4ee>
    /*read the code length codes out of 3 * (amount of code length codes) bits*/
    if(lodepng_gtofl(reader->bp, HCLEN * 3, reader->bitsize)) {
    5701:	8b 45 10             	mov    0x10(%ebp),%eax
    5704:	8b 48 08             	mov    0x8(%eax),%ecx
    5707:	8b 55 d0             	mov    -0x30(%ebp),%edx
    570a:	89 d0                	mov    %edx,%eax
    570c:	01 c0                	add    %eax,%eax
    570e:	01 d0                	add    %edx,%eax
    5710:	89 c2                	mov    %eax,%edx
    5712:	8b 45 10             	mov    0x10(%ebp),%eax
    5715:	8b 40 0c             	mov    0xc(%eax),%eax
    5718:	83 ec 04             	sub    $0x4,%esp
    571b:	51                   	push   %ecx
    571c:	52                   	push   %edx
    571d:	50                   	push   %eax
    571e:	e8 f7 dd ff ff       	call   351a <lodepng_gtofl>
    5723:	83 c4 10             	add    $0x10,%esp
    5726:	85 c0                	test   %eax,%eax
    5728:	74 0c                	je     5736 <getTreeInflateDynamic+0xe7>
      ERROR_BREAK(50); /*error: the bit pointer is or will go past the memory*/
    572a:	c7 45 f4 32 00 00 00 	movl   $0x32,-0xc(%ebp)
    5731:	e9 07 04 00 00       	jmp    5b3d <getTreeInflateDynamic+0x4ee>
    }
    for(i = 0; i != HCLEN; ++i) {
    5736:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    573d:	eb 3d                	jmp    577c <getTreeInflateDynamic+0x12d>
      ensureBits9(reader, 3); /*out of bounds already checked above */
    573f:	83 ec 08             	sub    $0x8,%esp
    5742:	6a 03                	push   $0x3
    5744:	ff 75 10             	pushl  0x10(%ebp)
    5747:	e8 8b e4 ff ff       	call   3bd7 <ensureBits9>
    574c:	83 c4 10             	add    $0x10,%esp
      bitlen_cl[CLCL_ORDER[i]] = readBits(reader, 3);
    574f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5752:	8b 04 85 20 a0 01 00 	mov    0x1a020(,%eax,4),%eax
    5759:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5760:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5763:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    5766:	83 ec 08             	sub    $0x8,%esp
    5769:	6a 03                	push   $0x3
    576b:	ff 75 10             	pushl  0x10(%ebp)
    576e:	e8 1c ea ff ff       	call   418f <readBits>
    5773:	83 c4 10             	add    $0x10,%esp
    5776:	89 03                	mov    %eax,(%ebx)
  while(!error) {
    /*read the code length codes out of 3 * (amount of code length codes) bits*/
    if(lodepng_gtofl(reader->bp, HCLEN * 3, reader->bitsize)) {
      ERROR_BREAK(50); /*error: the bit pointer is or will go past the memory*/
    }
    for(i = 0; i != HCLEN; ++i) {
    5778:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    577c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    577f:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    5782:	75 bb                	jne    573f <getTreeInflateDynamic+0xf0>
      ensureBits9(reader, 3); /*out of bounds already checked above */
      bitlen_cl[CLCL_ORDER[i]] = readBits(reader, 3);
    }
    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {
    5784:	8b 45 d0             	mov    -0x30(%ebp),%eax
    5787:	89 45 ec             	mov    %eax,-0x14(%ebp)
    578a:	eb 20                	jmp    57ac <getTreeInflateDynamic+0x15d>
      bitlen_cl[CLCL_ORDER[i]] = 0;
    578c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    578f:	8b 04 85 20 a0 01 00 	mov    0x1a020(,%eax,4),%eax
    5796:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    579d:	8b 45 dc             	mov    -0x24(%ebp),%eax
    57a0:	01 d0                	add    %edx,%eax
    57a2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    }
    for(i = 0; i != HCLEN; ++i) {
      ensureBits9(reader, 3); /*out of bounds already checked above */
      bitlen_cl[CLCL_ORDER[i]] = readBits(reader, 3);
    }
    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {
    57a8:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    57ac:	83 7d ec 13          	cmpl   $0x13,-0x14(%ebp)
    57b0:	75 da                	jne    578c <getTreeInflateDynamic+0x13d>
      bitlen_cl[CLCL_ORDER[i]] = 0;
    }

    error = HuffmanTree_makeFromLengths(&tree_cl, bitlen_cl, NUM_CODE_LENGTH_CODES, 7);
    57b2:	6a 07                	push   $0x7
    57b4:	6a 13                	push   $0x13
    57b6:	ff 75 dc             	pushl  -0x24(%ebp)
    57b9:	8d 45 a8             	lea    -0x58(%ebp),%eax
    57bc:	50                   	push   %eax
    57bd:	e8 83 f2 ff ff       	call   4a45 <HuffmanTree_makeFromLengths>
    57c2:	83 c4 10             	add    $0x10,%esp
    57c5:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    57c8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    57cc:	0f 85 64 03 00 00    	jne    5b36 <getTreeInflateDynamic+0x4e7>

    /*now we can use this tree to read the lengths for the tree that this function will return*/
    bitlen_ll = (unsigned*)lodepng_malloc(NUM_DEFLATE_CODE_SYMBOLS * sizeof(unsigned));
    57d2:	83 ec 0c             	sub    $0xc,%esp
    57d5:	68 80 04 00 00       	push   $0x480
    57da:	e8 24 dc ff ff       	call   3403 <lodepng_malloc>
    57df:	83 c4 10             	add    $0x10,%esp
    57e2:	89 45 e8             	mov    %eax,-0x18(%ebp)
    bitlen_d = (unsigned*)lodepng_malloc(NUM_DISTANCE_SYMBOLS * sizeof(unsigned));
    57e5:	83 ec 0c             	sub    $0xc,%esp
    57e8:	68 80 00 00 00       	push   $0x80
    57ed:	e8 11 dc ff ff       	call   3403 <lodepng_malloc>
    57f2:	83 c4 10             	add    $0x10,%esp
    57f5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(!bitlen_ll || !bitlen_d) ERROR_BREAK(83 /*alloc fail*/);
    57f8:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    57fc:	74 06                	je     5804 <getTreeInflateDynamic+0x1b5>
    57fe:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    5802:	75 0c                	jne    5810 <getTreeInflateDynamic+0x1c1>
    5804:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    580b:	e9 2d 03 00 00       	jmp    5b3d <getTreeInflateDynamic+0x4ee>
    lodepng_memset(bitlen_ll, 0, NUM_DEFLATE_CODE_SYMBOLS * sizeof(*bitlen_ll));
    5810:	83 ec 04             	sub    $0x4,%esp
    5813:	68 80 04 00 00       	push   $0x480
    5818:	6a 00                	push   $0x0
    581a:	ff 75 e8             	pushl  -0x18(%ebp)
    581d:	e8 52 dc ff ff       	call   3474 <lodepng_memset>
    5822:	83 c4 10             	add    $0x10,%esp
    lodepng_memset(bitlen_d, 0, NUM_DISTANCE_SYMBOLS * sizeof(*bitlen_d));
    5825:	83 ec 04             	sub    $0x4,%esp
    5828:	68 80 00 00 00       	push   $0x80
    582d:	6a 00                	push   $0x0
    582f:	ff 75 e4             	pushl  -0x1c(%ebp)
    5832:	e8 3d dc ff ff       	call   3474 <lodepng_memset>
    5837:	83 c4 10             	add    $0x10,%esp

    /*i is the current symbol we're reading in the part that contains the code lengths of lit/len and dist codes*/
    i = 0;
    583a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    while(i < HLIT + HDIST) {
    5841:	e9 8d 02 00 00       	jmp    5ad3 <getTreeInflateDynamic+0x484>
      unsigned code;
      ensureBits25(reader, 22); /* up to 15 bits for huffman code, up to 7 extra bits below*/
    5846:	83 ec 08             	sub    $0x8,%esp
    5849:	6a 16                	push   $0x16
    584b:	ff 75 10             	pushl  0x10(%ebp)
    584e:	e8 8c e5 ff ff       	call   3ddf <ensureBits25>
    5853:	83 c4 10             	add    $0x10,%esp
      code = huffmanDecodeSymbol(reader, &tree_cl);
    5856:	83 ec 08             	sub    $0x8,%esp
    5859:	8d 45 a8             	lea    -0x58(%ebp),%eax
    585c:	50                   	push   %eax
    585d:	ff 75 10             	pushl  0x10(%ebp)
    5860:	e8 f7 fc ff ff       	call   555c <huffmanDecodeSymbol>
    5865:	83 c4 10             	add    $0x10,%esp
    5868:	89 45 cc             	mov    %eax,-0x34(%ebp)
      if(code <= 15) /*a length code*/ {
    586b:	83 7d cc 0f          	cmpl   $0xf,-0x34(%ebp)
    586f:	77 3e                	ja     58af <getTreeInflateDynamic+0x260>
        if(i < HLIT) bitlen_ll[i] = code;
    5871:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5874:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    5877:	73 16                	jae    588f <getTreeInflateDynamic+0x240>
    5879:	8b 45 ec             	mov    -0x14(%ebp),%eax
    587c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5883:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5886:	01 c2                	add    %eax,%edx
    5888:	8b 45 cc             	mov    -0x34(%ebp),%eax
    588b:	89 02                	mov    %eax,(%edx)
    588d:	eb 17                	jmp    58a6 <getTreeInflateDynamic+0x257>
        else bitlen_d[i - HLIT] = code;
    588f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5892:	2b 45 d8             	sub    -0x28(%ebp),%eax
    5895:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    589c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    589f:	01 c2                	add    %eax,%edx
    58a1:	8b 45 cc             	mov    -0x34(%ebp),%eax
    58a4:	89 02                	mov    %eax,(%edx)
        ++i;
    58a6:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    58aa:	e9 0b 02 00 00       	jmp    5aba <getTreeInflateDynamic+0x46b>
      } else if(code == 16) /*repeat previous*/ {
    58af:	83 7d cc 10          	cmpl   $0x10,-0x34(%ebp)
    58b3:	0f 85 da 00 00 00    	jne    5993 <getTreeInflateDynamic+0x344>
        unsigned replength = 3; /*read in the 2 bits that indicate repeat length (3-6)*/
    58b9:	c7 45 c0 03 00 00 00 	movl   $0x3,-0x40(%ebp)
        unsigned value; /*set value to the previous code*/

        if(i == 0) ERROR_BREAK(54); /*can't repeat previous if i is 0*/
    58c0:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    58c4:	75 0c                	jne    58d2 <getTreeInflateDynamic+0x283>
    58c6:	c7 45 f4 36 00 00 00 	movl   $0x36,-0xc(%ebp)
    58cd:	e9 12 02 00 00       	jmp    5ae4 <getTreeInflateDynamic+0x495>

        replength += readBits(reader, 2);
    58d2:	83 ec 08             	sub    $0x8,%esp
    58d5:	6a 02                	push   $0x2
    58d7:	ff 75 10             	pushl  0x10(%ebp)
    58da:	e8 b0 e8 ff ff       	call   418f <readBits>
    58df:	83 c4 10             	add    $0x10,%esp
    58e2:	01 45 c0             	add    %eax,-0x40(%ebp)

        if(i < HLIT + 1) value = bitlen_ll[i - 1];
    58e5:	8b 45 d8             	mov    -0x28(%ebp),%eax
    58e8:	83 c0 01             	add    $0x1,%eax
    58eb:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    58ee:	76 1b                	jbe    590b <getTreeInflateDynamic+0x2bc>
    58f0:	8b 45 ec             	mov    -0x14(%ebp),%eax
    58f3:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    58f8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    58ff:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5902:	01 d0                	add    %edx,%eax
    5904:	8b 00                	mov    (%eax),%eax
    5906:	89 45 e0             	mov    %eax,-0x20(%ebp)
    5909:	eb 1c                	jmp    5927 <getTreeInflateDynamic+0x2d8>
        else value = bitlen_d[i - HLIT - 1];
    590b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    590e:	2b 45 d8             	sub    -0x28(%ebp),%eax
    5911:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    5916:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    591d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5920:	01 d0                	add    %edx,%eax
    5922:	8b 00                	mov    (%eax),%eax
    5924:	89 45 e0             	mov    %eax,-0x20(%ebp)
        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    5927:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    592e:	eb 56                	jmp    5986 <getTreeInflateDynamic+0x337>
          if(i >= HLIT + HDIST) ERROR_BREAK(13); /*error: i is larger than the amount of codes*/
    5930:	8b 55 d8             	mov    -0x28(%ebp),%edx
    5933:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5936:	01 d0                	add    %edx,%eax
    5938:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    593b:	77 0c                	ja     5949 <getTreeInflateDynamic+0x2fa>
    593d:	c7 45 f4 0d 00 00 00 	movl   $0xd,-0xc(%ebp)
    5944:	e9 71 01 00 00       	jmp    5aba <getTreeInflateDynamic+0x46b>
          if(i < HLIT) bitlen_ll[i] = value;
    5949:	8b 45 ec             	mov    -0x14(%ebp),%eax
    594c:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    594f:	73 16                	jae    5967 <getTreeInflateDynamic+0x318>
    5951:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5954:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    595b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    595e:	01 c2                	add    %eax,%edx
    5960:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5963:	89 02                	mov    %eax,(%edx)
    5965:	eb 17                	jmp    597e <getTreeInflateDynamic+0x32f>
          else bitlen_d[i - HLIT] = value;
    5967:	8b 45 ec             	mov    -0x14(%ebp),%eax
    596a:	2b 45 d8             	sub    -0x28(%ebp),%eax
    596d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5974:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5977:	01 c2                	add    %eax,%edx
    5979:	8b 45 e0             	mov    -0x20(%ebp),%eax
    597c:	89 02                	mov    %eax,(%edx)
          ++i;
    597e:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
        replength += readBits(reader, 2);

        if(i < HLIT + 1) value = bitlen_ll[i - 1];
        else value = bitlen_d[i - HLIT - 1];
        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    5982:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5986:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5989:	3b 45 c0             	cmp    -0x40(%ebp),%eax
    598c:	72 a2                	jb     5930 <getTreeInflateDynamic+0x2e1>
    598e:	e9 27 01 00 00       	jmp    5aba <getTreeInflateDynamic+0x46b>
          if(i >= HLIT + HDIST) ERROR_BREAK(13); /*error: i is larger than the amount of codes*/
          if(i < HLIT) bitlen_ll[i] = value;
          else bitlen_d[i - HLIT] = value;
          ++i;
        }
      } else if(code == 17) /*repeat "0" 3-10 times*/ {
    5993:	83 7d cc 11          	cmpl   $0x11,-0x34(%ebp)
    5997:	0f 85 88 00 00 00    	jne    5a25 <getTreeInflateDynamic+0x3d6>
        unsigned replength = 3; /*read in the bits that indicate repeat length*/
    599d:	c7 45 c8 03 00 00 00 	movl   $0x3,-0x38(%ebp)
        replength += readBits(reader, 3);
    59a4:	83 ec 08             	sub    $0x8,%esp
    59a7:	6a 03                	push   $0x3
    59a9:	ff 75 10             	pushl  0x10(%ebp)
    59ac:	e8 de e7 ff ff       	call   418f <readBits>
    59b1:	83 c4 10             	add    $0x10,%esp
    59b4:	01 45 c8             	add    %eax,-0x38(%ebp)

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    59b7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    59be:	eb 58                	jmp    5a18 <getTreeInflateDynamic+0x3c9>
          if(i >= HLIT + HDIST) ERROR_BREAK(14); /*error: i is larger than the amount of codes*/
    59c0:	8b 55 d8             	mov    -0x28(%ebp),%edx
    59c3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    59c6:	01 d0                	add    %edx,%eax
    59c8:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    59cb:	77 0c                	ja     59d9 <getTreeInflateDynamic+0x38a>
    59cd:	c7 45 f4 0e 00 00 00 	movl   $0xe,-0xc(%ebp)
    59d4:	e9 e1 00 00 00       	jmp    5aba <getTreeInflateDynamic+0x46b>

          if(i < HLIT) bitlen_ll[i] = 0;
    59d9:	8b 45 ec             	mov    -0x14(%ebp),%eax
    59dc:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    59df:	73 17                	jae    59f8 <getTreeInflateDynamic+0x3a9>
    59e1:	8b 45 ec             	mov    -0x14(%ebp),%eax
    59e4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    59eb:	8b 45 e8             	mov    -0x18(%ebp),%eax
    59ee:	01 d0                	add    %edx,%eax
    59f0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    59f6:	eb 18                	jmp    5a10 <getTreeInflateDynamic+0x3c1>
          else bitlen_d[i - HLIT] = 0;
    59f8:	8b 45 ec             	mov    -0x14(%ebp),%eax
    59fb:	2b 45 d8             	sub    -0x28(%ebp),%eax
    59fe:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5a05:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5a08:	01 d0                	add    %edx,%eax
    5a0a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          ++i;
    5a10:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
      } else if(code == 17) /*repeat "0" 3-10 times*/ {
        unsigned replength = 3; /*read in the bits that indicate repeat length*/
        replength += readBits(reader, 3);

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    5a14:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5a18:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5a1b:	3b 45 c8             	cmp    -0x38(%ebp),%eax
    5a1e:	72 a0                	jb     59c0 <getTreeInflateDynamic+0x371>
    5a20:	e9 95 00 00 00       	jmp    5aba <getTreeInflateDynamic+0x46b>

          if(i < HLIT) bitlen_ll[i] = 0;
          else bitlen_d[i - HLIT] = 0;
          ++i;
        }
      } else if(code == 18) /*repeat "0" 11-138 times*/ {
    5a25:	83 7d cc 12          	cmpl   $0x12,-0x34(%ebp)
    5a29:	0f 85 82 00 00 00    	jne    5ab1 <getTreeInflateDynamic+0x462>
        unsigned replength = 11; /*read in the bits that indicate repeat length*/
    5a2f:	c7 45 c4 0b 00 00 00 	movl   $0xb,-0x3c(%ebp)
        replength += readBits(reader, 7);
    5a36:	83 ec 08             	sub    $0x8,%esp
    5a39:	6a 07                	push   $0x7
    5a3b:	ff 75 10             	pushl  0x10(%ebp)
    5a3e:	e8 4c e7 ff ff       	call   418f <readBits>
    5a43:	83 c4 10             	add    $0x10,%esp
    5a46:	01 45 c4             	add    %eax,-0x3c(%ebp)

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    5a49:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    5a50:	eb 55                	jmp    5aa7 <getTreeInflateDynamic+0x458>
          if(i >= HLIT + HDIST) ERROR_BREAK(15); /*error: i is larger than the amount of codes*/
    5a52:	8b 55 d8             	mov    -0x28(%ebp),%edx
    5a55:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5a58:	01 d0                	add    %edx,%eax
    5a5a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    5a5d:	77 09                	ja     5a68 <getTreeInflateDynamic+0x419>
    5a5f:	c7 45 f4 0f 00 00 00 	movl   $0xf,-0xc(%ebp)
    5a66:	eb 52                	jmp    5aba <getTreeInflateDynamic+0x46b>

          if(i < HLIT) bitlen_ll[i] = 0;
    5a68:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5a6b:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    5a6e:	73 17                	jae    5a87 <getTreeInflateDynamic+0x438>
    5a70:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5a73:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5a7a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5a7d:	01 d0                	add    %edx,%eax
    5a7f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    5a85:	eb 18                	jmp    5a9f <getTreeInflateDynamic+0x450>
          else bitlen_d[i - HLIT] = 0;
    5a87:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5a8a:	2b 45 d8             	sub    -0x28(%ebp),%eax
    5a8d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5a94:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5a97:	01 d0                	add    %edx,%eax
    5a99:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          ++i;
    5a9f:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
      } else if(code == 18) /*repeat "0" 11-138 times*/ {
        unsigned replength = 11; /*read in the bits that indicate repeat length*/
        replength += readBits(reader, 7);

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    5aa3:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5aa7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5aaa:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
    5aad:	72 a3                	jb     5a52 <getTreeInflateDynamic+0x403>
    5aaf:	eb 09                	jmp    5aba <getTreeInflateDynamic+0x46b>
          if(i < HLIT) bitlen_ll[i] = 0;
          else bitlen_d[i - HLIT] = 0;
          ++i;
        }
      } else /*if(code == INVALIDSYMBOL)*/ {
        ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/
    5ab1:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
    5ab8:	eb 2a                	jmp    5ae4 <getTreeInflateDynamic+0x495>
      }
      /*check if any of the ensureBits above went out of bounds*/
      if(reader->bp > reader->bitsize) {
    5aba:	8b 45 10             	mov    0x10(%ebp),%eax
    5abd:	8b 50 0c             	mov    0xc(%eax),%edx
    5ac0:	8b 45 10             	mov    0x10(%ebp),%eax
    5ac3:	8b 40 08             	mov    0x8(%eax),%eax
    5ac6:	39 c2                	cmp    %eax,%edx
    5ac8:	7e 09                	jle    5ad3 <getTreeInflateDynamic+0x484>
        /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol
        (10=no endcode, 11=wrong jump outside of tree)*/
        /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
        ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
    5aca:	c7 45 f4 32 00 00 00 	movl   $0x32,-0xc(%ebp)
    5ad1:	eb 11                	jmp    5ae4 <getTreeInflateDynamic+0x495>
    lodepng_memset(bitlen_ll, 0, NUM_DEFLATE_CODE_SYMBOLS * sizeof(*bitlen_ll));
    lodepng_memset(bitlen_d, 0, NUM_DISTANCE_SYMBOLS * sizeof(*bitlen_d));

    /*i is the current symbol we're reading in the part that contains the code lengths of lit/len and dist codes*/
    i = 0;
    while(i < HLIT + HDIST) {
    5ad3:	8b 55 d8             	mov    -0x28(%ebp),%edx
    5ad6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5ad9:	01 d0                	add    %edx,%eax
    5adb:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    5ade:	0f 87 62 fd ff ff    	ja     5846 <getTreeInflateDynamic+0x1f7>
        (10=no endcode, 11=wrong jump outside of tree)*/
        /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
        ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
      }
    }
    if(error) break;
    5ae4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5ae8:	75 4f                	jne    5b39 <getTreeInflateDynamic+0x4ea>

    if(bitlen_ll[256] == 0) ERROR_BREAK(64); /*the length of the end code 256 must be larger than 0*/
    5aea:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5aed:	05 00 04 00 00       	add    $0x400,%eax
    5af2:	8b 00                	mov    (%eax),%eax
    5af4:	85 c0                	test   %eax,%eax
    5af6:	75 09                	jne    5b01 <getTreeInflateDynamic+0x4b2>
    5af8:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
    5aff:	eb 3c                	jmp    5b3d <getTreeInflateDynamic+0x4ee>

    /*now we've finally got HLIT and HDIST, so generate the code trees, and the function is done*/
    error = HuffmanTree_makeFromLengths(tree_ll, bitlen_ll, NUM_DEFLATE_CODE_SYMBOLS, 15);
    5b01:	6a 0f                	push   $0xf
    5b03:	68 20 01 00 00       	push   $0x120
    5b08:	ff 75 e8             	pushl  -0x18(%ebp)
    5b0b:	ff 75 08             	pushl  0x8(%ebp)
    5b0e:	e8 32 ef ff ff       	call   4a45 <HuffmanTree_makeFromLengths>
    5b13:	83 c4 10             	add    $0x10,%esp
    5b16:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    5b19:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5b1d:	75 1d                	jne    5b3c <getTreeInflateDynamic+0x4ed>
    error = HuffmanTree_makeFromLengths(tree_d, bitlen_d, NUM_DISTANCE_SYMBOLS, 15);
    5b1f:	6a 0f                	push   $0xf
    5b21:	6a 20                	push   $0x20
    5b23:	ff 75 e4             	pushl  -0x1c(%ebp)
    5b26:	ff 75 0c             	pushl  0xc(%ebp)
    5b29:	e8 17 ef ff ff       	call   4a45 <HuffmanTree_makeFromLengths>
    5b2e:	83 c4 10             	add    $0x10,%esp
    5b31:	89 45 f4             	mov    %eax,-0xc(%ebp)

    break; /*end of error-while*/
    5b34:	eb 07                	jmp    5b3d <getTreeInflateDynamic+0x4ee>
    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {
      bitlen_cl[CLCL_ORDER[i]] = 0;
    }

    error = HuffmanTree_makeFromLengths(&tree_cl, bitlen_cl, NUM_CODE_LENGTH_CODES, 7);
    if(error) break;
    5b36:	90                   	nop
    5b37:	eb 04                	jmp    5b3d <getTreeInflateDynamic+0x4ee>
        (10=no endcode, 11=wrong jump outside of tree)*/
        /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
        ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
      }
    }
    if(error) break;
    5b39:	90                   	nop
    5b3a:	eb 01                	jmp    5b3d <getTreeInflateDynamic+0x4ee>

    if(bitlen_ll[256] == 0) ERROR_BREAK(64); /*the length of the end code 256 must be larger than 0*/

    /*now we've finally got HLIT and HDIST, so generate the code trees, and the function is done*/
    error = HuffmanTree_makeFromLengths(tree_ll, bitlen_ll, NUM_DEFLATE_CODE_SYMBOLS, 15);
    if(error) break;
    5b3c:	90                   	nop
    error = HuffmanTree_makeFromLengths(tree_d, bitlen_d, NUM_DISTANCE_SYMBOLS, 15);

    break; /*end of error-while*/
  }

  lodepng_free(bitlen_cl);
    5b3d:	83 ec 0c             	sub    $0xc,%esp
    5b40:	ff 75 dc             	pushl  -0x24(%ebp)
    5b43:	e8 dc d8 ff ff       	call   3424 <lodepng_free>
    5b48:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_ll);
    5b4b:	83 ec 0c             	sub    $0xc,%esp
    5b4e:	ff 75 e8             	pushl  -0x18(%ebp)
    5b51:	e8 ce d8 ff ff       	call   3424 <lodepng_free>
    5b56:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_d);
    5b59:	83 ec 0c             	sub    $0xc,%esp
    5b5c:	ff 75 e4             	pushl  -0x1c(%ebp)
    5b5f:	e8 c0 d8 ff ff       	call   3424 <lodepng_free>
    5b64:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_cl);
    5b67:	83 ec 0c             	sub    $0xc,%esp
    5b6a:	8d 45 a8             	lea    -0x58(%ebp),%eax
    5b6d:	50                   	push   %eax
    5b6e:	e8 b1 e7 ff ff       	call   4324 <HuffmanTree_cleanup>
    5b73:	83 c4 10             	add    $0x10,%esp

  return error;
    5b76:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    5b79:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    5b7c:	c9                   	leave  
    5b7d:	c3                   	ret    

00005b7e <inflateHuffmanBlock>:

/*inflate a block with dynamic of fixed Huffman tree. btype must be 1 or 2.*/
static unsigned inflateHuffmanBlock(ucvector* out, LodePNGBitReader* reader,
                                    unsigned btype, size_t max_output_size) {
    5b7e:	55                   	push   %ebp
    5b7f:	89 e5                	mov    %esp,%ebp
    5b81:	53                   	push   %ebx
    5b82:	83 ec 64             	sub    $0x64,%esp
  unsigned error = 0;
    5b85:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  HuffmanTree tree_ll; /*the huffman tree for literal and length codes*/
  HuffmanTree tree_d; /*the huffman tree for distance codes*/

  HuffmanTree_init(&tree_ll);
    5b8c:	8d 45 b8             	lea    -0x48(%ebp),%eax
    5b8f:	50                   	push   %eax
    5b90:	e8 62 e7 ff ff       	call   42f7 <HuffmanTree_init>
    5b95:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_d);
    5b98:	8d 45 a0             	lea    -0x60(%ebp),%eax
    5b9b:	50                   	push   %eax
    5b9c:	e8 56 e7 ff ff       	call   42f7 <HuffmanTree_init>
    5ba1:	83 c4 04             	add    $0x4,%esp

  if(btype == 1) error = getTreeInflateFixed(&tree_ll, &tree_d);
    5ba4:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    5ba8:	75 1b                	jne    5bc5 <inflateHuffmanBlock+0x47>
    5baa:	83 ec 08             	sub    $0x8,%esp
    5bad:	8d 45 a0             	lea    -0x60(%ebp),%eax
    5bb0:	50                   	push   %eax
    5bb1:	8d 45 b8             	lea    -0x48(%ebp),%eax
    5bb4:	50                   	push   %eax
    5bb5:	e8 63 fa ff ff       	call   561d <getTreeInflateFixed>
    5bba:	83 c4 10             	add    $0x10,%esp
    5bbd:	89 45 f4             	mov    %eax,-0xc(%ebp)
    5bc0:	e9 9a 02 00 00       	jmp    5e5f <inflateHuffmanBlock+0x2e1>
  else /*if(btype == 2)*/ error = getTreeInflateDynamic(&tree_ll, &tree_d, reader);
    5bc5:	83 ec 04             	sub    $0x4,%esp
    5bc8:	ff 75 0c             	pushl  0xc(%ebp)
    5bcb:	8d 45 a0             	lea    -0x60(%ebp),%eax
    5bce:	50                   	push   %eax
    5bcf:	8d 45 b8             	lea    -0x48(%ebp),%eax
    5bd2:	50                   	push   %eax
    5bd3:	e8 77 fa ff ff       	call   564f <getTreeInflateDynamic>
    5bd8:	83 c4 10             	add    $0x10,%esp
    5bdb:	89 45 f4             	mov    %eax,-0xc(%ebp)

  while(!error) /*decode all symbols until end reached, breaks at end code*/ {
    5bde:	e9 7c 02 00 00       	jmp    5e5f <inflateHuffmanBlock+0x2e1>
    /*code_ll is literal, length or end code*/
    unsigned code_ll;
    ensureBits25(reader, 20); /* up to 15 for the huffman symbol, up to 5 for the length extra bits */
    5be3:	83 ec 08             	sub    $0x8,%esp
    5be6:	6a 14                	push   $0x14
    5be8:	ff 75 0c             	pushl  0xc(%ebp)
    5beb:	e8 ef e1 ff ff       	call   3ddf <ensureBits25>
    5bf0:	83 c4 10             	add    $0x10,%esp
    code_ll = huffmanDecodeSymbol(reader, &tree_ll);
    5bf3:	83 ec 08             	sub    $0x8,%esp
    5bf6:	8d 45 b8             	lea    -0x48(%ebp),%eax
    5bf9:	50                   	push   %eax
    5bfa:	ff 75 0c             	pushl  0xc(%ebp)
    5bfd:	e8 5a f9 ff ff       	call   555c <huffmanDecodeSymbol>
    5c02:	83 c4 10             	add    $0x10,%esp
    5c05:	89 45 dc             	mov    %eax,-0x24(%ebp)
    if(code_ll <= 255) /*literal symbol*/ {
    5c08:	81 7d dc ff 00 00 00 	cmpl   $0xff,-0x24(%ebp)
    5c0f:	77 42                	ja     5c53 <inflateHuffmanBlock+0xd5>
      if(!ucvector_resize(out, out->size + 1)) ERROR_BREAK(83 /*alloc fail*/);
    5c11:	8b 45 08             	mov    0x8(%ebp),%eax
    5c14:	8b 40 04             	mov    0x4(%eax),%eax
    5c17:	83 c0 01             	add    $0x1,%eax
    5c1a:	83 ec 08             	sub    $0x8,%esp
    5c1d:	50                   	push   %eax
    5c1e:	ff 75 08             	pushl  0x8(%ebp)
    5c21:	e8 37 da ff ff       	call   365d <ucvector_resize>
    5c26:	83 c4 10             	add    $0x10,%esp
    5c29:	85 c0                	test   %eax,%eax
    5c2b:	75 0c                	jne    5c39 <inflateHuffmanBlock+0xbb>
    5c2d:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    5c34:	e9 33 02 00 00       	jmp    5e6c <inflateHuffmanBlock+0x2ee>
      out->data[out->size - 1] = (unsigned char)code_ll;
    5c39:	8b 45 08             	mov    0x8(%ebp),%eax
    5c3c:	8b 10                	mov    (%eax),%edx
    5c3e:	8b 45 08             	mov    0x8(%ebp),%eax
    5c41:	8b 40 04             	mov    0x4(%eax),%eax
    5c44:	83 e8 01             	sub    $0x1,%eax
    5c47:	01 d0                	add    %edx,%eax
    5c49:	8b 55 dc             	mov    -0x24(%ebp),%edx
    5c4c:	88 10                	mov    %dl,(%eax)
    5c4e:	e9 d9 01 00 00       	jmp    5e2c <inflateHuffmanBlock+0x2ae>
    } else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/ {
    5c53:	81 7d dc 00 01 00 00 	cmpl   $0x100,-0x24(%ebp)
    5c5a:	0f 86 ba 01 00 00    	jbe    5e1a <inflateHuffmanBlock+0x29c>
    5c60:	81 7d dc 1d 01 00 00 	cmpl   $0x11d,-0x24(%ebp)
    5c67:	0f 87 ad 01 00 00    	ja     5e1a <inflateHuffmanBlock+0x29c>
      unsigned code_d, distance;
      unsigned numextrabits_l, numextrabits_d; /*extra bits for length and distance*/
      size_t start, backward, length;

      /*part 1: get length base*/
      length = LENGTHBASE[code_ll - FIRST_LENGTH_CODE_INDEX];
    5c6d:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5c70:	2d 01 01 00 00       	sub    $0x101,%eax
    5c75:	8b 04 85 20 9e 01 00 	mov    0x19e20(,%eax,4),%eax
    5c7c:	89 45 e4             	mov    %eax,-0x1c(%ebp)

      /*part 2: get extra bits and add the value of that to length*/
      numextrabits_l = LENGTHEXTRA[code_ll - FIRST_LENGTH_CODE_INDEX];
    5c7f:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5c82:	2d 01 01 00 00       	sub    $0x101,%eax
    5c87:	8b 04 85 a0 9e 01 00 	mov    0x19ea0(,%eax,4),%eax
    5c8e:	89 45 d8             	mov    %eax,-0x28(%ebp)
      if(numextrabits_l != 0) {
    5c91:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
    5c95:	74 1c                	je     5cb3 <inflateHuffmanBlock+0x135>
        /* bits already ensured above */
        length += readBits(reader, numextrabits_l);
    5c97:	8b 45 d8             	mov    -0x28(%ebp),%eax
    5c9a:	83 ec 08             	sub    $0x8,%esp
    5c9d:	50                   	push   %eax
    5c9e:	ff 75 0c             	pushl  0xc(%ebp)
    5ca1:	e8 e9 e4 ff ff       	call   418f <readBits>
    5ca6:	83 c4 10             	add    $0x10,%esp
    5ca9:	89 c2                	mov    %eax,%edx
    5cab:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5cae:	01 d0                	add    %edx,%eax
    5cb0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      }

      /*part 3: get distance code*/
      ensureBits32(reader, 28); /* up to 15 for the huffman symbol, up to 13 for the extra bits */
    5cb3:	83 ec 08             	sub    $0x8,%esp
    5cb6:	6a 1c                	push   $0x1c
    5cb8:	ff 75 0c             	pushl  0xc(%ebp)
    5cbb:	e8 98 e2 ff ff       	call   3f58 <ensureBits32>
    5cc0:	83 c4 10             	add    $0x10,%esp
      code_d = huffmanDecodeSymbol(reader, &tree_d);
    5cc3:	83 ec 08             	sub    $0x8,%esp
    5cc6:	8d 45 a0             	lea    -0x60(%ebp),%eax
    5cc9:	50                   	push   %eax
    5cca:	ff 75 0c             	pushl  0xc(%ebp)
    5ccd:	e8 8a f8 ff ff       	call   555c <huffmanDecodeSymbol>
    5cd2:	83 c4 10             	add    $0x10,%esp
    5cd5:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      if(code_d > 29) {
    5cd8:	83 7d d4 1d          	cmpl   $0x1d,-0x2c(%ebp)
    5cdc:	76 1e                	jbe    5cfc <inflateHuffmanBlock+0x17e>
        if(code_d <= 31) {
    5cde:	83 7d d4 1f          	cmpl   $0x1f,-0x2c(%ebp)
    5ce2:	77 0c                	ja     5cf0 <inflateHuffmanBlock+0x172>
          ERROR_BREAK(18); /*error: invalid distance code (30-31 are never used)*/
    5ce4:	c7 45 f4 12 00 00 00 	movl   $0x12,-0xc(%ebp)
    5ceb:	e9 7c 01 00 00       	jmp    5e6c <inflateHuffmanBlock+0x2ee>
        } else /* if(code_d == INVALIDSYMBOL) */{
          ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/
    5cf0:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
    5cf7:	e9 70 01 00 00       	jmp    5e6c <inflateHuffmanBlock+0x2ee>
        }
      }
      distance = DISTANCEBASE[code_d];
    5cfc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5cff:	8b 04 85 20 9f 01 00 	mov    0x19f20(,%eax,4),%eax
    5d06:	89 45 f0             	mov    %eax,-0x10(%ebp)

      /*part 4: get extra bits from distance*/
      numextrabits_d = DISTANCEEXTRA[code_d];
    5d09:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5d0c:	8b 04 85 a0 9f 01 00 	mov    0x19fa0(,%eax,4),%eax
    5d13:	89 45 d0             	mov    %eax,-0x30(%ebp)
      if(numextrabits_d != 0) {
    5d16:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
    5d1a:	74 15                	je     5d31 <inflateHuffmanBlock+0x1b3>
        /* bits already ensured above */
        distance += readBits(reader, numextrabits_d);
    5d1c:	8b 45 d0             	mov    -0x30(%ebp),%eax
    5d1f:	83 ec 08             	sub    $0x8,%esp
    5d22:	50                   	push   %eax
    5d23:	ff 75 0c             	pushl  0xc(%ebp)
    5d26:	e8 64 e4 ff ff       	call   418f <readBits>
    5d2b:	83 c4 10             	add    $0x10,%esp
    5d2e:	01 45 f0             	add    %eax,-0x10(%ebp)
      }

      /*part 5: fill in all the out[n] values based on the length and dist*/
      start = out->size;
    5d31:	8b 45 08             	mov    0x8(%ebp),%eax
    5d34:	8b 40 04             	mov    0x4(%eax),%eax
    5d37:	89 45 ec             	mov    %eax,-0x14(%ebp)
      if(distance > start) ERROR_BREAK(52); /*too long backward distance*/
    5d3a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5d3d:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    5d40:	76 0c                	jbe    5d4e <inflateHuffmanBlock+0x1d0>
    5d42:	c7 45 f4 34 00 00 00 	movl   $0x34,-0xc(%ebp)
    5d49:	e9 1e 01 00 00       	jmp    5e6c <inflateHuffmanBlock+0x2ee>
      backward = start - distance;
    5d4e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5d51:	2b 45 f0             	sub    -0x10(%ebp),%eax
    5d54:	89 45 e8             	mov    %eax,-0x18(%ebp)

      if(!ucvector_resize(out, out->size + length)) ERROR_BREAK(83 /*alloc fail*/);
    5d57:	8b 45 08             	mov    0x8(%ebp),%eax
    5d5a:	8b 50 04             	mov    0x4(%eax),%edx
    5d5d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5d60:	01 d0                	add    %edx,%eax
    5d62:	83 ec 08             	sub    $0x8,%esp
    5d65:	50                   	push   %eax
    5d66:	ff 75 08             	pushl  0x8(%ebp)
    5d69:	e8 ef d8 ff ff       	call   365d <ucvector_resize>
    5d6e:	83 c4 10             	add    $0x10,%esp
    5d71:	85 c0                	test   %eax,%eax
    5d73:	75 0c                	jne    5d81 <inflateHuffmanBlock+0x203>
    5d75:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    5d7c:	e9 eb 00 00 00       	jmp    5e6c <inflateHuffmanBlock+0x2ee>
      if(distance < length) {
    5d81:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5d84:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    5d87:	73 6b                	jae    5df4 <inflateHuffmanBlock+0x276>
        size_t forward;
        lodepng_memcpy(out->data + start, out->data + backward, distance);
    5d89:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5d8c:	8b 55 08             	mov    0x8(%ebp),%edx
    5d8f:	8b 0a                	mov    (%edx),%ecx
    5d91:	8b 55 e8             	mov    -0x18(%ebp),%edx
    5d94:	01 d1                	add    %edx,%ecx
    5d96:	8b 55 08             	mov    0x8(%ebp),%edx
    5d99:	8b 1a                	mov    (%edx),%ebx
    5d9b:	8b 55 ec             	mov    -0x14(%ebp),%edx
    5d9e:	01 da                	add    %ebx,%edx
    5da0:	83 ec 04             	sub    $0x4,%esp
    5da3:	50                   	push   %eax
    5da4:	51                   	push   %ecx
    5da5:	52                   	push   %edx
    5da6:	e8 96 d6 ff ff       	call   3441 <lodepng_memcpy>
    5dab:	83 c4 10             	add    $0x10,%esp
        start += distance;
    5dae:	8b 55 ec             	mov    -0x14(%ebp),%edx
    5db1:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5db4:	01 d0                	add    %edx,%eax
    5db6:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for(forward = distance; forward < length; ++forward) {
    5db9:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5dbc:	89 45 e0             	mov    %eax,-0x20(%ebp)
    5dbf:	eb 29                	jmp    5dea <inflateHuffmanBlock+0x26c>
          out->data[start++] = out->data[backward++];
    5dc1:	8b 45 08             	mov    0x8(%ebp),%eax
    5dc4:	8b 08                	mov    (%eax),%ecx
    5dc6:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5dc9:	8d 50 01             	lea    0x1(%eax),%edx
    5dcc:	89 55 ec             	mov    %edx,-0x14(%ebp)
    5dcf:	01 c1                	add    %eax,%ecx
    5dd1:	8b 45 08             	mov    0x8(%ebp),%eax
    5dd4:	8b 18                	mov    (%eax),%ebx
    5dd6:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5dd9:	8d 50 01             	lea    0x1(%eax),%edx
    5ddc:	89 55 e8             	mov    %edx,-0x18(%ebp)
    5ddf:	01 d8                	add    %ebx,%eax
    5de1:	0f b6 00             	movzbl (%eax),%eax
    5de4:	88 01                	mov    %al,(%ecx)
      if(!ucvector_resize(out, out->size + length)) ERROR_BREAK(83 /*alloc fail*/);
      if(distance < length) {
        size_t forward;
        lodepng_memcpy(out->data + start, out->data + backward, distance);
        start += distance;
        for(forward = distance; forward < length; ++forward) {
    5de6:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
    5dea:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5ded:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    5df0:	7c cf                	jl     5dc1 <inflateHuffmanBlock+0x243>
    ensureBits25(reader, 20); /* up to 15 for the huffman symbol, up to 5 for the length extra bits */
    code_ll = huffmanDecodeSymbol(reader, &tree_ll);
    if(code_ll <= 255) /*literal symbol*/ {
      if(!ucvector_resize(out, out->size + 1)) ERROR_BREAK(83 /*alloc fail*/);
      out->data[out->size - 1] = (unsigned char)code_ll;
    } else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/ {
    5df2:	eb 38                	jmp    5e2c <inflateHuffmanBlock+0x2ae>
        start += distance;
        for(forward = distance; forward < length; ++forward) {
          out->data[start++] = out->data[backward++];
        }
      } else {
        lodepng_memcpy(out->data + start, out->data + backward, length);
    5df4:	8b 45 08             	mov    0x8(%ebp),%eax
    5df7:	8b 10                	mov    (%eax),%edx
    5df9:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5dfc:	01 c2                	add    %eax,%edx
    5dfe:	8b 45 08             	mov    0x8(%ebp),%eax
    5e01:	8b 08                	mov    (%eax),%ecx
    5e03:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5e06:	01 c8                	add    %ecx,%eax
    5e08:	83 ec 04             	sub    $0x4,%esp
    5e0b:	ff 75 e4             	pushl  -0x1c(%ebp)
    5e0e:	52                   	push   %edx
    5e0f:	50                   	push   %eax
    5e10:	e8 2c d6 ff ff       	call   3441 <lodepng_memcpy>
    5e15:	83 c4 10             	add    $0x10,%esp
    ensureBits25(reader, 20); /* up to 15 for the huffman symbol, up to 5 for the length extra bits */
    code_ll = huffmanDecodeSymbol(reader, &tree_ll);
    if(code_ll <= 255) /*literal symbol*/ {
      if(!ucvector_resize(out, out->size + 1)) ERROR_BREAK(83 /*alloc fail*/);
      out->data[out->size - 1] = (unsigned char)code_ll;
    } else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/ {
    5e18:	eb 12                	jmp    5e2c <inflateHuffmanBlock+0x2ae>
          out->data[start++] = out->data[backward++];
        }
      } else {
        lodepng_memcpy(out->data + start, out->data + backward, length);
      }
    } else if(code_ll == 256) {
    5e1a:	81 7d dc 00 01 00 00 	cmpl   $0x100,-0x24(%ebp)
    5e21:	74 48                	je     5e6b <inflateHuffmanBlock+0x2ed>
      break; /*end code, break the loop*/
    } else /*if(code_ll == INVALIDSYMBOL)*/ {
      ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/
    5e23:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
    5e2a:	eb 40                	jmp    5e6c <inflateHuffmanBlock+0x2ee>
    }
    /*check if any of the ensureBits above went out of bounds*/
    if(reader->bp > reader->bitsize) {
    5e2c:	8b 45 0c             	mov    0xc(%ebp),%eax
    5e2f:	8b 50 0c             	mov    0xc(%eax),%edx
    5e32:	8b 45 0c             	mov    0xc(%ebp),%eax
    5e35:	8b 40 08             	mov    0x8(%eax),%eax
    5e38:	39 c2                	cmp    %eax,%edx
    5e3a:	7e 09                	jle    5e45 <inflateHuffmanBlock+0x2c7>
      /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol
      (10=no endcode, 11=wrong jump outside of tree)*/
      /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
      ERROR_BREAK(51); /*error, bit pointer jumps past memory*/
    5e3c:	c7 45 f4 33 00 00 00 	movl   $0x33,-0xc(%ebp)
    5e43:	eb 27                	jmp    5e6c <inflateHuffmanBlock+0x2ee>
    }
    if(max_output_size && out->size > max_output_size) {
    5e45:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    5e49:	74 14                	je     5e5f <inflateHuffmanBlock+0x2e1>
    5e4b:	8b 45 08             	mov    0x8(%ebp),%eax
    5e4e:	8b 40 04             	mov    0x4(%eax),%eax
    5e51:	3b 45 14             	cmp    0x14(%ebp),%eax
    5e54:	7e 09                	jle    5e5f <inflateHuffmanBlock+0x2e1>
      ERROR_BREAK(109); /*error, larger than max size*/
    5e56:	c7 45 f4 6d 00 00 00 	movl   $0x6d,-0xc(%ebp)
    5e5d:	eb 0d                	jmp    5e6c <inflateHuffmanBlock+0x2ee>
  HuffmanTree_init(&tree_d);

  if(btype == 1) error = getTreeInflateFixed(&tree_ll, &tree_d);
  else /*if(btype == 2)*/ error = getTreeInflateDynamic(&tree_ll, &tree_d, reader);

  while(!error) /*decode all symbols until end reached, breaks at end code*/ {
    5e5f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5e63:	0f 84 7a fd ff ff    	je     5be3 <inflateHuffmanBlock+0x65>
    5e69:	eb 01                	jmp    5e6c <inflateHuffmanBlock+0x2ee>
        }
      } else {
        lodepng_memcpy(out->data + start, out->data + backward, length);
      }
    } else if(code_ll == 256) {
      break; /*end code, break the loop*/
    5e6b:	90                   	nop
    if(max_output_size && out->size > max_output_size) {
      ERROR_BREAK(109); /*error, larger than max size*/
    }
  }

  HuffmanTree_cleanup(&tree_ll);
    5e6c:	83 ec 0c             	sub    $0xc,%esp
    5e6f:	8d 45 b8             	lea    -0x48(%ebp),%eax
    5e72:	50                   	push   %eax
    5e73:	e8 ac e4 ff ff       	call   4324 <HuffmanTree_cleanup>
    5e78:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_d);
    5e7b:	83 ec 0c             	sub    $0xc,%esp
    5e7e:	8d 45 a0             	lea    -0x60(%ebp),%eax
    5e81:	50                   	push   %eax
    5e82:	e8 9d e4 ff ff       	call   4324 <HuffmanTree_cleanup>
    5e87:	83 c4 10             	add    $0x10,%esp

  return error;
    5e8a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    5e8d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    5e90:	c9                   	leave  
    5e91:	c3                   	ret    

00005e92 <inflateNoCompression>:

static unsigned inflateNoCompression(ucvector* out, LodePNGBitReader* reader,
                                     const LodePNGDecompressSettings* settings) {
    5e92:	55                   	push   %ebp
    5e93:	89 e5                	mov    %esp,%ebp
    5e95:	53                   	push   %ebx
    5e96:	83 ec 20             	sub    $0x20,%esp
  size_t bytepos;
  size_t size = reader->size;
    5e99:	8b 45 0c             	mov    0xc(%ebp),%eax
    5e9c:	8b 40 04             	mov    0x4(%eax),%eax
    5e9f:	89 45 f8             	mov    %eax,-0x8(%ebp)
  unsigned LEN, NLEN, error = 0;
    5ea2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  /*go to first boundary of byte*/
  bytepos = (reader->bp + 7u) >> 3u;
    5ea9:	8b 45 0c             	mov    0xc(%ebp),%eax
    5eac:	8b 40 0c             	mov    0xc(%eax),%eax
    5eaf:	83 c0 07             	add    $0x7,%eax
    5eb2:	c1 e8 03             	shr    $0x3,%eax
    5eb5:	89 45 f0             	mov    %eax,-0x10(%ebp)

  /*read LEN (2 bytes) and NLEN (2 bytes)*/
  if(bytepos + 4 >= size) return 52; /*error, bit pointer will jump past memory*/
    5eb8:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5ebb:	83 c0 04             	add    $0x4,%eax
    5ebe:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    5ec1:	7c 0a                	jl     5ecd <inflateNoCompression+0x3b>
    5ec3:	b8 34 00 00 00       	mov    $0x34,%eax
    5ec8:	e9 01 01 00 00       	jmp    5fce <inflateNoCompression+0x13c>
  LEN = (unsigned)reader->data[bytepos] + ((unsigned)reader->data[bytepos + 1] << 8u); bytepos += 2;
    5ecd:	8b 45 0c             	mov    0xc(%ebp),%eax
    5ed0:	8b 10                	mov    (%eax),%edx
    5ed2:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5ed5:	01 d0                	add    %edx,%eax
    5ed7:	0f b6 00             	movzbl (%eax),%eax
    5eda:	0f b6 d0             	movzbl %al,%edx
    5edd:	8b 45 0c             	mov    0xc(%ebp),%eax
    5ee0:	8b 00                	mov    (%eax),%eax
    5ee2:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    5ee5:	83 c1 01             	add    $0x1,%ecx
    5ee8:	01 c8                	add    %ecx,%eax
    5eea:	0f b6 00             	movzbl (%eax),%eax
    5eed:	0f b6 c0             	movzbl %al,%eax
    5ef0:	c1 e0 08             	shl    $0x8,%eax
    5ef3:	01 d0                	add    %edx,%eax
    5ef5:	89 45 ec             	mov    %eax,-0x14(%ebp)
    5ef8:	83 45 f0 02          	addl   $0x2,-0x10(%ebp)
  NLEN = (unsigned)reader->data[bytepos] + ((unsigned)reader->data[bytepos + 1] << 8u); bytepos += 2;
    5efc:	8b 45 0c             	mov    0xc(%ebp),%eax
    5eff:	8b 10                	mov    (%eax),%edx
    5f01:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5f04:	01 d0                	add    %edx,%eax
    5f06:	0f b6 00             	movzbl (%eax),%eax
    5f09:	0f b6 d0             	movzbl %al,%edx
    5f0c:	8b 45 0c             	mov    0xc(%ebp),%eax
    5f0f:	8b 00                	mov    (%eax),%eax
    5f11:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    5f14:	83 c1 01             	add    $0x1,%ecx
    5f17:	01 c8                	add    %ecx,%eax
    5f19:	0f b6 00             	movzbl (%eax),%eax
    5f1c:	0f b6 c0             	movzbl %al,%eax
    5f1f:	c1 e0 08             	shl    $0x8,%eax
    5f22:	01 d0                	add    %edx,%eax
    5f24:	89 45 e8             	mov    %eax,-0x18(%ebp)
    5f27:	83 45 f0 02          	addl   $0x2,-0x10(%ebp)

  /*check if 16-bit NLEN is really the one's complement of LEN*/
  if(!settings->ignore_nlen && LEN + NLEN != 65535) {
    5f2b:	8b 45 10             	mov    0x10(%ebp),%eax
    5f2e:	8b 40 04             	mov    0x4(%eax),%eax
    5f31:	85 c0                	test   %eax,%eax
    5f33:	75 19                	jne    5f4e <inflateNoCompression+0xbc>
    5f35:	8b 55 ec             	mov    -0x14(%ebp),%edx
    5f38:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5f3b:	01 d0                	add    %edx,%eax
    5f3d:	3d ff ff 00 00       	cmp    $0xffff,%eax
    5f42:	74 0a                	je     5f4e <inflateNoCompression+0xbc>
    return 21; /*error: NLEN is not one's complement of LEN*/
    5f44:	b8 15 00 00 00       	mov    $0x15,%eax
    5f49:	e9 80 00 00 00       	jmp    5fce <inflateNoCompression+0x13c>
  }

  if(!ucvector_resize(out, out->size + LEN)) return 83; /*alloc fail*/
    5f4e:	8b 45 08             	mov    0x8(%ebp),%eax
    5f51:	8b 40 04             	mov    0x4(%eax),%eax
    5f54:	89 c2                	mov    %eax,%edx
    5f56:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5f59:	01 d0                	add    %edx,%eax
    5f5b:	50                   	push   %eax
    5f5c:	ff 75 08             	pushl  0x8(%ebp)
    5f5f:	e8 f9 d6 ff ff       	call   365d <ucvector_resize>
    5f64:	83 c4 08             	add    $0x8,%esp
    5f67:	85 c0                	test   %eax,%eax
    5f69:	75 07                	jne    5f72 <inflateNoCompression+0xe0>
    5f6b:	b8 53 00 00 00       	mov    $0x53,%eax
    5f70:	eb 5c                	jmp    5fce <inflateNoCompression+0x13c>

  /*read the literal data: LEN bytes are now stored in the out buffer*/
  if(bytepos + LEN > size) return 23; /*error: reading outside of in buffer*/
    5f72:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5f75:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5f78:	01 c2                	add    %eax,%edx
    5f7a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    5f7d:	39 c2                	cmp    %eax,%edx
    5f7f:	76 07                	jbe    5f88 <inflateNoCompression+0xf6>
    5f81:	b8 17 00 00 00       	mov    $0x17,%eax
    5f86:	eb 46                	jmp    5fce <inflateNoCompression+0x13c>

  lodepng_memcpy(out->data + out->size - LEN, reader->data + bytepos, LEN);
    5f88:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5f8b:	8b 55 0c             	mov    0xc(%ebp),%edx
    5f8e:	8b 0a                	mov    (%edx),%ecx
    5f90:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5f93:	01 d1                	add    %edx,%ecx
    5f95:	8b 55 08             	mov    0x8(%ebp),%edx
    5f98:	8b 1a                	mov    (%edx),%ebx
    5f9a:	8b 55 08             	mov    0x8(%ebp),%edx
    5f9d:	8b 52 04             	mov    0x4(%edx),%edx
    5fa0:	2b 55 ec             	sub    -0x14(%ebp),%edx
    5fa3:	01 da                	add    %ebx,%edx
    5fa5:	50                   	push   %eax
    5fa6:	51                   	push   %ecx
    5fa7:	52                   	push   %edx
    5fa8:	e8 94 d4 ff ff       	call   3441 <lodepng_memcpy>
    5fad:	83 c4 0c             	add    $0xc,%esp
  bytepos += LEN;
    5fb0:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5fb3:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5fb6:	01 d0                	add    %edx,%eax
    5fb8:	89 45 f0             	mov    %eax,-0x10(%ebp)

  reader->bp = bytepos << 3u;
    5fbb:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5fbe:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
    5fc5:	8b 45 0c             	mov    0xc(%ebp),%eax
    5fc8:	89 50 0c             	mov    %edx,0xc(%eax)

  return error;
    5fcb:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    5fce:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    5fd1:	c9                   	leave  
    5fd2:	c3                   	ret    

00005fd3 <lodepng_inflatev>:

static unsigned lodepng_inflatev(ucvector* out,
                                 const unsigned char* in, size_t insize,
                                 const LodePNGDecompressSettings* settings) {
    5fd3:	55                   	push   %ebp
    5fd4:	89 e5                	mov    %esp,%ebp
    5fd6:	83 ec 28             	sub    $0x28,%esp
  unsigned BFINAL = 0;
    5fd9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, in, insize);
    5fe0:	ff 75 10             	pushl  0x10(%ebp)
    5fe3:	ff 75 0c             	pushl  0xc(%ebp)
    5fe6:	8d 45 d8             	lea    -0x28(%ebp),%eax
    5fe9:	50                   	push   %eax
    5fea:	e8 77 db ff ff       	call   3b66 <LodePNGBitReader_init>
    5fef:	83 c4 0c             	add    $0xc,%esp
    5ff2:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if(error) return error;
    5ff5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    5ff9:	0f 84 b9 00 00 00    	je     60b8 <lodepng_inflatev+0xe5>
    5fff:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6002:	e9 c1 00 00 00       	jmp    60c8 <lodepng_inflatev+0xf5>

  while(!BFINAL) {
    unsigned BTYPE;
    if(!ensureBits9(&reader, 3)) return 52; /*error, bit pointer will jump past memory*/
    6007:	6a 03                	push   $0x3
    6009:	8d 45 d8             	lea    -0x28(%ebp),%eax
    600c:	50                   	push   %eax
    600d:	e8 c5 db ff ff       	call   3bd7 <ensureBits9>
    6012:	83 c4 08             	add    $0x8,%esp
    6015:	85 c0                	test   %eax,%eax
    6017:	75 0a                	jne    6023 <lodepng_inflatev+0x50>
    6019:	b8 34 00 00 00       	mov    $0x34,%eax
    601e:	e9 a5 00 00 00       	jmp    60c8 <lodepng_inflatev+0xf5>
    BFINAL = readBits(&reader, 1);
    6023:	6a 01                	push   $0x1
    6025:	8d 45 d8             	lea    -0x28(%ebp),%eax
    6028:	50                   	push   %eax
    6029:	e8 61 e1 ff ff       	call   418f <readBits>
    602e:	83 c4 08             	add    $0x8,%esp
    6031:	89 45 f4             	mov    %eax,-0xc(%ebp)
    BTYPE = readBits(&reader, 2);
    6034:	6a 02                	push   $0x2
    6036:	8d 45 d8             	lea    -0x28(%ebp),%eax
    6039:	50                   	push   %eax
    603a:	e8 50 e1 ff ff       	call   418f <readBits>
    603f:	83 c4 08             	add    $0x8,%esp
    6042:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(BTYPE == 3) return 20; /*error: invalid BTYPE*/
    6045:	83 7d ec 03          	cmpl   $0x3,-0x14(%ebp)
    6049:	75 07                	jne    6052 <lodepng_inflatev+0x7f>
    604b:	b8 14 00 00 00       	mov    $0x14,%eax
    6050:	eb 76                	jmp    60c8 <lodepng_inflatev+0xf5>
    else if(BTYPE == 0) error = inflateNoCompression(out, &reader, settings); /*no compression*/
    6052:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    6056:	75 17                	jne    606f <lodepng_inflatev+0x9c>
    6058:	ff 75 14             	pushl  0x14(%ebp)
    605b:	8d 45 d8             	lea    -0x28(%ebp),%eax
    605e:	50                   	push   %eax
    605f:	ff 75 08             	pushl  0x8(%ebp)
    6062:	e8 2b fe ff ff       	call   5e92 <inflateNoCompression>
    6067:	83 c4 0c             	add    $0xc,%esp
    606a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    606d:	eb 1c                	jmp    608b <lodepng_inflatev+0xb8>
    else error = inflateHuffmanBlock(out, &reader, BTYPE, settings->max_output_size); /*compression, BTYPE 01 or 10*/
    606f:	8b 45 14             	mov    0x14(%ebp),%eax
    6072:	8b 40 08             	mov    0x8(%eax),%eax
    6075:	50                   	push   %eax
    6076:	ff 75 ec             	pushl  -0x14(%ebp)
    6079:	8d 45 d8             	lea    -0x28(%ebp),%eax
    607c:	50                   	push   %eax
    607d:	ff 75 08             	pushl  0x8(%ebp)
    6080:	e8 f9 fa ff ff       	call   5b7e <inflateHuffmanBlock>
    6085:	83 c4 10             	add    $0x10,%esp
    6088:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!error && settings->max_output_size && out->size > settings->max_output_size) error = 109;
    608b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    608f:	75 21                	jne    60b2 <lodepng_inflatev+0xdf>
    6091:	8b 45 14             	mov    0x14(%ebp),%eax
    6094:	8b 40 08             	mov    0x8(%eax),%eax
    6097:	85 c0                	test   %eax,%eax
    6099:	74 17                	je     60b2 <lodepng_inflatev+0xdf>
    609b:	8b 45 08             	mov    0x8(%ebp),%eax
    609e:	8b 50 04             	mov    0x4(%eax),%edx
    60a1:	8b 45 14             	mov    0x14(%ebp),%eax
    60a4:	8b 40 08             	mov    0x8(%eax),%eax
    60a7:	39 c2                	cmp    %eax,%edx
    60a9:	7e 07                	jle    60b2 <lodepng_inflatev+0xdf>
    60ab:	c7 45 f0 6d 00 00 00 	movl   $0x6d,-0x10(%ebp)
    if(error) break;
    60b2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    60b6:	75 0c                	jne    60c4 <lodepng_inflatev+0xf1>
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, in, insize);

  if(error) return error;

  while(!BFINAL) {
    60b8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    60bc:	0f 84 45 ff ff ff    	je     6007 <lodepng_inflatev+0x34>
    60c2:	eb 01                	jmp    60c5 <lodepng_inflatev+0xf2>

    if(BTYPE == 3) return 20; /*error: invalid BTYPE*/
    else if(BTYPE == 0) error = inflateNoCompression(out, &reader, settings); /*no compression*/
    else error = inflateHuffmanBlock(out, &reader, BTYPE, settings->max_output_size); /*compression, BTYPE 01 or 10*/
    if(!error && settings->max_output_size && out->size > settings->max_output_size) error = 109;
    if(error) break;
    60c4:	90                   	nop
  }

  return error;
    60c5:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    60c8:	c9                   	leave  
    60c9:	c3                   	ret    

000060ca <lodepng_inflate>:

unsigned lodepng_inflate(unsigned char** out, size_t* outsize,
                         const unsigned char* in, size_t insize,
                         const LodePNGDecompressSettings* settings) {
    60ca:	55                   	push   %ebp
    60cb:	89 e5                	mov    %esp,%ebp
    60cd:	83 ec 18             	sub    $0x18,%esp
  ucvector v = ucvector_init(*out, *outsize);
    60d0:	8b 45 0c             	mov    0xc(%ebp),%eax
    60d3:	8b 08                	mov    (%eax),%ecx
    60d5:	8b 45 08             	mov    0x8(%ebp),%eax
    60d8:	8b 10                	mov    (%eax),%edx
    60da:	8d 45 e8             	lea    -0x18(%ebp),%eax
    60dd:	51                   	push   %ecx
    60de:	52                   	push   %edx
    60df:	50                   	push   %eax
    60e0:	e8 df d5 ff ff       	call   36c4 <ucvector_init>
    60e5:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_inflatev(&v, in, insize, settings);
    60e8:	ff 75 18             	pushl  0x18(%ebp)
    60eb:	ff 75 14             	pushl  0x14(%ebp)
    60ee:	ff 75 10             	pushl  0x10(%ebp)
    60f1:	8d 45 e8             	lea    -0x18(%ebp),%eax
    60f4:	50                   	push   %eax
    60f5:	e8 d9 fe ff ff       	call   5fd3 <lodepng_inflatev>
    60fa:	83 c4 10             	add    $0x10,%esp
    60fd:	89 45 f4             	mov    %eax,-0xc(%ebp)
  *out = v.data;
    6100:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6103:	8b 45 08             	mov    0x8(%ebp),%eax
    6106:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    6108:	8b 55 ec             	mov    -0x14(%ebp),%edx
    610b:	8b 45 0c             	mov    0xc(%ebp),%eax
    610e:	89 10                	mov    %edx,(%eax)
  return error;
    6110:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    6113:	c9                   	leave  
    6114:	c3                   	ret    

00006115 <inflatev>:

static unsigned inflatev(ucvector* out, const unsigned char* in, size_t insize,
                        const LodePNGDecompressSettings* settings) {
    6115:	55                   	push   %ebp
    6116:	89 e5                	mov    %esp,%ebp
    6118:	83 ec 18             	sub    $0x18,%esp
  if(settings->custom_inflate) {
    611b:	8b 45 14             	mov    0x14(%ebp),%eax
    611e:	8b 40 10             	mov    0x10(%eax),%eax
    6121:	85 c0                	test   %eax,%eax
    6123:	74 64                	je     6189 <inflatev+0x74>
    unsigned error = settings->custom_inflate(&out->data, &out->size, in, insize, settings);
    6125:	8b 45 14             	mov    0x14(%ebp),%eax
    6128:	8b 40 10             	mov    0x10(%eax),%eax
    612b:	8b 55 08             	mov    0x8(%ebp),%edx
    612e:	8d 4a 04             	lea    0x4(%edx),%ecx
    6131:	8b 55 08             	mov    0x8(%ebp),%edx
    6134:	83 ec 0c             	sub    $0xc,%esp
    6137:	ff 75 14             	pushl  0x14(%ebp)
    613a:	ff 75 10             	pushl  0x10(%ebp)
    613d:	ff 75 0c             	pushl  0xc(%ebp)
    6140:	51                   	push   %ecx
    6141:	52                   	push   %edx
    6142:	ff d0                	call   *%eax
    6144:	83 c4 20             	add    $0x20,%esp
    6147:	89 45 f4             	mov    %eax,-0xc(%ebp)
    out->allocsize = out->size;
    614a:	8b 45 08             	mov    0x8(%ebp),%eax
    614d:	8b 50 04             	mov    0x4(%eax),%edx
    6150:	8b 45 08             	mov    0x8(%ebp),%eax
    6153:	89 50 08             	mov    %edx,0x8(%eax)
    if(error) {
    6156:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    615a:	74 28                	je     6184 <inflatev+0x6f>
      /*the custom inflate is allowed to have its own error codes, however, we translate it to code 110*/
      error = 110;
    615c:	c7 45 f4 6e 00 00 00 	movl   $0x6e,-0xc(%ebp)
      /*if there's a max output size, and the custom zlib returned error, then indicate that error instead*/
      if(settings->max_output_size && out->size > settings->max_output_size) error = 109;
    6163:	8b 45 14             	mov    0x14(%ebp),%eax
    6166:	8b 40 08             	mov    0x8(%eax),%eax
    6169:	85 c0                	test   %eax,%eax
    616b:	74 17                	je     6184 <inflatev+0x6f>
    616d:	8b 45 08             	mov    0x8(%ebp),%eax
    6170:	8b 50 04             	mov    0x4(%eax),%edx
    6173:	8b 45 14             	mov    0x14(%ebp),%eax
    6176:	8b 40 08             	mov    0x8(%eax),%eax
    6179:	39 c2                	cmp    %eax,%edx
    617b:	7e 07                	jle    6184 <inflatev+0x6f>
    617d:	c7 45 f4 6d 00 00 00 	movl   $0x6d,-0xc(%ebp)
    }
    return error;
    6184:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6187:	eb 14                	jmp    619d <inflatev+0x88>
  } else {
    return lodepng_inflatev(out, in, insize, settings);
    6189:	ff 75 14             	pushl  0x14(%ebp)
    618c:	ff 75 10             	pushl  0x10(%ebp)
    618f:	ff 75 0c             	pushl  0xc(%ebp)
    6192:	ff 75 08             	pushl  0x8(%ebp)
    6195:	e8 39 fe ff ff       	call   5fd3 <lodepng_inflatev>
    619a:	83 c4 10             	add    $0x10,%esp
  }
}
    619d:	c9                   	leave  
    619e:	c3                   	ret    

0000619f <searchCodeIndex>:

static const size_t MAX_SUPPORTED_DEFLATE_LENGTH = 258;

/*search the index in the array, that has the largest value smaller than or equal to the given value,
given array must be sorted (if no value is smaller, it returns the size of the given array)*/
static size_t searchCodeIndex(const unsigned* array, size_t array_size, size_t value) {
    619f:	55                   	push   %ebp
    61a0:	89 e5                	mov    %esp,%ebp
    61a2:	83 ec 10             	sub    $0x10,%esp
  /*binary search (only small gain over linear). TODO: use CPU log2 instruction for getting symbols instead*/
  size_t left = 1;
    61a5:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
  size_t right = array_size - 1;
    61ac:	8b 45 0c             	mov    0xc(%ebp),%eax
    61af:	83 e8 01             	sub    $0x1,%eax
    61b2:	89 45 f8             	mov    %eax,-0x8(%ebp)

  while(left <= right) {
    61b5:	eb 39                	jmp    61f0 <searchCodeIndex+0x51>
    size_t mid = (left + right) >> 1;
    61b7:	8b 55 fc             	mov    -0x4(%ebp),%edx
    61ba:	8b 45 f8             	mov    -0x8(%ebp),%eax
    61bd:	01 d0                	add    %edx,%eax
    61bf:	d1 f8                	sar    %eax
    61c1:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(array[mid] >= value) right = mid - 1;
    61c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    61c7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    61ce:	8b 45 08             	mov    0x8(%ebp),%eax
    61d1:	01 d0                	add    %edx,%eax
    61d3:	8b 10                	mov    (%eax),%edx
    61d5:	8b 45 10             	mov    0x10(%ebp),%eax
    61d8:	39 c2                	cmp    %eax,%edx
    61da:	72 0b                	jb     61e7 <searchCodeIndex+0x48>
    61dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    61df:	83 e8 01             	sub    $0x1,%eax
    61e2:	89 45 f8             	mov    %eax,-0x8(%ebp)
    61e5:	eb 09                	jmp    61f0 <searchCodeIndex+0x51>
    else left = mid + 1;
    61e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    61ea:	83 c0 01             	add    $0x1,%eax
    61ed:	89 45 fc             	mov    %eax,-0x4(%ebp)
static size_t searchCodeIndex(const unsigned* array, size_t array_size, size_t value) {
  /*binary search (only small gain over linear). TODO: use CPU log2 instruction for getting symbols instead*/
  size_t left = 1;
  size_t right = array_size - 1;

  while(left <= right) {
    61f0:	8b 45 fc             	mov    -0x4(%ebp),%eax
    61f3:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    61f6:	7e bf                	jle    61b7 <searchCodeIndex+0x18>
    size_t mid = (left + right) >> 1;
    if(array[mid] >= value) right = mid - 1;
    else left = mid + 1;
  }
  if(left >= array_size || array[left] > value) left--;
    61f8:	8b 45 fc             	mov    -0x4(%ebp),%eax
    61fb:	3b 45 0c             	cmp    0xc(%ebp),%eax
    61fe:	7d 18                	jge    6218 <searchCodeIndex+0x79>
    6200:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6203:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    620a:	8b 45 08             	mov    0x8(%ebp),%eax
    620d:	01 d0                	add    %edx,%eax
    620f:	8b 10                	mov    (%eax),%edx
    6211:	8b 45 10             	mov    0x10(%ebp),%eax
    6214:	39 c2                	cmp    %eax,%edx
    6216:	76 04                	jbe    621c <searchCodeIndex+0x7d>
    6218:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
  return left;
    621c:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    621f:	c9                   	leave  
    6220:	c3                   	ret    

00006221 <addLengthDistance>:

static void addLengthDistance(uivector* values, size_t length, size_t distance) {
    6221:	55                   	push   %ebp
    6222:	89 e5                	mov    %esp,%ebp
    6224:	83 ec 20             	sub    $0x20,%esp
  0-255: literal bytes
  256: end
  257-285: length/distance pair (length code, followed by extra length bits, distance code, extra distance bits)
  286-287: invalid*/

  unsigned length_code = (unsigned)searchCodeIndex(LENGTHBASE, 29, length);
    6227:	ff 75 0c             	pushl  0xc(%ebp)
    622a:	6a 1d                	push   $0x1d
    622c:	68 20 9e 01 00       	push   $0x19e20
    6231:	e8 69 ff ff ff       	call   619f <searchCodeIndex>
    6236:	83 c4 0c             	add    $0xc,%esp
    6239:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned extra_length = (unsigned)(length - LENGTHBASE[length_code]);
    623c:	8b 55 0c             	mov    0xc(%ebp),%edx
    623f:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6242:	8b 04 85 20 9e 01 00 	mov    0x19e20(,%eax,4),%eax
    6249:	29 c2                	sub    %eax,%edx
    624b:	89 d0                	mov    %edx,%eax
    624d:	89 45 f8             	mov    %eax,-0x8(%ebp)
  unsigned dist_code = (unsigned)searchCodeIndex(DISTANCEBASE, 30, distance);
    6250:	ff 75 10             	pushl  0x10(%ebp)
    6253:	6a 1e                	push   $0x1e
    6255:	68 20 9f 01 00       	push   $0x19f20
    625a:	e8 40 ff ff ff       	call   619f <searchCodeIndex>
    625f:	83 c4 0c             	add    $0xc,%esp
    6262:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned extra_distance = (unsigned)(distance - DISTANCEBASE[dist_code]);
    6265:	8b 55 10             	mov    0x10(%ebp),%edx
    6268:	8b 45 f4             	mov    -0xc(%ebp),%eax
    626b:	8b 04 85 20 9f 01 00 	mov    0x19f20(,%eax,4),%eax
    6272:	29 c2                	sub    %eax,%edx
    6274:	89 d0                	mov    %edx,%eax
    6276:	89 45 f0             	mov    %eax,-0x10(%ebp)

  size_t pos = values->size;
    6279:	8b 45 08             	mov    0x8(%ebp),%eax
    627c:	8b 40 04             	mov    0x4(%eax),%eax
    627f:	89 45 ec             	mov    %eax,-0x14(%ebp)
  /*TODO: return error when this fails (out of memory)*/
  unsigned ok = uivector_resize(values, values->size + 4);
    6282:	8b 45 08             	mov    0x8(%ebp),%eax
    6285:	8b 40 04             	mov    0x4(%eax),%eax
    6288:	83 c0 04             	add    $0x4,%eax
    628b:	50                   	push   %eax
    628c:	ff 75 08             	pushl  0x8(%ebp)
    628f:	e8 f0 d2 ff ff       	call   3584 <uivector_resize>
    6294:	83 c4 08             	add    $0x8,%esp
    6297:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(ok) {
    629a:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    629e:	74 57                	je     62f7 <addLengthDistance+0xd6>
    values->data[pos + 0] = length_code + FIRST_LENGTH_CODE_INDEX;
    62a0:	8b 45 08             	mov    0x8(%ebp),%eax
    62a3:	8b 00                	mov    (%eax),%eax
    62a5:	8b 55 ec             	mov    -0x14(%ebp),%edx
    62a8:	c1 e2 02             	shl    $0x2,%edx
    62ab:	01 d0                	add    %edx,%eax
    62ad:	8b 55 fc             	mov    -0x4(%ebp),%edx
    62b0:	81 c2 01 01 00 00    	add    $0x101,%edx
    62b6:	89 10                	mov    %edx,(%eax)
    values->data[pos + 1] = extra_length;
    62b8:	8b 45 08             	mov    0x8(%ebp),%eax
    62bb:	8b 00                	mov    (%eax),%eax
    62bd:	8b 55 ec             	mov    -0x14(%ebp),%edx
    62c0:	83 c2 01             	add    $0x1,%edx
    62c3:	c1 e2 02             	shl    $0x2,%edx
    62c6:	01 c2                	add    %eax,%edx
    62c8:	8b 45 f8             	mov    -0x8(%ebp),%eax
    62cb:	89 02                	mov    %eax,(%edx)
    values->data[pos + 2] = dist_code;
    62cd:	8b 45 08             	mov    0x8(%ebp),%eax
    62d0:	8b 00                	mov    (%eax),%eax
    62d2:	8b 55 ec             	mov    -0x14(%ebp),%edx
    62d5:	83 c2 02             	add    $0x2,%edx
    62d8:	c1 e2 02             	shl    $0x2,%edx
    62db:	01 c2                	add    %eax,%edx
    62dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
    62e0:	89 02                	mov    %eax,(%edx)
    values->data[pos + 3] = extra_distance;
    62e2:	8b 45 08             	mov    0x8(%ebp),%eax
    62e5:	8b 00                	mov    (%eax),%eax
    62e7:	8b 55 ec             	mov    -0x14(%ebp),%edx
    62ea:	83 c2 03             	add    $0x3,%edx
    62ed:	c1 e2 02             	shl    $0x2,%edx
    62f0:	01 c2                	add    %eax,%edx
    62f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
    62f5:	89 02                	mov    %eax,(%edx)
  }
}
    62f7:	90                   	nop
    62f8:	c9                   	leave  
    62f9:	c3                   	ret    

000062fa <hash_init>:
  int* headz; /*similar to head, but for chainz*/
  unsigned short* chainz; /*those with same amount of zeros*/
  unsigned short* zeros; /*length of zeros streak, used as a second hash chain*/
} Hash;

static unsigned hash_init(Hash* hash, unsigned windowsize) {
    62fa:	55                   	push   %ebp
    62fb:	89 e5                	mov    %esp,%ebp
    62fd:	83 ec 18             	sub    $0x18,%esp
  unsigned i;
  hash->head = (int*)lodepng_malloc(sizeof(int) * HASH_NUM_VALUES);
    6300:	b8 00 00 01 00       	mov    $0x10000,%eax
    6305:	c1 e0 02             	shl    $0x2,%eax
    6308:	83 ec 0c             	sub    $0xc,%esp
    630b:	50                   	push   %eax
    630c:	e8 f2 d0 ff ff       	call   3403 <lodepng_malloc>
    6311:	83 c4 10             	add    $0x10,%esp
    6314:	89 c2                	mov    %eax,%edx
    6316:	8b 45 08             	mov    0x8(%ebp),%eax
    6319:	89 10                	mov    %edx,(%eax)
  hash->val = (int*)lodepng_malloc(sizeof(int) * windowsize);
    631b:	8b 45 0c             	mov    0xc(%ebp),%eax
    631e:	c1 e0 02             	shl    $0x2,%eax
    6321:	83 ec 0c             	sub    $0xc,%esp
    6324:	50                   	push   %eax
    6325:	e8 d9 d0 ff ff       	call   3403 <lodepng_malloc>
    632a:	83 c4 10             	add    $0x10,%esp
    632d:	89 c2                	mov    %eax,%edx
    632f:	8b 45 08             	mov    0x8(%ebp),%eax
    6332:	89 50 08             	mov    %edx,0x8(%eax)
  hash->chain = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
    6335:	8b 45 0c             	mov    0xc(%ebp),%eax
    6338:	01 c0                	add    %eax,%eax
    633a:	83 ec 0c             	sub    $0xc,%esp
    633d:	50                   	push   %eax
    633e:	e8 c0 d0 ff ff       	call   3403 <lodepng_malloc>
    6343:	83 c4 10             	add    $0x10,%esp
    6346:	89 c2                	mov    %eax,%edx
    6348:	8b 45 08             	mov    0x8(%ebp),%eax
    634b:	89 50 04             	mov    %edx,0x4(%eax)

  hash->zeros = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
    634e:	8b 45 0c             	mov    0xc(%ebp),%eax
    6351:	01 c0                	add    %eax,%eax
    6353:	83 ec 0c             	sub    $0xc,%esp
    6356:	50                   	push   %eax
    6357:	e8 a7 d0 ff ff       	call   3403 <lodepng_malloc>
    635c:	83 c4 10             	add    $0x10,%esp
    635f:	89 c2                	mov    %eax,%edx
    6361:	8b 45 08             	mov    0x8(%ebp),%eax
    6364:	89 50 14             	mov    %edx,0x14(%eax)
  hash->headz = (int*)lodepng_malloc(sizeof(int) * (MAX_SUPPORTED_DEFLATE_LENGTH + 1));
    6367:	b8 02 01 00 00       	mov    $0x102,%eax
    636c:	83 c0 01             	add    $0x1,%eax
    636f:	c1 e0 02             	shl    $0x2,%eax
    6372:	83 ec 0c             	sub    $0xc,%esp
    6375:	50                   	push   %eax
    6376:	e8 88 d0 ff ff       	call   3403 <lodepng_malloc>
    637b:	83 c4 10             	add    $0x10,%esp
    637e:	89 c2                	mov    %eax,%edx
    6380:	8b 45 08             	mov    0x8(%ebp),%eax
    6383:	89 50 0c             	mov    %edx,0xc(%eax)
  hash->chainz = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
    6386:	8b 45 0c             	mov    0xc(%ebp),%eax
    6389:	01 c0                	add    %eax,%eax
    638b:	83 ec 0c             	sub    $0xc,%esp
    638e:	50                   	push   %eax
    638f:	e8 6f d0 ff ff       	call   3403 <lodepng_malloc>
    6394:	83 c4 10             	add    $0x10,%esp
    6397:	89 c2                	mov    %eax,%edx
    6399:	8b 45 08             	mov    0x8(%ebp),%eax
    639c:	89 50 10             	mov    %edx,0x10(%eax)

  if(!hash->head || !hash->chain || !hash->val  || !hash->headz|| !hash->chainz || !hash->zeros) {
    639f:	8b 45 08             	mov    0x8(%ebp),%eax
    63a2:	8b 00                	mov    (%eax),%eax
    63a4:	85 c0                	test   %eax,%eax
    63a6:	74 32                	je     63da <hash_init+0xe0>
    63a8:	8b 45 08             	mov    0x8(%ebp),%eax
    63ab:	8b 40 04             	mov    0x4(%eax),%eax
    63ae:	85 c0                	test   %eax,%eax
    63b0:	74 28                	je     63da <hash_init+0xe0>
    63b2:	8b 45 08             	mov    0x8(%ebp),%eax
    63b5:	8b 40 08             	mov    0x8(%eax),%eax
    63b8:	85 c0                	test   %eax,%eax
    63ba:	74 1e                	je     63da <hash_init+0xe0>
    63bc:	8b 45 08             	mov    0x8(%ebp),%eax
    63bf:	8b 40 0c             	mov    0xc(%eax),%eax
    63c2:	85 c0                	test   %eax,%eax
    63c4:	74 14                	je     63da <hash_init+0xe0>
    63c6:	8b 45 08             	mov    0x8(%ebp),%eax
    63c9:	8b 40 10             	mov    0x10(%eax),%eax
    63cc:	85 c0                	test   %eax,%eax
    63ce:	74 0a                	je     63da <hash_init+0xe0>
    63d0:	8b 45 08             	mov    0x8(%ebp),%eax
    63d3:	8b 40 14             	mov    0x14(%eax),%eax
    63d6:	85 c0                	test   %eax,%eax
    63d8:	75 0a                	jne    63e4 <hash_init+0xea>
    return 83; /*alloc fail*/
    63da:	b8 53 00 00 00       	mov    $0x53,%eax
    63df:	e9 d3 00 00 00       	jmp    64b7 <hash_init+0x1bd>
  }

  /*initialize hash table*/
  for(i = 0; i != HASH_NUM_VALUES; ++i) hash->head[i] = -1;
    63e4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    63eb:	eb 17                	jmp    6404 <hash_init+0x10a>
    63ed:	8b 45 08             	mov    0x8(%ebp),%eax
    63f0:	8b 00                	mov    (%eax),%eax
    63f2:	8b 55 f4             	mov    -0xc(%ebp),%edx
    63f5:	c1 e2 02             	shl    $0x2,%edx
    63f8:	01 d0                	add    %edx,%eax
    63fa:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    6400:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    6404:	b8 00 00 01 00       	mov    $0x10000,%eax
    6409:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    640c:	75 df                	jne    63ed <hash_init+0xf3>
  for(i = 0; i != windowsize; ++i) hash->val[i] = -1;
    640e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    6415:	eb 18                	jmp    642f <hash_init+0x135>
    6417:	8b 45 08             	mov    0x8(%ebp),%eax
    641a:	8b 40 08             	mov    0x8(%eax),%eax
    641d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6420:	c1 e2 02             	shl    $0x2,%edx
    6423:	01 d0                	add    %edx,%eax
    6425:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    642b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    642f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6432:	3b 45 0c             	cmp    0xc(%ebp),%eax
    6435:	75 e0                	jne    6417 <hash_init+0x11d>
  for(i = 0; i != windowsize; ++i) hash->chain[i] = i; /*same value as index indicates uninitialized*/
    6437:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    643e:	eb 17                	jmp    6457 <hash_init+0x15d>
    6440:	8b 45 08             	mov    0x8(%ebp),%eax
    6443:	8b 40 04             	mov    0x4(%eax),%eax
    6446:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6449:	01 d2                	add    %edx,%edx
    644b:	01 d0                	add    %edx,%eax
    644d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6450:	66 89 10             	mov    %dx,(%eax)
    6453:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    6457:	8b 45 f4             	mov    -0xc(%ebp),%eax
    645a:	3b 45 0c             	cmp    0xc(%ebp),%eax
    645d:	75 e1                	jne    6440 <hash_init+0x146>

  for(i = 0; i <= MAX_SUPPORTED_DEFLATE_LENGTH; ++i) hash->headz[i] = -1;
    645f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    6466:	eb 18                	jmp    6480 <hash_init+0x186>
    6468:	8b 45 08             	mov    0x8(%ebp),%eax
    646b:	8b 40 0c             	mov    0xc(%eax),%eax
    646e:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6471:	c1 e2 02             	shl    $0x2,%edx
    6474:	01 d0                	add    %edx,%eax
    6476:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    647c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    6480:	b8 02 01 00 00       	mov    $0x102,%eax
    6485:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    6488:	76 de                	jbe    6468 <hash_init+0x16e>
  for(i = 0; i != windowsize; ++i) hash->chainz[i] = i; /*same value as index indicates uninitialized*/
    648a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    6491:	eb 17                	jmp    64aa <hash_init+0x1b0>
    6493:	8b 45 08             	mov    0x8(%ebp),%eax
    6496:	8b 40 10             	mov    0x10(%eax),%eax
    6499:	8b 55 f4             	mov    -0xc(%ebp),%edx
    649c:	01 d2                	add    %edx,%edx
    649e:	01 d0                	add    %edx,%eax
    64a0:	8b 55 f4             	mov    -0xc(%ebp),%edx
    64a3:	66 89 10             	mov    %dx,(%eax)
    64a6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    64aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
    64ad:	3b 45 0c             	cmp    0xc(%ebp),%eax
    64b0:	75 e1                	jne    6493 <hash_init+0x199>

  return 0;
    64b2:	b8 00 00 00 00       	mov    $0x0,%eax
}
    64b7:	c9                   	leave  
    64b8:	c3                   	ret    

000064b9 <hash_cleanup>:

static void hash_cleanup(Hash* hash) {
    64b9:	55                   	push   %ebp
    64ba:	89 e5                	mov    %esp,%ebp
    64bc:	83 ec 08             	sub    $0x8,%esp
  lodepng_free(hash->head);
    64bf:	8b 45 08             	mov    0x8(%ebp),%eax
    64c2:	8b 00                	mov    (%eax),%eax
    64c4:	83 ec 0c             	sub    $0xc,%esp
    64c7:	50                   	push   %eax
    64c8:	e8 57 cf ff ff       	call   3424 <lodepng_free>
    64cd:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->val);
    64d0:	8b 45 08             	mov    0x8(%ebp),%eax
    64d3:	8b 40 08             	mov    0x8(%eax),%eax
    64d6:	83 ec 0c             	sub    $0xc,%esp
    64d9:	50                   	push   %eax
    64da:	e8 45 cf ff ff       	call   3424 <lodepng_free>
    64df:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->chain);
    64e2:	8b 45 08             	mov    0x8(%ebp),%eax
    64e5:	8b 40 04             	mov    0x4(%eax),%eax
    64e8:	83 ec 0c             	sub    $0xc,%esp
    64eb:	50                   	push   %eax
    64ec:	e8 33 cf ff ff       	call   3424 <lodepng_free>
    64f1:	83 c4 10             	add    $0x10,%esp

  lodepng_free(hash->zeros);
    64f4:	8b 45 08             	mov    0x8(%ebp),%eax
    64f7:	8b 40 14             	mov    0x14(%eax),%eax
    64fa:	83 ec 0c             	sub    $0xc,%esp
    64fd:	50                   	push   %eax
    64fe:	e8 21 cf ff ff       	call   3424 <lodepng_free>
    6503:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->headz);
    6506:	8b 45 08             	mov    0x8(%ebp),%eax
    6509:	8b 40 0c             	mov    0xc(%eax),%eax
    650c:	83 ec 0c             	sub    $0xc,%esp
    650f:	50                   	push   %eax
    6510:	e8 0f cf ff ff       	call   3424 <lodepng_free>
    6515:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->chainz);
    6518:	8b 45 08             	mov    0x8(%ebp),%eax
    651b:	8b 40 10             	mov    0x10(%eax),%eax
    651e:	83 ec 0c             	sub    $0xc,%esp
    6521:	50                   	push   %eax
    6522:	e8 fd ce ff ff       	call   3424 <lodepng_free>
    6527:	83 c4 10             	add    $0x10,%esp
}
    652a:	90                   	nop
    652b:	c9                   	leave  
    652c:	c3                   	ret    

0000652d <getHash>:



static unsigned getHash(const unsigned char* data, size_t size, size_t pos) {
    652d:	55                   	push   %ebp
    652e:	89 e5                	mov    %esp,%ebp
    6530:	83 ec 10             	sub    $0x10,%esp
  unsigned result = 0;
    6533:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  if(pos + 2 < size) {
    653a:	8b 45 10             	mov    0x10(%ebp),%eax
    653d:	83 c0 02             	add    $0x2,%eax
    6540:	3b 45 0c             	cmp    0xc(%ebp),%eax
    6543:	7d 41                	jge    6586 <getHash+0x59>
    /*A simple shift and xor hash is used. Since the data of PNGs is dominated
    by zeroes due to the filters, a better hash does not have a significant
    effect on speed in traversing the chain, and causes more time spend on
    calculating the hash.*/
    result ^= ((unsigned)data[pos + 0] << 0u);
    6545:	8b 55 10             	mov    0x10(%ebp),%edx
    6548:	8b 45 08             	mov    0x8(%ebp),%eax
    654b:	01 d0                	add    %edx,%eax
    654d:	0f b6 00             	movzbl (%eax),%eax
    6550:	0f b6 c0             	movzbl %al,%eax
    6553:	31 45 fc             	xor    %eax,-0x4(%ebp)
    result ^= ((unsigned)data[pos + 1] << 4u);
    6556:	8b 45 10             	mov    0x10(%ebp),%eax
    6559:	8d 50 01             	lea    0x1(%eax),%edx
    655c:	8b 45 08             	mov    0x8(%ebp),%eax
    655f:	01 d0                	add    %edx,%eax
    6561:	0f b6 00             	movzbl (%eax),%eax
    6564:	0f b6 c0             	movzbl %al,%eax
    6567:	c1 e0 04             	shl    $0x4,%eax
    656a:	31 45 fc             	xor    %eax,-0x4(%ebp)
    result ^= ((unsigned)data[pos + 2] << 8u);
    656d:	8b 45 10             	mov    0x10(%ebp),%eax
    6570:	8d 50 02             	lea    0x2(%eax),%edx
    6573:	8b 45 08             	mov    0x8(%ebp),%eax
    6576:	01 d0                	add    %edx,%eax
    6578:	0f b6 00             	movzbl (%eax),%eax
    657b:	0f b6 c0             	movzbl %al,%eax
    657e:	c1 e0 08             	shl    $0x8,%eax
    6581:	31 45 fc             	xor    %eax,-0x4(%ebp)
    6584:	eb 51                	jmp    65d7 <getHash+0xaa>
  } else {
    size_t amount, i;
    if(pos >= size) return 0;
    6586:	8b 45 10             	mov    0x10(%ebp),%eax
    6589:	3b 45 0c             	cmp    0xc(%ebp),%eax
    658c:	7c 07                	jl     6595 <getHash+0x68>
    658e:	b8 00 00 00 00       	mov    $0x0,%eax
    6593:	eb 4a                	jmp    65df <getHash+0xb2>
    amount = size - pos;
    6595:	8b 45 0c             	mov    0xc(%ebp),%eax
    6598:	2b 45 10             	sub    0x10(%ebp),%eax
    659b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    for(i = 0; i != amount; ++i) result ^= ((unsigned)data[pos + i] << (i * 8u));
    659e:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    65a5:	eb 28                	jmp    65cf <getHash+0xa2>
    65a7:	8b 55 10             	mov    0x10(%ebp),%edx
    65aa:	8b 45 f8             	mov    -0x8(%ebp),%eax
    65ad:	01 d0                	add    %edx,%eax
    65af:	89 c2                	mov    %eax,%edx
    65b1:	8b 45 08             	mov    0x8(%ebp),%eax
    65b4:	01 d0                	add    %edx,%eax
    65b6:	0f b6 00             	movzbl (%eax),%eax
    65b9:	0f b6 d0             	movzbl %al,%edx
    65bc:	8b 45 f8             	mov    -0x8(%ebp),%eax
    65bf:	c1 e0 03             	shl    $0x3,%eax
    65c2:	89 c1                	mov    %eax,%ecx
    65c4:	d3 e2                	shl    %cl,%edx
    65c6:	89 d0                	mov    %edx,%eax
    65c8:	31 45 fc             	xor    %eax,-0x4(%ebp)
    65cb:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    65cf:	8b 45 f8             	mov    -0x8(%ebp),%eax
    65d2:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    65d5:	75 d0                	jne    65a7 <getHash+0x7a>
  }
  return result & HASH_BIT_MASK;
    65d7:	b8 ff ff 00 00       	mov    $0xffff,%eax
    65dc:	23 45 fc             	and    -0x4(%ebp),%eax
}
    65df:	c9                   	leave  
    65e0:	c3                   	ret    

000065e1 <countZeros>:

static unsigned countZeros(const unsigned char* data, size_t size, size_t pos) {
    65e1:	55                   	push   %ebp
    65e2:	89 e5                	mov    %esp,%ebp
    65e4:	83 ec 10             	sub    $0x10,%esp
  const unsigned char* start = data + pos;
    65e7:	8b 55 10             	mov    0x10(%ebp),%edx
    65ea:	8b 45 08             	mov    0x8(%ebp),%eax
    65ed:	01 d0                	add    %edx,%eax
    65ef:	89 45 f8             	mov    %eax,-0x8(%ebp)
  const unsigned char* end = start + MAX_SUPPORTED_DEFLATE_LENGTH;
    65f2:	b8 02 01 00 00       	mov    $0x102,%eax
    65f7:	89 c2                	mov    %eax,%edx
    65f9:	8b 45 f8             	mov    -0x8(%ebp),%eax
    65fc:	01 d0                	add    %edx,%eax
    65fe:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if(end > data + size) end = data + size;
    6601:	8b 55 0c             	mov    0xc(%ebp),%edx
    6604:	8b 45 08             	mov    0x8(%ebp),%eax
    6607:	01 d0                	add    %edx,%eax
    6609:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    660c:	73 0b                	jae    6619 <countZeros+0x38>
    660e:	8b 55 0c             	mov    0xc(%ebp),%edx
    6611:	8b 45 08             	mov    0x8(%ebp),%eax
    6614:	01 d0                	add    %edx,%eax
    6616:	89 45 fc             	mov    %eax,-0x4(%ebp)
  data = start;
    6619:	8b 45 f8             	mov    -0x8(%ebp),%eax
    661c:	89 45 08             	mov    %eax,0x8(%ebp)
  while(data != end && *data == 0) ++data;
    661f:	eb 04                	jmp    6625 <countZeros+0x44>
    6621:	83 45 08 01          	addl   $0x1,0x8(%ebp)
    6625:	8b 45 08             	mov    0x8(%ebp),%eax
    6628:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    662b:	74 0a                	je     6637 <countZeros+0x56>
    662d:	8b 45 08             	mov    0x8(%ebp),%eax
    6630:	0f b6 00             	movzbl (%eax),%eax
    6633:	84 c0                	test   %al,%al
    6635:	74 ea                	je     6621 <countZeros+0x40>
  /*subtracting two addresses returned as 32-bit number (max value is MAX_SUPPORTED_DEFLATE_LENGTH)*/
  return (unsigned)(data - start);
    6637:	8b 55 08             	mov    0x8(%ebp),%edx
    663a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    663d:	29 c2                	sub    %eax,%edx
    663f:	89 d0                	mov    %edx,%eax
}
    6641:	c9                   	leave  
    6642:	c3                   	ret    

00006643 <updateHashChain>:

/*wpos = pos & (windowsize - 1)*/
static void updateHashChain(Hash* hash, size_t wpos, unsigned hashval, unsigned short numzeros) {
    6643:	55                   	push   %ebp
    6644:	89 e5                	mov    %esp,%ebp
    6646:	83 ec 04             	sub    $0x4,%esp
    6649:	8b 45 14             	mov    0x14(%ebp),%eax
    664c:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
  hash->val[wpos] = (int)hashval;
    6650:	8b 45 08             	mov    0x8(%ebp),%eax
    6653:	8b 40 08             	mov    0x8(%eax),%eax
    6656:	8b 55 0c             	mov    0xc(%ebp),%edx
    6659:	c1 e2 02             	shl    $0x2,%edx
    665c:	01 c2                	add    %eax,%edx
    665e:	8b 45 10             	mov    0x10(%ebp),%eax
    6661:	89 02                	mov    %eax,(%edx)
  if(hash->head[hashval] != -1) hash->chain[wpos] = hash->head[hashval];
    6663:	8b 45 08             	mov    0x8(%ebp),%eax
    6666:	8b 00                	mov    (%eax),%eax
    6668:	8b 55 10             	mov    0x10(%ebp),%edx
    666b:	c1 e2 02             	shl    $0x2,%edx
    666e:	01 d0                	add    %edx,%eax
    6670:	8b 00                	mov    (%eax),%eax
    6672:	83 f8 ff             	cmp    $0xffffffff,%eax
    6675:	74 1f                	je     6696 <updateHashChain+0x53>
    6677:	8b 45 08             	mov    0x8(%ebp),%eax
    667a:	8b 40 04             	mov    0x4(%eax),%eax
    667d:	8b 55 0c             	mov    0xc(%ebp),%edx
    6680:	01 d2                	add    %edx,%edx
    6682:	01 c2                	add    %eax,%edx
    6684:	8b 45 08             	mov    0x8(%ebp),%eax
    6687:	8b 00                	mov    (%eax),%eax
    6689:	8b 4d 10             	mov    0x10(%ebp),%ecx
    668c:	c1 e1 02             	shl    $0x2,%ecx
    668f:	01 c8                	add    %ecx,%eax
    6691:	8b 00                	mov    (%eax),%eax
    6693:	66 89 02             	mov    %ax,(%edx)
  hash->head[hashval] = (int)wpos;
    6696:	8b 45 08             	mov    0x8(%ebp),%eax
    6699:	8b 00                	mov    (%eax),%eax
    669b:	8b 55 10             	mov    0x10(%ebp),%edx
    669e:	c1 e2 02             	shl    $0x2,%edx
    66a1:	01 c2                	add    %eax,%edx
    66a3:	8b 45 0c             	mov    0xc(%ebp),%eax
    66a6:	89 02                	mov    %eax,(%edx)

  hash->zeros[wpos] = numzeros;
    66a8:	8b 45 08             	mov    0x8(%ebp),%eax
    66ab:	8b 40 14             	mov    0x14(%eax),%eax
    66ae:	8b 55 0c             	mov    0xc(%ebp),%edx
    66b1:	01 d2                	add    %edx,%edx
    66b3:	01 c2                	add    %eax,%edx
    66b5:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
    66b9:	66 89 02             	mov    %ax,(%edx)
  if(hash->headz[numzeros] != -1) hash->chainz[wpos] = hash->headz[numzeros];
    66bc:	8b 45 08             	mov    0x8(%ebp),%eax
    66bf:	8b 40 0c             	mov    0xc(%eax),%eax
    66c2:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
    66c6:	c1 e2 02             	shl    $0x2,%edx
    66c9:	01 d0                	add    %edx,%eax
    66cb:	8b 00                	mov    (%eax),%eax
    66cd:	83 f8 ff             	cmp    $0xffffffff,%eax
    66d0:	74 21                	je     66f3 <updateHashChain+0xb0>
    66d2:	8b 45 08             	mov    0x8(%ebp),%eax
    66d5:	8b 40 10             	mov    0x10(%eax),%eax
    66d8:	8b 55 0c             	mov    0xc(%ebp),%edx
    66db:	01 d2                	add    %edx,%edx
    66dd:	01 c2                	add    %eax,%edx
    66df:	8b 45 08             	mov    0x8(%ebp),%eax
    66e2:	8b 40 0c             	mov    0xc(%eax),%eax
    66e5:	0f b7 4d fc          	movzwl -0x4(%ebp),%ecx
    66e9:	c1 e1 02             	shl    $0x2,%ecx
    66ec:	01 c8                	add    %ecx,%eax
    66ee:	8b 00                	mov    (%eax),%eax
    66f0:	66 89 02             	mov    %ax,(%edx)
  hash->headz[numzeros] = (int)wpos;
    66f3:	8b 45 08             	mov    0x8(%ebp),%eax
    66f6:	8b 40 0c             	mov    0xc(%eax),%eax
    66f9:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
    66fd:	c1 e2 02             	shl    $0x2,%edx
    6700:	01 c2                	add    %eax,%edx
    6702:	8b 45 0c             	mov    0xc(%ebp),%eax
    6705:	89 02                	mov    %eax,(%edx)
}
    6707:	90                   	nop
    6708:	c9                   	leave  
    6709:	c3                   	ret    

0000670a <encodeLZ77>:
the "dictionary". A brute force search through all possible distances would be slow, and
this hash technique is one out of several ways to speed this up.
*/
static unsigned encodeLZ77(uivector* out, Hash* hash,
                           const unsigned char* in, size_t inpos, size_t insize, unsigned windowsize,
                           unsigned minmatch, unsigned nicematch, unsigned lazymatching) {
    670a:	55                   	push   %ebp
    670b:	89 e5                	mov    %esp,%ebp
    670d:	83 ec 60             	sub    $0x60,%esp
  size_t pos;
  unsigned i, error = 0;
    6710:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  /*for large window lengths, assume the user wants no compression loss. Otherwise, max hash chain length speedup.*/
  unsigned maxchainlength = windowsize >= 8192 ? windowsize : windowsize / 8u;
    6717:	81 7d 1c ff 1f 00 00 	cmpl   $0x1fff,0x1c(%ebp)
    671e:	77 08                	ja     6728 <encodeLZ77+0x1e>
    6720:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6723:	c1 e8 03             	shr    $0x3,%eax
    6726:	eb 03                	jmp    672b <encodeLZ77+0x21>
    6728:	8b 45 1c             	mov    0x1c(%ebp),%eax
    672b:	89 45 c0             	mov    %eax,-0x40(%ebp)
  unsigned maxlazymatch = windowsize >= 8192 ? MAX_SUPPORTED_DEFLATE_LENGTH : 64;
    672e:	81 7d 1c ff 1f 00 00 	cmpl   $0x1fff,0x1c(%ebp)
    6735:	76 07                	jbe    673e <encodeLZ77+0x34>
    6737:	b8 02 01 00 00       	mov    $0x102,%eax
    673c:	eb 05                	jmp    6743 <encodeLZ77+0x39>
    673e:	b8 40 00 00 00       	mov    $0x40,%eax
    6743:	89 45 bc             	mov    %eax,-0x44(%ebp)

  unsigned usezeros = 1; /*not sure if setting it to false for windowsize < 8192 is better or worse*/
    6746:	c7 45 b8 01 00 00 00 	movl   $0x1,-0x48(%ebp)
  unsigned numzeros = 0;
    674d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  unsigned offset; /*the offset represents the distance in LZ77 terminology*/
  unsigned length;
  unsigned lazy = 0;
    6754:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  unsigned lazylength = 0, lazyoffset = 0;
    675b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    6762:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  unsigned current_offset, current_length;
  unsigned prev_offset;
  const unsigned char *lastptr, *foreptr, *backptr;
  unsigned hashpos;

  if(windowsize == 0 || windowsize > 32768) return 60; /*error: windowsize smaller/larger than allowed*/
    6769:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
    676d:	74 09                	je     6778 <encodeLZ77+0x6e>
    676f:	81 7d 1c 00 80 00 00 	cmpl   $0x8000,0x1c(%ebp)
    6776:	76 0a                	jbe    6782 <encodeLZ77+0x78>
    6778:	b8 3c 00 00 00       	mov    $0x3c,%eax
    677d:	e9 e3 04 00 00       	jmp    6c65 <encodeLZ77+0x55b>
  if((windowsize & (windowsize - 1)) != 0) return 90; /*error: must be power of two*/
    6782:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6785:	83 e8 01             	sub    $0x1,%eax
    6788:	23 45 1c             	and    0x1c(%ebp),%eax
    678b:	85 c0                	test   %eax,%eax
    678d:	74 0a                	je     6799 <encodeLZ77+0x8f>
    678f:	b8 5a 00 00 00       	mov    $0x5a,%eax
    6794:	e9 cc 04 00 00       	jmp    6c65 <encodeLZ77+0x55b>

  if(nicematch > MAX_SUPPORTED_DEFLATE_LENGTH) nicematch = MAX_SUPPORTED_DEFLATE_LENGTH;
    6799:	b8 02 01 00 00       	mov    $0x102,%eax
    679e:	39 45 24             	cmp    %eax,0x24(%ebp)
    67a1:	76 08                	jbe    67ab <encodeLZ77+0xa1>
    67a3:	b8 02 01 00 00       	mov    $0x102,%eax
    67a8:	89 45 24             	mov    %eax,0x24(%ebp)

  for(pos = inpos; pos < insize; ++pos) {
    67ab:	8b 45 14             	mov    0x14(%ebp),%eax
    67ae:	89 45 fc             	mov    %eax,-0x4(%ebp)
    67b1:	e9 a0 04 00 00       	jmp    6c56 <encodeLZ77+0x54c>
    size_t wpos = pos & (windowsize - 1); /*position for in 'circular' hash buffers*/
    67b6:	8b 45 1c             	mov    0x1c(%ebp),%eax
    67b9:	8d 50 ff             	lea    -0x1(%eax),%edx
    67bc:	8b 45 fc             	mov    -0x4(%ebp),%eax
    67bf:	21 d0                	and    %edx,%eax
    67c1:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    unsigned chainlength = 0;
    67c4:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)

    hashval = getHash(in, insize, pos);
    67cb:	ff 75 fc             	pushl  -0x4(%ebp)
    67ce:	ff 75 18             	pushl  0x18(%ebp)
    67d1:	ff 75 10             	pushl  0x10(%ebp)
    67d4:	e8 54 fd ff ff       	call   652d <getHash>
    67d9:	83 c4 0c             	add    $0xc,%esp
    67dc:	89 45 b0             	mov    %eax,-0x50(%ebp)

    if(usezeros && hashval == 0) {
    67df:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
    67e3:	74 4e                	je     6833 <encodeLZ77+0x129>
    67e5:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
    67e9:	75 48                	jne    6833 <encodeLZ77+0x129>
      if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    67eb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    67ef:	75 16                	jne    6807 <encodeLZ77+0xfd>
    67f1:	ff 75 fc             	pushl  -0x4(%ebp)
    67f4:	ff 75 18             	pushl  0x18(%ebp)
    67f7:	ff 75 10             	pushl  0x10(%ebp)
    67fa:	e8 e2 fd ff ff       	call   65e1 <countZeros>
    67ff:	83 c4 0c             	add    $0xc,%esp
    6802:	89 45 f0             	mov    %eax,-0x10(%ebp)
    6805:	eb 35                	jmp    683c <encodeLZ77+0x132>
      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    6807:	8b 55 fc             	mov    -0x4(%ebp),%edx
    680a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    680d:	01 c2                	add    %eax,%edx
    680f:	8b 45 18             	mov    0x18(%ebp),%eax
    6812:	39 c2                	cmp    %eax,%edx
    6814:	77 17                	ja     682d <encodeLZ77+0x123>
    6816:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6819:	8b 45 f0             	mov    -0x10(%ebp),%eax
    681c:	01 d0                	add    %edx,%eax
    681e:	8d 50 ff             	lea    -0x1(%eax),%edx
    6821:	8b 45 10             	mov    0x10(%ebp),%eax
    6824:	01 d0                	add    %edx,%eax
    6826:	0f b6 00             	movzbl (%eax),%eax
    6829:	84 c0                	test   %al,%al
    682b:	74 0f                	je     683c <encodeLZ77+0x132>
    682d:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
    unsigned chainlength = 0;

    hashval = getHash(in, insize, pos);

    if(usezeros && hashval == 0) {
      if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    6831:	eb 09                	jmp    683c <encodeLZ77+0x132>
      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    } else {
      numzeros = 0;
    6833:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    683a:	eb 01                	jmp    683d <encodeLZ77+0x133>
    unsigned chainlength = 0;

    hashval = getHash(in, insize, pos);

    if(usezeros && hashval == 0) {
      if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    683c:	90                   	nop
      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    } else {
      numzeros = 0;
    }

    updateHashChain(hash, wpos, hashval, numzeros);
    683d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6840:	0f b7 c0             	movzwl %ax,%eax
    6843:	50                   	push   %eax
    6844:	ff 75 b0             	pushl  -0x50(%ebp)
    6847:	ff 75 b4             	pushl  -0x4c(%ebp)
    684a:	ff 75 0c             	pushl  0xc(%ebp)
    684d:	e8 f1 fd ff ff       	call   6643 <updateHashChain>
    6852:	83 c4 10             	add    $0x10,%esp

    /*the length and offset found for the current position*/
    length = 0;
    6855:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    offset = 0;
    685c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

    hashpos = hash->chain[wpos];
    6863:	8b 45 0c             	mov    0xc(%ebp),%eax
    6866:	8b 40 04             	mov    0x4(%eax),%eax
    6869:	8b 55 b4             	mov    -0x4c(%ebp),%edx
    686c:	01 d2                	add    %edx,%edx
    686e:	01 d0                	add    %edx,%eax
    6870:	0f b7 00             	movzwl (%eax),%eax
    6873:	0f b7 c0             	movzwl %ax,%eax
    6876:	89 45 cc             	mov    %eax,-0x34(%ebp)

    lastptr = &in[insize < pos + MAX_SUPPORTED_DEFLATE_LENGTH ? insize : pos + MAX_SUPPORTED_DEFLATE_LENGTH];
    6879:	ba 02 01 00 00       	mov    $0x102,%edx
    687e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6881:	01 c2                	add    %eax,%edx
    6883:	8b 45 18             	mov    0x18(%ebp),%eax
    6886:	39 c2                	cmp    %eax,%edx
    6888:	0f 4e c2             	cmovle %edx,%eax
    688b:	89 c2                	mov    %eax,%edx
    688d:	8b 45 10             	mov    0x10(%ebp),%eax
    6890:	01 d0                	add    %edx,%eax
    6892:	89 45 ac             	mov    %eax,-0x54(%ebp)

    /*search for the longest string*/
    prev_offset = 0;
    6895:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    for(;;) {
      if(chainlength++ >= maxchainlength) break;
    689c:	8b 45 c8             	mov    -0x38(%ebp),%eax
    689f:	8d 50 01             	lea    0x1(%eax),%edx
    68a2:	89 55 c8             	mov    %edx,-0x38(%ebp)
    68a5:	3b 45 c0             	cmp    -0x40(%ebp),%eax
    68a8:	0f 83 67 01 00 00    	jae    6a15 <encodeLZ77+0x30b>
      current_offset = (unsigned)(hashpos <= wpos ? wpos - hashpos : wpos - hashpos + windowsize);
    68ae:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    68b1:	39 45 cc             	cmp    %eax,-0x34(%ebp)
    68b4:	77 08                	ja     68be <encodeLZ77+0x1b4>
    68b6:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    68b9:	2b 45 cc             	sub    -0x34(%ebp),%eax
    68bc:	eb 0d                	jmp    68cb <encodeLZ77+0x1c1>
    68be:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    68c1:	2b 45 cc             	sub    -0x34(%ebp),%eax
    68c4:	89 c2                	mov    %eax,%edx
    68c6:	8b 45 1c             	mov    0x1c(%ebp),%eax
    68c9:	01 d0                	add    %edx,%eax
    68cb:	89 45 a8             	mov    %eax,-0x58(%ebp)

      if(current_offset < prev_offset) break; /*stop when went completely around the circular buffer*/
    68ce:	8b 45 a8             	mov    -0x58(%ebp),%eax
    68d1:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    68d4:	0f 82 3e 01 00 00    	jb     6a18 <encodeLZ77+0x30e>
      prev_offset = current_offset;
    68da:	8b 45 a8             	mov    -0x58(%ebp),%eax
    68dd:	89 45 d8             	mov    %eax,-0x28(%ebp)
      if(current_offset > 0) {
    68e0:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
    68e4:	0f 84 a3 00 00 00    	je     698d <encodeLZ77+0x283>
        /*test the next characters*/
        foreptr = &in[pos];
    68ea:	8b 55 fc             	mov    -0x4(%ebp),%edx
    68ed:	8b 45 10             	mov    0x10(%ebp),%eax
    68f0:	01 d0                	add    %edx,%eax
    68f2:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        backptr = &in[pos - current_offset];
    68f5:	8b 45 fc             	mov    -0x4(%ebp),%eax
    68f8:	2b 45 a8             	sub    -0x58(%ebp),%eax
    68fb:	89 c2                	mov    %eax,%edx
    68fd:	8b 45 10             	mov    0x10(%ebp),%eax
    6900:	01 d0                	add    %edx,%eax
    6902:	89 45 d0             	mov    %eax,-0x30(%ebp)

        /*common case in PNGs is lots of zeros. Quickly skip over them as a speedup*/
        if(numzeros >= 3) {
    6905:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
    6909:	76 3a                	jbe    6945 <encodeLZ77+0x23b>
          unsigned skip = hash->zeros[hashpos];
    690b:	8b 45 0c             	mov    0xc(%ebp),%eax
    690e:	8b 40 14             	mov    0x14(%eax),%eax
    6911:	8b 55 cc             	mov    -0x34(%ebp),%edx
    6914:	01 d2                	add    %edx,%edx
    6916:	01 d0                	add    %edx,%eax
    6918:	0f b7 00             	movzwl (%eax),%eax
    691b:	0f b7 c0             	movzwl %ax,%eax
    691e:	89 45 c4             	mov    %eax,-0x3c(%ebp)
          if(skip > numzeros) skip = numzeros;
    6921:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    6924:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    6927:	76 06                	jbe    692f <encodeLZ77+0x225>
    6929:	8b 45 f0             	mov    -0x10(%ebp),%eax
    692c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
          backptr += skip;
    692f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    6932:	01 45 d0             	add    %eax,-0x30(%ebp)
          foreptr += skip;
    6935:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    6938:	01 45 d4             	add    %eax,-0x2c(%ebp)
        }

        while(foreptr != lastptr && *backptr == *foreptr) /*maximum supported length by deflate is max length*/ {
    693b:	eb 08                	jmp    6945 <encodeLZ77+0x23b>
          ++backptr;
    693d:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
          ++foreptr;
    6941:	83 45 d4 01          	addl   $0x1,-0x2c(%ebp)
          if(skip > numzeros) skip = numzeros;
          backptr += skip;
          foreptr += skip;
        }

        while(foreptr != lastptr && *backptr == *foreptr) /*maximum supported length by deflate is max length*/ {
    6945:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    6948:	3b 45 ac             	cmp    -0x54(%ebp),%eax
    694b:	74 10                	je     695d <encodeLZ77+0x253>
    694d:	8b 45 d0             	mov    -0x30(%ebp),%eax
    6950:	0f b6 10             	movzbl (%eax),%edx
    6953:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    6956:	0f b6 00             	movzbl (%eax),%eax
    6959:	38 c2                	cmp    %al,%dl
    695b:	74 e0                	je     693d <encodeLZ77+0x233>
          ++backptr;
          ++foreptr;
        }
        current_length = (unsigned)(foreptr - &in[pos]);
    695d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    6960:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    6963:	8b 55 10             	mov    0x10(%ebp),%edx
    6966:	01 ca                	add    %ecx,%edx
    6968:	29 d0                	sub    %edx,%eax
    696a:	89 45 a4             	mov    %eax,-0x5c(%ebp)

        if(current_length > length) {
    696d:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    6970:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    6973:	76 18                	jbe    698d <encodeLZ77+0x283>
          length = current_length; /*the longest length*/
    6975:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    6978:	89 45 e8             	mov    %eax,-0x18(%ebp)
          offset = current_offset; /*the offset that is related to this longest length*/
    697b:	8b 45 a8             	mov    -0x58(%ebp),%eax
    697e:	89 45 ec             	mov    %eax,-0x14(%ebp)
          /*jump out once a length of max length is found (speed gain). This also jumps
          out if length is MAX_SUPPORTED_DEFLATE_LENGTH*/
          if(current_length >= nicematch) break;
    6981:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    6984:	3b 45 24             	cmp    0x24(%ebp),%eax
    6987:	0f 83 8e 00 00 00    	jae    6a1b <encodeLZ77+0x311>
        }
      }

      if(hashpos == hash->chain[hashpos]) break;
    698d:	8b 45 0c             	mov    0xc(%ebp),%eax
    6990:	8b 40 04             	mov    0x4(%eax),%eax
    6993:	8b 55 cc             	mov    -0x34(%ebp),%edx
    6996:	01 d2                	add    %edx,%edx
    6998:	01 d0                	add    %edx,%eax
    699a:	0f b7 00             	movzwl (%eax),%eax
    699d:	0f b7 c0             	movzwl %ax,%eax
    69a0:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    69a3:	74 79                	je     6a1e <encodeLZ77+0x314>

      if(numzeros >= 3 && length > numzeros) {
    69a5:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
    69a9:	76 38                	jbe    69e3 <encodeLZ77+0x2d9>
    69ab:	8b 45 e8             	mov    -0x18(%ebp),%eax
    69ae:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    69b1:	76 30                	jbe    69e3 <encodeLZ77+0x2d9>
        hashpos = hash->chainz[hashpos];
    69b3:	8b 45 0c             	mov    0xc(%ebp),%eax
    69b6:	8b 40 10             	mov    0x10(%eax),%eax
    69b9:	8b 55 cc             	mov    -0x34(%ebp),%edx
    69bc:	01 d2                	add    %edx,%edx
    69be:	01 d0                	add    %edx,%eax
    69c0:	0f b7 00             	movzwl (%eax),%eax
    69c3:	0f b7 c0             	movzwl %ax,%eax
    69c6:	89 45 cc             	mov    %eax,-0x34(%ebp)
        if(hash->zeros[hashpos] != numzeros) break;
    69c9:	8b 45 0c             	mov    0xc(%ebp),%eax
    69cc:	8b 40 14             	mov    0x14(%eax),%eax
    69cf:	8b 55 cc             	mov    -0x34(%ebp),%edx
    69d2:	01 d2                	add    %edx,%edx
    69d4:	01 d0                	add    %edx,%eax
    69d6:	0f b7 00             	movzwl (%eax),%eax
    69d9:	0f b7 c0             	movzwl %ax,%eax
    69dc:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    69df:	74 2f                	je     6a10 <encodeLZ77+0x306>
    69e1:	eb 3f                	jmp    6a22 <encodeLZ77+0x318>
      } else {
        hashpos = hash->chain[hashpos];
    69e3:	8b 45 0c             	mov    0xc(%ebp),%eax
    69e6:	8b 40 04             	mov    0x4(%eax),%eax
    69e9:	8b 55 cc             	mov    -0x34(%ebp),%edx
    69ec:	01 d2                	add    %edx,%edx
    69ee:	01 d0                	add    %edx,%eax
    69f0:	0f b7 00             	movzwl (%eax),%eax
    69f3:	0f b7 c0             	movzwl %ax,%eax
    69f6:	89 45 cc             	mov    %eax,-0x34(%ebp)
        /*outdated hash value, happens if particular value was not encountered in whole last window*/
        if(hash->val[hashpos] != (int)hashval) break;
    69f9:	8b 45 0c             	mov    0xc(%ebp),%eax
    69fc:	8b 40 08             	mov    0x8(%eax),%eax
    69ff:	8b 55 cc             	mov    -0x34(%ebp),%edx
    6a02:	c1 e2 02             	shl    $0x2,%edx
    6a05:	01 d0                	add    %edx,%eax
    6a07:	8b 10                	mov    (%eax),%edx
    6a09:	8b 45 b0             	mov    -0x50(%ebp),%eax
    6a0c:	39 c2                	cmp    %eax,%edx
    6a0e:	75 11                	jne    6a21 <encodeLZ77+0x317>
      }
    }
    6a10:	e9 87 fe ff ff       	jmp    689c <encodeLZ77+0x192>
    lastptr = &in[insize < pos + MAX_SUPPORTED_DEFLATE_LENGTH ? insize : pos + MAX_SUPPORTED_DEFLATE_LENGTH];

    /*search for the longest string*/
    prev_offset = 0;
    for(;;) {
      if(chainlength++ >= maxchainlength) break;
    6a15:	90                   	nop
    6a16:	eb 0a                	jmp    6a22 <encodeLZ77+0x318>
      current_offset = (unsigned)(hashpos <= wpos ? wpos - hashpos : wpos - hashpos + windowsize);

      if(current_offset < prev_offset) break; /*stop when went completely around the circular buffer*/
    6a18:	90                   	nop
    6a19:	eb 07                	jmp    6a22 <encodeLZ77+0x318>
        if(current_length > length) {
          length = current_length; /*the longest length*/
          offset = current_offset; /*the offset that is related to this longest length*/
          /*jump out once a length of max length is found (speed gain). This also jumps
          out if length is MAX_SUPPORTED_DEFLATE_LENGTH*/
          if(current_length >= nicematch) break;
    6a1b:	90                   	nop
    6a1c:	eb 04                	jmp    6a22 <encodeLZ77+0x318>
        }
      }

      if(hashpos == hash->chain[hashpos]) break;
    6a1e:	90                   	nop
    6a1f:	eb 01                	jmp    6a22 <encodeLZ77+0x318>
        hashpos = hash->chainz[hashpos];
        if(hash->zeros[hashpos] != numzeros) break;
      } else {
        hashpos = hash->chain[hashpos];
        /*outdated hash value, happens if particular value was not encountered in whole last window*/
        if(hash->val[hashpos] != (int)hashval) break;
    6a21:	90                   	nop
      }
    }

    if(lazymatching) {
    6a22:	83 7d 28 00          	cmpl   $0x0,0x28(%ebp)
    6a26:	0f 84 c8 00 00 00    	je     6af4 <encodeLZ77+0x3ea>
      if(!lazy && length >= 3 && length <= maxlazymatch && length < MAX_SUPPORTED_DEFLATE_LENGTH) {
    6a2c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    6a30:	75 30                	jne    6a62 <encodeLZ77+0x358>
    6a32:	83 7d e8 02          	cmpl   $0x2,-0x18(%ebp)
    6a36:	76 2a                	jbe    6a62 <encodeLZ77+0x358>
    6a38:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6a3b:	3b 45 bc             	cmp    -0x44(%ebp),%eax
    6a3e:	77 22                	ja     6a62 <encodeLZ77+0x358>
    6a40:	b8 02 01 00 00       	mov    $0x102,%eax
    6a45:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    6a48:	73 18                	jae    6a62 <encodeLZ77+0x358>
        lazy = 1;
    6a4a:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
        lazylength = length;
    6a51:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6a54:	89 45 e0             	mov    %eax,-0x20(%ebp)
        lazyoffset = offset;
    6a57:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6a5a:	89 45 dc             	mov    %eax,-0x24(%ebp)
        continue; /*try the next byte*/
    6a5d:	e9 f0 01 00 00       	jmp    6c52 <encodeLZ77+0x548>
      }
      if(lazy) {
    6a62:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    6a66:	0f 84 88 00 00 00    	je     6af4 <encodeLZ77+0x3ea>
        lazy = 0;
    6a6c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
        if(pos == 0) ERROR_BREAK(81);
    6a73:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
    6a77:	75 0c                	jne    6a85 <encodeLZ77+0x37b>
    6a79:	c7 45 f4 51 00 00 00 	movl   $0x51,-0xc(%ebp)
    6a80:	e9 dd 01 00 00       	jmp    6c62 <encodeLZ77+0x558>
        if(length > lazylength + 1) {
    6a85:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6a88:	83 c0 01             	add    $0x1,%eax
    6a8b:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    6a8e:	73 2d                	jae    6abd <encodeLZ77+0x3b3>
          /*push the previous character as literal*/
          if(!uivector_push_back(out, in[pos - 1])) ERROR_BREAK(83 /*alloc fail*/);
    6a90:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6a93:	8d 50 ff             	lea    -0x1(%eax),%edx
    6a96:	8b 45 10             	mov    0x10(%ebp),%eax
    6a99:	01 d0                	add    %edx,%eax
    6a9b:	0f b6 00             	movzbl (%eax),%eax
    6a9e:	0f b6 c0             	movzbl %al,%eax
    6aa1:	50                   	push   %eax
    6aa2:	ff 75 08             	pushl  0x8(%ebp)
    6aa5:	e8 6f cb ff ff       	call   3619 <uivector_push_back>
    6aaa:	83 c4 08             	add    $0x8,%esp
    6aad:	85 c0                	test   %eax,%eax
    6aaf:	75 43                	jne    6af4 <encodeLZ77+0x3ea>
    6ab1:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    6ab8:	e9 a5 01 00 00       	jmp    6c62 <encodeLZ77+0x558>
        } else {
          length = lazylength;
    6abd:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6ac0:	89 45 e8             	mov    %eax,-0x18(%ebp)
          offset = lazyoffset;
    6ac3:	8b 45 dc             	mov    -0x24(%ebp),%eax
    6ac6:	89 45 ec             	mov    %eax,-0x14(%ebp)
          hash->head[hashval] = -1; /*the same hashchain update will be done, this ensures no wrong alteration*/
    6ac9:	8b 45 0c             	mov    0xc(%ebp),%eax
    6acc:	8b 00                	mov    (%eax),%eax
    6ace:	8b 55 b0             	mov    -0x50(%ebp),%edx
    6ad1:	c1 e2 02             	shl    $0x2,%edx
    6ad4:	01 d0                	add    %edx,%eax
    6ad6:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
          hash->headz[numzeros] = -1; /*idem*/
    6adc:	8b 45 0c             	mov    0xc(%ebp),%eax
    6adf:	8b 40 0c             	mov    0xc(%eax),%eax
    6ae2:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6ae5:	c1 e2 02             	shl    $0x2,%edx
    6ae8:	01 d0                	add    %edx,%eax
    6aea:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
          --pos;
    6af0:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
        }
      }
    }
    if(length >= 3 && offset > windowsize) ERROR_BREAK(86 /*too big (or overflown negative) offset*/);
    6af4:	83 7d e8 02          	cmpl   $0x2,-0x18(%ebp)
    6af8:	76 14                	jbe    6b0e <encodeLZ77+0x404>
    6afa:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6afd:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    6b00:	76 0c                	jbe    6b0e <encodeLZ77+0x404>
    6b02:	c7 45 f4 56 00 00 00 	movl   $0x56,-0xc(%ebp)
    6b09:	e9 54 01 00 00       	jmp    6c62 <encodeLZ77+0x558>

    /*encode it as length/distance pair or literal value*/
    if(length < 3) /*only lengths of 3 or higher are supported as length/distance pair*/ {
    6b0e:	83 7d e8 02          	cmpl   $0x2,-0x18(%ebp)
    6b12:	77 2e                	ja     6b42 <encodeLZ77+0x438>
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
    6b14:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6b17:	8b 45 10             	mov    0x10(%ebp),%eax
    6b1a:	01 d0                	add    %edx,%eax
    6b1c:	0f b6 00             	movzbl (%eax),%eax
    6b1f:	0f b6 c0             	movzbl %al,%eax
    6b22:	50                   	push   %eax
    6b23:	ff 75 08             	pushl  0x8(%ebp)
    6b26:	e8 ee ca ff ff       	call   3619 <uivector_push_back>
    6b2b:	83 c4 08             	add    $0x8,%esp
    6b2e:	85 c0                	test   %eax,%eax
    6b30:	0f 85 1c 01 00 00    	jne    6c52 <encodeLZ77+0x548>
    6b36:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    6b3d:	e9 20 01 00 00       	jmp    6c62 <encodeLZ77+0x558>
    } else if(length < minmatch || (length == 3 && offset > 4096)) {
    6b42:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6b45:	3b 45 20             	cmp    0x20(%ebp),%eax
    6b48:	72 0f                	jb     6b59 <encodeLZ77+0x44f>
    6b4a:	83 7d e8 03          	cmpl   $0x3,-0x18(%ebp)
    6b4e:	75 37                	jne    6b87 <encodeLZ77+0x47d>
    6b50:	81 7d ec 00 10 00 00 	cmpl   $0x1000,-0x14(%ebp)
    6b57:	76 2e                	jbe    6b87 <encodeLZ77+0x47d>
      /*compensate for the fact that longer offsets have more extra bits, a
      length of only 3 may be not worth it then*/
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
    6b59:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6b5c:	8b 45 10             	mov    0x10(%ebp),%eax
    6b5f:	01 d0                	add    %edx,%eax
    6b61:	0f b6 00             	movzbl (%eax),%eax
    6b64:	0f b6 c0             	movzbl %al,%eax
    6b67:	50                   	push   %eax
    6b68:	ff 75 08             	pushl  0x8(%ebp)
    6b6b:	e8 a9 ca ff ff       	call   3619 <uivector_push_back>
    6b70:	83 c4 08             	add    $0x8,%esp
    6b73:	85 c0                	test   %eax,%eax
    6b75:	0f 85 d7 00 00 00    	jne    6c52 <encodeLZ77+0x548>
    6b7b:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    6b82:	e9 db 00 00 00       	jmp    6c62 <encodeLZ77+0x558>
    } else {
      addLengthDistance(out, length, offset);
    6b87:	8b 55 ec             	mov    -0x14(%ebp),%edx
    6b8a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6b8d:	52                   	push   %edx
    6b8e:	50                   	push   %eax
    6b8f:	ff 75 08             	pushl  0x8(%ebp)
    6b92:	e8 8a f6 ff ff       	call   6221 <addLengthDistance>
    6b97:	83 c4 0c             	add    $0xc,%esp
      for(i = 1; i < length; ++i) {
    6b9a:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
    6ba1:	e9 a0 00 00 00       	jmp    6c46 <encodeLZ77+0x53c>
        ++pos;
    6ba6:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
        wpos = pos & (windowsize - 1);
    6baa:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6bad:	8d 50 ff             	lea    -0x1(%eax),%edx
    6bb0:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6bb3:	21 d0                	and    %edx,%eax
    6bb5:	89 45 b4             	mov    %eax,-0x4c(%ebp)
        hashval = getHash(in, insize, pos);
    6bb8:	ff 75 fc             	pushl  -0x4(%ebp)
    6bbb:	ff 75 18             	pushl  0x18(%ebp)
    6bbe:	ff 75 10             	pushl  0x10(%ebp)
    6bc1:	e8 67 f9 ff ff       	call   652d <getHash>
    6bc6:	83 c4 0c             	add    $0xc,%esp
    6bc9:	89 45 b0             	mov    %eax,-0x50(%ebp)
        if(usezeros && hashval == 0) {
    6bcc:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
    6bd0:	74 4e                	je     6c20 <encodeLZ77+0x516>
    6bd2:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
    6bd6:	75 48                	jne    6c20 <encodeLZ77+0x516>
          if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    6bd8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    6bdc:	75 16                	jne    6bf4 <encodeLZ77+0x4ea>
    6bde:	ff 75 fc             	pushl  -0x4(%ebp)
    6be1:	ff 75 18             	pushl  0x18(%ebp)
    6be4:	ff 75 10             	pushl  0x10(%ebp)
    6be7:	e8 f5 f9 ff ff       	call   65e1 <countZeros>
    6bec:	83 c4 0c             	add    $0xc,%esp
    6bef:	89 45 f0             	mov    %eax,-0x10(%ebp)
    6bf2:	eb 35                	jmp    6c29 <encodeLZ77+0x51f>
          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    6bf4:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6bf7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6bfa:	01 c2                	add    %eax,%edx
    6bfc:	8b 45 18             	mov    0x18(%ebp),%eax
    6bff:	39 c2                	cmp    %eax,%edx
    6c01:	77 17                	ja     6c1a <encodeLZ77+0x510>
    6c03:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6c06:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6c09:	01 d0                	add    %edx,%eax
    6c0b:	8d 50 ff             	lea    -0x1(%eax),%edx
    6c0e:	8b 45 10             	mov    0x10(%ebp),%eax
    6c11:	01 d0                	add    %edx,%eax
    6c13:	0f b6 00             	movzbl (%eax),%eax
    6c16:	84 c0                	test   %al,%al
    6c18:	74 0f                	je     6c29 <encodeLZ77+0x51f>
    6c1a:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
      for(i = 1; i < length; ++i) {
        ++pos;
        wpos = pos & (windowsize - 1);
        hashval = getHash(in, insize, pos);
        if(usezeros && hashval == 0) {
          if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    6c1e:	eb 09                	jmp    6c29 <encodeLZ77+0x51f>
          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
        } else {
          numzeros = 0;
    6c20:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    6c27:	eb 01                	jmp    6c2a <encodeLZ77+0x520>
      for(i = 1; i < length; ++i) {
        ++pos;
        wpos = pos & (windowsize - 1);
        hashval = getHash(in, insize, pos);
        if(usezeros && hashval == 0) {
          if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    6c29:	90                   	nop
          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
        } else {
          numzeros = 0;
        }
        updateHashChain(hash, wpos, hashval, numzeros);
    6c2a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6c2d:	0f b7 c0             	movzwl %ax,%eax
    6c30:	50                   	push   %eax
    6c31:	ff 75 b0             	pushl  -0x50(%ebp)
    6c34:	ff 75 b4             	pushl  -0x4c(%ebp)
    6c37:	ff 75 0c             	pushl  0xc(%ebp)
    6c3a:	e8 04 fa ff ff       	call   6643 <updateHashChain>
    6c3f:	83 c4 10             	add    $0x10,%esp
      /*compensate for the fact that longer offsets have more extra bits, a
      length of only 3 may be not worth it then*/
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
    } else {
      addLengthDistance(out, length, offset);
      for(i = 1; i < length; ++i) {
    6c42:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    6c46:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6c49:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    6c4c:	0f 82 54 ff ff ff    	jb     6ba6 <encodeLZ77+0x49c>
  if(windowsize == 0 || windowsize > 32768) return 60; /*error: windowsize smaller/larger than allowed*/
  if((windowsize & (windowsize - 1)) != 0) return 90; /*error: must be power of two*/

  if(nicematch > MAX_SUPPORTED_DEFLATE_LENGTH) nicematch = MAX_SUPPORTED_DEFLATE_LENGTH;

  for(pos = inpos; pos < insize; ++pos) {
    6c52:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    6c56:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6c59:	3b 45 18             	cmp    0x18(%ebp),%eax
    6c5c:	0f 8c 54 fb ff ff    	jl     67b6 <encodeLZ77+0xac>
        updateHashChain(hash, wpos, hashval, numzeros);
      }
    }
  } /*end of the loop through each character of input*/

  return error;
    6c62:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    6c65:	c9                   	leave  
    6c66:	c3                   	ret    

00006c67 <deflateNoCompression>:

/* /////////////////////////////////////////////////////////////////////////// */

static unsigned deflateNoCompression(ucvector* out, const unsigned char* data, size_t datasize) {
    6c67:	55                   	push   %ebp
    6c68:	89 e5                	mov    %esp,%ebp
    6c6a:	53                   	push   %ebx
    6c6b:	83 ec 30             	sub    $0x30,%esp
  /*non compressed deflate block data: 1 bit BFINAL,2 bits BTYPE,(5 bits): it jumps to start of next byte,
  2 bytes LEN, 2 bytes NLEN, LEN bytes literal DATA*/

  size_t i, numdeflateblocks = (datasize + 65534u) / 65535u;
    6c6e:	8b 45 10             	mov    0x10(%ebp),%eax
    6c71:	05 fe ff 00 00       	add    $0xfffe,%eax
    6c76:	ba 01 80 00 80       	mov    $0x80008001,%edx
    6c7b:	f7 e2                	mul    %edx
    6c7d:	89 d0                	mov    %edx,%eax
    6c7f:	c1 e8 0f             	shr    $0xf,%eax
    6c82:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned datapos = 0;
    6c85:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  for(i = 0; i != numdeflateblocks; ++i) {
    6c8c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    6c93:	e9 1b 01 00 00       	jmp    6db3 <deflateNoCompression+0x14c>
    unsigned BFINAL, BTYPE, LEN, NLEN;
    unsigned char firstbyte;
    size_t pos = out->size;
    6c98:	8b 45 08             	mov    0x8(%ebp),%eax
    6c9b:	8b 40 04             	mov    0x4(%eax),%eax
    6c9e:	89 45 e8             	mov    %eax,-0x18(%ebp)

    BFINAL = (i == numdeflateblocks - 1);
    6ca1:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6ca4:	83 e8 01             	sub    $0x1,%eax
    6ca7:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    6caa:	0f 94 c0             	sete   %al
    6cad:	0f b6 c0             	movzbl %al,%eax
    6cb0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    BTYPE = 0;
    6cb3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

    LEN = 65535;
    6cba:	c7 45 f0 ff ff 00 00 	movl   $0xffff,-0x10(%ebp)
    if(datasize - datapos < 65535u) LEN = (unsigned)datasize - datapos;
    6cc1:	8b 45 10             	mov    0x10(%ebp),%eax
    6cc4:	2b 45 f4             	sub    -0xc(%ebp),%eax
    6cc7:	3d fe ff 00 00       	cmp    $0xfffe,%eax
    6ccc:	77 09                	ja     6cd7 <deflateNoCompression+0x70>
    6cce:	8b 45 10             	mov    0x10(%ebp),%eax
    6cd1:	2b 45 f4             	sub    -0xc(%ebp),%eax
    6cd4:	89 45 f0             	mov    %eax,-0x10(%ebp)
    NLEN = 65535 - LEN;
    6cd7:	b8 ff ff 00 00       	mov    $0xffff,%eax
    6cdc:	2b 45 f0             	sub    -0x10(%ebp),%eax
    6cdf:	89 45 dc             	mov    %eax,-0x24(%ebp)

    if(!ucvector_resize(out, out->size + LEN + 5)) return 83; /*alloc fail*/
    6ce2:	8b 45 08             	mov    0x8(%ebp),%eax
    6ce5:	8b 40 04             	mov    0x4(%eax),%eax
    6ce8:	89 c2                	mov    %eax,%edx
    6cea:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6ced:	01 d0                	add    %edx,%eax
    6cef:	83 c0 05             	add    $0x5,%eax
    6cf2:	50                   	push   %eax
    6cf3:	ff 75 08             	pushl  0x8(%ebp)
    6cf6:	e8 62 c9 ff ff       	call   365d <ucvector_resize>
    6cfb:	83 c4 08             	add    $0x8,%esp
    6cfe:	85 c0                	test   %eax,%eax
    6d00:	75 0a                	jne    6d0c <deflateNoCompression+0xa5>
    6d02:	b8 53 00 00 00       	mov    $0x53,%eax
    6d07:	e9 b8 00 00 00       	jmp    6dc4 <deflateNoCompression+0x15d>

    firstbyte = (unsigned char)(BFINAL + ((BTYPE & 1u) << 1u) + ((BTYPE & 2u) << 1u));
    6d0c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    6d0f:	89 c2                	mov    %eax,%edx
    6d11:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6d14:	83 e0 01             	and    $0x1,%eax
    6d17:	01 c0                	add    %eax,%eax
    6d19:	01 c2                	add    %eax,%edx
    6d1b:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6d1e:	83 e0 02             	and    $0x2,%eax
    6d21:	01 c0                	add    %eax,%eax
    6d23:	01 d0                	add    %edx,%eax
    6d25:	88 45 db             	mov    %al,-0x25(%ebp)
    out->data[pos + 0] = firstbyte;
    6d28:	8b 45 08             	mov    0x8(%ebp),%eax
    6d2b:	8b 10                	mov    (%eax),%edx
    6d2d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6d30:	01 c2                	add    %eax,%edx
    6d32:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
    6d36:	88 02                	mov    %al,(%edx)
    out->data[pos + 1] = (unsigned char)(LEN & 255);
    6d38:	8b 45 08             	mov    0x8(%ebp),%eax
    6d3b:	8b 00                	mov    (%eax),%eax
    6d3d:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6d40:	83 c2 01             	add    $0x1,%edx
    6d43:	01 d0                	add    %edx,%eax
    6d45:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6d48:	88 10                	mov    %dl,(%eax)
    out->data[pos + 2] = (unsigned char)(LEN >> 8u);
    6d4a:	8b 45 08             	mov    0x8(%ebp),%eax
    6d4d:	8b 00                	mov    (%eax),%eax
    6d4f:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6d52:	83 c2 02             	add    $0x2,%edx
    6d55:	01 d0                	add    %edx,%eax
    6d57:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6d5a:	c1 ea 08             	shr    $0x8,%edx
    6d5d:	88 10                	mov    %dl,(%eax)
    out->data[pos + 3] = (unsigned char)(NLEN & 255);
    6d5f:	8b 45 08             	mov    0x8(%ebp),%eax
    6d62:	8b 00                	mov    (%eax),%eax
    6d64:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6d67:	83 c2 03             	add    $0x3,%edx
    6d6a:	01 d0                	add    %edx,%eax
    6d6c:	8b 55 dc             	mov    -0x24(%ebp),%edx
    6d6f:	88 10                	mov    %dl,(%eax)
    out->data[pos + 4] = (unsigned char)(NLEN >> 8u);
    6d71:	8b 45 08             	mov    0x8(%ebp),%eax
    6d74:	8b 00                	mov    (%eax),%eax
    6d76:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6d79:	83 c2 04             	add    $0x4,%edx
    6d7c:	01 d0                	add    %edx,%eax
    6d7e:	8b 55 dc             	mov    -0x24(%ebp),%edx
    6d81:	c1 ea 08             	shr    $0x8,%edx
    6d84:	88 10                	mov    %dl,(%eax)
    lodepng_memcpy(out->data + pos + 5, data + datapos, LEN);
    6d86:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6d89:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    6d8c:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6d8f:	01 d1                	add    %edx,%ecx
    6d91:	8b 55 08             	mov    0x8(%ebp),%edx
    6d94:	8b 12                	mov    (%edx),%edx
    6d96:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    6d99:	83 c3 05             	add    $0x5,%ebx
    6d9c:	01 da                	add    %ebx,%edx
    6d9e:	50                   	push   %eax
    6d9f:	51                   	push   %ecx
    6da0:	52                   	push   %edx
    6da1:	e8 9b c6 ff ff       	call   3441 <lodepng_memcpy>
    6da6:	83 c4 0c             	add    $0xc,%esp
    datapos += LEN;
    6da9:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6dac:	01 45 f4             	add    %eax,-0xc(%ebp)
  /*non compressed deflate block data: 1 bit BFINAL,2 bits BTYPE,(5 bits): it jumps to start of next byte,
  2 bytes LEN, 2 bytes NLEN, LEN bytes literal DATA*/

  size_t i, numdeflateblocks = (datasize + 65534u) / 65535u;
  unsigned datapos = 0;
  for(i = 0; i != numdeflateblocks; ++i) {
    6daf:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    6db3:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6db6:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    6db9:	0f 85 d9 fe ff ff    	jne    6c98 <deflateNoCompression+0x31>
    out->data[pos + 4] = (unsigned char)(NLEN >> 8u);
    lodepng_memcpy(out->data + pos + 5, data + datapos, LEN);
    datapos += LEN;
  }

  return 0;
    6dbf:	b8 00 00 00 00       	mov    $0x0,%eax
}
    6dc4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    6dc7:	c9                   	leave  
    6dc8:	c3                   	ret    

00006dc9 <writeLZ77data>:
write the lz77-encoded data, which has lit, len and dist codes, to compressed stream using huffman trees.
tree_ll: the tree for lit and len codes.
tree_d: the tree for distance codes.
*/
static void writeLZ77data(LodePNGBitWriter* writer, const uivector* lz77_encoded,
                          const HuffmanTree* tree_ll, const HuffmanTree* tree_d) {
    6dc9:	55                   	push   %ebp
    6dca:	89 e5                	mov    %esp,%ebp
    6dcc:	83 ec 30             	sub    $0x30,%esp
  size_t i = 0;
    6dcf:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  for(i = 0; i != lz77_encoded->size; ++i) {
    6dd6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    6ddd:	e9 10 01 00 00       	jmp    6ef2 <writeLZ77data+0x129>
    unsigned val = lz77_encoded->data[i];
    6de2:	8b 45 0c             	mov    0xc(%ebp),%eax
    6de5:	8b 00                	mov    (%eax),%eax
    6de7:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6dea:	c1 e2 02             	shl    $0x2,%edx
    6ded:	01 d0                	add    %edx,%eax
    6def:	8b 00                	mov    (%eax),%eax
    6df1:	89 45 f8             	mov    %eax,-0x8(%ebp)
    writeBitsReversed(writer, tree_ll->codes[val], tree_ll->lengths[val]);
    6df4:	8b 45 10             	mov    0x10(%ebp),%eax
    6df7:	8b 40 04             	mov    0x4(%eax),%eax
    6dfa:	8b 55 f8             	mov    -0x8(%ebp),%edx
    6dfd:	c1 e2 02             	shl    $0x2,%edx
    6e00:	01 d0                	add    %edx,%eax
    6e02:	8b 00                	mov    (%eax),%eax
    6e04:	89 c1                	mov    %eax,%ecx
    6e06:	8b 45 10             	mov    0x10(%ebp),%eax
    6e09:	8b 00                	mov    (%eax),%eax
    6e0b:	8b 55 f8             	mov    -0x8(%ebp),%edx
    6e0e:	c1 e2 02             	shl    $0x2,%edx
    6e11:	01 d0                	add    %edx,%eax
    6e13:	8b 00                	mov    (%eax),%eax
    6e15:	51                   	push   %ecx
    6e16:	50                   	push   %eax
    6e17:	ff 75 08             	pushl  0x8(%ebp)
    6e1a:	e8 60 cc ff ff       	call   3a7f <writeBitsReversed>
    6e1f:	83 c4 0c             	add    $0xc,%esp
    if(val > 256) /*for a length code, 3 more things have to be added*/ {
    6e22:	81 7d f8 00 01 00 00 	cmpl   $0x100,-0x8(%ebp)
    6e29:	0f 86 bf 00 00 00    	jbe    6eee <writeLZ77data+0x125>
      unsigned length_index = val - FIRST_LENGTH_CODE_INDEX;
    6e2f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6e32:	2d 01 01 00 00       	sub    $0x101,%eax
    6e37:	89 45 f4             	mov    %eax,-0xc(%ebp)
      unsigned n_length_extra_bits = LENGTHEXTRA[length_index];
    6e3a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6e3d:	8b 04 85 a0 9e 01 00 	mov    0x19ea0(,%eax,4),%eax
    6e44:	89 45 f0             	mov    %eax,-0x10(%ebp)
      unsigned length_extra_bits = lz77_encoded->data[++i];
    6e47:	8b 45 0c             	mov    0xc(%ebp),%eax
    6e4a:	8b 00                	mov    (%eax),%eax
    6e4c:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    6e50:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6e53:	c1 e2 02             	shl    $0x2,%edx
    6e56:	01 d0                	add    %edx,%eax
    6e58:	8b 00                	mov    (%eax),%eax
    6e5a:	89 45 ec             	mov    %eax,-0x14(%ebp)

      unsigned distance_code = lz77_encoded->data[++i];
    6e5d:	8b 45 0c             	mov    0xc(%ebp),%eax
    6e60:	8b 00                	mov    (%eax),%eax
    6e62:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    6e66:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6e69:	c1 e2 02             	shl    $0x2,%edx
    6e6c:	01 d0                	add    %edx,%eax
    6e6e:	8b 00                	mov    (%eax),%eax
    6e70:	89 45 e8             	mov    %eax,-0x18(%ebp)

      unsigned distance_index = distance_code;
    6e73:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6e76:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      unsigned n_distance_extra_bits = DISTANCEEXTRA[distance_index];
    6e79:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    6e7c:	8b 04 85 a0 9f 01 00 	mov    0x19fa0(,%eax,4),%eax
    6e83:	89 45 e0             	mov    %eax,-0x20(%ebp)
      unsigned distance_extra_bits = lz77_encoded->data[++i];
    6e86:	8b 45 0c             	mov    0xc(%ebp),%eax
    6e89:	8b 00                	mov    (%eax),%eax
    6e8b:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    6e8f:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6e92:	c1 e2 02             	shl    $0x2,%edx
    6e95:	01 d0                	add    %edx,%eax
    6e97:	8b 00                	mov    (%eax),%eax
    6e99:	89 45 dc             	mov    %eax,-0x24(%ebp)

      writeBits(writer, length_extra_bits, n_length_extra_bits);
    6e9c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6e9f:	50                   	push   %eax
    6ea0:	ff 75 ec             	pushl  -0x14(%ebp)
    6ea3:	ff 75 08             	pushl  0x8(%ebp)
    6ea6:	e8 40 ca ff ff       	call   38eb <writeBits>
    6eab:	83 c4 0c             	add    $0xc,%esp
      writeBitsReversed(writer, tree_d->codes[distance_code], tree_d->lengths[distance_code]);
    6eae:	8b 45 14             	mov    0x14(%ebp),%eax
    6eb1:	8b 40 04             	mov    0x4(%eax),%eax
    6eb4:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6eb7:	c1 e2 02             	shl    $0x2,%edx
    6eba:	01 d0                	add    %edx,%eax
    6ebc:	8b 00                	mov    (%eax),%eax
    6ebe:	89 c1                	mov    %eax,%ecx
    6ec0:	8b 45 14             	mov    0x14(%ebp),%eax
    6ec3:	8b 00                	mov    (%eax),%eax
    6ec5:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6ec8:	c1 e2 02             	shl    $0x2,%edx
    6ecb:	01 d0                	add    %edx,%eax
    6ecd:	8b 00                	mov    (%eax),%eax
    6ecf:	51                   	push   %ecx
    6ed0:	50                   	push   %eax
    6ed1:	ff 75 08             	pushl  0x8(%ebp)
    6ed4:	e8 a6 cb ff ff       	call   3a7f <writeBitsReversed>
    6ed9:	83 c4 0c             	add    $0xc,%esp
      writeBits(writer, distance_extra_bits, n_distance_extra_bits);
    6edc:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6edf:	50                   	push   %eax
    6ee0:	ff 75 dc             	pushl  -0x24(%ebp)
    6ee3:	ff 75 08             	pushl  0x8(%ebp)
    6ee6:	e8 00 ca ff ff       	call   38eb <writeBits>
    6eeb:	83 c4 0c             	add    $0xc,%esp
tree_d: the tree for distance codes.
*/
static void writeLZ77data(LodePNGBitWriter* writer, const uivector* lz77_encoded,
                          const HuffmanTree* tree_ll, const HuffmanTree* tree_d) {
  size_t i = 0;
  for(i = 0; i != lz77_encoded->size; ++i) {
    6eee:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    6ef2:	8b 45 0c             	mov    0xc(%ebp),%eax
    6ef5:	8b 40 04             	mov    0x4(%eax),%eax
    6ef8:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    6efb:	0f 85 e1 fe ff ff    	jne    6de2 <writeLZ77data+0x19>
      writeBits(writer, length_extra_bits, n_length_extra_bits);
      writeBitsReversed(writer, tree_d->codes[distance_code], tree_d->lengths[distance_code]);
      writeBits(writer, distance_extra_bits, n_distance_extra_bits);
    }
  }
}
    6f01:	90                   	nop
    6f02:	c9                   	leave  
    6f03:	c3                   	ret    

00006f04 <deflateDynamic>:

/*Deflate for a block of type "dynamic", that is, with freely, optimally, created huffman trees*/
static unsigned deflateDynamic(LodePNGBitWriter* writer, Hash* hash,
                               const unsigned char* data, size_t datapos, size_t dataend,
                               const LodePNGCompressSettings* settings, unsigned final) {
    6f04:	55                   	push   %ebp
    6f05:	89 e5                	mov    %esp,%ebp
    6f07:	53                   	push   %ebx
    6f08:	81 ec b4 00 00 00    	sub    $0xb4,%esp
  unsigned error = 0;
    6f0e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  /*The lz77 encoded data, represented with integers since there will also be length and distance codes in it*/
  uivector lz77_encoded;
  HuffmanTree tree_ll; /*tree for lit,len values*/
  HuffmanTree tree_d; /*tree for distance codes*/
  HuffmanTree tree_cl; /*tree for encoding the code lengths representing tree_ll and tree_d*/
  unsigned* frequencies_ll = 0; /*frequency of lit,len codes*/
    6f15:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  unsigned* frequencies_d = 0; /*frequency of dist codes*/
    6f1c:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  unsigned* frequencies_cl = 0; /*frequency of code length codes*/
    6f23:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
  unsigned* bitlen_lld = 0; /*lit,len,dist code lengths (int bits), literally (without repeat codes).*/
    6f2a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  unsigned* bitlen_lld_e = 0; /*bitlen_lld encoded with repeat codes (this is a rudimentary run length compression)*/
    6f31:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  size_t datasize = dataend - datapos;
    6f38:	8b 45 18             	mov    0x18(%ebp),%eax
    6f3b:	2b 45 14             	sub    0x14(%ebp),%eax
    6f3e:	89 45 c8             	mov    %eax,-0x38(%ebp)
  bitlen_lld is to tree_cl what data is to tree_ll and tree_d.
  bitlen_lld_e is to bitlen_lld what lz77_encoded is to data.
  bitlen_cl is to bitlen_lld_e what bitlen_lld is to lz77_encoded.
  */

  unsigned BFINAL = final;
    6f41:	8b 45 20             	mov    0x20(%ebp),%eax
    6f44:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  size_t i;
  size_t numcodes_ll, numcodes_d, numcodes_lld, numcodes_lld_e, numcodes_cl;
  unsigned HLIT, HDIST, HCLEN;

  uivector_init(&lz77_encoded);
    6f47:	8d 45 90             	lea    -0x70(%ebp),%eax
    6f4a:	50                   	push   %eax
    6f4b:	e8 a4 c6 ff ff       	call   35f4 <uivector_init>
    6f50:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_ll);
    6f53:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    6f59:	50                   	push   %eax
    6f5a:	e8 98 d3 ff ff       	call   42f7 <HuffmanTree_init>
    6f5f:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_d);
    6f62:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    6f68:	50                   	push   %eax
    6f69:	e8 89 d3 ff ff       	call   42f7 <HuffmanTree_init>
    6f6e:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_cl);
    6f71:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    6f77:	50                   	push   %eax
    6f78:	e8 7a d3 ff ff       	call   42f7 <HuffmanTree_init>
    6f7d:	83 c4 04             	add    $0x4,%esp
  /* could fit on stack, but >1KB is on the larger side so allocate instead */
  frequencies_ll = (unsigned*)lodepng_malloc(286 * sizeof(*frequencies_ll));
    6f80:	83 ec 0c             	sub    $0xc,%esp
    6f83:	68 78 04 00 00       	push   $0x478
    6f88:	e8 76 c4 ff ff       	call   3403 <lodepng_malloc>
    6f8d:	83 c4 10             	add    $0x10,%esp
    6f90:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  frequencies_d = (unsigned*)lodepng_malloc(30 * sizeof(*frequencies_d));
    6f93:	83 ec 0c             	sub    $0xc,%esp
    6f96:	6a 78                	push   $0x78
    6f98:	e8 66 c4 ff ff       	call   3403 <lodepng_malloc>
    6f9d:	83 c4 10             	add    $0x10,%esp
    6fa0:	89 45 d0             	mov    %eax,-0x30(%ebp)
  frequencies_cl = (unsigned*)lodepng_malloc(NUM_CODE_LENGTH_CODES * sizeof(*frequencies_cl));
    6fa3:	83 ec 0c             	sub    $0xc,%esp
    6fa6:	6a 4c                	push   $0x4c
    6fa8:	e8 56 c4 ff ff       	call   3403 <lodepng_malloc>
    6fad:	83 c4 10             	add    $0x10,%esp
    6fb0:	89 45 cc             	mov    %eax,-0x34(%ebp)

  if(!frequencies_ll || !frequencies_d || !frequencies_cl) error = 83; /*alloc fail*/
    6fb3:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
    6fb7:	74 0c                	je     6fc5 <deflateDynamic+0xc1>
    6fb9:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
    6fbd:	74 06                	je     6fc5 <deflateDynamic+0xc1>
    6fbf:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
    6fc3:	75 07                	jne    6fcc <deflateDynamic+0xc8>
    6fc5:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)

  /*This while loop never loops due to a break at the end, it is here to
  allow breaking out of it to the cleanup phase on error conditions.*/
  while(!error) {
    6fcc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    6fd0:	0f 85 f6 07 00 00    	jne    77cc <deflateDynamic+0x8c8>
    lodepng_memset(frequencies_ll, 0, 286 * sizeof(*frequencies_ll));
    6fd6:	83 ec 04             	sub    $0x4,%esp
    6fd9:	68 78 04 00 00       	push   $0x478
    6fde:	6a 00                	push   $0x0
    6fe0:	ff 75 d4             	pushl  -0x2c(%ebp)
    6fe3:	e8 8c c4 ff ff       	call   3474 <lodepng_memset>
    6fe8:	83 c4 10             	add    $0x10,%esp
    lodepng_memset(frequencies_d, 0, 30 * sizeof(*frequencies_d));
    6feb:	83 ec 04             	sub    $0x4,%esp
    6fee:	6a 78                	push   $0x78
    6ff0:	6a 00                	push   $0x0
    6ff2:	ff 75 d0             	pushl  -0x30(%ebp)
    6ff5:	e8 7a c4 ff ff       	call   3474 <lodepng_memset>
    6ffa:	83 c4 10             	add    $0x10,%esp
    lodepng_memset(frequencies_cl, 0, NUM_CODE_LENGTH_CODES * sizeof(*frequencies_cl));
    6ffd:	83 ec 04             	sub    $0x4,%esp
    7000:	6a 4c                	push   $0x4c
    7002:	6a 00                	push   $0x0
    7004:	ff 75 cc             	pushl  -0x34(%ebp)
    7007:	e8 68 c4 ff ff       	call   3474 <lodepng_memset>
    700c:	83 c4 10             	add    $0x10,%esp

    if(settings->use_lz77) {
    700f:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7012:	8b 40 04             	mov    0x4(%eax),%eax
    7015:	85 c0                	test   %eax,%eax
    7017:	74 45                	je     705e <deflateDynamic+0x15a>
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
    7019:	8b 45 1c             	mov    0x1c(%ebp),%eax
    701c:	8b 58 14             	mov    0x14(%eax),%ebx
    701f:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7022:	8b 48 10             	mov    0x10(%eax),%ecx
    7025:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7028:	8b 50 0c             	mov    0xc(%eax),%edx
    702b:	8b 45 1c             	mov    0x1c(%ebp),%eax
    702e:	8b 40 08             	mov    0x8(%eax),%eax
    7031:	83 ec 0c             	sub    $0xc,%esp
    7034:	53                   	push   %ebx
    7035:	51                   	push   %ecx
    7036:	52                   	push   %edx
    7037:	50                   	push   %eax
    7038:	ff 75 18             	pushl  0x18(%ebp)
    703b:	ff 75 14             	pushl  0x14(%ebp)
    703e:	ff 75 10             	pushl  0x10(%ebp)
    7041:	ff 75 0c             	pushl  0xc(%ebp)
    7044:	8d 45 90             	lea    -0x70(%ebp),%eax
    7047:	50                   	push   %eax
    7048:	e8 bd f6 ff ff       	call   670a <encodeLZ77>
    704d:	83 c4 30             	add    $0x30,%esp
    7050:	89 45 f4             	mov    %eax,-0xc(%ebp)
                         settings->minmatch, settings->nicematch, settings->lazymatching);
      if(error) break;
    7053:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7057:	74 59                	je     70b2 <deflateDynamic+0x1ae>
    7059:	e9 6e 07 00 00       	jmp    77cc <deflateDynamic+0x8c8>
    } else {
      if(!uivector_resize(&lz77_encoded, datasize)) ERROR_BREAK(83 /*alloc fail*/);
    705e:	83 ec 08             	sub    $0x8,%esp
    7061:	ff 75 c8             	pushl  -0x38(%ebp)
    7064:	8d 45 90             	lea    -0x70(%ebp),%eax
    7067:	50                   	push   %eax
    7068:	e8 17 c5 ff ff       	call   3584 <uivector_resize>
    706d:	83 c4 10             	add    $0x10,%esp
    7070:	85 c0                	test   %eax,%eax
    7072:	75 0c                	jne    7080 <deflateDynamic+0x17c>
    7074:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    707b:	e9 4c 07 00 00       	jmp    77cc <deflateDynamic+0x8c8>
      for(i = datapos; i < dataend; ++i) lz77_encoded.data[i - datapos] = data[i]; /*no LZ77, but still will be Huffman compressed*/
    7080:	8b 45 14             	mov    0x14(%ebp),%eax
    7083:	89 45 e8             	mov    %eax,-0x18(%ebp)
    7086:	eb 22                	jmp    70aa <deflateDynamic+0x1a6>
    7088:	8b 55 90             	mov    -0x70(%ebp),%edx
    708b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    708e:	2b 45 14             	sub    0x14(%ebp),%eax
    7091:	c1 e0 02             	shl    $0x2,%eax
    7094:	01 c2                	add    %eax,%edx
    7096:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    7099:	8b 45 10             	mov    0x10(%ebp),%eax
    709c:	01 c8                	add    %ecx,%eax
    709e:	0f b6 00             	movzbl (%eax),%eax
    70a1:	0f b6 c0             	movzbl %al,%eax
    70a4:	89 02                	mov    %eax,(%edx)
    70a6:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    70aa:	8b 45 e8             	mov    -0x18(%ebp),%eax
    70ad:	3b 45 18             	cmp    0x18(%ebp),%eax
    70b0:	7c d6                	jl     7088 <deflateDynamic+0x184>
    }

    /*Count the frequencies of lit, len and dist codes*/
    for(i = 0; i != lz77_encoded.size; ++i) {
    70b2:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    70b9:	eb 60                	jmp    711b <deflateDynamic+0x217>
      unsigned symbol = lz77_encoded.data[i];
    70bb:	8b 45 90             	mov    -0x70(%ebp),%eax
    70be:	8b 55 e8             	mov    -0x18(%ebp),%edx
    70c1:	c1 e2 02             	shl    $0x2,%edx
    70c4:	01 d0                	add    %edx,%eax
    70c6:	8b 00                	mov    (%eax),%eax
    70c8:	89 45 c0             	mov    %eax,-0x40(%ebp)
      ++frequencies_ll[symbol];
    70cb:	8b 45 c0             	mov    -0x40(%ebp),%eax
    70ce:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    70d5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    70d8:	01 d0                	add    %edx,%eax
    70da:	8b 10                	mov    (%eax),%edx
    70dc:	83 c2 01             	add    $0x1,%edx
    70df:	89 10                	mov    %edx,(%eax)
      if(symbol > 256) {
    70e1:	81 7d c0 00 01 00 00 	cmpl   $0x100,-0x40(%ebp)
    70e8:	76 2d                	jbe    7117 <deflateDynamic+0x213>
        unsigned dist = lz77_encoded.data[i + 2];
    70ea:	8b 45 90             	mov    -0x70(%ebp),%eax
    70ed:	8b 55 e8             	mov    -0x18(%ebp),%edx
    70f0:	83 c2 02             	add    $0x2,%edx
    70f3:	c1 e2 02             	shl    $0x2,%edx
    70f6:	01 d0                	add    %edx,%eax
    70f8:	8b 00                	mov    (%eax),%eax
    70fa:	89 45 bc             	mov    %eax,-0x44(%ebp)
        ++frequencies_d[dist];
    70fd:	8b 45 bc             	mov    -0x44(%ebp),%eax
    7100:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7107:	8b 45 d0             	mov    -0x30(%ebp),%eax
    710a:	01 d0                	add    %edx,%eax
    710c:	8b 10                	mov    (%eax),%edx
    710e:	83 c2 01             	add    $0x1,%edx
    7111:	89 10                	mov    %edx,(%eax)
        i += 3;
    7113:	83 45 e8 03          	addl   $0x3,-0x18(%ebp)
      if(!uivector_resize(&lz77_encoded, datasize)) ERROR_BREAK(83 /*alloc fail*/);
      for(i = datapos; i < dataend; ++i) lz77_encoded.data[i - datapos] = data[i]; /*no LZ77, but still will be Huffman compressed*/
    }

    /*Count the frequencies of lit, len and dist codes*/
    for(i = 0; i != lz77_encoded.size; ++i) {
    7117:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    711b:	8b 45 94             	mov    -0x6c(%ebp),%eax
    711e:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    7121:	75 98                	jne    70bb <deflateDynamic+0x1b7>
        unsigned dist = lz77_encoded.data[i + 2];
        ++frequencies_d[dist];
        i += 3;
      }
    }
    frequencies_ll[256] = 1; /*there will be exactly 1 end code, at the end of the block*/
    7123:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7126:	05 00 04 00 00       	add    $0x400,%eax
    712b:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

    /*Make both huffman trees, one for the lit and len codes, one for the dist codes*/
    error = HuffmanTree_makeFromFrequencies(&tree_ll, frequencies_ll, 257, 286, 15);
    7131:	83 ec 0c             	sub    $0xc,%esp
    7134:	6a 0f                	push   $0xf
    7136:	68 1e 01 00 00       	push   $0x11e
    713b:	68 01 01 00 00       	push   $0x101
    7140:	ff 75 d4             	pushl  -0x2c(%ebp)
    7143:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    7149:	50                   	push   %eax
    714a:	e8 e0 e1 ff ff       	call   532f <HuffmanTree_makeFromFrequencies>
    714f:	83 c4 20             	add    $0x20,%esp
    7152:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    7155:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7159:	0f 85 66 06 00 00    	jne    77c5 <deflateDynamic+0x8c1>
    /*2, not 1, is chosen for mincodes: some buggy PNG decoders require at least 2 symbols in the dist tree*/
    error = HuffmanTree_makeFromFrequencies(&tree_d, frequencies_d, 2, 30, 15);
    715f:	83 ec 0c             	sub    $0xc,%esp
    7162:	6a 0f                	push   $0xf
    7164:	6a 1e                	push   $0x1e
    7166:	6a 02                	push   $0x2
    7168:	ff 75 d0             	pushl  -0x30(%ebp)
    716b:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    7171:	50                   	push   %eax
    7172:	e8 b8 e1 ff ff       	call   532f <HuffmanTree_makeFromFrequencies>
    7177:	83 c4 20             	add    $0x20,%esp
    717a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    717d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7181:	0f 85 41 06 00 00    	jne    77c8 <deflateDynamic+0x8c4>

    numcodes_ll = LODEPNG_MIN(tree_ll.numcodes, 286);
    7187:	8b 45 84             	mov    -0x7c(%ebp),%eax
    718a:	ba 1e 01 00 00       	mov    $0x11e,%edx
    718f:	3d 1e 01 00 00       	cmp    $0x11e,%eax
    7194:	0f 47 c2             	cmova  %edx,%eax
    7197:	89 45 b8             	mov    %eax,-0x48(%ebp)
    numcodes_d = LODEPNG_MIN(tree_d.numcodes, 30);
    719a:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
    71a0:	ba 1e 00 00 00       	mov    $0x1e,%edx
    71a5:	83 f8 1e             	cmp    $0x1e,%eax
    71a8:	0f 47 c2             	cmova  %edx,%eax
    71ab:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    /*store the code lengths of both generated trees in bitlen_lld*/
    numcodes_lld = numcodes_ll + numcodes_d;
    71ae:	8b 55 b8             	mov    -0x48(%ebp),%edx
    71b1:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    71b4:	01 d0                	add    %edx,%eax
    71b6:	89 45 b0             	mov    %eax,-0x50(%ebp)
    bitlen_lld = (unsigned*)lodepng_malloc(numcodes_lld * sizeof(*bitlen_lld));
    71b9:	8b 45 b0             	mov    -0x50(%ebp),%eax
    71bc:	c1 e0 02             	shl    $0x2,%eax
    71bf:	83 ec 0c             	sub    $0xc,%esp
    71c2:	50                   	push   %eax
    71c3:	e8 3b c2 ff ff       	call   3403 <lodepng_malloc>
    71c8:	83 c4 10             	add    $0x10,%esp
    71cb:	89 45 f0             	mov    %eax,-0x10(%ebp)
    /*numcodes_lld_e never needs more size than bitlen_lld*/
    bitlen_lld_e = (unsigned*)lodepng_malloc(numcodes_lld * sizeof(*bitlen_lld_e));
    71ce:	8b 45 b0             	mov    -0x50(%ebp),%eax
    71d1:	c1 e0 02             	shl    $0x2,%eax
    71d4:	83 ec 0c             	sub    $0xc,%esp
    71d7:	50                   	push   %eax
    71d8:	e8 26 c2 ff ff       	call   3403 <lodepng_malloc>
    71dd:	83 c4 10             	add    $0x10,%esp
    71e0:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!bitlen_lld || !bitlen_lld_e) ERROR_BREAK(83); /*alloc fail*/
    71e3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    71e7:	74 06                	je     71ef <deflateDynamic+0x2eb>
    71e9:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    71ed:	75 0c                	jne    71fb <deflateDynamic+0x2f7>
    71ef:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    71f6:	e9 d1 05 00 00       	jmp    77cc <deflateDynamic+0x8c8>
    numcodes_lld_e = 0;
    71fb:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

    for(i = 0; i != numcodes_ll; ++i) bitlen_lld[i] = tree_ll.lengths[i];
    7202:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    7209:	eb 25                	jmp    7230 <deflateDynamic+0x32c>
    720b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    720e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7215:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7218:	01 c2                	add    %eax,%edx
    721a:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
    7220:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    7223:	c1 e1 02             	shl    $0x2,%ecx
    7226:	01 c8                	add    %ecx,%eax
    7228:	8b 00                	mov    (%eax),%eax
    722a:	89 02                	mov    %eax,(%edx)
    722c:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7230:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7233:	3b 45 b8             	cmp    -0x48(%ebp),%eax
    7236:	75 d3                	jne    720b <deflateDynamic+0x307>
    for(i = 0; i != numcodes_d; ++i) bitlen_lld[numcodes_ll + i] = tree_d.lengths[i];
    7238:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    723f:	eb 2a                	jmp    726b <deflateDynamic+0x367>
    7241:	8b 55 b8             	mov    -0x48(%ebp),%edx
    7244:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7247:	01 d0                	add    %edx,%eax
    7249:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7250:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7253:	01 c2                	add    %eax,%edx
    7255:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
    725b:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    725e:	c1 e1 02             	shl    $0x2,%ecx
    7261:	01 c8                	add    %ecx,%eax
    7263:	8b 00                	mov    (%eax),%eax
    7265:	89 02                	mov    %eax,(%edx)
    7267:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    726b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    726e:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
    7271:	75 ce                	jne    7241 <deflateDynamic+0x33d>

    /*run-length compress bitlen_ldd into bitlen_lld_e by using repeat codes 16 (copy length 3-6 times),
    17 (3-10 zeroes), 18 (11-138 zeroes)*/
    for(i = 0; i != numcodes_lld; ++i) {
    7273:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    727a:	e9 3b 02 00 00       	jmp    74ba <deflateDynamic+0x5b6>
      unsigned j = 0; /*amount of repetitions*/
    727f:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
      while(i + j + 1 < numcodes_lld && bitlen_lld[i + j + 1] == bitlen_lld[i]) ++j;
    7286:	eb 04                	jmp    728c <deflateDynamic+0x388>
    7288:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
    728c:	8b 55 e8             	mov    -0x18(%ebp),%edx
    728f:	8b 45 dc             	mov    -0x24(%ebp),%eax
    7292:	01 d0                	add    %edx,%eax
    7294:	8d 50 01             	lea    0x1(%eax),%edx
    7297:	8b 45 b0             	mov    -0x50(%ebp),%eax
    729a:	39 c2                	cmp    %eax,%edx
    729c:	73 2e                	jae    72cc <deflateDynamic+0x3c8>
    729e:	8b 55 e8             	mov    -0x18(%ebp),%edx
    72a1:	8b 45 dc             	mov    -0x24(%ebp),%eax
    72a4:	01 d0                	add    %edx,%eax
    72a6:	83 c0 01             	add    $0x1,%eax
    72a9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    72b0:	8b 45 f0             	mov    -0x10(%ebp),%eax
    72b3:	01 d0                	add    %edx,%eax
    72b5:	8b 10                	mov    (%eax),%edx
    72b7:	8b 45 e8             	mov    -0x18(%ebp),%eax
    72ba:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    72c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
    72c4:	01 c8                	add    %ecx,%eax
    72c6:	8b 00                	mov    (%eax),%eax
    72c8:	39 c2                	cmp    %eax,%edx
    72ca:	74 bc                	je     7288 <deflateDynamic+0x384>

      if(bitlen_lld[i] == 0 && j >= 2) /*repeat code for zeroes*/ {
    72cc:	8b 45 e8             	mov    -0x18(%ebp),%eax
    72cf:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    72d6:	8b 45 f0             	mov    -0x10(%ebp),%eax
    72d9:	01 d0                	add    %edx,%eax
    72db:	8b 00                	mov    (%eax),%eax
    72dd:	85 c0                	test   %eax,%eax
    72df:	0f 85 a9 00 00 00    	jne    738e <deflateDynamic+0x48a>
    72e5:	83 7d dc 01          	cmpl   $0x1,-0x24(%ebp)
    72e9:	0f 86 9f 00 00 00    	jbe    738e <deflateDynamic+0x48a>
        ++j; /*include the first zero*/
    72ef:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
        if(j <= 10) /*repeat code 17 supports max 10 zeroes*/ {
    72f3:	83 7d dc 0a          	cmpl   $0xa,-0x24(%ebp)
    72f7:	77 3a                	ja     7333 <deflateDynamic+0x42f>
          bitlen_lld_e[numcodes_lld_e++] = 17;
    72f9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    72fc:	8d 50 01             	lea    0x1(%eax),%edx
    72ff:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7302:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7309:	8b 45 ec             	mov    -0x14(%ebp),%eax
    730c:	01 d0                	add    %edx,%eax
    730e:	c7 00 11 00 00 00    	movl   $0x11,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = j - 3;
    7314:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7317:	8d 50 01             	lea    0x1(%eax),%edx
    731a:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    731d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7324:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7327:	01 d0                	add    %edx,%eax
    7329:	8b 55 dc             	mov    -0x24(%ebp),%edx
    732c:	83 ea 03             	sub    $0x3,%edx
    732f:	89 10                	mov    %edx,(%eax)
    7331:	eb 48                	jmp    737b <deflateDynamic+0x477>
        } else /*repeat code 18 supports max 138 zeroes*/ {
          if(j > 138) j = 138;
    7333:	81 7d dc 8a 00 00 00 	cmpl   $0x8a,-0x24(%ebp)
    733a:	76 07                	jbe    7343 <deflateDynamic+0x43f>
    733c:	c7 45 dc 8a 00 00 00 	movl   $0x8a,-0x24(%ebp)
          bitlen_lld_e[numcodes_lld_e++] = 18;
    7343:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7346:	8d 50 01             	lea    0x1(%eax),%edx
    7349:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    734c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7353:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7356:	01 d0                	add    %edx,%eax
    7358:	c7 00 12 00 00 00    	movl   $0x12,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = j - 11;
    735e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7361:	8d 50 01             	lea    0x1(%eax),%edx
    7364:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7367:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    736e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7371:	01 d0                	add    %edx,%eax
    7373:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7376:	83 ea 0b             	sub    $0xb,%edx
    7379:	89 10                	mov    %edx,(%eax)
        }
        i += (j - 1);
    737b:	8b 55 e8             	mov    -0x18(%ebp),%edx
    737e:	8b 45 dc             	mov    -0x24(%ebp),%eax
    7381:	01 d0                	add    %edx,%eax
    7383:	83 e8 01             	sub    $0x1,%eax
    7386:	89 45 e8             	mov    %eax,-0x18(%ebp)
    7389:	e9 28 01 00 00       	jmp    74b6 <deflateDynamic+0x5b2>
      } else if(j >= 3) /*repeat code for value other than zero*/ {
    738e:	83 7d dc 02          	cmpl   $0x2,-0x24(%ebp)
    7392:	0f 86 f6 00 00 00    	jbe    748e <deflateDynamic+0x58a>
        size_t k;
        unsigned num = j / 6u, rest = j % 6u;
    7398:	8b 45 dc             	mov    -0x24(%ebp),%eax
    739b:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
    73a0:	f7 e2                	mul    %edx
    73a2:	89 d0                	mov    %edx,%eax
    73a4:	c1 e8 02             	shr    $0x2,%eax
    73a7:	89 45 ac             	mov    %eax,-0x54(%ebp)
    73aa:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    73ad:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
    73b2:	89 c8                	mov    %ecx,%eax
    73b4:	f7 e2                	mul    %edx
    73b6:	c1 ea 02             	shr    $0x2,%edx
    73b9:	89 d0                	mov    %edx,%eax
    73bb:	01 c0                	add    %eax,%eax
    73bd:	01 d0                	add    %edx,%eax
    73bf:	01 c0                	add    %eax,%eax
    73c1:	29 c1                	sub    %eax,%ecx
    73c3:	89 c8                	mov    %ecx,%eax
    73c5:	89 45 a8             	mov    %eax,-0x58(%ebp)
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
    73c8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    73cb:	8d 50 01             	lea    0x1(%eax),%edx
    73ce:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    73d1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    73d8:	8b 45 ec             	mov    -0x14(%ebp),%eax
    73db:	01 c2                	add    %eax,%edx
    73dd:	8b 45 e8             	mov    -0x18(%ebp),%eax
    73e0:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    73e7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    73ea:	01 c8                	add    %ecx,%eax
    73ec:	8b 00                	mov    (%eax),%eax
    73ee:	89 02                	mov    %eax,(%edx)
        for(k = 0; k < num; ++k) {
    73f0:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    73f7:	eb 3a                	jmp    7433 <deflateDynamic+0x52f>
          bitlen_lld_e[numcodes_lld_e++] = 16;
    73f9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    73fc:	8d 50 01             	lea    0x1(%eax),%edx
    73ff:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7402:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7409:	8b 45 ec             	mov    -0x14(%ebp),%eax
    740c:	01 d0                	add    %edx,%eax
    740e:	c7 00 10 00 00 00    	movl   $0x10,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = 6 - 3;
    7414:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7417:	8d 50 01             	lea    0x1(%eax),%edx
    741a:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    741d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7424:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7427:	01 d0                	add    %edx,%eax
    7429:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
        i += (j - 1);
      } else if(j >= 3) /*repeat code for value other than zero*/ {
        size_t k;
        unsigned num = j / 6u, rest = j % 6u;
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
        for(k = 0; k < num; ++k) {
    742f:	83 45 d8 01          	addl   $0x1,-0x28(%ebp)
    7433:	8b 45 d8             	mov    -0x28(%ebp),%eax
    7436:	3b 45 ac             	cmp    -0x54(%ebp),%eax
    7439:	72 be                	jb     73f9 <deflateDynamic+0x4f5>
          bitlen_lld_e[numcodes_lld_e++] = 16;
          bitlen_lld_e[numcodes_lld_e++] = 6 - 3;
        }
        if(rest >= 3) {
    743b:	83 7d a8 02          	cmpl   $0x2,-0x58(%ebp)
    743f:	76 3a                	jbe    747b <deflateDynamic+0x577>
          bitlen_lld_e[numcodes_lld_e++] = 16;
    7441:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7444:	8d 50 01             	lea    0x1(%eax),%edx
    7447:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    744a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7451:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7454:	01 d0                	add    %edx,%eax
    7456:	c7 00 10 00 00 00    	movl   $0x10,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = rest - 3;
    745c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    745f:	8d 50 01             	lea    0x1(%eax),%edx
    7462:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7465:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    746c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    746f:	01 d0                	add    %edx,%eax
    7471:	8b 55 a8             	mov    -0x58(%ebp),%edx
    7474:	83 ea 03             	sub    $0x3,%edx
    7477:	89 10                	mov    %edx,(%eax)
    7479:	eb 06                	jmp    7481 <deflateDynamic+0x57d>
        }
        else j -= rest;
    747b:	8b 45 a8             	mov    -0x58(%ebp),%eax
    747e:	29 45 dc             	sub    %eax,-0x24(%ebp)
        i += j;
    7481:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7484:	8b 45 dc             	mov    -0x24(%ebp),%eax
    7487:	01 d0                	add    %edx,%eax
    7489:	89 45 e8             	mov    %eax,-0x18(%ebp)
    748c:	eb 28                	jmp    74b6 <deflateDynamic+0x5b2>
      } else /*too short to benefit from repeat code*/ {
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
    748e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7491:	8d 50 01             	lea    0x1(%eax),%edx
    7494:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7497:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    749e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    74a1:	01 c2                	add    %eax,%edx
    74a3:	8b 45 e8             	mov    -0x18(%ebp),%eax
    74a6:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    74ad:	8b 45 f0             	mov    -0x10(%ebp),%eax
    74b0:	01 c8                	add    %ecx,%eax
    74b2:	8b 00                	mov    (%eax),%eax
    74b4:	89 02                	mov    %eax,(%edx)
    for(i = 0; i != numcodes_ll; ++i) bitlen_lld[i] = tree_ll.lengths[i];
    for(i = 0; i != numcodes_d; ++i) bitlen_lld[numcodes_ll + i] = tree_d.lengths[i];

    /*run-length compress bitlen_ldd into bitlen_lld_e by using repeat codes 16 (copy length 3-6 times),
    17 (3-10 zeroes), 18 (11-138 zeroes)*/
    for(i = 0; i != numcodes_lld; ++i) {
    74b6:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    74ba:	8b 45 e8             	mov    -0x18(%ebp),%eax
    74bd:	3b 45 b0             	cmp    -0x50(%ebp),%eax
    74c0:	0f 85 b9 fd ff ff    	jne    727f <deflateDynamic+0x37b>
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
      }
    }

    /*generate tree_cl, the huffmantree of huffmantrees*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    74c6:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    74cd:	eb 42                	jmp    7511 <deflateDynamic+0x60d>
      ++frequencies_cl[bitlen_lld_e[i]];
    74cf:	8b 45 e8             	mov    -0x18(%ebp),%eax
    74d2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    74d9:	8b 45 ec             	mov    -0x14(%ebp),%eax
    74dc:	01 d0                	add    %edx,%eax
    74de:	8b 00                	mov    (%eax),%eax
    74e0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    74e7:	8b 45 cc             	mov    -0x34(%ebp),%eax
    74ea:	01 d0                	add    %edx,%eax
    74ec:	8b 10                	mov    (%eax),%edx
    74ee:	83 c2 01             	add    $0x1,%edx
    74f1:	89 10                	mov    %edx,(%eax)
      /*after a repeat code come the bits that specify the number of repetitions,
      those don't need to be in the frequencies_cl calculation*/
      if(bitlen_lld_e[i] >= 16) ++i;
    74f3:	8b 45 e8             	mov    -0x18(%ebp),%eax
    74f6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    74fd:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7500:	01 d0                	add    %edx,%eax
    7502:	8b 00                	mov    (%eax),%eax
    7504:	83 f8 0f             	cmp    $0xf,%eax
    7507:	76 04                	jbe    750d <deflateDynamic+0x609>
    7509:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
      }
    }

    /*generate tree_cl, the huffmantree of huffmantrees*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    750d:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7511:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7514:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    7517:	75 b6                	jne    74cf <deflateDynamic+0x5cb>
      /*after a repeat code come the bits that specify the number of repetitions,
      those don't need to be in the frequencies_cl calculation*/
      if(bitlen_lld_e[i] >= 16) ++i;
    }

    error = HuffmanTree_makeFromFrequencies(&tree_cl, frequencies_cl,
    7519:	83 ec 0c             	sub    $0xc,%esp
    751c:	6a 07                	push   $0x7
    751e:	6a 13                	push   $0x13
    7520:	6a 13                	push   $0x13
    7522:	ff 75 cc             	pushl  -0x34(%ebp)
    7525:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    752b:	50                   	push   %eax
    752c:	e8 fe dd ff ff       	call   532f <HuffmanTree_makeFromFrequencies>
    7531:	83 c4 20             	add    $0x20,%esp
    7534:	89 45 f4             	mov    %eax,-0xc(%ebp)
                                            NUM_CODE_LENGTH_CODES, NUM_CODE_LENGTH_CODES, 7);
    if(error) break;
    7537:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    753b:	0f 85 8a 02 00 00    	jne    77cb <deflateDynamic+0x8c7>

    /*compute amount of code-length-code-lengths to output*/
    numcodes_cl = NUM_CODE_LENGTH_CODES;
    7541:	c7 45 e0 13 00 00 00 	movl   $0x13,-0x20(%ebp)
    /*trim zeros at the end (using CLCL_ORDER), but minimum size must be 4 (see HCLEN below)*/
    while(numcodes_cl > 4u && tree_cl.lengths[CLCL_ORDER[numcodes_cl - 1u]] == 0) {
    7548:	eb 04                	jmp    754e <deflateDynamic+0x64a>
      numcodes_cl--;
    754a:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
    if(error) break;

    /*compute amount of code-length-code-lengths to output*/
    numcodes_cl = NUM_CODE_LENGTH_CODES;
    /*trim zeros at the end (using CLCL_ORDER), but minimum size must be 4 (see HCLEN below)*/
    while(numcodes_cl > 4u && tree_cl.lengths[CLCL_ORDER[numcodes_cl - 1u]] == 0) {
    754e:	8b 45 e0             	mov    -0x20(%ebp),%eax
    7551:	83 f8 04             	cmp    $0x4,%eax
    7554:	76 1e                	jbe    7574 <deflateDynamic+0x670>
    7556:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
    755c:	8b 55 e0             	mov    -0x20(%ebp),%edx
    755f:	83 ea 01             	sub    $0x1,%edx
    7562:	8b 14 95 20 a0 01 00 	mov    0x1a020(,%edx,4),%edx
    7569:	c1 e2 02             	shl    $0x2,%edx
    756c:	01 d0                	add    %edx,%eax
    756e:	8b 00                	mov    (%eax),%eax
    7570:	85 c0                	test   %eax,%eax
    7572:	74 d6                	je     754a <deflateDynamic+0x646>
    - compressed data
    - 256 (end code)
    */

    /*Write block type*/
    writeBits(writer, BFINAL, 1);
    7574:	83 ec 04             	sub    $0x4,%esp
    7577:	6a 01                	push   $0x1
    7579:	ff 75 c4             	pushl  -0x3c(%ebp)
    757c:	ff 75 08             	pushl  0x8(%ebp)
    757f:	e8 67 c3 ff ff       	call   38eb <writeBits>
    7584:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 0, 1); /*first bit of BTYPE "dynamic"*/
    7587:	83 ec 04             	sub    $0x4,%esp
    758a:	6a 01                	push   $0x1
    758c:	6a 00                	push   $0x0
    758e:	ff 75 08             	pushl  0x8(%ebp)
    7591:	e8 55 c3 ff ff       	call   38eb <writeBits>
    7596:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 1, 1); /*second bit of BTYPE "dynamic"*/
    7599:	83 ec 04             	sub    $0x4,%esp
    759c:	6a 01                	push   $0x1
    759e:	6a 01                	push   $0x1
    75a0:	ff 75 08             	pushl  0x8(%ebp)
    75a3:	e8 43 c3 ff ff       	call   38eb <writeBits>
    75a8:	83 c4 10             	add    $0x10,%esp

    /*write the HLIT, HDIST and HCLEN values*/
    /*all three sizes take trimmed ending zeroes into account, done either by HuffmanTree_makeFromFrequencies
    or in the loop for numcodes_cl above, which saves space. */
    HLIT = (unsigned)(numcodes_ll - 257);
    75ab:	8b 45 b8             	mov    -0x48(%ebp),%eax
    75ae:	2d 01 01 00 00       	sub    $0x101,%eax
    75b3:	89 45 a4             	mov    %eax,-0x5c(%ebp)
    HDIST = (unsigned)(numcodes_d - 1);
    75b6:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    75b9:	83 e8 01             	sub    $0x1,%eax
    75bc:	89 45 a0             	mov    %eax,-0x60(%ebp)
    HCLEN = (unsigned)(numcodes_cl - 4);
    75bf:	8b 45 e0             	mov    -0x20(%ebp),%eax
    75c2:	83 e8 04             	sub    $0x4,%eax
    75c5:	89 45 9c             	mov    %eax,-0x64(%ebp)
    writeBits(writer, HLIT, 5);
    75c8:	83 ec 04             	sub    $0x4,%esp
    75cb:	6a 05                	push   $0x5
    75cd:	ff 75 a4             	pushl  -0x5c(%ebp)
    75d0:	ff 75 08             	pushl  0x8(%ebp)
    75d3:	e8 13 c3 ff ff       	call   38eb <writeBits>
    75d8:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, HDIST, 5);
    75db:	83 ec 04             	sub    $0x4,%esp
    75de:	6a 05                	push   $0x5
    75e0:	ff 75 a0             	pushl  -0x60(%ebp)
    75e3:	ff 75 08             	pushl  0x8(%ebp)
    75e6:	e8 00 c3 ff ff       	call   38eb <writeBits>
    75eb:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, HCLEN, 4);
    75ee:	83 ec 04             	sub    $0x4,%esp
    75f1:	6a 04                	push   $0x4
    75f3:	ff 75 9c             	pushl  -0x64(%ebp)
    75f6:	ff 75 08             	pushl  0x8(%ebp)
    75f9:	e8 ed c2 ff ff       	call   38eb <writeBits>
    75fe:	83 c4 10             	add    $0x10,%esp

    /*write the code lengths of the code length alphabet ("bitlen_cl")*/
    for(i = 0; i != numcodes_cl; ++i) writeBits(writer, tree_cl.lengths[CLCL_ORDER[i]], 3);
    7601:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    7608:	eb 2c                	jmp    7636 <deflateDynamic+0x732>
    760a:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
    7610:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7613:	8b 04 85 20 a0 01 00 	mov    0x1a020(,%eax,4),%eax
    761a:	c1 e0 02             	shl    $0x2,%eax
    761d:	01 d0                	add    %edx,%eax
    761f:	8b 00                	mov    (%eax),%eax
    7621:	83 ec 04             	sub    $0x4,%esp
    7624:	6a 03                	push   $0x3
    7626:	50                   	push   %eax
    7627:	ff 75 08             	pushl  0x8(%ebp)
    762a:	e8 bc c2 ff ff       	call   38eb <writeBits>
    762f:	83 c4 10             	add    $0x10,%esp
    7632:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7636:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7639:	3b 45 e0             	cmp    -0x20(%ebp),%eax
    763c:	75 cc                	jne    760a <deflateDynamic+0x706>

    /*write the lengths of the lit/len AND the dist alphabet*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    763e:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    7645:	e9 0a 01 00 00       	jmp    7754 <deflateDynamic+0x850>
      writeBitsReversed(writer, tree_cl.codes[bitlen_lld_e[i]], tree_cl.lengths[bitlen_lld_e[i]]);
    764a:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
    7650:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7653:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    765a:	8b 55 ec             	mov    -0x14(%ebp),%edx
    765d:	01 ca                	add    %ecx,%edx
    765f:	8b 12                	mov    (%edx),%edx
    7661:	c1 e2 02             	shl    $0x2,%edx
    7664:	01 d0                	add    %edx,%eax
    7666:	8b 00                	mov    (%eax),%eax
    7668:	89 c3                	mov    %eax,%ebx
    766a:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
    7670:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7673:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    767a:	8b 55 ec             	mov    -0x14(%ebp),%edx
    767d:	01 ca                	add    %ecx,%edx
    767f:	8b 12                	mov    (%edx),%edx
    7681:	c1 e2 02             	shl    $0x2,%edx
    7684:	01 d0                	add    %edx,%eax
    7686:	8b 00                	mov    (%eax),%eax
    7688:	83 ec 04             	sub    $0x4,%esp
    768b:	53                   	push   %ebx
    768c:	50                   	push   %eax
    768d:	ff 75 08             	pushl  0x8(%ebp)
    7690:	e8 ea c3 ff ff       	call   3a7f <writeBitsReversed>
    7695:	83 c4 10             	add    $0x10,%esp
      /*extra bits of repeat codes*/
      if(bitlen_lld_e[i] == 16) writeBits(writer, bitlen_lld_e[++i], 2);
    7698:	8b 45 e8             	mov    -0x18(%ebp),%eax
    769b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    76a2:	8b 45 ec             	mov    -0x14(%ebp),%eax
    76a5:	01 d0                	add    %edx,%eax
    76a7:	8b 00                	mov    (%eax),%eax
    76a9:	83 f8 10             	cmp    $0x10,%eax
    76ac:	75 28                	jne    76d6 <deflateDynamic+0x7d2>
    76ae:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    76b2:	8b 45 e8             	mov    -0x18(%ebp),%eax
    76b5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    76bc:	8b 45 ec             	mov    -0x14(%ebp),%eax
    76bf:	01 d0                	add    %edx,%eax
    76c1:	8b 00                	mov    (%eax),%eax
    76c3:	83 ec 04             	sub    $0x4,%esp
    76c6:	6a 02                	push   $0x2
    76c8:	50                   	push   %eax
    76c9:	ff 75 08             	pushl  0x8(%ebp)
    76cc:	e8 1a c2 ff ff       	call   38eb <writeBits>
    76d1:	83 c4 10             	add    $0x10,%esp
    76d4:	eb 7a                	jmp    7750 <deflateDynamic+0x84c>
      else if(bitlen_lld_e[i] == 17) writeBits(writer, bitlen_lld_e[++i], 3);
    76d6:	8b 45 e8             	mov    -0x18(%ebp),%eax
    76d9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    76e0:	8b 45 ec             	mov    -0x14(%ebp),%eax
    76e3:	01 d0                	add    %edx,%eax
    76e5:	8b 00                	mov    (%eax),%eax
    76e7:	83 f8 11             	cmp    $0x11,%eax
    76ea:	75 28                	jne    7714 <deflateDynamic+0x810>
    76ec:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    76f0:	8b 45 e8             	mov    -0x18(%ebp),%eax
    76f3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    76fa:	8b 45 ec             	mov    -0x14(%ebp),%eax
    76fd:	01 d0                	add    %edx,%eax
    76ff:	8b 00                	mov    (%eax),%eax
    7701:	83 ec 04             	sub    $0x4,%esp
    7704:	6a 03                	push   $0x3
    7706:	50                   	push   %eax
    7707:	ff 75 08             	pushl  0x8(%ebp)
    770a:	e8 dc c1 ff ff       	call   38eb <writeBits>
    770f:	83 c4 10             	add    $0x10,%esp
    7712:	eb 3c                	jmp    7750 <deflateDynamic+0x84c>
      else if(bitlen_lld_e[i] == 18) writeBits(writer, bitlen_lld_e[++i], 7);
    7714:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7717:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    771e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7721:	01 d0                	add    %edx,%eax
    7723:	8b 00                	mov    (%eax),%eax
    7725:	83 f8 12             	cmp    $0x12,%eax
    7728:	75 26                	jne    7750 <deflateDynamic+0x84c>
    772a:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    772e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7731:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7738:	8b 45 ec             	mov    -0x14(%ebp),%eax
    773b:	01 d0                	add    %edx,%eax
    773d:	8b 00                	mov    (%eax),%eax
    773f:	83 ec 04             	sub    $0x4,%esp
    7742:	6a 07                	push   $0x7
    7744:	50                   	push   %eax
    7745:	ff 75 08             	pushl  0x8(%ebp)
    7748:	e8 9e c1 ff ff       	call   38eb <writeBits>
    774d:	83 c4 10             	add    $0x10,%esp

    /*write the code lengths of the code length alphabet ("bitlen_cl")*/
    for(i = 0; i != numcodes_cl; ++i) writeBits(writer, tree_cl.lengths[CLCL_ORDER[i]], 3);

    /*write the lengths of the lit/len AND the dist alphabet*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    7750:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7754:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7757:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    775a:	0f 85 ea fe ff ff    	jne    764a <deflateDynamic+0x746>
      else if(bitlen_lld_e[i] == 17) writeBits(writer, bitlen_lld_e[++i], 3);
      else if(bitlen_lld_e[i] == 18) writeBits(writer, bitlen_lld_e[++i], 7);
    }

    /*write the compressed data symbols*/
    writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);
    7760:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    7766:	50                   	push   %eax
    7767:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    776d:	50                   	push   %eax
    776e:	8d 45 90             	lea    -0x70(%ebp),%eax
    7771:	50                   	push   %eax
    7772:	ff 75 08             	pushl  0x8(%ebp)
    7775:	e8 4f f6 ff ff       	call   6dc9 <writeLZ77data>
    777a:	83 c4 10             	add    $0x10,%esp
    /*error: the length of the end code 256 must be larger than 0*/
    if(tree_ll.lengths[256] == 0) ERROR_BREAK(64);
    777d:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
    7783:	05 00 04 00 00       	add    $0x400,%eax
    7788:	8b 00                	mov    (%eax),%eax
    778a:	85 c0                	test   %eax,%eax
    778c:	75 09                	jne    7797 <deflateDynamic+0x893>
    778e:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
    7795:	eb 35                	jmp    77cc <deflateDynamic+0x8c8>

    /*write the end code*/
    writeBitsReversed(writer, tree_ll.codes[256], tree_ll.lengths[256]);
    7797:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
    779d:	05 00 04 00 00       	add    $0x400,%eax
    77a2:	8b 00                	mov    (%eax),%eax
    77a4:	89 c2                	mov    %eax,%edx
    77a6:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
    77ac:	05 00 04 00 00       	add    $0x400,%eax
    77b1:	8b 00                	mov    (%eax),%eax
    77b3:	83 ec 04             	sub    $0x4,%esp
    77b6:	52                   	push   %edx
    77b7:	50                   	push   %eax
    77b8:	ff 75 08             	pushl  0x8(%ebp)
    77bb:	e8 bf c2 ff ff       	call   3a7f <writeBitsReversed>
    77c0:	83 c4 10             	add    $0x10,%esp

    break; /*end of error-while*/
    77c3:	eb 07                	jmp    77cc <deflateDynamic+0x8c8>
    }
    frequencies_ll[256] = 1; /*there will be exactly 1 end code, at the end of the block*/

    /*Make both huffman trees, one for the lit and len codes, one for the dist codes*/
    error = HuffmanTree_makeFromFrequencies(&tree_ll, frequencies_ll, 257, 286, 15);
    if(error) break;
    77c5:	90                   	nop
    77c6:	eb 04                	jmp    77cc <deflateDynamic+0x8c8>
    /*2, not 1, is chosen for mincodes: some buggy PNG decoders require at least 2 symbols in the dist tree*/
    error = HuffmanTree_makeFromFrequencies(&tree_d, frequencies_d, 2, 30, 15);
    if(error) break;
    77c8:	90                   	nop
    77c9:	eb 01                	jmp    77cc <deflateDynamic+0x8c8>
      if(bitlen_lld_e[i] >= 16) ++i;
    }

    error = HuffmanTree_makeFromFrequencies(&tree_cl, frequencies_cl,
                                            NUM_CODE_LENGTH_CODES, NUM_CODE_LENGTH_CODES, 7);
    if(error) break;
    77cb:	90                   	nop

    break; /*end of error-while*/
  }

  /*cleanup*/
  uivector_cleanup(&lz77_encoded);
    77cc:	83 ec 0c             	sub    $0xc,%esp
    77cf:	8d 45 90             	lea    -0x70(%ebp),%eax
    77d2:	50                   	push   %eax
    77d3:	e8 73 bd ff ff       	call   354b <uivector_cleanup>
    77d8:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_ll);
    77db:	83 ec 0c             	sub    $0xc,%esp
    77de:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    77e4:	50                   	push   %eax
    77e5:	e8 3a cb ff ff       	call   4324 <HuffmanTree_cleanup>
    77ea:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_d);
    77ed:	83 ec 0c             	sub    $0xc,%esp
    77f0:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    77f6:	50                   	push   %eax
    77f7:	e8 28 cb ff ff       	call   4324 <HuffmanTree_cleanup>
    77fc:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_cl);
    77ff:	83 ec 0c             	sub    $0xc,%esp
    7802:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    7808:	50                   	push   %eax
    7809:	e8 16 cb ff ff       	call   4324 <HuffmanTree_cleanup>
    780e:	83 c4 10             	add    $0x10,%esp
  lodepng_free(frequencies_ll);
    7811:	83 ec 0c             	sub    $0xc,%esp
    7814:	ff 75 d4             	pushl  -0x2c(%ebp)
    7817:	e8 08 bc ff ff       	call   3424 <lodepng_free>
    781c:	83 c4 10             	add    $0x10,%esp
  lodepng_free(frequencies_d);
    781f:	83 ec 0c             	sub    $0xc,%esp
    7822:	ff 75 d0             	pushl  -0x30(%ebp)
    7825:	e8 fa bb ff ff       	call   3424 <lodepng_free>
    782a:	83 c4 10             	add    $0x10,%esp
  lodepng_free(frequencies_cl);
    782d:	83 ec 0c             	sub    $0xc,%esp
    7830:	ff 75 cc             	pushl  -0x34(%ebp)
    7833:	e8 ec bb ff ff       	call   3424 <lodepng_free>
    7838:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_lld);
    783b:	83 ec 0c             	sub    $0xc,%esp
    783e:	ff 75 f0             	pushl  -0x10(%ebp)
    7841:	e8 de bb ff ff       	call   3424 <lodepng_free>
    7846:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_lld_e);
    7849:	83 ec 0c             	sub    $0xc,%esp
    784c:	ff 75 ec             	pushl  -0x14(%ebp)
    784f:	e8 d0 bb ff ff       	call   3424 <lodepng_free>
    7854:	83 c4 10             	add    $0x10,%esp

  return error;
    7857:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    785a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    785d:	c9                   	leave  
    785e:	c3                   	ret    

0000785f <deflateFixed>:

static unsigned deflateFixed(LodePNGBitWriter* writer, Hash* hash,
                             const unsigned char* data,
                             size_t datapos, size_t dataend,
                             const LodePNGCompressSettings* settings, unsigned final) {
    785f:	55                   	push   %ebp
    7860:	89 e5                	mov    %esp,%ebp
    7862:	53                   	push   %ebx
    7863:	83 ec 54             	sub    $0x54,%esp
  HuffmanTree tree_ll; /*tree for literal values and length codes*/
  HuffmanTree tree_d; /*tree for distance codes*/

  unsigned BFINAL = final;
    7866:	8b 45 20             	mov    0x20(%ebp),%eax
    7869:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned error = 0;
    786c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  size_t i;

  HuffmanTree_init(&tree_ll);
    7873:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    7876:	50                   	push   %eax
    7877:	e8 7b ca ff ff       	call   42f7 <HuffmanTree_init>
    787c:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_d);
    787f:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7882:	50                   	push   %eax
    7883:	e8 6f ca ff ff       	call   42f7 <HuffmanTree_init>
    7888:	83 c4 04             	add    $0x4,%esp

  error = generateFixedLitLenTree(&tree_ll);
    788b:	83 ec 0c             	sub    $0xc,%esp
    788e:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    7891:	50                   	push   %eax
    7892:	e8 41 db ff ff       	call   53d8 <generateFixedLitLenTree>
    7897:	83 c4 10             	add    $0x10,%esp
    789a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = generateFixedDistanceTree(&tree_d);
    789d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    78a1:	75 12                	jne    78b5 <deflateFixed+0x56>
    78a3:	83 ec 0c             	sub    $0xc,%esp
    78a6:	8d 45 bc             	lea    -0x44(%ebp),%eax
    78a9:	50                   	push   %eax
    78aa:	e8 30 dc ff ff       	call   54df <generateFixedDistanceTree>
    78af:	83 c4 10             	add    $0x10,%esp
    78b2:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(!error) {
    78b5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    78b9:	0f 85 3a 01 00 00    	jne    79f9 <deflateFixed+0x19a>
    writeBits(writer, BFINAL, 1);
    78bf:	83 ec 04             	sub    $0x4,%esp
    78c2:	6a 01                	push   $0x1
    78c4:	ff 75 ec             	pushl  -0x14(%ebp)
    78c7:	ff 75 08             	pushl  0x8(%ebp)
    78ca:	e8 1c c0 ff ff       	call   38eb <writeBits>
    78cf:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 1, 1); /*first bit of BTYPE*/
    78d2:	83 ec 04             	sub    $0x4,%esp
    78d5:	6a 01                	push   $0x1
    78d7:	6a 01                	push   $0x1
    78d9:	ff 75 08             	pushl  0x8(%ebp)
    78dc:	e8 0a c0 ff ff       	call   38eb <writeBits>
    78e1:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 0, 1); /*second bit of BTYPE*/
    78e4:	83 ec 04             	sub    $0x4,%esp
    78e7:	6a 01                	push   $0x1
    78e9:	6a 00                	push   $0x0
    78eb:	ff 75 08             	pushl  0x8(%ebp)
    78ee:	e8 f8 bf ff ff       	call   38eb <writeBits>
    78f3:	83 c4 10             	add    $0x10,%esp

    if(settings->use_lz77) /*LZ77 encoded*/ {
    78f6:	8b 45 1c             	mov    0x1c(%ebp),%eax
    78f9:	8b 40 04             	mov    0x4(%eax),%eax
    78fc:	85 c0                	test   %eax,%eax
    78fe:	74 77                	je     7977 <deflateFixed+0x118>
      uivector lz77_encoded;
      uivector_init(&lz77_encoded);
    7900:	83 ec 0c             	sub    $0xc,%esp
    7903:	8d 45 b0             	lea    -0x50(%ebp),%eax
    7906:	50                   	push   %eax
    7907:	e8 e8 bc ff ff       	call   35f4 <uivector_init>
    790c:	83 c4 10             	add    $0x10,%esp
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
    790f:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7912:	8b 58 14             	mov    0x14(%eax),%ebx
    7915:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7918:	8b 48 10             	mov    0x10(%eax),%ecx
    791b:	8b 45 1c             	mov    0x1c(%ebp),%eax
    791e:	8b 50 0c             	mov    0xc(%eax),%edx
    7921:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7924:	8b 40 08             	mov    0x8(%eax),%eax
    7927:	83 ec 0c             	sub    $0xc,%esp
    792a:	53                   	push   %ebx
    792b:	51                   	push   %ecx
    792c:	52                   	push   %edx
    792d:	50                   	push   %eax
    792e:	ff 75 18             	pushl  0x18(%ebp)
    7931:	ff 75 14             	pushl  0x14(%ebp)
    7934:	ff 75 10             	pushl  0x10(%ebp)
    7937:	ff 75 0c             	pushl  0xc(%ebp)
    793a:	8d 45 b0             	lea    -0x50(%ebp),%eax
    793d:	50                   	push   %eax
    793e:	e8 c7 ed ff ff       	call   670a <encodeLZ77>
    7943:	83 c4 30             	add    $0x30,%esp
    7946:	89 45 f4             	mov    %eax,-0xc(%ebp)
                         settings->minmatch, settings->nicematch, settings->lazymatching);
      if(!error) writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);
    7949:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    794d:	75 17                	jne    7966 <deflateFixed+0x107>
    794f:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7952:	50                   	push   %eax
    7953:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    7956:	50                   	push   %eax
    7957:	8d 45 b0             	lea    -0x50(%ebp),%eax
    795a:	50                   	push   %eax
    795b:	ff 75 08             	pushl  0x8(%ebp)
    795e:	e8 66 f4 ff ff       	call   6dc9 <writeLZ77data>
    7963:	83 c4 10             	add    $0x10,%esp
      uivector_cleanup(&lz77_encoded);
    7966:	83 ec 0c             	sub    $0xc,%esp
    7969:	8d 45 b0             	lea    -0x50(%ebp),%eax
    796c:	50                   	push   %eax
    796d:	e8 d9 bb ff ff       	call   354b <uivector_cleanup>
    7972:	83 c4 10             	add    $0x10,%esp
    7975:	eb 56                	jmp    79cd <deflateFixed+0x16e>
    } else /*no LZ77, but still will be Huffman compressed*/ {
      for(i = datapos; i < dataend; ++i) {
    7977:	8b 45 14             	mov    0x14(%ebp),%eax
    797a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    797d:	eb 46                	jmp    79c5 <deflateFixed+0x166>
        writeBitsReversed(writer, tree_ll.codes[data[i]], tree_ll.lengths[data[i]]);
    797f:	8b 45 d8             	mov    -0x28(%ebp),%eax
    7982:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    7985:	8b 55 10             	mov    0x10(%ebp),%edx
    7988:	01 ca                	add    %ecx,%edx
    798a:	0f b6 12             	movzbl (%edx),%edx
    798d:	0f b6 d2             	movzbl %dl,%edx
    7990:	c1 e2 02             	shl    $0x2,%edx
    7993:	01 d0                	add    %edx,%eax
    7995:	8b 00                	mov    (%eax),%eax
    7997:	89 c3                	mov    %eax,%ebx
    7999:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    799c:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    799f:	8b 55 10             	mov    0x10(%ebp),%edx
    79a2:	01 ca                	add    %ecx,%edx
    79a4:	0f b6 12             	movzbl (%edx),%edx
    79a7:	0f b6 d2             	movzbl %dl,%edx
    79aa:	c1 e2 02             	shl    $0x2,%edx
    79ad:	01 d0                	add    %edx,%eax
    79af:	8b 00                	mov    (%eax),%eax
    79b1:	83 ec 04             	sub    $0x4,%esp
    79b4:	53                   	push   %ebx
    79b5:	50                   	push   %eax
    79b6:	ff 75 08             	pushl  0x8(%ebp)
    79b9:	e8 c1 c0 ff ff       	call   3a7f <writeBitsReversed>
    79be:	83 c4 10             	add    $0x10,%esp
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
                         settings->minmatch, settings->nicematch, settings->lazymatching);
      if(!error) writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);
      uivector_cleanup(&lz77_encoded);
    } else /*no LZ77, but still will be Huffman compressed*/ {
      for(i = datapos; i < dataend; ++i) {
    79c1:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    79c5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    79c8:	3b 45 18             	cmp    0x18(%ebp),%eax
    79cb:	7c b2                	jl     797f <deflateFixed+0x120>
        writeBitsReversed(writer, tree_ll.codes[data[i]], tree_ll.lengths[data[i]]);
      }
    }
    /*add END code*/
    if(!error) writeBitsReversed(writer,tree_ll.codes[256], tree_ll.lengths[256]);
    79cd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    79d1:	75 26                	jne    79f9 <deflateFixed+0x19a>
    79d3:	8b 45 d8             	mov    -0x28(%ebp),%eax
    79d6:	05 00 04 00 00       	add    $0x400,%eax
    79db:	8b 00                	mov    (%eax),%eax
    79dd:	89 c2                	mov    %eax,%edx
    79df:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    79e2:	05 00 04 00 00       	add    $0x400,%eax
    79e7:	8b 00                	mov    (%eax),%eax
    79e9:	83 ec 04             	sub    $0x4,%esp
    79ec:	52                   	push   %edx
    79ed:	50                   	push   %eax
    79ee:	ff 75 08             	pushl  0x8(%ebp)
    79f1:	e8 89 c0 ff ff       	call   3a7f <writeBitsReversed>
    79f6:	83 c4 10             	add    $0x10,%esp
  }

  /*cleanup*/
  HuffmanTree_cleanup(&tree_ll);
    79f9:	83 ec 0c             	sub    $0xc,%esp
    79fc:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    79ff:	50                   	push   %eax
    7a00:	e8 1f c9 ff ff       	call   4324 <HuffmanTree_cleanup>
    7a05:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_d);
    7a08:	83 ec 0c             	sub    $0xc,%esp
    7a0b:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7a0e:	50                   	push   %eax
    7a0f:	e8 10 c9 ff ff       	call   4324 <HuffmanTree_cleanup>
    7a14:	83 c4 10             	add    $0x10,%esp

  return error;
    7a17:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7a1a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    7a1d:	c9                   	leave  
    7a1e:	c3                   	ret    

00007a1f <lodepng_deflatev>:

static unsigned lodepng_deflatev(ucvector* out, const unsigned char* in, size_t insize,
                                 const LodePNGCompressSettings* settings) {
    7a1f:	55                   	push   %ebp
    7a20:	89 e5                	mov    %esp,%ebp
    7a22:	83 ec 48             	sub    $0x48,%esp
  unsigned error = 0;
    7a25:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  size_t i, blocksize, numdeflateblocks;
  Hash hash;
  LodePNGBitWriter writer;

  LodePNGBitWriter_init(&writer, out);
    7a2c:	ff 75 08             	pushl  0x8(%ebp)
    7a2f:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7a32:	50                   	push   %eax
    7a33:	e8 9e be ff ff       	call   38d6 <LodePNGBitWriter_init>
    7a38:	83 c4 08             	add    $0x8,%esp

  if(settings->btype > 2) return 61;
    7a3b:	8b 45 14             	mov    0x14(%ebp),%eax
    7a3e:	8b 00                	mov    (%eax),%eax
    7a40:	83 f8 02             	cmp    $0x2,%eax
    7a43:	76 0a                	jbe    7a4f <lodepng_deflatev+0x30>
    7a45:	b8 3d 00 00 00       	mov    $0x3d,%eax
    7a4a:	e9 68 01 00 00       	jmp    7bb7 <lodepng_deflatev+0x198>
  else if(settings->btype == 0) return deflateNoCompression(out, in, insize);
    7a4f:	8b 45 14             	mov    0x14(%ebp),%eax
    7a52:	8b 00                	mov    (%eax),%eax
    7a54:	85 c0                	test   %eax,%eax
    7a56:	75 16                	jne    7a6e <lodepng_deflatev+0x4f>
    7a58:	ff 75 10             	pushl  0x10(%ebp)
    7a5b:	ff 75 0c             	pushl  0xc(%ebp)
    7a5e:	ff 75 08             	pushl  0x8(%ebp)
    7a61:	e8 01 f2 ff ff       	call   6c67 <deflateNoCompression>
    7a66:	83 c4 0c             	add    $0xc,%esp
    7a69:	e9 49 01 00 00       	jmp    7bb7 <lodepng_deflatev+0x198>
  else if(settings->btype == 1) blocksize = insize;
    7a6e:	8b 45 14             	mov    0x14(%ebp),%eax
    7a71:	8b 00                	mov    (%eax),%eax
    7a73:	83 f8 01             	cmp    $0x1,%eax
    7a76:	75 08                	jne    7a80 <lodepng_deflatev+0x61>
    7a78:	8b 45 10             	mov    0x10(%ebp),%eax
    7a7b:	89 45 ec             	mov    %eax,-0x14(%ebp)
    7a7e:	eb 2c                	jmp    7aac <lodepng_deflatev+0x8d>
  else /*if(settings->btype == 2)*/ {
    /*on PNGs, deflate blocks of 65-262k seem to give most dense encoding*/
    blocksize = insize / 8u + 8;
    7a80:	8b 45 10             	mov    0x10(%ebp),%eax
    7a83:	c1 e8 03             	shr    $0x3,%eax
    7a86:	83 c0 08             	add    $0x8,%eax
    7a89:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(blocksize < 65536) blocksize = 65536;
    7a8c:	81 7d ec ff ff 00 00 	cmpl   $0xffff,-0x14(%ebp)
    7a93:	7f 07                	jg     7a9c <lodepng_deflatev+0x7d>
    7a95:	c7 45 ec 00 00 01 00 	movl   $0x10000,-0x14(%ebp)
    if(blocksize > 262144) blocksize = 262144;
    7a9c:	81 7d ec 00 00 04 00 	cmpl   $0x40000,-0x14(%ebp)
    7aa3:	7e 07                	jle    7aac <lodepng_deflatev+0x8d>
    7aa5:	c7 45 ec 00 00 04 00 	movl   $0x40000,-0x14(%ebp)
  }

  numdeflateblocks = (insize + blocksize - 1) / blocksize;
    7aac:	8b 55 10             	mov    0x10(%ebp),%edx
    7aaf:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7ab2:	01 d0                	add    %edx,%eax
    7ab4:	83 e8 01             	sub    $0x1,%eax
    7ab7:	99                   	cltd   
    7ab8:	f7 7d ec             	idivl  -0x14(%ebp)
    7abb:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(numdeflateblocks == 0) numdeflateblocks = 1;
    7abe:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    7ac2:	75 07                	jne    7acb <lodepng_deflatev+0xac>
    7ac4:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)

  error = hash_init(&hash, settings->windowsize);
    7acb:	8b 45 14             	mov    0x14(%ebp),%eax
    7ace:	8b 40 08             	mov    0x8(%eax),%eax
    7ad1:	83 ec 08             	sub    $0x8,%esp
    7ad4:	50                   	push   %eax
    7ad5:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    7ad8:	50                   	push   %eax
    7ad9:	e8 1c e8 ff ff       	call   62fa <hash_init>
    7ade:	83 c4 10             	add    $0x10,%esp
    7ae1:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(!error) {
    7ae4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7ae8:	0f 85 b7 00 00 00    	jne    7ba5 <lodepng_deflatev+0x186>
    for(i = 0; i != numdeflateblocks && !error; ++i) {
    7aee:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    7af5:	e9 99 00 00 00       	jmp    7b93 <lodepng_deflatev+0x174>
      unsigned final = (i == numdeflateblocks - 1);
    7afa:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7afd:	83 e8 01             	sub    $0x1,%eax
    7b00:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    7b03:	0f 94 c0             	sete   %al
    7b06:	0f b6 c0             	movzbl %al,%eax
    7b09:	89 45 e0             	mov    %eax,-0x20(%ebp)
      size_t start = i * blocksize;
    7b0c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7b0f:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    7b13:	89 45 dc             	mov    %eax,-0x24(%ebp)
      size_t end = start + blocksize;
    7b16:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7b19:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7b1c:	01 d0                	add    %edx,%eax
    7b1e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      if(end > insize) end = insize;
    7b21:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7b24:	3b 45 10             	cmp    0x10(%ebp),%eax
    7b27:	7e 06                	jle    7b2f <lodepng_deflatev+0x110>
    7b29:	8b 45 10             	mov    0x10(%ebp),%eax
    7b2c:	89 45 e4             	mov    %eax,-0x1c(%ebp)

      if(settings->btype == 1) error = deflateFixed(&writer, &hash, in, start, end, settings, final);
    7b2f:	8b 45 14             	mov    0x14(%ebp),%eax
    7b32:	8b 00                	mov    (%eax),%eax
    7b34:	83 f8 01             	cmp    $0x1,%eax
    7b37:	75 27                	jne    7b60 <lodepng_deflatev+0x141>
    7b39:	83 ec 04             	sub    $0x4,%esp
    7b3c:	ff 75 e0             	pushl  -0x20(%ebp)
    7b3f:	ff 75 14             	pushl  0x14(%ebp)
    7b42:	ff 75 e4             	pushl  -0x1c(%ebp)
    7b45:	ff 75 dc             	pushl  -0x24(%ebp)
    7b48:	ff 75 0c             	pushl  0xc(%ebp)
    7b4b:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    7b4e:	50                   	push   %eax
    7b4f:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7b52:	50                   	push   %eax
    7b53:	e8 07 fd ff ff       	call   785f <deflateFixed>
    7b58:	83 c4 20             	add    $0x20,%esp
    7b5b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    7b5e:	eb 2f                	jmp    7b8f <lodepng_deflatev+0x170>
      else if(settings->btype == 2) error = deflateDynamic(&writer, &hash, in, start, end, settings, final);
    7b60:	8b 45 14             	mov    0x14(%ebp),%eax
    7b63:	8b 00                	mov    (%eax),%eax
    7b65:	83 f8 02             	cmp    $0x2,%eax
    7b68:	75 25                	jne    7b8f <lodepng_deflatev+0x170>
    7b6a:	83 ec 04             	sub    $0x4,%esp
    7b6d:	ff 75 e0             	pushl  -0x20(%ebp)
    7b70:	ff 75 14             	pushl  0x14(%ebp)
    7b73:	ff 75 e4             	pushl  -0x1c(%ebp)
    7b76:	ff 75 dc             	pushl  -0x24(%ebp)
    7b79:	ff 75 0c             	pushl  0xc(%ebp)
    7b7c:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    7b7f:	50                   	push   %eax
    7b80:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7b83:	50                   	push   %eax
    7b84:	e8 7b f3 ff ff       	call   6f04 <deflateDynamic>
    7b89:	83 c4 20             	add    $0x20,%esp
    7b8c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(numdeflateblocks == 0) numdeflateblocks = 1;

  error = hash_init(&hash, settings->windowsize);

  if(!error) {
    for(i = 0; i != numdeflateblocks && !error; ++i) {
    7b8f:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    7b93:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7b96:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    7b99:	74 0a                	je     7ba5 <lodepng_deflatev+0x186>
    7b9b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7b9f:	0f 84 55 ff ff ff    	je     7afa <lodepng_deflatev+0xdb>
      if(settings->btype == 1) error = deflateFixed(&writer, &hash, in, start, end, settings, final);
      else if(settings->btype == 2) error = deflateDynamic(&writer, &hash, in, start, end, settings, final);
    }
  }

  hash_cleanup(&hash);
    7ba5:	83 ec 0c             	sub    $0xc,%esp
    7ba8:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    7bab:	50                   	push   %eax
    7bac:	e8 08 e9 ff ff       	call   64b9 <hash_cleanup>
    7bb1:	83 c4 10             	add    $0x10,%esp

  return error;
    7bb4:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7bb7:	c9                   	leave  
    7bb8:	c3                   	ret    

00007bb9 <lodepng_deflate>:

unsigned lodepng_deflate(unsigned char** out, size_t* outsize,
                         const unsigned char* in, size_t insize,
                         const LodePNGCompressSettings* settings) {
    7bb9:	55                   	push   %ebp
    7bba:	89 e5                	mov    %esp,%ebp
    7bbc:	83 ec 18             	sub    $0x18,%esp
  ucvector v = ucvector_init(*out, *outsize);
    7bbf:	8b 45 0c             	mov    0xc(%ebp),%eax
    7bc2:	8b 08                	mov    (%eax),%ecx
    7bc4:	8b 45 08             	mov    0x8(%ebp),%eax
    7bc7:	8b 10                	mov    (%eax),%edx
    7bc9:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7bcc:	51                   	push   %ecx
    7bcd:	52                   	push   %edx
    7bce:	50                   	push   %eax
    7bcf:	e8 f0 ba ff ff       	call   36c4 <ucvector_init>
    7bd4:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_deflatev(&v, in, insize, settings);
    7bd7:	ff 75 18             	pushl  0x18(%ebp)
    7bda:	ff 75 14             	pushl  0x14(%ebp)
    7bdd:	ff 75 10             	pushl  0x10(%ebp)
    7be0:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7be3:	50                   	push   %eax
    7be4:	e8 36 fe ff ff       	call   7a1f <lodepng_deflatev>
    7be9:	83 c4 10             	add    $0x10,%esp
    7bec:	89 45 f4             	mov    %eax,-0xc(%ebp)
  *out = v.data;
    7bef:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7bf2:	8b 45 08             	mov    0x8(%ebp),%eax
    7bf5:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    7bf7:	8b 55 ec             	mov    -0x14(%ebp),%edx
    7bfa:	8b 45 0c             	mov    0xc(%ebp),%eax
    7bfd:	89 10                	mov    %edx,(%eax)
  return error;
    7bff:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7c02:	c9                   	leave  
    7c03:	c3                   	ret    

00007c04 <deflate>:

static unsigned deflate(unsigned char** out, size_t* outsize,
                        const unsigned char* in, size_t insize,
                        const LodePNGCompressSettings* settings) {
    7c04:	55                   	push   %ebp
    7c05:	89 e5                	mov    %esp,%ebp
    7c07:	83 ec 18             	sub    $0x18,%esp
  if(settings->custom_deflate) {
    7c0a:	8b 45 18             	mov    0x18(%ebp),%eax
    7c0d:	8b 40 1c             	mov    0x1c(%eax),%eax
    7c10:	85 c0                	test   %eax,%eax
    7c12:	74 34                	je     7c48 <deflate+0x44>
    unsigned error = settings->custom_deflate(out, outsize, in, insize, settings);
    7c14:	8b 45 18             	mov    0x18(%ebp),%eax
    7c17:	8b 40 1c             	mov    0x1c(%eax),%eax
    7c1a:	83 ec 0c             	sub    $0xc,%esp
    7c1d:	ff 75 18             	pushl  0x18(%ebp)
    7c20:	ff 75 14             	pushl  0x14(%ebp)
    7c23:	ff 75 10             	pushl  0x10(%ebp)
    7c26:	ff 75 0c             	pushl  0xc(%ebp)
    7c29:	ff 75 08             	pushl  0x8(%ebp)
    7c2c:	ff d0                	call   *%eax
    7c2e:	83 c4 20             	add    $0x20,%esp
    7c31:	89 45 f4             	mov    %eax,-0xc(%ebp)
    /*the custom deflate is allowed to have its own error codes, however, we translate it to code 111*/
    return error ? 111 : 0;
    7c34:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7c38:	74 07                	je     7c41 <deflate+0x3d>
    7c3a:	b8 6f 00 00 00       	mov    $0x6f,%eax
    7c3f:	eb 21                	jmp    7c62 <deflate+0x5e>
    7c41:	b8 00 00 00 00       	mov    $0x0,%eax
    7c46:	eb 1a                	jmp    7c62 <deflate+0x5e>
  } else {
    return lodepng_deflate(out, outsize, in, insize, settings);
    7c48:	83 ec 0c             	sub    $0xc,%esp
    7c4b:	ff 75 18             	pushl  0x18(%ebp)
    7c4e:	ff 75 14             	pushl  0x14(%ebp)
    7c51:	ff 75 10             	pushl  0x10(%ebp)
    7c54:	ff 75 0c             	pushl  0xc(%ebp)
    7c57:	ff 75 08             	pushl  0x8(%ebp)
    7c5a:	e8 5a ff ff ff       	call   7bb9 <lodepng_deflate>
    7c5f:	83 c4 20             	add    $0x20,%esp
  }
}
    7c62:	c9                   	leave  
    7c63:	c3                   	ret    

00007c64 <update_adler32>:

/* ////////////////////////////////////////////////////////////////////////// */
/* / Adler32                                                                / */
/* ////////////////////////////////////////////////////////////////////////// */

static unsigned update_adler32(unsigned adler, const unsigned char* data, unsigned len) {
    7c64:	55                   	push   %ebp
    7c65:	89 e5                	mov    %esp,%ebp
    7c67:	83 ec 10             	sub    $0x10,%esp
  unsigned s1 = adler & 0xffffu;
    7c6a:	8b 45 08             	mov    0x8(%ebp),%eax
    7c6d:	0f b7 c0             	movzwl %ax,%eax
    7c70:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned s2 = (adler >> 16u) & 0xffffu;
    7c73:	8b 45 08             	mov    0x8(%ebp),%eax
    7c76:	c1 e8 10             	shr    $0x10,%eax
    7c79:	89 45 f8             	mov    %eax,-0x8(%ebp)

  while(len != 0u) {
    7c7c:	e9 82 00 00 00       	jmp    7d03 <update_adler32+0x9f>
    unsigned i;
    /*at least 5552 sums can be done before the sums overflow, saving a lot of module divisions*/
    unsigned amount = len > 5552u ? 5552u : len;
    7c81:	b8 b0 15 00 00       	mov    $0x15b0,%eax
    7c86:	81 7d 10 b0 15 00 00 	cmpl   $0x15b0,0x10(%ebp)
    7c8d:	0f 46 45 10          	cmovbe 0x10(%ebp),%eax
    7c91:	89 45 f0             	mov    %eax,-0x10(%ebp)
    len -= amount;
    7c94:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7c97:	29 45 10             	sub    %eax,0x10(%ebp)
    for(i = 0; i != amount; ++i) {
    7c9a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    7ca1:	eb 1c                	jmp    7cbf <update_adler32+0x5b>
      s1 += (*data++);
    7ca3:	8b 45 0c             	mov    0xc(%ebp),%eax
    7ca6:	8d 50 01             	lea    0x1(%eax),%edx
    7ca9:	89 55 0c             	mov    %edx,0xc(%ebp)
    7cac:	0f b6 00             	movzbl (%eax),%eax
    7caf:	0f b6 c0             	movzbl %al,%eax
    7cb2:	01 45 fc             	add    %eax,-0x4(%ebp)
      s2 += s1;
    7cb5:	8b 45 fc             	mov    -0x4(%ebp),%eax
    7cb8:	01 45 f8             	add    %eax,-0x8(%ebp)
  while(len != 0u) {
    unsigned i;
    /*at least 5552 sums can be done before the sums overflow, saving a lot of module divisions*/
    unsigned amount = len > 5552u ? 5552u : len;
    len -= amount;
    for(i = 0; i != amount; ++i) {
    7cbb:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    7cbf:	8b 45 f4             	mov    -0xc(%ebp),%eax
    7cc2:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    7cc5:	75 dc                	jne    7ca3 <update_adler32+0x3f>
      s1 += (*data++);
      s2 += s1;
    }
    s1 %= 65521u;
    7cc7:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    7cca:	ba 71 80 07 80       	mov    $0x80078071,%edx
    7ccf:	89 c8                	mov    %ecx,%eax
    7cd1:	f7 e2                	mul    %edx
    7cd3:	89 d0                	mov    %edx,%eax
    7cd5:	c1 e8 0f             	shr    $0xf,%eax
    7cd8:	69 c0 f1 ff 00 00    	imul   $0xfff1,%eax,%eax
    7cde:	29 c1                	sub    %eax,%ecx
    7ce0:	89 c8                	mov    %ecx,%eax
    7ce2:	89 45 fc             	mov    %eax,-0x4(%ebp)
    s2 %= 65521u;
    7ce5:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    7ce8:	ba 71 80 07 80       	mov    $0x80078071,%edx
    7ced:	89 c8                	mov    %ecx,%eax
    7cef:	f7 e2                	mul    %edx
    7cf1:	89 d0                	mov    %edx,%eax
    7cf3:	c1 e8 0f             	shr    $0xf,%eax
    7cf6:	69 c0 f1 ff 00 00    	imul   $0xfff1,%eax,%eax
    7cfc:	29 c1                	sub    %eax,%ecx
    7cfe:	89 c8                	mov    %ecx,%eax
    7d00:	89 45 f8             	mov    %eax,-0x8(%ebp)

static unsigned update_adler32(unsigned adler, const unsigned char* data, unsigned len) {
  unsigned s1 = adler & 0xffffu;
  unsigned s2 = (adler >> 16u) & 0xffffu;

  while(len != 0u) {
    7d03:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    7d07:	0f 85 74 ff ff ff    	jne    7c81 <update_adler32+0x1d>
    }
    s1 %= 65521u;
    s2 %= 65521u;
  }

  return (s2 << 16u) | s1;
    7d0d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    7d10:	c1 e0 10             	shl    $0x10,%eax
    7d13:	0b 45 fc             	or     -0x4(%ebp),%eax
}
    7d16:	c9                   	leave  
    7d17:	c3                   	ret    

00007d18 <adler32>:

/*Return the adler32 of the bytes data[0..len-1]*/
static unsigned adler32(const unsigned char* data, unsigned len) {
    7d18:	55                   	push   %ebp
    7d19:	89 e5                	mov    %esp,%ebp
  return update_adler32(1u, data, len);
    7d1b:	ff 75 0c             	pushl  0xc(%ebp)
    7d1e:	ff 75 08             	pushl  0x8(%ebp)
    7d21:	6a 01                	push   $0x1
    7d23:	e8 3c ff ff ff       	call   7c64 <update_adler32>
    7d28:	83 c4 0c             	add    $0xc,%esp
}
    7d2b:	c9                   	leave  
    7d2c:	c3                   	ret    

00007d2d <lodepng_zlib_decompressv>:

#ifdef LODEPNG_COMPILE_DECODER

static unsigned lodepng_zlib_decompressv(ucvector* out,
                                         const unsigned char* in, size_t insize,
                                         const LodePNGDecompressSettings* settings) {
    7d2d:	55                   	push   %ebp
    7d2e:	89 e5                	mov    %esp,%ebp
    7d30:	83 ec 28             	sub    $0x28,%esp
  unsigned error = 0;
    7d33:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned CM, CINFO, FDICT;

  if(insize < 2) return 53; /*error, size of zlib data too small*/
    7d3a:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    7d3e:	7f 0a                	jg     7d4a <lodepng_zlib_decompressv+0x1d>
    7d40:	b8 35 00 00 00       	mov    $0x35,%eax
    7d45:	e9 27 01 00 00       	jmp    7e71 <lodepng_zlib_decompressv+0x144>
  /*read information from zlib header*/
  if((in[0] * 256 + in[1]) % 31 != 0) {
    7d4a:	8b 45 0c             	mov    0xc(%ebp),%eax
    7d4d:	0f b6 00             	movzbl (%eax),%eax
    7d50:	0f b6 c0             	movzbl %al,%eax
    7d53:	c1 e0 08             	shl    $0x8,%eax
    7d56:	89 c2                	mov    %eax,%edx
    7d58:	8b 45 0c             	mov    0xc(%ebp),%eax
    7d5b:	83 c0 01             	add    $0x1,%eax
    7d5e:	0f b6 00             	movzbl (%eax),%eax
    7d61:	0f b6 c0             	movzbl %al,%eax
    7d64:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    7d67:	ba 43 08 21 84       	mov    $0x84210843,%edx
    7d6c:	89 c8                	mov    %ecx,%eax
    7d6e:	f7 ea                	imul   %edx
    7d70:	8d 04 0a             	lea    (%edx,%ecx,1),%eax
    7d73:	c1 f8 04             	sar    $0x4,%eax
    7d76:	89 c2                	mov    %eax,%edx
    7d78:	89 c8                	mov    %ecx,%eax
    7d7a:	c1 f8 1f             	sar    $0x1f,%eax
    7d7d:	29 c2                	sub    %eax,%edx
    7d7f:	89 d0                	mov    %edx,%eax
    7d81:	89 c2                	mov    %eax,%edx
    7d83:	c1 e2 05             	shl    $0x5,%edx
    7d86:	29 c2                	sub    %eax,%edx
    7d88:	89 c8                	mov    %ecx,%eax
    7d8a:	29 d0                	sub    %edx,%eax
    7d8c:	85 c0                	test   %eax,%eax
    7d8e:	74 0a                	je     7d9a <lodepng_zlib_decompressv+0x6d>
    /*error: 256 * in[0] + in[1] must be a multiple of 31, the FCHECK value is supposed to be made that way*/
    return 24;
    7d90:	b8 18 00 00 00       	mov    $0x18,%eax
    7d95:	e9 d7 00 00 00       	jmp    7e71 <lodepng_zlib_decompressv+0x144>
  }

  CM = in[0] & 15;
    7d9a:	8b 45 0c             	mov    0xc(%ebp),%eax
    7d9d:	0f b6 00             	movzbl (%eax),%eax
    7da0:	0f b6 c0             	movzbl %al,%eax
    7da3:	83 e0 0f             	and    $0xf,%eax
    7da6:	89 45 f0             	mov    %eax,-0x10(%ebp)
  CINFO = (in[0] >> 4) & 15;
    7da9:	8b 45 0c             	mov    0xc(%ebp),%eax
    7dac:	0f b6 00             	movzbl (%eax),%eax
    7daf:	c0 e8 04             	shr    $0x4,%al
    7db2:	0f b6 c0             	movzbl %al,%eax
    7db5:	83 e0 0f             	and    $0xf,%eax
    7db8:	89 45 ec             	mov    %eax,-0x14(%ebp)
  /*FCHECK = in[1] & 31;*/ /*FCHECK is already tested above*/
  FDICT = (in[1] >> 5) & 1;
    7dbb:	8b 45 0c             	mov    0xc(%ebp),%eax
    7dbe:	83 c0 01             	add    $0x1,%eax
    7dc1:	0f b6 00             	movzbl (%eax),%eax
    7dc4:	c0 e8 05             	shr    $0x5,%al
    7dc7:	0f b6 c0             	movzbl %al,%eax
    7dca:	83 e0 01             	and    $0x1,%eax
    7dcd:	89 45 e8             	mov    %eax,-0x18(%ebp)
  /*FLEVEL = (in[1] >> 6) & 3;*/ /*FLEVEL is not used here*/

  if(CM != 8 || CINFO > 7) {
    7dd0:	83 7d f0 08          	cmpl   $0x8,-0x10(%ebp)
    7dd4:	75 06                	jne    7ddc <lodepng_zlib_decompressv+0xaf>
    7dd6:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
    7dda:	76 0a                	jbe    7de6 <lodepng_zlib_decompressv+0xb9>
    /*error: only compression method 8: inflate with sliding window of 32k is supported by the PNG spec*/
    return 25;
    7ddc:	b8 19 00 00 00       	mov    $0x19,%eax
    7de1:	e9 8b 00 00 00       	jmp    7e71 <lodepng_zlib_decompressv+0x144>
  }
  if(FDICT != 0) {
    7de6:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    7dea:	74 07                	je     7df3 <lodepng_zlib_decompressv+0xc6>
    /*error: the specification of PNG says about the zlib stream:
      "The additional flags shall not specify a preset dictionary."*/
    return 26;
    7dec:	b8 1a 00 00 00       	mov    $0x1a,%eax
    7df1:	eb 7e                	jmp    7e71 <lodepng_zlib_decompressv+0x144>
  }

  error = inflatev(out, in + 2, insize - 2, settings);
    7df3:	8b 45 10             	mov    0x10(%ebp),%eax
    7df6:	8d 50 fe             	lea    -0x2(%eax),%edx
    7df9:	8b 45 0c             	mov    0xc(%ebp),%eax
    7dfc:	83 c0 02             	add    $0x2,%eax
    7dff:	ff 75 14             	pushl  0x14(%ebp)
    7e02:	52                   	push   %edx
    7e03:	50                   	push   %eax
    7e04:	ff 75 08             	pushl  0x8(%ebp)
    7e07:	e8 09 e3 ff ff       	call   6115 <inflatev>
    7e0c:	83 c4 10             	add    $0x10,%esp
    7e0f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(error) return error;
    7e12:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7e16:	74 05                	je     7e1d <lodepng_zlib_decompressv+0xf0>
    7e18:	8b 45 f4             	mov    -0xc(%ebp),%eax
    7e1b:	eb 54                	jmp    7e71 <lodepng_zlib_decompressv+0x144>

  if(!settings->ignore_adler32) {
    7e1d:	8b 45 14             	mov    0x14(%ebp),%eax
    7e20:	8b 00                	mov    (%eax),%eax
    7e22:	85 c0                	test   %eax,%eax
    7e24:	75 46                	jne    7e6c <lodepng_zlib_decompressv+0x13f>
    unsigned ADLER32 = lodepng_read32bitInt(&in[insize - 4]);
    7e26:	8b 45 10             	mov    0x10(%ebp),%eax
    7e29:	8d 50 fc             	lea    -0x4(%eax),%edx
    7e2c:	8b 45 0c             	mov    0xc(%ebp),%eax
    7e2f:	01 d0                	add    %edx,%eax
    7e31:	83 ec 0c             	sub    $0xc,%esp
    7e34:	50                   	push   %eax
    7e35:	e8 47 b9 ff ff       	call   3781 <lodepng_read32bitInt>
    7e3a:	83 c4 10             	add    $0x10,%esp
    7e3d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    unsigned checksum = adler32(out->data, (unsigned)(out->size));
    7e40:	8b 45 08             	mov    0x8(%ebp),%eax
    7e43:	8b 40 04             	mov    0x4(%eax),%eax
    7e46:	89 c2                	mov    %eax,%edx
    7e48:	8b 45 08             	mov    0x8(%ebp),%eax
    7e4b:	8b 00                	mov    (%eax),%eax
    7e4d:	83 ec 08             	sub    $0x8,%esp
    7e50:	52                   	push   %edx
    7e51:	50                   	push   %eax
    7e52:	e8 c1 fe ff ff       	call   7d18 <adler32>
    7e57:	83 c4 10             	add    $0x10,%esp
    7e5a:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(checksum != ADLER32) return 58; /*error, adler checksum not correct, data must be corrupted*/
    7e5d:	8b 45 e0             	mov    -0x20(%ebp),%eax
    7e60:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    7e63:	74 07                	je     7e6c <lodepng_zlib_decompressv+0x13f>
    7e65:	b8 3a 00 00 00       	mov    $0x3a,%eax
    7e6a:	eb 05                	jmp    7e71 <lodepng_zlib_decompressv+0x144>
  }

  return 0; /*no error*/
    7e6c:	b8 00 00 00 00       	mov    $0x0,%eax
}
    7e71:	c9                   	leave  
    7e72:	c3                   	ret    

00007e73 <lodepng_zlib_decompress>:


unsigned lodepng_zlib_decompress(unsigned char** out, size_t* outsize, const unsigned char* in,
                                 size_t insize, const LodePNGDecompressSettings* settings) {
    7e73:	55                   	push   %ebp
    7e74:	89 e5                	mov    %esp,%ebp
    7e76:	83 ec 18             	sub    $0x18,%esp
  ucvector v = ucvector_init(*out, *outsize);
    7e79:	8b 45 0c             	mov    0xc(%ebp),%eax
    7e7c:	8b 08                	mov    (%eax),%ecx
    7e7e:	8b 45 08             	mov    0x8(%ebp),%eax
    7e81:	8b 10                	mov    (%eax),%edx
    7e83:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7e86:	51                   	push   %ecx
    7e87:	52                   	push   %edx
    7e88:	50                   	push   %eax
    7e89:	e8 36 b8 ff ff       	call   36c4 <ucvector_init>
    7e8e:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_zlib_decompressv(&v, in, insize, settings);
    7e91:	ff 75 18             	pushl  0x18(%ebp)
    7e94:	ff 75 14             	pushl  0x14(%ebp)
    7e97:	ff 75 10             	pushl  0x10(%ebp)
    7e9a:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7e9d:	50                   	push   %eax
    7e9e:	e8 8a fe ff ff       	call   7d2d <lodepng_zlib_decompressv>
    7ea3:	83 c4 10             	add    $0x10,%esp
    7ea6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  *out = v.data;
    7ea9:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7eac:	8b 45 08             	mov    0x8(%ebp),%eax
    7eaf:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    7eb1:	8b 55 ec             	mov    -0x14(%ebp),%edx
    7eb4:	8b 45 0c             	mov    0xc(%ebp),%eax
    7eb7:	89 10                	mov    %edx,(%eax)
  return error;
    7eb9:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7ebc:	c9                   	leave  
    7ebd:	c3                   	ret    

00007ebe <zlib_decompress>:

/*expected_size is expected output size, to avoid intermediate allocations. Set to 0 if not known. */
static unsigned zlib_decompress(unsigned char** out, size_t* outsize, size_t expected_size,
                                const unsigned char* in, size_t insize, const LodePNGDecompressSettings* settings) {
    7ebe:	55                   	push   %ebp
    7ebf:	89 e5                	mov    %esp,%ebp
    7ec1:	83 ec 18             	sub    $0x18,%esp
  unsigned error;
  if(settings->custom_zlib) {
    7ec4:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7ec7:	8b 40 0c             	mov    0xc(%eax),%eax
    7eca:	85 c0                	test   %eax,%eax
    7ecc:	74 57                	je     7f25 <zlib_decompress+0x67>
    error = settings->custom_zlib(out, outsize, in, insize, settings);
    7ece:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7ed1:	8b 40 0c             	mov    0xc(%eax),%eax
    7ed4:	83 ec 0c             	sub    $0xc,%esp
    7ed7:	ff 75 1c             	pushl  0x1c(%ebp)
    7eda:	ff 75 18             	pushl  0x18(%ebp)
    7edd:	ff 75 14             	pushl  0x14(%ebp)
    7ee0:	ff 75 0c             	pushl  0xc(%ebp)
    7ee3:	ff 75 08             	pushl  0x8(%ebp)
    7ee6:	ff d0                	call   *%eax
    7ee8:	83 c4 20             	add    $0x20,%esp
    7eeb:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) {
    7eee:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7ef2:	0f 84 98 00 00 00    	je     7f90 <zlib_decompress+0xd2>
      /*the custom zlib is allowed to have its own error codes, however, we translate it to code 110*/
      error = 110;
    7ef8:	c7 45 f4 6e 00 00 00 	movl   $0x6e,-0xc(%ebp)
      /*if there's a max output size, and the custom zlib returned error, then indicate that error instead*/
      if(settings->max_output_size && *outsize > settings->max_output_size) error = 109;
    7eff:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7f02:	8b 40 08             	mov    0x8(%eax),%eax
    7f05:	85 c0                	test   %eax,%eax
    7f07:	0f 84 83 00 00 00    	je     7f90 <zlib_decompress+0xd2>
    7f0d:	8b 45 0c             	mov    0xc(%ebp),%eax
    7f10:	8b 10                	mov    (%eax),%edx
    7f12:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7f15:	8b 40 08             	mov    0x8(%eax),%eax
    7f18:	39 c2                	cmp    %eax,%edx
    7f1a:	7e 74                	jle    7f90 <zlib_decompress+0xd2>
    7f1c:	c7 45 f4 6d 00 00 00 	movl   $0x6d,-0xc(%ebp)
    7f23:	eb 6b                	jmp    7f90 <zlib_decompress+0xd2>
    }
  } else {
    ucvector v = ucvector_init(*out, *outsize);
    7f25:	8b 45 0c             	mov    0xc(%ebp),%eax
    7f28:	8b 08                	mov    (%eax),%ecx
    7f2a:	8b 45 08             	mov    0x8(%ebp),%eax
    7f2d:	8b 10                	mov    (%eax),%edx
    7f2f:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7f32:	83 ec 04             	sub    $0x4,%esp
    7f35:	51                   	push   %ecx
    7f36:	52                   	push   %edx
    7f37:	50                   	push   %eax
    7f38:	e8 87 b7 ff ff       	call   36c4 <ucvector_init>
    7f3d:	83 c4 0c             	add    $0xc,%esp
    if(expected_size) {
    7f40:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    7f44:	74 22                	je     7f68 <zlib_decompress+0xaa>
      /*reserve the memory to avoid intermediate reallocations*/
      ucvector_resize(&v, *outsize + expected_size);
    7f46:	8b 45 0c             	mov    0xc(%ebp),%eax
    7f49:	8b 10                	mov    (%eax),%edx
    7f4b:	8b 45 10             	mov    0x10(%ebp),%eax
    7f4e:	01 d0                	add    %edx,%eax
    7f50:	83 ec 08             	sub    $0x8,%esp
    7f53:	50                   	push   %eax
    7f54:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7f57:	50                   	push   %eax
    7f58:	e8 00 b7 ff ff       	call   365d <ucvector_resize>
    7f5d:	83 c4 10             	add    $0x10,%esp
      v.size = *outsize;
    7f60:	8b 45 0c             	mov    0xc(%ebp),%eax
    7f63:	8b 00                	mov    (%eax),%eax
    7f65:	89 45 ec             	mov    %eax,-0x14(%ebp)
    }
    error = lodepng_zlib_decompressv(&v, in, insize, settings);
    7f68:	ff 75 1c             	pushl  0x1c(%ebp)
    7f6b:	ff 75 18             	pushl  0x18(%ebp)
    7f6e:	ff 75 14             	pushl  0x14(%ebp)
    7f71:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7f74:	50                   	push   %eax
    7f75:	e8 b3 fd ff ff       	call   7d2d <lodepng_zlib_decompressv>
    7f7a:	83 c4 10             	add    $0x10,%esp
    7f7d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    *out = v.data;
    7f80:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7f83:	8b 45 08             	mov    0x8(%ebp),%eax
    7f86:	89 10                	mov    %edx,(%eax)
    *outsize = v.size;
    7f88:	8b 55 ec             	mov    -0x14(%ebp),%edx
    7f8b:	8b 45 0c             	mov    0xc(%ebp),%eax
    7f8e:	89 10                	mov    %edx,(%eax)
  }
  return error;
    7f90:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7f93:	c9                   	leave  
    7f94:	c3                   	ret    

00007f95 <lodepng_zlib_compress>:
#endif /*LODEPNG_COMPILE_DECODER*/

#ifdef LODEPNG_COMPILE_ENCODER

unsigned lodepng_zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,
                               size_t insize, const LodePNGCompressSettings* settings) {
    7f95:	55                   	push   %ebp
    7f96:	89 e5                	mov    %esp,%ebp
    7f98:	83 ec 38             	sub    $0x38,%esp
  size_t i;
  unsigned error;
  unsigned char* deflatedata = 0;
    7f9b:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  size_t deflatesize = 0;
    7fa2:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)

  error = deflate(&deflatedata, &deflatesize, in, insize, settings);
    7fa9:	83 ec 0c             	sub    $0xc,%esp
    7fac:	ff 75 18             	pushl  0x18(%ebp)
    7faf:	ff 75 14             	pushl  0x14(%ebp)
    7fb2:	ff 75 10             	pushl  0x10(%ebp)
    7fb5:	8d 45 d0             	lea    -0x30(%ebp),%eax
    7fb8:	50                   	push   %eax
    7fb9:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    7fbc:	50                   	push   %eax
    7fbd:	e8 42 fc ff ff       	call   7c04 <deflate>
    7fc2:	83 c4 20             	add    $0x20,%esp
    7fc5:	89 45 f0             	mov    %eax,-0x10(%ebp)

  *out = NULL;
    7fc8:	8b 45 08             	mov    0x8(%ebp),%eax
    7fcb:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *outsize = 0;
    7fd1:	8b 45 0c             	mov    0xc(%ebp),%eax
    7fd4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  if(!error) {
    7fda:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    7fde:	75 33                	jne    8013 <lodepng_zlib_compress+0x7e>
    *outsize = deflatesize + 6;
    7fe0:	8b 45 d0             	mov    -0x30(%ebp),%eax
    7fe3:	8d 50 06             	lea    0x6(%eax),%edx
    7fe6:	8b 45 0c             	mov    0xc(%ebp),%eax
    7fe9:	89 10                	mov    %edx,(%eax)
    *out = (unsigned char*)lodepng_malloc(*outsize);
    7feb:	8b 45 0c             	mov    0xc(%ebp),%eax
    7fee:	8b 00                	mov    (%eax),%eax
    7ff0:	83 ec 0c             	sub    $0xc,%esp
    7ff3:	50                   	push   %eax
    7ff4:	e8 0a b4 ff ff       	call   3403 <lodepng_malloc>
    7ff9:	83 c4 10             	add    $0x10,%esp
    7ffc:	89 c2                	mov    %eax,%edx
    7ffe:	8b 45 08             	mov    0x8(%ebp),%eax
    8001:	89 10                	mov    %edx,(%eax)
    if(!*out) error = 83; /*alloc fail*/
    8003:	8b 45 08             	mov    0x8(%ebp),%eax
    8006:	8b 00                	mov    (%eax),%eax
    8008:	85 c0                	test   %eax,%eax
    800a:	75 07                	jne    8013 <lodepng_zlib_compress+0x7e>
    800c:	c7 45 f0 53 00 00 00 	movl   $0x53,-0x10(%ebp)
  }

  if(!error) {
    8013:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    8017:	0f 85 e2 00 00 00    	jne    80ff <lodepng_zlib_compress+0x16a>
    unsigned ADLER32 = adler32(in, (unsigned)insize);
    801d:	8b 45 14             	mov    0x14(%ebp),%eax
    8020:	83 ec 08             	sub    $0x8,%esp
    8023:	50                   	push   %eax
    8024:	ff 75 10             	pushl  0x10(%ebp)
    8027:	e8 ec fc ff ff       	call   7d18 <adler32>
    802c:	83 c4 10             	add    $0x10,%esp
    802f:	89 45 ec             	mov    %eax,-0x14(%ebp)
    /*zlib data: 1 byte CMF (CM+CINFO), 1 byte FLG, deflate data, 4 byte ADLER32 checksum of the Decompressed data*/
    unsigned CMF = 120; /*0b01111000: CM 8, CINFO 7. With CINFO 7, any window size up to 32768 can be used.*/
    8032:	c7 45 e8 78 00 00 00 	movl   $0x78,-0x18(%ebp)
    unsigned FLEVEL = 0;
    8039:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    unsigned FDICT = 0;
    8040:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    unsigned CMFFLG = 256 * CMF + FDICT * 32 + FLEVEL * 64;
    8047:	8b 45 e8             	mov    -0x18(%ebp),%eax
    804a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    8051:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    8054:	01 d0                	add    %edx,%eax
    8056:	8d 14 00             	lea    (%eax,%eax,1),%edx
    8059:	8b 45 e0             	mov    -0x20(%ebp),%eax
    805c:	01 d0                	add    %edx,%eax
    805e:	c1 e0 05             	shl    $0x5,%eax
    8061:	89 45 dc             	mov    %eax,-0x24(%ebp)
    unsigned FCHECK = 31 - CMFFLG % 31;
    8064:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    8067:	ba 85 10 42 08       	mov    $0x8421085,%edx
    806c:	89 c8                	mov    %ecx,%eax
    806e:	f7 e2                	mul    %edx
    8070:	89 c8                	mov    %ecx,%eax
    8072:	29 d0                	sub    %edx,%eax
    8074:	d1 e8                	shr    %eax
    8076:	01 d0                	add    %edx,%eax
    8078:	c1 e8 04             	shr    $0x4,%eax
    807b:	89 c2                	mov    %eax,%edx
    807d:	c1 e2 05             	shl    $0x5,%edx
    8080:	29 c2                	sub    %eax,%edx
    8082:	89 c8                	mov    %ecx,%eax
    8084:	29 d0                	sub    %edx,%eax
    8086:	ba 1f 00 00 00       	mov    $0x1f,%edx
    808b:	29 c2                	sub    %eax,%edx
    808d:	89 d0                	mov    %edx,%eax
    808f:	89 45 d8             	mov    %eax,-0x28(%ebp)
    CMFFLG += FCHECK;
    8092:	8b 45 d8             	mov    -0x28(%ebp),%eax
    8095:	01 45 dc             	add    %eax,-0x24(%ebp)

    (*out)[0] = (unsigned char)(CMFFLG >> 8);
    8098:	8b 45 08             	mov    0x8(%ebp),%eax
    809b:	8b 00                	mov    (%eax),%eax
    809d:	8b 55 dc             	mov    -0x24(%ebp),%edx
    80a0:	c1 ea 08             	shr    $0x8,%edx
    80a3:	88 10                	mov    %dl,(%eax)
    (*out)[1] = (unsigned char)(CMFFLG & 255);
    80a5:	8b 45 08             	mov    0x8(%ebp),%eax
    80a8:	8b 00                	mov    (%eax),%eax
    80aa:	83 c0 01             	add    $0x1,%eax
    80ad:	8b 55 dc             	mov    -0x24(%ebp),%edx
    80b0:	88 10                	mov    %dl,(%eax)
    for(i = 0; i != deflatesize; ++i) (*out)[i + 2] = deflatedata[i];
    80b2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    80b9:	eb 1e                	jmp    80d9 <lodepng_zlib_compress+0x144>
    80bb:	8b 45 08             	mov    0x8(%ebp),%eax
    80be:	8b 00                	mov    (%eax),%eax
    80c0:	8b 55 f4             	mov    -0xc(%ebp),%edx
    80c3:	83 c2 02             	add    $0x2,%edx
    80c6:	01 c2                	add    %eax,%edx
    80c8:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
    80cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    80ce:	01 c8                	add    %ecx,%eax
    80d0:	0f b6 00             	movzbl (%eax),%eax
    80d3:	88 02                	mov    %al,(%edx)
    80d5:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    80d9:	8b 45 d0             	mov    -0x30(%ebp),%eax
    80dc:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    80df:	75 da                	jne    80bb <lodepng_zlib_compress+0x126>
    lodepng_set32bitInt(&(*out)[*outsize - 4], ADLER32);
    80e1:	8b 45 08             	mov    0x8(%ebp),%eax
    80e4:	8b 10                	mov    (%eax),%edx
    80e6:	8b 45 0c             	mov    0xc(%ebp),%eax
    80e9:	8b 00                	mov    (%eax),%eax
    80eb:	83 e8 04             	sub    $0x4,%eax
    80ee:	01 d0                	add    %edx,%eax
    80f0:	83 ec 08             	sub    $0x8,%esp
    80f3:	ff 75 ec             	pushl  -0x14(%ebp)
    80f6:	50                   	push   %eax
    80f7:	e8 c8 b6 ff ff       	call   37c4 <lodepng_set32bitInt>
    80fc:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(deflatedata);
    80ff:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    8102:	83 ec 0c             	sub    $0xc,%esp
    8105:	50                   	push   %eax
    8106:	e8 19 b3 ff ff       	call   3424 <lodepng_free>
    810b:	83 c4 10             	add    $0x10,%esp
  return error;
    810e:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    8111:	c9                   	leave  
    8112:	c3                   	ret    

00008113 <zlib_compress>:

/* compress using the default or custom zlib function */
static unsigned zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,
                              size_t insize, const LodePNGCompressSettings* settings) {
    8113:	55                   	push   %ebp
    8114:	89 e5                	mov    %esp,%ebp
    8116:	83 ec 18             	sub    $0x18,%esp
  if(settings->custom_zlib) {
    8119:	8b 45 18             	mov    0x18(%ebp),%eax
    811c:	8b 40 18             	mov    0x18(%eax),%eax
    811f:	85 c0                	test   %eax,%eax
    8121:	74 34                	je     8157 <zlib_compress+0x44>
    unsigned error = settings->custom_zlib(out, outsize, in, insize, settings);
    8123:	8b 45 18             	mov    0x18(%ebp),%eax
    8126:	8b 40 18             	mov    0x18(%eax),%eax
    8129:	83 ec 0c             	sub    $0xc,%esp
    812c:	ff 75 18             	pushl  0x18(%ebp)
    812f:	ff 75 14             	pushl  0x14(%ebp)
    8132:	ff 75 10             	pushl  0x10(%ebp)
    8135:	ff 75 0c             	pushl  0xc(%ebp)
    8138:	ff 75 08             	pushl  0x8(%ebp)
    813b:	ff d0                	call   *%eax
    813d:	83 c4 20             	add    $0x20,%esp
    8140:	89 45 f4             	mov    %eax,-0xc(%ebp)
    /*the custom zlib is allowed to have its own error codes, however, we translate it to code 111*/
    return error ? 111 : 0;
    8143:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    8147:	74 07                	je     8150 <zlib_compress+0x3d>
    8149:	b8 6f 00 00 00       	mov    $0x6f,%eax
    814e:	eb 21                	jmp    8171 <zlib_compress+0x5e>
    8150:	b8 00 00 00 00       	mov    $0x0,%eax
    8155:	eb 1a                	jmp    8171 <zlib_compress+0x5e>
  } else {
    return lodepng_zlib_compress(out, outsize, in, insize, settings);
    8157:	83 ec 0c             	sub    $0xc,%esp
    815a:	ff 75 18             	pushl  0x18(%ebp)
    815d:	ff 75 14             	pushl  0x14(%ebp)
    8160:	ff 75 10             	pushl  0x10(%ebp)
    8163:	ff 75 0c             	pushl  0xc(%ebp)
    8166:	ff 75 08             	pushl  0x8(%ebp)
    8169:	e8 27 fe ff ff       	call   7f95 <lodepng_zlib_compress>
    816e:	83 c4 20             	add    $0x20,%esp
  }
}
    8171:	c9                   	leave  
    8172:	c3                   	ret    

00008173 <lodepng_compress_settings_init>:
#ifdef LODEPNG_COMPILE_ENCODER

/*this is a good tradeoff between speed and compression ratio*/
#define DEFAULT_WINDOWSIZE 2048

void lodepng_compress_settings_init(LodePNGCompressSettings* settings) {
    8173:	55                   	push   %ebp
    8174:	89 e5                	mov    %esp,%ebp
  /*compress with dynamic huffman tree (not in the mathematical sense, just not the predefined one)*/
  settings->btype = 2;
    8176:	8b 45 08             	mov    0x8(%ebp),%eax
    8179:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
  settings->use_lz77 = 1;
    817f:	8b 45 08             	mov    0x8(%ebp),%eax
    8182:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
  settings->windowsize = DEFAULT_WINDOWSIZE;
    8189:	8b 45 08             	mov    0x8(%ebp),%eax
    818c:	c7 40 08 00 08 00 00 	movl   $0x800,0x8(%eax)
  settings->minmatch = 3;
    8193:	8b 45 08             	mov    0x8(%ebp),%eax
    8196:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
  settings->nicematch = 128;
    819d:	8b 45 08             	mov    0x8(%ebp),%eax
    81a0:	c7 40 10 80 00 00 00 	movl   $0x80,0x10(%eax)
  settings->lazymatching = 1;
    81a7:	8b 45 08             	mov    0x8(%ebp),%eax
    81aa:	c7 40 14 01 00 00 00 	movl   $0x1,0x14(%eax)

  settings->custom_zlib = 0;
    81b1:	8b 45 08             	mov    0x8(%ebp),%eax
    81b4:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  settings->custom_deflate = 0;
    81bb:	8b 45 08             	mov    0x8(%ebp),%eax
    81be:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
  settings->custom_context = 0;
    81c5:	8b 45 08             	mov    0x8(%ebp),%eax
    81c8:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
}
    81cf:	90                   	nop
    81d0:	5d                   	pop    %ebp
    81d1:	c3                   	ret    

000081d2 <lodepng_decompress_settings_init>:

#endif /*LODEPNG_COMPILE_ENCODER*/

#ifdef LODEPNG_COMPILE_DECODER

void lodepng_decompress_settings_init(LodePNGDecompressSettings* settings) {
    81d2:	55                   	push   %ebp
    81d3:	89 e5                	mov    %esp,%ebp
  settings->ignore_adler32 = 0;
    81d5:	8b 45 08             	mov    0x8(%ebp),%eax
    81d8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  settings->ignore_nlen = 0;
    81de:	8b 45 08             	mov    0x8(%ebp),%eax
    81e1:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  settings->max_output_size = 0;
    81e8:	8b 45 08             	mov    0x8(%ebp),%eax
    81eb:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

  settings->custom_zlib = 0;
    81f2:	8b 45 08             	mov    0x8(%ebp),%eax
    81f5:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  settings->custom_inflate = 0;
    81fc:	8b 45 08             	mov    0x8(%ebp),%eax
    81ff:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  settings->custom_context = 0;
    8206:	8b 45 08             	mov    0x8(%ebp),%eax
    8209:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
}
    8210:	90                   	nop
    8211:	5d                   	pop    %ebp
    8212:	c3                   	ret    

00008213 <lodepng_crc32>:
  3183342108u, 3401237130u, 1404277552u,  615818150u, 3134207493u, 3453421203u, 1423857449u,  601450431u,
  3009837614u, 3294710456u, 1567103746u,  711928724u, 3020668471u, 3272380065u, 1510334235u,  755167117u
};

/*Return the CRC of the bytes buf[0..len-1].*/
unsigned lodepng_crc32(const unsigned char* data, size_t length) {
    8213:	55                   	push   %ebp
    8214:	89 e5                	mov    %esp,%ebp
    8216:	83 ec 10             	sub    $0x10,%esp
  unsigned r = 0xffffffffu;
    8219:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  size_t i;
  for(i = 0; i < length; ++i) {
    8220:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    8227:	eb 2a                	jmp    8253 <lodepng_crc32+0x40>
    r = lodepng_crc32_table[(r ^ data[i]) & 0xffu] ^ (r >> 8u);
    8229:	8b 55 f8             	mov    -0x8(%ebp),%edx
    822c:	8b 45 08             	mov    0x8(%ebp),%eax
    822f:	01 d0                	add    %edx,%eax
    8231:	0f b6 00             	movzbl (%eax),%eax
    8234:	0f b6 c0             	movzbl %al,%eax
    8237:	33 45 fc             	xor    -0x4(%ebp),%eax
    823a:	0f b6 c0             	movzbl %al,%eax
    823d:	8b 04 85 00 e2 01 00 	mov    0x1e200(,%eax,4),%eax
    8244:	8b 55 fc             	mov    -0x4(%ebp),%edx
    8247:	c1 ea 08             	shr    $0x8,%edx
    824a:	31 d0                	xor    %edx,%eax
    824c:	89 45 fc             	mov    %eax,-0x4(%ebp)

/*Return the CRC of the bytes buf[0..len-1].*/
unsigned lodepng_crc32(const unsigned char* data, size_t length) {
  unsigned r = 0xffffffffu;
  size_t i;
  for(i = 0; i < length; ++i) {
    824f:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    8253:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8256:	3b 45 0c             	cmp    0xc(%ebp),%eax
    8259:	7c ce                	jl     8229 <lodepng_crc32+0x16>
    r = lodepng_crc32_table[(r ^ data[i]) & 0xffu] ^ (r >> 8u);
  }
  return r ^ 0xffffffffu;
    825b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    825e:	f7 d0                	not    %eax
}
    8260:	c9                   	leave  
    8261:	c3                   	ret    

00008262 <readBitFromReversedStream>:
/* ////////////////////////////////////////////////////////////////////////// */

/* The color channel bits of less-than-8-bit pixels are read with the MSB of bytes first,
so LodePNGBitWriter and LodePNGBitReader can't be used for those. */

static unsigned char readBitFromReversedStream(size_t* bitpointer, const unsigned char* bitstream) {
    8262:	55                   	push   %ebp
    8263:	89 e5                	mov    %esp,%ebp
    8265:	83 ec 10             	sub    $0x10,%esp
  unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> (7 - ((*bitpointer) & 0x7))) & 1);
    8268:	8b 45 08             	mov    0x8(%ebp),%eax
    826b:	8b 00                	mov    (%eax),%eax
    826d:	c1 f8 03             	sar    $0x3,%eax
    8270:	89 c2                	mov    %eax,%edx
    8272:	8b 45 0c             	mov    0xc(%ebp),%eax
    8275:	01 d0                	add    %edx,%eax
    8277:	0f b6 00             	movzbl (%eax),%eax
    827a:	0f b6 d0             	movzbl %al,%edx
    827d:	8b 45 08             	mov    0x8(%ebp),%eax
    8280:	8b 00                	mov    (%eax),%eax
    8282:	f7 d0                	not    %eax
    8284:	83 e0 07             	and    $0x7,%eax
    8287:	89 c1                	mov    %eax,%ecx
    8289:	d3 fa                	sar    %cl,%edx
    828b:	89 d0                	mov    %edx,%eax
    828d:	83 e0 01             	and    $0x1,%eax
    8290:	88 45 ff             	mov    %al,-0x1(%ebp)
  ++(*bitpointer);
    8293:	8b 45 08             	mov    0x8(%ebp),%eax
    8296:	8b 00                	mov    (%eax),%eax
    8298:	8d 50 01             	lea    0x1(%eax),%edx
    829b:	8b 45 08             	mov    0x8(%ebp),%eax
    829e:	89 10                	mov    %edx,(%eax)
  return result;
    82a0:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
    82a4:	c9                   	leave  
    82a5:	c3                   	ret    

000082a6 <readBitsFromReversedStream>:

/* TODO: make this faster */
static unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits) {
    82a6:	55                   	push   %ebp
    82a7:	89 e5                	mov    %esp,%ebp
    82a9:	83 ec 10             	sub    $0x10,%esp
  unsigned result = 0;
    82ac:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  size_t i;
  for(i = 0 ; i < nbits; ++i) {
    82b3:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    82ba:	eb 1b                	jmp    82d7 <readBitsFromReversedStream+0x31>
    result <<= 1u;
    82bc:	d1 65 fc             	shll   -0x4(%ebp)
    result |= (unsigned)readBitFromReversedStream(bitpointer, bitstream);
    82bf:	ff 75 0c             	pushl  0xc(%ebp)
    82c2:	ff 75 08             	pushl  0x8(%ebp)
    82c5:	e8 98 ff ff ff       	call   8262 <readBitFromReversedStream>
    82ca:	83 c4 08             	add    $0x8,%esp
    82cd:	0f b6 c0             	movzbl %al,%eax
    82d0:	09 45 fc             	or     %eax,-0x4(%ebp)

/* TODO: make this faster */
static unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits) {
  unsigned result = 0;
  size_t i;
  for(i = 0 ; i < nbits; ++i) {
    82d3:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    82d7:	8b 45 f8             	mov    -0x8(%ebp),%eax
    82da:	3b 45 10             	cmp    0x10(%ebp),%eax
    82dd:	7c dd                	jl     82bc <readBitsFromReversedStream+0x16>
    result <<= 1u;
    result |= (unsigned)readBitFromReversedStream(bitpointer, bitstream);
  }
  return result;
    82df:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    82e2:	c9                   	leave  
    82e3:	c3                   	ret    

000082e4 <setBitOfReversedStream>:

static void setBitOfReversedStream(size_t* bitpointer, unsigned char* bitstream, unsigned char bit) {
    82e4:	55                   	push   %ebp
    82e5:	89 e5                	mov    %esp,%ebp
    82e7:	56                   	push   %esi
    82e8:	53                   	push   %ebx
    82e9:	83 ec 04             	sub    $0x4,%esp
    82ec:	8b 45 10             	mov    0x10(%ebp),%eax
    82ef:	88 45 f4             	mov    %al,-0xc(%ebp)
  /*the current bit in bitstream may be 0 or 1 for this to work*/
  if(bit == 0) bitstream[(*bitpointer) >> 3u] &=  (unsigned char)(~(1u << (7u - ((*bitpointer) & 7u))));
    82f2:	80 7d f4 00          	cmpb   $0x0,-0xc(%ebp)
    82f6:	75 3e                	jne    8336 <setBitOfReversedStream+0x52>
    82f8:	8b 45 08             	mov    0x8(%ebp),%eax
    82fb:	8b 00                	mov    (%eax),%eax
    82fd:	c1 f8 03             	sar    $0x3,%eax
    8300:	89 c2                	mov    %eax,%edx
    8302:	8b 45 0c             	mov    0xc(%ebp),%eax
    8305:	01 c2                	add    %eax,%edx
    8307:	8b 45 08             	mov    0x8(%ebp),%eax
    830a:	8b 00                	mov    (%eax),%eax
    830c:	c1 f8 03             	sar    $0x3,%eax
    830f:	89 c1                	mov    %eax,%ecx
    8311:	8b 45 0c             	mov    0xc(%ebp),%eax
    8314:	01 c8                	add    %ecx,%eax
    8316:	0f b6 18             	movzbl (%eax),%ebx
    8319:	8b 45 08             	mov    0x8(%ebp),%eax
    831c:	8b 00                	mov    (%eax),%eax
    831e:	f7 d0                	not    %eax
    8320:	83 e0 07             	and    $0x7,%eax
    8323:	be 01 00 00 00       	mov    $0x1,%esi
    8328:	89 c1                	mov    %eax,%ecx
    832a:	d3 e6                	shl    %cl,%esi
    832c:	89 f0                	mov    %esi,%eax
    832e:	f7 d0                	not    %eax
    8330:	21 d8                	and    %ebx,%eax
    8332:	88 02                	mov    %al,(%edx)
    8334:	eb 3a                	jmp    8370 <setBitOfReversedStream+0x8c>
  else         bitstream[(*bitpointer) >> 3u] |=  (1u << (7u - ((*bitpointer) & 7u)));
    8336:	8b 45 08             	mov    0x8(%ebp),%eax
    8339:	8b 00                	mov    (%eax),%eax
    833b:	c1 f8 03             	sar    $0x3,%eax
    833e:	89 c2                	mov    %eax,%edx
    8340:	8b 45 0c             	mov    0xc(%ebp),%eax
    8343:	01 c2                	add    %eax,%edx
    8345:	8b 45 08             	mov    0x8(%ebp),%eax
    8348:	8b 00                	mov    (%eax),%eax
    834a:	c1 f8 03             	sar    $0x3,%eax
    834d:	89 c1                	mov    %eax,%ecx
    834f:	8b 45 0c             	mov    0xc(%ebp),%eax
    8352:	01 c8                	add    %ecx,%eax
    8354:	0f b6 18             	movzbl (%eax),%ebx
    8357:	8b 45 08             	mov    0x8(%ebp),%eax
    835a:	8b 00                	mov    (%eax),%eax
    835c:	f7 d0                	not    %eax
    835e:	83 e0 07             	and    $0x7,%eax
    8361:	be 01 00 00 00       	mov    $0x1,%esi
    8366:	89 c1                	mov    %eax,%ecx
    8368:	d3 e6                	shl    %cl,%esi
    836a:	89 f0                	mov    %esi,%eax
    836c:	09 d8                	or     %ebx,%eax
    836e:	88 02                	mov    %al,(%edx)
  ++(*bitpointer);
    8370:	8b 45 08             	mov    0x8(%ebp),%eax
    8373:	8b 00                	mov    (%eax),%eax
    8375:	8d 50 01             	lea    0x1(%eax),%edx
    8378:	8b 45 08             	mov    0x8(%ebp),%eax
    837b:	89 10                	mov    %edx,(%eax)
}
    837d:	90                   	nop
    837e:	83 c4 04             	add    $0x4,%esp
    8381:	5b                   	pop    %ebx
    8382:	5e                   	pop    %esi
    8383:	5d                   	pop    %ebp
    8384:	c3                   	ret    

00008385 <lodepng_chunk_length>:

/* ////////////////////////////////////////////////////////////////////////// */
/* / PNG chunks                                                             / */
/* ////////////////////////////////////////////////////////////////////////// */

unsigned lodepng_chunk_length(const unsigned char* chunk) {
    8385:	55                   	push   %ebp
    8386:	89 e5                	mov    %esp,%ebp
  return lodepng_read32bitInt(&chunk[0]);
    8388:	ff 75 08             	pushl  0x8(%ebp)
    838b:	e8 f1 b3 ff ff       	call   3781 <lodepng_read32bitInt>
    8390:	83 c4 04             	add    $0x4,%esp
}
    8393:	c9                   	leave  
    8394:	c3                   	ret    

00008395 <lodepng_chunk_type>:

void lodepng_chunk_type(char type[5], const unsigned char* chunk) {
    8395:	55                   	push   %ebp
    8396:	89 e5                	mov    %esp,%ebp
    8398:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  for(i = 0; i != 4; ++i) type[i] = (char)chunk[4 + i];
    839b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    83a2:	eb 1c                	jmp    83c0 <lodepng_chunk_type+0x2b>
    83a4:	8b 55 08             	mov    0x8(%ebp),%edx
    83a7:	8b 45 fc             	mov    -0x4(%ebp),%eax
    83aa:	01 d0                	add    %edx,%eax
    83ac:	8b 55 fc             	mov    -0x4(%ebp),%edx
    83af:	8d 4a 04             	lea    0x4(%edx),%ecx
    83b2:	8b 55 0c             	mov    0xc(%ebp),%edx
    83b5:	01 ca                	add    %ecx,%edx
    83b7:	0f b6 12             	movzbl (%edx),%edx
    83ba:	88 10                	mov    %dl,(%eax)
    83bc:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    83c0:	83 7d fc 04          	cmpl   $0x4,-0x4(%ebp)
    83c4:	75 de                	jne    83a4 <lodepng_chunk_type+0xf>
  type[4] = 0; /*null termination char*/
    83c6:	8b 45 08             	mov    0x8(%ebp),%eax
    83c9:	83 c0 04             	add    $0x4,%eax
    83cc:	c6 00 00             	movb   $0x0,(%eax)
}
    83cf:	90                   	nop
    83d0:	c9                   	leave  
    83d1:	c3                   	ret    

000083d2 <lodepng_chunk_type_equals>:

unsigned char lodepng_chunk_type_equals(const unsigned char* chunk, const char* type) {
    83d2:	55                   	push   %ebp
    83d3:	89 e5                	mov    %esp,%ebp
  if(lodepng_strlen(type) != 4) return 0;
    83d5:	ff 75 0c             	pushl  0xc(%ebp)
    83d8:	e8 c2 b0 ff ff       	call   349f <lodepng_strlen>
    83dd:	83 c4 04             	add    $0x4,%esp
    83e0:	83 f8 04             	cmp    $0x4,%eax
    83e3:	74 07                	je     83ec <lodepng_chunk_type_equals+0x1a>
    83e5:	b8 00 00 00 00       	mov    $0x0,%eax
    83ea:	eb 79                	jmp    8465 <lodepng_chunk_type_equals+0x93>
  return (chunk[4] == type[0] && chunk[5] == type[1] && chunk[6] == type[2] && chunk[7] == type[3]);
    83ec:	8b 45 08             	mov    0x8(%ebp),%eax
    83ef:	83 c0 04             	add    $0x4,%eax
    83f2:	0f b6 00             	movzbl (%eax),%eax
    83f5:	0f b6 d0             	movzbl %al,%edx
    83f8:	8b 45 0c             	mov    0xc(%ebp),%eax
    83fb:	0f b6 00             	movzbl (%eax),%eax
    83fe:	0f be c0             	movsbl %al,%eax
    8401:	39 c2                	cmp    %eax,%edx
    8403:	75 5b                	jne    8460 <lodepng_chunk_type_equals+0x8e>
    8405:	8b 45 08             	mov    0x8(%ebp),%eax
    8408:	83 c0 05             	add    $0x5,%eax
    840b:	0f b6 00             	movzbl (%eax),%eax
    840e:	0f b6 d0             	movzbl %al,%edx
    8411:	8b 45 0c             	mov    0xc(%ebp),%eax
    8414:	83 c0 01             	add    $0x1,%eax
    8417:	0f b6 00             	movzbl (%eax),%eax
    841a:	0f be c0             	movsbl %al,%eax
    841d:	39 c2                	cmp    %eax,%edx
    841f:	75 3f                	jne    8460 <lodepng_chunk_type_equals+0x8e>
    8421:	8b 45 08             	mov    0x8(%ebp),%eax
    8424:	83 c0 06             	add    $0x6,%eax
    8427:	0f b6 00             	movzbl (%eax),%eax
    842a:	0f b6 d0             	movzbl %al,%edx
    842d:	8b 45 0c             	mov    0xc(%ebp),%eax
    8430:	83 c0 02             	add    $0x2,%eax
    8433:	0f b6 00             	movzbl (%eax),%eax
    8436:	0f be c0             	movsbl %al,%eax
    8439:	39 c2                	cmp    %eax,%edx
    843b:	75 23                	jne    8460 <lodepng_chunk_type_equals+0x8e>
    843d:	8b 45 08             	mov    0x8(%ebp),%eax
    8440:	83 c0 07             	add    $0x7,%eax
    8443:	0f b6 00             	movzbl (%eax),%eax
    8446:	0f b6 d0             	movzbl %al,%edx
    8449:	8b 45 0c             	mov    0xc(%ebp),%eax
    844c:	83 c0 03             	add    $0x3,%eax
    844f:	0f b6 00             	movzbl (%eax),%eax
    8452:	0f be c0             	movsbl %al,%eax
    8455:	39 c2                	cmp    %eax,%edx
    8457:	75 07                	jne    8460 <lodepng_chunk_type_equals+0x8e>
    8459:	b8 01 00 00 00       	mov    $0x1,%eax
    845e:	eb 05                	jmp    8465 <lodepng_chunk_type_equals+0x93>
    8460:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8465:	c9                   	leave  
    8466:	c3                   	ret    

00008467 <lodepng_chunk_ancillary>:

unsigned char lodepng_chunk_ancillary(const unsigned char* chunk) {
    8467:	55                   	push   %ebp
    8468:	89 e5                	mov    %esp,%ebp
  return((chunk[4] & 32) != 0);
    846a:	8b 45 08             	mov    0x8(%ebp),%eax
    846d:	83 c0 04             	add    $0x4,%eax
    8470:	0f b6 00             	movzbl (%eax),%eax
    8473:	0f b6 c0             	movzbl %al,%eax
    8476:	83 e0 20             	and    $0x20,%eax
    8479:	85 c0                	test   %eax,%eax
    847b:	0f 95 c0             	setne  %al
}
    847e:	5d                   	pop    %ebp
    847f:	c3                   	ret    

00008480 <lodepng_chunk_private>:

unsigned char lodepng_chunk_private(const unsigned char* chunk) {
    8480:	55                   	push   %ebp
    8481:	89 e5                	mov    %esp,%ebp
  return((chunk[6] & 32) != 0);
    8483:	8b 45 08             	mov    0x8(%ebp),%eax
    8486:	83 c0 06             	add    $0x6,%eax
    8489:	0f b6 00             	movzbl (%eax),%eax
    848c:	0f b6 c0             	movzbl %al,%eax
    848f:	83 e0 20             	and    $0x20,%eax
    8492:	85 c0                	test   %eax,%eax
    8494:	0f 95 c0             	setne  %al
}
    8497:	5d                   	pop    %ebp
    8498:	c3                   	ret    

00008499 <lodepng_chunk_safetocopy>:

unsigned char lodepng_chunk_safetocopy(const unsigned char* chunk) {
    8499:	55                   	push   %ebp
    849a:	89 e5                	mov    %esp,%ebp
  return((chunk[7] & 32) != 0);
    849c:	8b 45 08             	mov    0x8(%ebp),%eax
    849f:	83 c0 07             	add    $0x7,%eax
    84a2:	0f b6 00             	movzbl (%eax),%eax
    84a5:	0f b6 c0             	movzbl %al,%eax
    84a8:	83 e0 20             	and    $0x20,%eax
    84ab:	85 c0                	test   %eax,%eax
    84ad:	0f 95 c0             	setne  %al
}
    84b0:	5d                   	pop    %ebp
    84b1:	c3                   	ret    

000084b2 <lodepng_chunk_data>:

unsigned char* lodepng_chunk_data(unsigned char* chunk) {
    84b2:	55                   	push   %ebp
    84b3:	89 e5                	mov    %esp,%ebp
  return &chunk[8];
    84b5:	8b 45 08             	mov    0x8(%ebp),%eax
    84b8:	83 c0 08             	add    $0x8,%eax
}
    84bb:	5d                   	pop    %ebp
    84bc:	c3                   	ret    

000084bd <lodepng_chunk_data_const>:

const unsigned char* lodepng_chunk_data_const(const unsigned char* chunk) {
    84bd:	55                   	push   %ebp
    84be:	89 e5                	mov    %esp,%ebp
  return &chunk[8];
    84c0:	8b 45 08             	mov    0x8(%ebp),%eax
    84c3:	83 c0 08             	add    $0x8,%eax
}
    84c6:	5d                   	pop    %ebp
    84c7:	c3                   	ret    

000084c8 <lodepng_chunk_check_crc>:

unsigned lodepng_chunk_check_crc(const unsigned char* chunk) {
    84c8:	55                   	push   %ebp
    84c9:	89 e5                	mov    %esp,%ebp
    84cb:	83 ec 10             	sub    $0x10,%esp
  unsigned length = lodepng_chunk_length(chunk);
    84ce:	ff 75 08             	pushl  0x8(%ebp)
    84d1:	e8 af fe ff ff       	call   8385 <lodepng_chunk_length>
    84d6:	83 c4 04             	add    $0x4,%esp
    84d9:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned CRC = lodepng_read32bitInt(&chunk[length + 8]);
    84dc:	8b 45 fc             	mov    -0x4(%ebp),%eax
    84df:	8d 50 08             	lea    0x8(%eax),%edx
    84e2:	8b 45 08             	mov    0x8(%ebp),%eax
    84e5:	01 d0                	add    %edx,%eax
    84e7:	50                   	push   %eax
    84e8:	e8 94 b2 ff ff       	call   3781 <lodepng_read32bitInt>
    84ed:	83 c4 04             	add    $0x4,%esp
    84f0:	89 45 f8             	mov    %eax,-0x8(%ebp)
  /*the CRC is taken of the data and the 4 chunk type letters, not the length*/
  unsigned checksum = lodepng_crc32(&chunk[4], length + 4);
    84f3:	8b 45 fc             	mov    -0x4(%ebp),%eax
    84f6:	83 c0 04             	add    $0x4,%eax
    84f9:	89 c2                	mov    %eax,%edx
    84fb:	8b 45 08             	mov    0x8(%ebp),%eax
    84fe:	83 c0 04             	add    $0x4,%eax
    8501:	52                   	push   %edx
    8502:	50                   	push   %eax
    8503:	e8 0b fd ff ff       	call   8213 <lodepng_crc32>
    8508:	83 c4 08             	add    $0x8,%esp
    850b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(CRC != checksum) return 1;
    850e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8511:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    8514:	74 07                	je     851d <lodepng_chunk_check_crc+0x55>
    8516:	b8 01 00 00 00       	mov    $0x1,%eax
    851b:	eb 05                	jmp    8522 <lodepng_chunk_check_crc+0x5a>
  else return 0;
    851d:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8522:	c9                   	leave  
    8523:	c3                   	ret    

00008524 <lodepng_chunk_generate_crc>:

void lodepng_chunk_generate_crc(unsigned char* chunk) {
    8524:	55                   	push   %ebp
    8525:	89 e5                	mov    %esp,%ebp
    8527:	83 ec 10             	sub    $0x10,%esp
  unsigned length = lodepng_chunk_length(chunk);
    852a:	ff 75 08             	pushl  0x8(%ebp)
    852d:	e8 53 fe ff ff       	call   8385 <lodepng_chunk_length>
    8532:	83 c4 04             	add    $0x4,%esp
    8535:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned CRC = lodepng_crc32(&chunk[4], length + 4);
    8538:	8b 45 fc             	mov    -0x4(%ebp),%eax
    853b:	83 c0 04             	add    $0x4,%eax
    853e:	89 c2                	mov    %eax,%edx
    8540:	8b 45 08             	mov    0x8(%ebp),%eax
    8543:	83 c0 04             	add    $0x4,%eax
    8546:	52                   	push   %edx
    8547:	50                   	push   %eax
    8548:	e8 c6 fc ff ff       	call   8213 <lodepng_crc32>
    854d:	83 c4 08             	add    $0x8,%esp
    8550:	89 45 f8             	mov    %eax,-0x8(%ebp)
  lodepng_set32bitInt(chunk + 8 + length, CRC);
    8553:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8556:	8d 50 08             	lea    0x8(%eax),%edx
    8559:	8b 45 08             	mov    0x8(%ebp),%eax
    855c:	01 d0                	add    %edx,%eax
    855e:	ff 75 f8             	pushl  -0x8(%ebp)
    8561:	50                   	push   %eax
    8562:	e8 5d b2 ff ff       	call   37c4 <lodepng_set32bitInt>
    8567:	83 c4 08             	add    $0x8,%esp
}
    856a:	90                   	nop
    856b:	c9                   	leave  
    856c:	c3                   	ret    

0000856d <lodepng_chunk_next>:

unsigned char* lodepng_chunk_next(unsigned char* chunk, unsigned char* end) {
    856d:	55                   	push   %ebp
    856e:	89 e5                	mov    %esp,%ebp
    8570:	83 ec 10             	sub    $0x10,%esp
  if(chunk >= end || end - chunk < 12) return end; /*too small to contain a chunk*/
    8573:	8b 45 08             	mov    0x8(%ebp),%eax
    8576:	3b 45 0c             	cmp    0xc(%ebp),%eax
    8579:	73 0f                	jae    858a <lodepng_chunk_next+0x1d>
    857b:	8b 55 0c             	mov    0xc(%ebp),%edx
    857e:	8b 45 08             	mov    0x8(%ebp),%eax
    8581:	29 c2                	sub    %eax,%edx
    8583:	89 d0                	mov    %edx,%eax
    8585:	83 f8 0b             	cmp    $0xb,%eax
    8588:	7f 08                	jg     8592 <lodepng_chunk_next+0x25>
    858a:	8b 45 0c             	mov    0xc(%ebp),%eax
    858d:	e9 af 00 00 00       	jmp    8641 <lodepng_chunk_next+0xd4>
  if(chunk[0] == 0x89 && chunk[1] == 0x50 && chunk[2] == 0x4e && chunk[3] == 0x47
    8592:	8b 45 08             	mov    0x8(%ebp),%eax
    8595:	0f b6 00             	movzbl (%eax),%eax
    8598:	3c 89                	cmp    $0x89,%al
    859a:	75 63                	jne    85ff <lodepng_chunk_next+0x92>
    859c:	8b 45 08             	mov    0x8(%ebp),%eax
    859f:	83 c0 01             	add    $0x1,%eax
    85a2:	0f b6 00             	movzbl (%eax),%eax
    85a5:	3c 50                	cmp    $0x50,%al
    85a7:	75 56                	jne    85ff <lodepng_chunk_next+0x92>
    85a9:	8b 45 08             	mov    0x8(%ebp),%eax
    85ac:	83 c0 02             	add    $0x2,%eax
    85af:	0f b6 00             	movzbl (%eax),%eax
    85b2:	3c 4e                	cmp    $0x4e,%al
    85b4:	75 49                	jne    85ff <lodepng_chunk_next+0x92>
    85b6:	8b 45 08             	mov    0x8(%ebp),%eax
    85b9:	83 c0 03             	add    $0x3,%eax
    85bc:	0f b6 00             	movzbl (%eax),%eax
    85bf:	3c 47                	cmp    $0x47,%al
    85c1:	75 3c                	jne    85ff <lodepng_chunk_next+0x92>
    && chunk[4] == 0x0d && chunk[5] == 0x0a && chunk[6] == 0x1a && chunk[7] == 0x0a) {
    85c3:	8b 45 08             	mov    0x8(%ebp),%eax
    85c6:	83 c0 04             	add    $0x4,%eax
    85c9:	0f b6 00             	movzbl (%eax),%eax
    85cc:	3c 0d                	cmp    $0xd,%al
    85ce:	75 2f                	jne    85ff <lodepng_chunk_next+0x92>
    85d0:	8b 45 08             	mov    0x8(%ebp),%eax
    85d3:	83 c0 05             	add    $0x5,%eax
    85d6:	0f b6 00             	movzbl (%eax),%eax
    85d9:	3c 0a                	cmp    $0xa,%al
    85db:	75 22                	jne    85ff <lodepng_chunk_next+0x92>
    85dd:	8b 45 08             	mov    0x8(%ebp),%eax
    85e0:	83 c0 06             	add    $0x6,%eax
    85e3:	0f b6 00             	movzbl (%eax),%eax
    85e6:	3c 1a                	cmp    $0x1a,%al
    85e8:	75 15                	jne    85ff <lodepng_chunk_next+0x92>
    85ea:	8b 45 08             	mov    0x8(%ebp),%eax
    85ed:	83 c0 07             	add    $0x7,%eax
    85f0:	0f b6 00             	movzbl (%eax),%eax
    85f3:	3c 0a                	cmp    $0xa,%al
    85f5:	75 08                	jne    85ff <lodepng_chunk_next+0x92>
    /* Is PNG magic header at start of PNG file. Jump to first actual chunk. */
    return chunk + 8;
    85f7:	8b 45 08             	mov    0x8(%ebp),%eax
    85fa:	83 c0 08             	add    $0x8,%eax
    85fd:	eb 42                	jmp    8641 <lodepng_chunk_next+0xd4>
  } else {
    size_t total_chunk_length;
    unsigned char* result;
    if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return end;
    85ff:	ff 75 08             	pushl  0x8(%ebp)
    8602:	e8 7e fd ff ff       	call   8385 <lodepng_chunk_length>
    8607:	83 c4 04             	add    $0x4,%esp
    860a:	89 c2                	mov    %eax,%edx
    860c:	8d 45 f8             	lea    -0x8(%ebp),%eax
    860f:	50                   	push   %eax
    8610:	6a 0c                	push   $0xc
    8612:	52                   	push   %edx
    8613:	e8 af ae ff ff       	call   34c7 <lodepng_addofl>
    8618:	83 c4 0c             	add    $0xc,%esp
    861b:	85 c0                	test   %eax,%eax
    861d:	74 05                	je     8624 <lodepng_chunk_next+0xb7>
    861f:	8b 45 0c             	mov    0xc(%ebp),%eax
    8622:	eb 1d                	jmp    8641 <lodepng_chunk_next+0xd4>
    result = chunk + total_chunk_length;
    8624:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8627:	89 c2                	mov    %eax,%edx
    8629:	8b 45 08             	mov    0x8(%ebp),%eax
    862c:	01 d0                	add    %edx,%eax
    862e:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(result < chunk) return end; /*pointer overflow*/
    8631:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8634:	3b 45 08             	cmp    0x8(%ebp),%eax
    8637:	73 05                	jae    863e <lodepng_chunk_next+0xd1>
    8639:	8b 45 0c             	mov    0xc(%ebp),%eax
    863c:	eb 03                	jmp    8641 <lodepng_chunk_next+0xd4>
    return result;
    863e:	8b 45 fc             	mov    -0x4(%ebp),%eax
  }
}
    8641:	c9                   	leave  
    8642:	c3                   	ret    

00008643 <lodepng_chunk_next_const>:

const unsigned char* lodepng_chunk_next_const(const unsigned char* chunk, const unsigned char* end) {
    8643:	55                   	push   %ebp
    8644:	89 e5                	mov    %esp,%ebp
    8646:	83 ec 10             	sub    $0x10,%esp
  if(chunk >= end || end - chunk < 12) return end; /*too small to contain a chunk*/
    8649:	8b 45 08             	mov    0x8(%ebp),%eax
    864c:	3b 45 0c             	cmp    0xc(%ebp),%eax
    864f:	73 0f                	jae    8660 <lodepng_chunk_next_const+0x1d>
    8651:	8b 55 0c             	mov    0xc(%ebp),%edx
    8654:	8b 45 08             	mov    0x8(%ebp),%eax
    8657:	29 c2                	sub    %eax,%edx
    8659:	89 d0                	mov    %edx,%eax
    865b:	83 f8 0b             	cmp    $0xb,%eax
    865e:	7f 08                	jg     8668 <lodepng_chunk_next_const+0x25>
    8660:	8b 45 0c             	mov    0xc(%ebp),%eax
    8663:	e9 af 00 00 00       	jmp    8717 <lodepng_chunk_next_const+0xd4>
  if(chunk[0] == 0x89 && chunk[1] == 0x50 && chunk[2] == 0x4e && chunk[3] == 0x47
    8668:	8b 45 08             	mov    0x8(%ebp),%eax
    866b:	0f b6 00             	movzbl (%eax),%eax
    866e:	3c 89                	cmp    $0x89,%al
    8670:	75 63                	jne    86d5 <lodepng_chunk_next_const+0x92>
    8672:	8b 45 08             	mov    0x8(%ebp),%eax
    8675:	83 c0 01             	add    $0x1,%eax
    8678:	0f b6 00             	movzbl (%eax),%eax
    867b:	3c 50                	cmp    $0x50,%al
    867d:	75 56                	jne    86d5 <lodepng_chunk_next_const+0x92>
    867f:	8b 45 08             	mov    0x8(%ebp),%eax
    8682:	83 c0 02             	add    $0x2,%eax
    8685:	0f b6 00             	movzbl (%eax),%eax
    8688:	3c 4e                	cmp    $0x4e,%al
    868a:	75 49                	jne    86d5 <lodepng_chunk_next_const+0x92>
    868c:	8b 45 08             	mov    0x8(%ebp),%eax
    868f:	83 c0 03             	add    $0x3,%eax
    8692:	0f b6 00             	movzbl (%eax),%eax
    8695:	3c 47                	cmp    $0x47,%al
    8697:	75 3c                	jne    86d5 <lodepng_chunk_next_const+0x92>
    && chunk[4] == 0x0d && chunk[5] == 0x0a && chunk[6] == 0x1a && chunk[7] == 0x0a) {
    8699:	8b 45 08             	mov    0x8(%ebp),%eax
    869c:	83 c0 04             	add    $0x4,%eax
    869f:	0f b6 00             	movzbl (%eax),%eax
    86a2:	3c 0d                	cmp    $0xd,%al
    86a4:	75 2f                	jne    86d5 <lodepng_chunk_next_const+0x92>
    86a6:	8b 45 08             	mov    0x8(%ebp),%eax
    86a9:	83 c0 05             	add    $0x5,%eax
    86ac:	0f b6 00             	movzbl (%eax),%eax
    86af:	3c 0a                	cmp    $0xa,%al
    86b1:	75 22                	jne    86d5 <lodepng_chunk_next_const+0x92>
    86b3:	8b 45 08             	mov    0x8(%ebp),%eax
    86b6:	83 c0 06             	add    $0x6,%eax
    86b9:	0f b6 00             	movzbl (%eax),%eax
    86bc:	3c 1a                	cmp    $0x1a,%al
    86be:	75 15                	jne    86d5 <lodepng_chunk_next_const+0x92>
    86c0:	8b 45 08             	mov    0x8(%ebp),%eax
    86c3:	83 c0 07             	add    $0x7,%eax
    86c6:	0f b6 00             	movzbl (%eax),%eax
    86c9:	3c 0a                	cmp    $0xa,%al
    86cb:	75 08                	jne    86d5 <lodepng_chunk_next_const+0x92>
    /* Is PNG magic header at start of PNG file. Jump to first actual chunk. */
    return chunk + 8;
    86cd:	8b 45 08             	mov    0x8(%ebp),%eax
    86d0:	83 c0 08             	add    $0x8,%eax
    86d3:	eb 42                	jmp    8717 <lodepng_chunk_next_const+0xd4>
  } else {
    size_t total_chunk_length;
    const unsigned char* result;
    if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return end;
    86d5:	ff 75 08             	pushl  0x8(%ebp)
    86d8:	e8 a8 fc ff ff       	call   8385 <lodepng_chunk_length>
    86dd:	83 c4 04             	add    $0x4,%esp
    86e0:	89 c2                	mov    %eax,%edx
    86e2:	8d 45 f8             	lea    -0x8(%ebp),%eax
    86e5:	50                   	push   %eax
    86e6:	6a 0c                	push   $0xc
    86e8:	52                   	push   %edx
    86e9:	e8 d9 ad ff ff       	call   34c7 <lodepng_addofl>
    86ee:	83 c4 0c             	add    $0xc,%esp
    86f1:	85 c0                	test   %eax,%eax
    86f3:	74 05                	je     86fa <lodepng_chunk_next_const+0xb7>
    86f5:	8b 45 0c             	mov    0xc(%ebp),%eax
    86f8:	eb 1d                	jmp    8717 <lodepng_chunk_next_const+0xd4>
    result = chunk + total_chunk_length;
    86fa:	8b 45 f8             	mov    -0x8(%ebp),%eax
    86fd:	89 c2                	mov    %eax,%edx
    86ff:	8b 45 08             	mov    0x8(%ebp),%eax
    8702:	01 d0                	add    %edx,%eax
    8704:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(result < chunk) return end; /*pointer overflow*/
    8707:	8b 45 fc             	mov    -0x4(%ebp),%eax
    870a:	3b 45 08             	cmp    0x8(%ebp),%eax
    870d:	73 05                	jae    8714 <lodepng_chunk_next_const+0xd1>
    870f:	8b 45 0c             	mov    0xc(%ebp),%eax
    8712:	eb 03                	jmp    8717 <lodepng_chunk_next_const+0xd4>
    return result;
    8714:	8b 45 fc             	mov    -0x4(%ebp),%eax
  }
}
    8717:	c9                   	leave  
    8718:	c3                   	ret    

00008719 <lodepng_chunk_find>:

unsigned char* lodepng_chunk_find(unsigned char* chunk, unsigned char* end, const char type[5]) {
    8719:	55                   	push   %ebp
    871a:	89 e5                	mov    %esp,%ebp
  for(;;) {
    if(chunk >= end || end - chunk < 12) return 0; /* past file end: chunk + 12 > end */
    871c:	8b 45 08             	mov    0x8(%ebp),%eax
    871f:	3b 45 0c             	cmp    0xc(%ebp),%eax
    8722:	73 0f                	jae    8733 <lodepng_chunk_find+0x1a>
    8724:	8b 55 0c             	mov    0xc(%ebp),%edx
    8727:	8b 45 08             	mov    0x8(%ebp),%eax
    872a:	29 c2                	sub    %eax,%edx
    872c:	89 d0                	mov    %edx,%eax
    872e:	83 f8 0b             	cmp    $0xb,%eax
    8731:	7f 07                	jg     873a <lodepng_chunk_find+0x21>
    8733:	b8 00 00 00 00       	mov    $0x0,%eax
    8738:	eb 2a                	jmp    8764 <lodepng_chunk_find+0x4b>
    if(lodepng_chunk_type_equals(chunk, type)) return chunk;
    873a:	ff 75 10             	pushl  0x10(%ebp)
    873d:	ff 75 08             	pushl  0x8(%ebp)
    8740:	e8 8d fc ff ff       	call   83d2 <lodepng_chunk_type_equals>
    8745:	83 c4 08             	add    $0x8,%esp
    8748:	84 c0                	test   %al,%al
    874a:	74 05                	je     8751 <lodepng_chunk_find+0x38>
    874c:	8b 45 08             	mov    0x8(%ebp),%eax
    874f:	eb 13                	jmp    8764 <lodepng_chunk_find+0x4b>
    chunk = lodepng_chunk_next(chunk, end);
    8751:	ff 75 0c             	pushl  0xc(%ebp)
    8754:	ff 75 08             	pushl  0x8(%ebp)
    8757:	e8 11 fe ff ff       	call   856d <lodepng_chunk_next>
    875c:	83 c4 08             	add    $0x8,%esp
    875f:	89 45 08             	mov    %eax,0x8(%ebp)
  }
    8762:	eb b8                	jmp    871c <lodepng_chunk_find+0x3>
}
    8764:	c9                   	leave  
    8765:	c3                   	ret    

00008766 <lodepng_chunk_find_const>:

const unsigned char* lodepng_chunk_find_const(const unsigned char* chunk, const unsigned char* end, const char type[5]) {
    8766:	55                   	push   %ebp
    8767:	89 e5                	mov    %esp,%ebp
  for(;;) {
    if(chunk >= end || end - chunk < 12) return 0; /* past file end: chunk + 12 > end */
    8769:	8b 45 08             	mov    0x8(%ebp),%eax
    876c:	3b 45 0c             	cmp    0xc(%ebp),%eax
    876f:	73 0f                	jae    8780 <lodepng_chunk_find_const+0x1a>
    8771:	8b 55 0c             	mov    0xc(%ebp),%edx
    8774:	8b 45 08             	mov    0x8(%ebp),%eax
    8777:	29 c2                	sub    %eax,%edx
    8779:	89 d0                	mov    %edx,%eax
    877b:	83 f8 0b             	cmp    $0xb,%eax
    877e:	7f 07                	jg     8787 <lodepng_chunk_find_const+0x21>
    8780:	b8 00 00 00 00       	mov    $0x0,%eax
    8785:	eb 2a                	jmp    87b1 <lodepng_chunk_find_const+0x4b>
    if(lodepng_chunk_type_equals(chunk, type)) return chunk;
    8787:	ff 75 10             	pushl  0x10(%ebp)
    878a:	ff 75 08             	pushl  0x8(%ebp)
    878d:	e8 40 fc ff ff       	call   83d2 <lodepng_chunk_type_equals>
    8792:	83 c4 08             	add    $0x8,%esp
    8795:	84 c0                	test   %al,%al
    8797:	74 05                	je     879e <lodepng_chunk_find_const+0x38>
    8799:	8b 45 08             	mov    0x8(%ebp),%eax
    879c:	eb 13                	jmp    87b1 <lodepng_chunk_find_const+0x4b>
    chunk = lodepng_chunk_next_const(chunk, end);
    879e:	ff 75 0c             	pushl  0xc(%ebp)
    87a1:	ff 75 08             	pushl  0x8(%ebp)
    87a4:	e8 9a fe ff ff       	call   8643 <lodepng_chunk_next_const>
    87a9:	83 c4 08             	add    $0x8,%esp
    87ac:	89 45 08             	mov    %eax,0x8(%ebp)
  }
    87af:	eb b8                	jmp    8769 <lodepng_chunk_find_const+0x3>
}
    87b1:	c9                   	leave  
    87b2:	c3                   	ret    

000087b3 <lodepng_chunk_append>:

unsigned lodepng_chunk_append(unsigned char** out, size_t* outsize, const unsigned char* chunk) {
    87b3:	55                   	push   %ebp
    87b4:	89 e5                	mov    %esp,%ebp
    87b6:	83 ec 20             	sub    $0x20,%esp
  unsigned i;
  size_t total_chunk_length, new_length;
  unsigned char *chunk_start, *new_buffer;

  if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return 77;
    87b9:	ff 75 10             	pushl  0x10(%ebp)
    87bc:	e8 c4 fb ff ff       	call   8385 <lodepng_chunk_length>
    87c1:	83 c4 04             	add    $0x4,%esp
    87c4:	89 c2                	mov    %eax,%edx
    87c6:	8d 45 f0             	lea    -0x10(%ebp),%eax
    87c9:	50                   	push   %eax
    87ca:	6a 0c                	push   $0xc
    87cc:	52                   	push   %edx
    87cd:	e8 f5 ac ff ff       	call   34c7 <lodepng_addofl>
    87d2:	83 c4 0c             	add    $0xc,%esp
    87d5:	85 c0                	test   %eax,%eax
    87d7:	74 0a                	je     87e3 <lodepng_chunk_append+0x30>
    87d9:	b8 4d 00 00 00       	mov    $0x4d,%eax
    87de:	e9 96 00 00 00       	jmp    8879 <lodepng_chunk_append+0xc6>
  if(lodepng_addofl(*outsize, total_chunk_length, &new_length)) return 77;
    87e3:	8b 55 f0             	mov    -0x10(%ebp),%edx
    87e6:	8b 45 0c             	mov    0xc(%ebp),%eax
    87e9:	8b 00                	mov    (%eax),%eax
    87eb:	8d 4d ec             	lea    -0x14(%ebp),%ecx
    87ee:	51                   	push   %ecx
    87ef:	52                   	push   %edx
    87f0:	50                   	push   %eax
    87f1:	e8 d1 ac ff ff       	call   34c7 <lodepng_addofl>
    87f6:	83 c4 0c             	add    $0xc,%esp
    87f9:	85 c0                	test   %eax,%eax
    87fb:	74 07                	je     8804 <lodepng_chunk_append+0x51>
    87fd:	b8 4d 00 00 00       	mov    $0x4d,%eax
    8802:	eb 75                	jmp    8879 <lodepng_chunk_append+0xc6>

  new_buffer = (unsigned char*)lodepng_realloc(*out, new_length);
    8804:	8b 55 ec             	mov    -0x14(%ebp),%edx
    8807:	8b 45 08             	mov    0x8(%ebp),%eax
    880a:	8b 00                	mov    (%eax),%eax
    880c:	52                   	push   %edx
    880d:	50                   	push   %eax
    880e:	e8 07 ac ff ff       	call   341a <lodepng_realloc>
    8813:	83 c4 08             	add    $0x8,%esp
    8816:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(!new_buffer) return 83; /*alloc fail*/
    8819:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    881d:	75 07                	jne    8826 <lodepng_chunk_append+0x73>
    881f:	b8 53 00 00 00       	mov    $0x53,%eax
    8824:	eb 53                	jmp    8879 <lodepng_chunk_append+0xc6>
  (*out) = new_buffer;
    8826:	8b 45 08             	mov    0x8(%ebp),%eax
    8829:	8b 55 f8             	mov    -0x8(%ebp),%edx
    882c:	89 10                	mov    %edx,(%eax)
  (*outsize) = new_length;
    882e:	8b 55 ec             	mov    -0x14(%ebp),%edx
    8831:	8b 45 0c             	mov    0xc(%ebp),%eax
    8834:	89 10                	mov    %edx,(%eax)
  chunk_start = &(*out)[new_length - total_chunk_length];
    8836:	8b 45 08             	mov    0x8(%ebp),%eax
    8839:	8b 00                	mov    (%eax),%eax
    883b:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    883e:	8b 55 f0             	mov    -0x10(%ebp),%edx
    8841:	29 d1                	sub    %edx,%ecx
    8843:	89 ca                	mov    %ecx,%edx
    8845:	01 d0                	add    %edx,%eax
    8847:	89 45 f4             	mov    %eax,-0xc(%ebp)

  for(i = 0; i != total_chunk_length; ++i) chunk_start[i] = chunk[i];
    884a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    8851:	eb 19                	jmp    886c <lodepng_chunk_append+0xb9>
    8853:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8856:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8859:	01 c2                	add    %eax,%edx
    885b:	8b 4d 10             	mov    0x10(%ebp),%ecx
    885e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8861:	01 c8                	add    %ecx,%eax
    8863:	0f b6 00             	movzbl (%eax),%eax
    8866:	88 02                	mov    %al,(%edx)
    8868:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    886c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    886f:	39 45 fc             	cmp    %eax,-0x4(%ebp)
    8872:	75 df                	jne    8853 <lodepng_chunk_append+0xa0>

  return 0;
    8874:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8879:	c9                   	leave  
    887a:	c3                   	ret    

0000887b <lodepng_chunk_init>:
set data or crc yet. Returns the start of the chunk in chunk. The start of
the data is at chunk + 8. To finalize chunk, add the data, then use
lodepng_chunk_generate_crc */
static unsigned lodepng_chunk_init(unsigned char** chunk,
                                   ucvector* out,
                                   unsigned length, const char* type) {
    887b:	55                   	push   %ebp
    887c:	89 e5                	mov    %esp,%ebp
    887e:	83 ec 10             	sub    $0x10,%esp
  size_t new_length = out->size;
    8881:	8b 45 0c             	mov    0xc(%ebp),%eax
    8884:	8b 40 04             	mov    0x4(%eax),%eax
    8887:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if(lodepng_addofl(new_length, length, &new_length)) return 77;
    888a:	8b 55 10             	mov    0x10(%ebp),%edx
    888d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8890:	8d 4d fc             	lea    -0x4(%ebp),%ecx
    8893:	51                   	push   %ecx
    8894:	52                   	push   %edx
    8895:	50                   	push   %eax
    8896:	e8 2c ac ff ff       	call   34c7 <lodepng_addofl>
    889b:	83 c4 0c             	add    $0xc,%esp
    889e:	85 c0                	test   %eax,%eax
    88a0:	74 07                	je     88a9 <lodepng_chunk_init+0x2e>
    88a2:	b8 4d 00 00 00       	mov    $0x4d,%eax
    88a7:	eb 78                	jmp    8921 <lodepng_chunk_init+0xa6>
  if(lodepng_addofl(new_length, 12, &new_length)) return 77;
    88a9:	8b 45 fc             	mov    -0x4(%ebp),%eax
    88ac:	8d 55 fc             	lea    -0x4(%ebp),%edx
    88af:	52                   	push   %edx
    88b0:	6a 0c                	push   $0xc
    88b2:	50                   	push   %eax
    88b3:	e8 0f ac ff ff       	call   34c7 <lodepng_addofl>
    88b8:	83 c4 0c             	add    $0xc,%esp
    88bb:	85 c0                	test   %eax,%eax
    88bd:	74 07                	je     88c6 <lodepng_chunk_init+0x4b>
    88bf:	b8 4d 00 00 00       	mov    $0x4d,%eax
    88c4:	eb 5b                	jmp    8921 <lodepng_chunk_init+0xa6>
  if(!ucvector_resize(out, new_length)) return 83; /*alloc fail*/
    88c6:	8b 45 fc             	mov    -0x4(%ebp),%eax
    88c9:	50                   	push   %eax
    88ca:	ff 75 0c             	pushl  0xc(%ebp)
    88cd:	e8 8b ad ff ff       	call   365d <ucvector_resize>
    88d2:	83 c4 08             	add    $0x8,%esp
    88d5:	85 c0                	test   %eax,%eax
    88d7:	75 07                	jne    88e0 <lodepng_chunk_init+0x65>
    88d9:	b8 53 00 00 00       	mov    $0x53,%eax
    88de:	eb 41                	jmp    8921 <lodepng_chunk_init+0xa6>
  *chunk = out->data + new_length - length - 12u;
    88e0:	8b 45 0c             	mov    0xc(%ebp),%eax
    88e3:	8b 00                	mov    (%eax),%eax
    88e5:	8b 55 fc             	mov    -0x4(%ebp),%edx
    88e8:	2b 55 10             	sub    0x10(%ebp),%edx
    88eb:	83 ea 0c             	sub    $0xc,%edx
    88ee:	01 c2                	add    %eax,%edx
    88f0:	8b 45 08             	mov    0x8(%ebp),%eax
    88f3:	89 10                	mov    %edx,(%eax)

  /*1: length*/
  lodepng_set32bitInt(*chunk, length);
    88f5:	8b 45 08             	mov    0x8(%ebp),%eax
    88f8:	8b 00                	mov    (%eax),%eax
    88fa:	ff 75 10             	pushl  0x10(%ebp)
    88fd:	50                   	push   %eax
    88fe:	e8 c1 ae ff ff       	call   37c4 <lodepng_set32bitInt>
    8903:	83 c4 08             	add    $0x8,%esp

  /*2: chunk name (4 letters)*/
  lodepng_memcpy(*chunk + 4, type, 4);
    8906:	8b 45 08             	mov    0x8(%ebp),%eax
    8909:	8b 00                	mov    (%eax),%eax
    890b:	83 c0 04             	add    $0x4,%eax
    890e:	6a 04                	push   $0x4
    8910:	ff 75 14             	pushl  0x14(%ebp)
    8913:	50                   	push   %eax
    8914:	e8 28 ab ff ff       	call   3441 <lodepng_memcpy>
    8919:	83 c4 0c             	add    $0xc,%esp

  return 0;
    891c:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8921:	c9                   	leave  
    8922:	c3                   	ret    

00008923 <lodepng_chunk_createv>:

/* like lodepng_chunk_create but with custom allocsize */
static unsigned lodepng_chunk_createv(ucvector* out,
                                      unsigned length, const char* type, const unsigned char* data) {
    8923:	55                   	push   %ebp
    8924:	89 e5                	mov    %esp,%ebp
    8926:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, length, type));
    8929:	ff 75 10             	pushl  0x10(%ebp)
    892c:	ff 75 0c             	pushl  0xc(%ebp)
    892f:	ff 75 08             	pushl  0x8(%ebp)
    8932:	8d 45 f8             	lea    -0x8(%ebp),%eax
    8935:	50                   	push   %eax
    8936:	e8 40 ff ff ff       	call   887b <lodepng_chunk_init>
    893b:	83 c4 10             	add    $0x10,%esp
    893e:	89 45 fc             	mov    %eax,-0x4(%ebp)
    8941:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
    8945:	74 05                	je     894c <lodepng_chunk_createv+0x29>
    8947:	8b 45 fc             	mov    -0x4(%ebp),%eax
    894a:	eb 27                	jmp    8973 <lodepng_chunk_createv+0x50>

  /*3: the data*/
  lodepng_memcpy(chunk + 8, data, length);
    894c:	8b 45 0c             	mov    0xc(%ebp),%eax
    894f:	8b 55 f8             	mov    -0x8(%ebp),%edx
    8952:	83 c2 08             	add    $0x8,%edx
    8955:	50                   	push   %eax
    8956:	ff 75 14             	pushl  0x14(%ebp)
    8959:	52                   	push   %edx
    895a:	e8 e2 aa ff ff       	call   3441 <lodepng_memcpy>
    895f:	83 c4 0c             	add    $0xc,%esp

  /*4: CRC (of the chunkname characters and the data)*/
  lodepng_chunk_generate_crc(chunk);
    8962:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8965:	50                   	push   %eax
    8966:	e8 b9 fb ff ff       	call   8524 <lodepng_chunk_generate_crc>
    896b:	83 c4 04             	add    $0x4,%esp

  return 0;
    896e:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8973:	c9                   	leave  
    8974:	c3                   	ret    

00008975 <lodepng_chunk_create>:

unsigned lodepng_chunk_create(unsigned char** out, size_t* outsize,
                              unsigned length, const char* type, const unsigned char* data) {
    8975:	55                   	push   %ebp
    8976:	89 e5                	mov    %esp,%ebp
    8978:	83 ec 10             	sub    $0x10,%esp
  ucvector v = ucvector_init(*out, *outsize);
    897b:	8b 45 0c             	mov    0xc(%ebp),%eax
    897e:	8b 08                	mov    (%eax),%ecx
    8980:	8b 45 08             	mov    0x8(%ebp),%eax
    8983:	8b 10                	mov    (%eax),%edx
    8985:	8d 45 f0             	lea    -0x10(%ebp),%eax
    8988:	51                   	push   %ecx
    8989:	52                   	push   %edx
    898a:	50                   	push   %eax
    898b:	e8 34 ad ff ff       	call   36c4 <ucvector_init>
    8990:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_chunk_createv(&v, length, type, data);
    8993:	ff 75 18             	pushl  0x18(%ebp)
    8996:	ff 75 14             	pushl  0x14(%ebp)
    8999:	ff 75 10             	pushl  0x10(%ebp)
    899c:	8d 45 f0             	lea    -0x10(%ebp),%eax
    899f:	50                   	push   %eax
    89a0:	e8 7e ff ff ff       	call   8923 <lodepng_chunk_createv>
    89a5:	83 c4 10             	add    $0x10,%esp
    89a8:	89 45 fc             	mov    %eax,-0x4(%ebp)
  *out = v.data;
    89ab:	8b 55 f0             	mov    -0x10(%ebp),%edx
    89ae:	8b 45 08             	mov    0x8(%ebp),%eax
    89b1:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    89b3:	8b 55 f4             	mov    -0xc(%ebp),%edx
    89b6:	8b 45 0c             	mov    0xc(%ebp),%eax
    89b9:	89 10                	mov    %edx,(%eax)
  return error;
    89bb:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    89be:	c9                   	leave  
    89bf:	c3                   	ret    

000089c0 <checkColorValidity>:
/* / Color types, channels, bits                                            / */
/* ////////////////////////////////////////////////////////////////////////// */

/*checks if the colortype is valid and the bitdepth bd is allowed for this colortype.
Return value is a LodePNG error code.*/
static unsigned checkColorValidity(LodePNGColorType colortype, unsigned bd) {
    89c0:	55                   	push   %ebp
    89c1:	89 e5                	mov    %esp,%ebp
  switch(colortype) {
    89c3:	8b 45 08             	mov    0x8(%ebp),%eax
    89c6:	83 f8 03             	cmp    $0x3,%eax
    89c9:	74 6d                	je     8a38 <checkColorValidity+0x78>
    89cb:	83 f8 03             	cmp    $0x3,%eax
    89ce:	77 0e                	ja     89de <checkColorValidity+0x1e>
    89d0:	85 c0                	test   %eax,%eax
    89d2:	74 28                	je     89fc <checkColorValidity+0x3c>
    89d4:	83 f8 02             	cmp    $0x2,%eax
    89d7:	74 4c                	je     8a25 <checkColorValidity+0x65>
    89d9:	e9 a6 00 00 00       	jmp    8a84 <checkColorValidity+0xc4>
    89de:	83 f8 06             	cmp    $0x6,%eax
    89e1:	0f 84 83 00 00 00    	je     8a6a <checkColorValidity+0xaa>
    89e7:	3d ff 00 00 00       	cmp    $0xff,%eax
    89ec:	0f 84 8b 00 00 00    	je     8a7d <checkColorValidity+0xbd>
    89f2:	83 f8 04             	cmp    $0x4,%eax
    89f5:	74 60                	je     8a57 <checkColorValidity+0x97>
    89f7:	e9 88 00 00 00       	jmp    8a84 <checkColorValidity+0xc4>
    case LCT_GREY:       if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8 || bd == 16)) return 37; break;
    89fc:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
    8a00:	0f 84 85 00 00 00    	je     8a8b <checkColorValidity+0xcb>
    8a06:	83 7d 0c 02          	cmpl   $0x2,0xc(%ebp)
    8a0a:	74 7f                	je     8a8b <checkColorValidity+0xcb>
    8a0c:	83 7d 0c 04          	cmpl   $0x4,0xc(%ebp)
    8a10:	74 79                	je     8a8b <checkColorValidity+0xcb>
    8a12:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    8a16:	74 73                	je     8a8b <checkColorValidity+0xcb>
    8a18:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    8a1c:	74 6d                	je     8a8b <checkColorValidity+0xcb>
    8a1e:	b8 25 00 00 00       	mov    $0x25,%eax
    8a23:	eb 78                	jmp    8a9d <checkColorValidity+0xdd>
    case LCT_RGB:        if(!(                                 bd == 8 || bd == 16)) return 37; break;
    8a25:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    8a29:	74 63                	je     8a8e <checkColorValidity+0xce>
    8a2b:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    8a2f:	74 5d                	je     8a8e <checkColorValidity+0xce>
    8a31:	b8 25 00 00 00       	mov    $0x25,%eax
    8a36:	eb 65                	jmp    8a9d <checkColorValidity+0xdd>
    case LCT_PALETTE:    if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8            )) return 37; break;
    8a38:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
    8a3c:	74 53                	je     8a91 <checkColorValidity+0xd1>
    8a3e:	83 7d 0c 02          	cmpl   $0x2,0xc(%ebp)
    8a42:	74 4d                	je     8a91 <checkColorValidity+0xd1>
    8a44:	83 7d 0c 04          	cmpl   $0x4,0xc(%ebp)
    8a48:	74 47                	je     8a91 <checkColorValidity+0xd1>
    8a4a:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    8a4e:	74 41                	je     8a91 <checkColorValidity+0xd1>
    8a50:	b8 25 00 00 00       	mov    $0x25,%eax
    8a55:	eb 46                	jmp    8a9d <checkColorValidity+0xdd>
    case LCT_GREY_ALPHA: if(!(                                 bd == 8 || bd == 16)) return 37; break;
    8a57:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    8a5b:	74 37                	je     8a94 <checkColorValidity+0xd4>
    8a5d:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    8a61:	74 31                	je     8a94 <checkColorValidity+0xd4>
    8a63:	b8 25 00 00 00       	mov    $0x25,%eax
    8a68:	eb 33                	jmp    8a9d <checkColorValidity+0xdd>
    case LCT_RGBA:       if(!(                                 bd == 8 || bd == 16)) return 37; break;
    8a6a:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    8a6e:	74 27                	je     8a97 <checkColorValidity+0xd7>
    8a70:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    8a74:	74 21                	je     8a97 <checkColorValidity+0xd7>
    8a76:	b8 25 00 00 00       	mov    $0x25,%eax
    8a7b:	eb 20                	jmp    8a9d <checkColorValidity+0xdd>
    case LCT_MAX_OCTET_VALUE: return 31; /* invalid color type */
    8a7d:	b8 1f 00 00 00       	mov    $0x1f,%eax
    8a82:	eb 19                	jmp    8a9d <checkColorValidity+0xdd>
    default: return 31; /* invalid color type */
    8a84:	b8 1f 00 00 00       	mov    $0x1f,%eax
    8a89:	eb 12                	jmp    8a9d <checkColorValidity+0xdd>

/*checks if the colortype is valid and the bitdepth bd is allowed for this colortype.
Return value is a LodePNG error code.*/
static unsigned checkColorValidity(LodePNGColorType colortype, unsigned bd) {
  switch(colortype) {
    case LCT_GREY:       if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8 || bd == 16)) return 37; break;
    8a8b:	90                   	nop
    8a8c:	eb 0a                	jmp    8a98 <checkColorValidity+0xd8>
    case LCT_RGB:        if(!(                                 bd == 8 || bd == 16)) return 37; break;
    8a8e:	90                   	nop
    8a8f:	eb 07                	jmp    8a98 <checkColorValidity+0xd8>
    case LCT_PALETTE:    if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8            )) return 37; break;
    8a91:	90                   	nop
    8a92:	eb 04                	jmp    8a98 <checkColorValidity+0xd8>
    case LCT_GREY_ALPHA: if(!(                                 bd == 8 || bd == 16)) return 37; break;
    8a94:	90                   	nop
    8a95:	eb 01                	jmp    8a98 <checkColorValidity+0xd8>
    case LCT_RGBA:       if(!(                                 bd == 8 || bd == 16)) return 37; break;
    8a97:	90                   	nop
    case LCT_MAX_OCTET_VALUE: return 31; /* invalid color type */
    default: return 31; /* invalid color type */
  }
  return 0; /*allowed color type / bits combination*/
    8a98:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8a9d:	5d                   	pop    %ebp
    8a9e:	c3                   	ret    

00008a9f <getNumColorChannels>:

static unsigned getNumColorChannels(LodePNGColorType colortype) {
    8a9f:	55                   	push   %ebp
    8aa0:	89 e5                	mov    %esp,%ebp
  switch(colortype) {
    8aa2:	8b 45 08             	mov    0x8(%ebp),%eax
    8aa5:	83 f8 03             	cmp    $0x3,%eax
    8aa8:	74 31                	je     8adb <getNumColorChannels+0x3c>
    8aaa:	83 f8 03             	cmp    $0x3,%eax
    8aad:	77 0b                	ja     8aba <getNumColorChannels+0x1b>
    8aaf:	85 c0                	test   %eax,%eax
    8ab1:	74 1a                	je     8acd <getNumColorChannels+0x2e>
    8ab3:	83 f8 02             	cmp    $0x2,%eax
    8ab6:	74 1c                	je     8ad4 <getNumColorChannels+0x35>
    8ab8:	eb 3d                	jmp    8af7 <getNumColorChannels+0x58>
    8aba:	83 f8 06             	cmp    $0x6,%eax
    8abd:	74 2a                	je     8ae9 <getNumColorChannels+0x4a>
    8abf:	3d ff 00 00 00       	cmp    $0xff,%eax
    8ac4:	74 2a                	je     8af0 <getNumColorChannels+0x51>
    8ac6:	83 f8 04             	cmp    $0x4,%eax
    8ac9:	74 17                	je     8ae2 <getNumColorChannels+0x43>
    8acb:	eb 2a                	jmp    8af7 <getNumColorChannels+0x58>
    case LCT_GREY: return 1;
    8acd:	b8 01 00 00 00       	mov    $0x1,%eax
    8ad2:	eb 28                	jmp    8afc <getNumColorChannels+0x5d>
    case LCT_RGB: return 3;
    8ad4:	b8 03 00 00 00       	mov    $0x3,%eax
    8ad9:	eb 21                	jmp    8afc <getNumColorChannels+0x5d>
    case LCT_PALETTE: return 1;
    8adb:	b8 01 00 00 00       	mov    $0x1,%eax
    8ae0:	eb 1a                	jmp    8afc <getNumColorChannels+0x5d>
    case LCT_GREY_ALPHA: return 2;
    8ae2:	b8 02 00 00 00       	mov    $0x2,%eax
    8ae7:	eb 13                	jmp    8afc <getNumColorChannels+0x5d>
    case LCT_RGBA: return 4;
    8ae9:	b8 04 00 00 00       	mov    $0x4,%eax
    8aee:	eb 0c                	jmp    8afc <getNumColorChannels+0x5d>
    case LCT_MAX_OCTET_VALUE: return 0; /* invalid color type */
    8af0:	b8 00 00 00 00       	mov    $0x0,%eax
    8af5:	eb 05                	jmp    8afc <getNumColorChannels+0x5d>
    default: return 0; /*invalid color type*/
    8af7:	b8 00 00 00 00       	mov    $0x0,%eax
  }
}
    8afc:	5d                   	pop    %ebp
    8afd:	c3                   	ret    

00008afe <lodepng_get_bpp_lct>:

static unsigned lodepng_get_bpp_lct(LodePNGColorType colortype, unsigned bitdepth) {
    8afe:	55                   	push   %ebp
    8aff:	89 e5                	mov    %esp,%ebp
  /*bits per pixel is amount of channels * bits per channel*/
  return getNumColorChannels(colortype) * bitdepth;
    8b01:	ff 75 08             	pushl  0x8(%ebp)
    8b04:	e8 96 ff ff ff       	call   8a9f <getNumColorChannels>
    8b09:	83 c4 04             	add    $0x4,%esp
    8b0c:	0f af 45 0c          	imul   0xc(%ebp),%eax
}
    8b10:	c9                   	leave  
    8b11:	c3                   	ret    

00008b12 <lodepng_color_mode_init>:

/* ////////////////////////////////////////////////////////////////////////// */

void lodepng_color_mode_init(LodePNGColorMode* info) {
    8b12:	55                   	push   %ebp
    8b13:	89 e5                	mov    %esp,%ebp
  info->key_defined = 0;
    8b15:	8b 45 08             	mov    0x8(%ebp),%eax
    8b18:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  info->key_r = info->key_g = info->key_b = 0;
    8b1f:	8b 45 08             	mov    0x8(%ebp),%eax
    8b22:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
    8b29:	8b 45 08             	mov    0x8(%ebp),%eax
    8b2c:	8b 50 1c             	mov    0x1c(%eax),%edx
    8b2f:	8b 45 08             	mov    0x8(%ebp),%eax
    8b32:	89 50 18             	mov    %edx,0x18(%eax)
    8b35:	8b 45 08             	mov    0x8(%ebp),%eax
    8b38:	8b 50 18             	mov    0x18(%eax),%edx
    8b3b:	8b 45 08             	mov    0x8(%ebp),%eax
    8b3e:	89 50 14             	mov    %edx,0x14(%eax)
  info->colortype = LCT_RGBA;
    8b41:	8b 45 08             	mov    0x8(%ebp),%eax
    8b44:	c7 00 06 00 00 00    	movl   $0x6,(%eax)
  info->bitdepth = 8;
    8b4a:	8b 45 08             	mov    0x8(%ebp),%eax
    8b4d:	c7 40 04 08 00 00 00 	movl   $0x8,0x4(%eax)
  info->palette = 0;
    8b54:	8b 45 08             	mov    0x8(%ebp),%eax
    8b57:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  info->palettesize = 0;
    8b5e:	8b 45 08             	mov    0x8(%ebp),%eax
    8b61:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
    8b68:	90                   	nop
    8b69:	5d                   	pop    %ebp
    8b6a:	c3                   	ret    

00008b6b <lodepng_color_mode_alloc_palette>:

/*allocates palette memory if needed, and initializes all colors to black*/
static void lodepng_color_mode_alloc_palette(LodePNGColorMode* info) {
    8b6b:	55                   	push   %ebp
    8b6c:	89 e5                	mov    %esp,%ebp
    8b6e:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  /*if the palette is already allocated, it will have size 1024 so no reallocation needed in that case*/
  /*the palette must have room for up to 256 colors with 4 bytes each.*/
  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);
    8b71:	8b 45 08             	mov    0x8(%ebp),%eax
    8b74:	8b 40 08             	mov    0x8(%eax),%eax
    8b77:	85 c0                	test   %eax,%eax
    8b79:	75 18                	jne    8b93 <lodepng_color_mode_alloc_palette+0x28>
    8b7b:	83 ec 0c             	sub    $0xc,%esp
    8b7e:	68 00 04 00 00       	push   $0x400
    8b83:	e8 7b a8 ff ff       	call   3403 <lodepng_malloc>
    8b88:	83 c4 10             	add    $0x10,%esp
    8b8b:	89 c2                	mov    %eax,%edx
    8b8d:	8b 45 08             	mov    0x8(%ebp),%eax
    8b90:	89 50 08             	mov    %edx,0x8(%eax)
  if(!info->palette) return; /*alloc fail*/
    8b93:	8b 45 08             	mov    0x8(%ebp),%eax
    8b96:	8b 40 08             	mov    0x8(%eax),%eax
    8b99:	85 c0                	test   %eax,%eax
    8b9b:	74 65                	je     8c02 <lodepng_color_mode_alloc_palette+0x97>
  for(i = 0; i != 256; ++i) {
    8b9d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    8ba4:	eb 51                	jmp    8bf7 <lodepng_color_mode_alloc_palette+0x8c>
    /*Initialize all unused colors with black, the value used for invalid palette indices.
    This is an error according to the PNG spec, but common PNG decoders make it black instead.
    That makes color conversion slightly faster due to no error handling needed.*/
    info->palette[i * 4 + 0] = 0;
    8ba6:	8b 45 08             	mov    0x8(%ebp),%eax
    8ba9:	8b 40 08             	mov    0x8(%eax),%eax
    8bac:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8baf:	c1 e2 02             	shl    $0x2,%edx
    8bb2:	01 d0                	add    %edx,%eax
    8bb4:	c6 00 00             	movb   $0x0,(%eax)
    info->palette[i * 4 + 1] = 0;
    8bb7:	8b 45 08             	mov    0x8(%ebp),%eax
    8bba:	8b 40 08             	mov    0x8(%eax),%eax
    8bbd:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8bc0:	c1 e2 02             	shl    $0x2,%edx
    8bc3:	83 c2 01             	add    $0x1,%edx
    8bc6:	01 d0                	add    %edx,%eax
    8bc8:	c6 00 00             	movb   $0x0,(%eax)
    info->palette[i * 4 + 2] = 0;
    8bcb:	8b 45 08             	mov    0x8(%ebp),%eax
    8bce:	8b 40 08             	mov    0x8(%eax),%eax
    8bd1:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8bd4:	c1 e2 02             	shl    $0x2,%edx
    8bd7:	83 c2 02             	add    $0x2,%edx
    8bda:	01 d0                	add    %edx,%eax
    8bdc:	c6 00 00             	movb   $0x0,(%eax)
    info->palette[i * 4 + 3] = 255;
    8bdf:	8b 45 08             	mov    0x8(%ebp),%eax
    8be2:	8b 40 08             	mov    0x8(%eax),%eax
    8be5:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8be8:	c1 e2 02             	shl    $0x2,%edx
    8beb:	83 c2 03             	add    $0x3,%edx
    8bee:	01 d0                	add    %edx,%eax
    8bf0:	c6 00 ff             	movb   $0xff,(%eax)
  size_t i;
  /*if the palette is already allocated, it will have size 1024 so no reallocation needed in that case*/
  /*the palette must have room for up to 256 colors with 4 bytes each.*/
  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);
  if(!info->palette) return; /*alloc fail*/
  for(i = 0; i != 256; ++i) {
    8bf3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    8bf7:	81 7d f4 00 01 00 00 	cmpl   $0x100,-0xc(%ebp)
    8bfe:	75 a6                	jne    8ba6 <lodepng_color_mode_alloc_palette+0x3b>
    8c00:	eb 01                	jmp    8c03 <lodepng_color_mode_alloc_palette+0x98>
static void lodepng_color_mode_alloc_palette(LodePNGColorMode* info) {
  size_t i;
  /*if the palette is already allocated, it will have size 1024 so no reallocation needed in that case*/
  /*the palette must have room for up to 256 colors with 4 bytes each.*/
  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);
  if(!info->palette) return; /*alloc fail*/
    8c02:	90                   	nop
    info->palette[i * 4 + 0] = 0;
    info->palette[i * 4 + 1] = 0;
    info->palette[i * 4 + 2] = 0;
    info->palette[i * 4 + 3] = 255;
  }
}
    8c03:	c9                   	leave  
    8c04:	c3                   	ret    

00008c05 <lodepng_color_mode_cleanup>:

void lodepng_color_mode_cleanup(LodePNGColorMode* info) {
    8c05:	55                   	push   %ebp
    8c06:	89 e5                	mov    %esp,%ebp
    8c08:	83 ec 08             	sub    $0x8,%esp
  lodepng_palette_clear(info);
    8c0b:	83 ec 0c             	sub    $0xc,%esp
    8c0e:	ff 75 08             	pushl  0x8(%ebp)
    8c11:	e8 f3 01 00 00       	call   8e09 <lodepng_palette_clear>
    8c16:	83 c4 10             	add    $0x10,%esp
}
    8c19:	90                   	nop
    8c1a:	c9                   	leave  
    8c1b:	c3                   	ret    

00008c1c <lodepng_color_mode_copy>:

unsigned lodepng_color_mode_copy(LodePNGColorMode* dest, const LodePNGColorMode* source) {
    8c1c:	55                   	push   %ebp
    8c1d:	89 e5                	mov    %esp,%ebp
    8c1f:	83 ec 08             	sub    $0x8,%esp
  lodepng_color_mode_cleanup(dest);
    8c22:	83 ec 0c             	sub    $0xc,%esp
    8c25:	ff 75 08             	pushl  0x8(%ebp)
    8c28:	e8 d8 ff ff ff       	call   8c05 <lodepng_color_mode_cleanup>
    8c2d:	83 c4 10             	add    $0x10,%esp
  lodepng_memcpy(dest, source, sizeof(LodePNGColorMode));
    8c30:	83 ec 04             	sub    $0x4,%esp
    8c33:	6a 20                	push   $0x20
    8c35:	ff 75 0c             	pushl  0xc(%ebp)
    8c38:	ff 75 08             	pushl  0x8(%ebp)
    8c3b:	e8 01 a8 ff ff       	call   3441 <lodepng_memcpy>
    8c40:	83 c4 10             	add    $0x10,%esp
  if(source->palette) {
    8c43:	8b 45 0c             	mov    0xc(%ebp),%eax
    8c46:	8b 40 08             	mov    0x8(%eax),%eax
    8c49:	85 c0                	test   %eax,%eax
    8c4b:	74 5a                	je     8ca7 <lodepng_color_mode_copy+0x8b>
    dest->palette = (unsigned char*)lodepng_malloc(1024);
    8c4d:	83 ec 0c             	sub    $0xc,%esp
    8c50:	68 00 04 00 00       	push   $0x400
    8c55:	e8 a9 a7 ff ff       	call   3403 <lodepng_malloc>
    8c5a:	83 c4 10             	add    $0x10,%esp
    8c5d:	89 c2                	mov    %eax,%edx
    8c5f:	8b 45 08             	mov    0x8(%ebp),%eax
    8c62:	89 50 08             	mov    %edx,0x8(%eax)
    if(!dest->palette && source->palettesize) return 83; /*alloc fail*/
    8c65:	8b 45 08             	mov    0x8(%ebp),%eax
    8c68:	8b 40 08             	mov    0x8(%eax),%eax
    8c6b:	85 c0                	test   %eax,%eax
    8c6d:	75 11                	jne    8c80 <lodepng_color_mode_copy+0x64>
    8c6f:	8b 45 0c             	mov    0xc(%ebp),%eax
    8c72:	8b 40 0c             	mov    0xc(%eax),%eax
    8c75:	85 c0                	test   %eax,%eax
    8c77:	74 07                	je     8c80 <lodepng_color_mode_copy+0x64>
    8c79:	b8 53 00 00 00       	mov    $0x53,%eax
    8c7e:	eb 2c                	jmp    8cac <lodepng_color_mode_copy+0x90>
    lodepng_memcpy(dest->palette, source->palette, source->palettesize * 4);
    8c80:	8b 45 0c             	mov    0xc(%ebp),%eax
    8c83:	8b 40 0c             	mov    0xc(%eax),%eax
    8c86:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    8c8d:	8b 45 0c             	mov    0xc(%ebp),%eax
    8c90:	8b 50 08             	mov    0x8(%eax),%edx
    8c93:	8b 45 08             	mov    0x8(%ebp),%eax
    8c96:	8b 40 08             	mov    0x8(%eax),%eax
    8c99:	83 ec 04             	sub    $0x4,%esp
    8c9c:	51                   	push   %ecx
    8c9d:	52                   	push   %edx
    8c9e:	50                   	push   %eax
    8c9f:	e8 9d a7 ff ff       	call   3441 <lodepng_memcpy>
    8ca4:	83 c4 10             	add    $0x10,%esp
  }
  return 0;
    8ca7:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8cac:	c9                   	leave  
    8cad:	c3                   	ret    

00008cae <lodepng_color_mode_make>:

LodePNGColorMode lodepng_color_mode_make(LodePNGColorType colortype, unsigned bitdepth) {
    8cae:	55                   	push   %ebp
    8caf:	89 e5                	mov    %esp,%ebp
    8cb1:	83 ec 20             	sub    $0x20,%esp
  LodePNGColorMode result;
  lodepng_color_mode_init(&result);
    8cb4:	8d 45 e0             	lea    -0x20(%ebp),%eax
    8cb7:	50                   	push   %eax
    8cb8:	e8 55 fe ff ff       	call   8b12 <lodepng_color_mode_init>
    8cbd:	83 c4 04             	add    $0x4,%esp
  result.colortype = colortype;
    8cc0:	8b 45 0c             	mov    0xc(%ebp),%eax
    8cc3:	89 45 e0             	mov    %eax,-0x20(%ebp)
  result.bitdepth = bitdepth;
    8cc6:	8b 45 10             	mov    0x10(%ebp),%eax
    8cc9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  return result;
    8ccc:	8b 45 08             	mov    0x8(%ebp),%eax
    8ccf:	8b 55 e0             	mov    -0x20(%ebp),%edx
    8cd2:	89 10                	mov    %edx,(%eax)
    8cd4:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    8cd7:	89 50 04             	mov    %edx,0x4(%eax)
    8cda:	8b 55 e8             	mov    -0x18(%ebp),%edx
    8cdd:	89 50 08             	mov    %edx,0x8(%eax)
    8ce0:	8b 55 ec             	mov    -0x14(%ebp),%edx
    8ce3:	89 50 0c             	mov    %edx,0xc(%eax)
    8ce6:	8b 55 f0             	mov    -0x10(%ebp),%edx
    8ce9:	89 50 10             	mov    %edx,0x10(%eax)
    8cec:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8cef:	89 50 14             	mov    %edx,0x14(%eax)
    8cf2:	8b 55 f8             	mov    -0x8(%ebp),%edx
    8cf5:	89 50 18             	mov    %edx,0x18(%eax)
    8cf8:	8b 55 fc             	mov    -0x4(%ebp),%edx
    8cfb:	89 50 1c             	mov    %edx,0x1c(%eax)
}
    8cfe:	8b 45 08             	mov    0x8(%ebp),%eax
    8d01:	c9                   	leave  
    8d02:	c2 04 00             	ret    $0x4

00008d05 <lodepng_color_mode_equal>:

static int lodepng_color_mode_equal(const LodePNGColorMode* a, const LodePNGColorMode* b) {
    8d05:	55                   	push   %ebp
    8d06:	89 e5                	mov    %esp,%ebp
    8d08:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  if(a->colortype != b->colortype) return 0;
    8d0b:	8b 45 08             	mov    0x8(%ebp),%eax
    8d0e:	8b 10                	mov    (%eax),%edx
    8d10:	8b 45 0c             	mov    0xc(%ebp),%eax
    8d13:	8b 00                	mov    (%eax),%eax
    8d15:	39 c2                	cmp    %eax,%edx
    8d17:	74 0a                	je     8d23 <lodepng_color_mode_equal+0x1e>
    8d19:	b8 00 00 00 00       	mov    $0x0,%eax
    8d1e:	e9 e4 00 00 00       	jmp    8e07 <lodepng_color_mode_equal+0x102>
  if(a->bitdepth != b->bitdepth) return 0;
    8d23:	8b 45 08             	mov    0x8(%ebp),%eax
    8d26:	8b 50 04             	mov    0x4(%eax),%edx
    8d29:	8b 45 0c             	mov    0xc(%ebp),%eax
    8d2c:	8b 40 04             	mov    0x4(%eax),%eax
    8d2f:	39 c2                	cmp    %eax,%edx
    8d31:	74 0a                	je     8d3d <lodepng_color_mode_equal+0x38>
    8d33:	b8 00 00 00 00       	mov    $0x0,%eax
    8d38:	e9 ca 00 00 00       	jmp    8e07 <lodepng_color_mode_equal+0x102>
  if(a->key_defined != b->key_defined) return 0;
    8d3d:	8b 45 08             	mov    0x8(%ebp),%eax
    8d40:	8b 50 10             	mov    0x10(%eax),%edx
    8d43:	8b 45 0c             	mov    0xc(%ebp),%eax
    8d46:	8b 40 10             	mov    0x10(%eax),%eax
    8d49:	39 c2                	cmp    %eax,%edx
    8d4b:	74 0a                	je     8d57 <lodepng_color_mode_equal+0x52>
    8d4d:	b8 00 00 00 00       	mov    $0x0,%eax
    8d52:	e9 b0 00 00 00       	jmp    8e07 <lodepng_color_mode_equal+0x102>
  if(a->key_defined) {
    8d57:	8b 45 08             	mov    0x8(%ebp),%eax
    8d5a:	8b 40 10             	mov    0x10(%eax),%eax
    8d5d:	85 c0                	test   %eax,%eax
    8d5f:	74 48                	je     8da9 <lodepng_color_mode_equal+0xa4>
    if(a->key_r != b->key_r) return 0;
    8d61:	8b 45 08             	mov    0x8(%ebp),%eax
    8d64:	8b 50 14             	mov    0x14(%eax),%edx
    8d67:	8b 45 0c             	mov    0xc(%ebp),%eax
    8d6a:	8b 40 14             	mov    0x14(%eax),%eax
    8d6d:	39 c2                	cmp    %eax,%edx
    8d6f:	74 0a                	je     8d7b <lodepng_color_mode_equal+0x76>
    8d71:	b8 00 00 00 00       	mov    $0x0,%eax
    8d76:	e9 8c 00 00 00       	jmp    8e07 <lodepng_color_mode_equal+0x102>
    if(a->key_g != b->key_g) return 0;
    8d7b:	8b 45 08             	mov    0x8(%ebp),%eax
    8d7e:	8b 50 18             	mov    0x18(%eax),%edx
    8d81:	8b 45 0c             	mov    0xc(%ebp),%eax
    8d84:	8b 40 18             	mov    0x18(%eax),%eax
    8d87:	39 c2                	cmp    %eax,%edx
    8d89:	74 07                	je     8d92 <lodepng_color_mode_equal+0x8d>
    8d8b:	b8 00 00 00 00       	mov    $0x0,%eax
    8d90:	eb 75                	jmp    8e07 <lodepng_color_mode_equal+0x102>
    if(a->key_b != b->key_b) return 0;
    8d92:	8b 45 08             	mov    0x8(%ebp),%eax
    8d95:	8b 50 1c             	mov    0x1c(%eax),%edx
    8d98:	8b 45 0c             	mov    0xc(%ebp),%eax
    8d9b:	8b 40 1c             	mov    0x1c(%eax),%eax
    8d9e:	39 c2                	cmp    %eax,%edx
    8da0:	74 07                	je     8da9 <lodepng_color_mode_equal+0xa4>
    8da2:	b8 00 00 00 00       	mov    $0x0,%eax
    8da7:	eb 5e                	jmp    8e07 <lodepng_color_mode_equal+0x102>
  }
  if(a->palettesize != b->palettesize) return 0;
    8da9:	8b 45 08             	mov    0x8(%ebp),%eax
    8dac:	8b 50 0c             	mov    0xc(%eax),%edx
    8daf:	8b 45 0c             	mov    0xc(%ebp),%eax
    8db2:	8b 40 0c             	mov    0xc(%eax),%eax
    8db5:	39 c2                	cmp    %eax,%edx
    8db7:	74 07                	je     8dc0 <lodepng_color_mode_equal+0xbb>
    8db9:	b8 00 00 00 00       	mov    $0x0,%eax
    8dbe:	eb 47                	jmp    8e07 <lodepng_color_mode_equal+0x102>
  for(i = 0; i != a->palettesize * 4; ++i) {
    8dc0:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    8dc7:	eb 2b                	jmp    8df4 <lodepng_color_mode_equal+0xef>
    if(a->palette[i] != b->palette[i]) return 0;
    8dc9:	8b 45 08             	mov    0x8(%ebp),%eax
    8dcc:	8b 50 08             	mov    0x8(%eax),%edx
    8dcf:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8dd2:	01 d0                	add    %edx,%eax
    8dd4:	0f b6 10             	movzbl (%eax),%edx
    8dd7:	8b 45 0c             	mov    0xc(%ebp),%eax
    8dda:	8b 48 08             	mov    0x8(%eax),%ecx
    8ddd:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8de0:	01 c8                	add    %ecx,%eax
    8de2:	0f b6 00             	movzbl (%eax),%eax
    8de5:	38 c2                	cmp    %al,%dl
    8de7:	74 07                	je     8df0 <lodepng_color_mode_equal+0xeb>
    8de9:	b8 00 00 00 00       	mov    $0x0,%eax
    8dee:	eb 17                	jmp    8e07 <lodepng_color_mode_equal+0x102>
    if(a->key_r != b->key_r) return 0;
    if(a->key_g != b->key_g) return 0;
    if(a->key_b != b->key_b) return 0;
  }
  if(a->palettesize != b->palettesize) return 0;
  for(i = 0; i != a->palettesize * 4; ++i) {
    8df0:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    8df4:	8b 45 08             	mov    0x8(%ebp),%eax
    8df7:	8b 40 0c             	mov    0xc(%eax),%eax
    8dfa:	c1 e0 02             	shl    $0x2,%eax
    8dfd:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    8e00:	75 c7                	jne    8dc9 <lodepng_color_mode_equal+0xc4>
    if(a->palette[i] != b->palette[i]) return 0;
  }
  return 1;
    8e02:	b8 01 00 00 00       	mov    $0x1,%eax
}
    8e07:	c9                   	leave  
    8e08:	c3                   	ret    

00008e09 <lodepng_palette_clear>:

void lodepng_palette_clear(LodePNGColorMode* info) {
    8e09:	55                   	push   %ebp
    8e0a:	89 e5                	mov    %esp,%ebp
    8e0c:	83 ec 08             	sub    $0x8,%esp
  if(info->palette) lodepng_free(info->palette);
    8e0f:	8b 45 08             	mov    0x8(%ebp),%eax
    8e12:	8b 40 08             	mov    0x8(%eax),%eax
    8e15:	85 c0                	test   %eax,%eax
    8e17:	74 12                	je     8e2b <lodepng_palette_clear+0x22>
    8e19:	8b 45 08             	mov    0x8(%ebp),%eax
    8e1c:	8b 40 08             	mov    0x8(%eax),%eax
    8e1f:	83 ec 0c             	sub    $0xc,%esp
    8e22:	50                   	push   %eax
    8e23:	e8 fc a5 ff ff       	call   3424 <lodepng_free>
    8e28:	83 c4 10             	add    $0x10,%esp
  info->palette = 0;
    8e2b:	8b 45 08             	mov    0x8(%ebp),%eax
    8e2e:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  info->palettesize = 0;
    8e35:	8b 45 08             	mov    0x8(%ebp),%eax
    8e38:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
    8e3f:	90                   	nop
    8e40:	c9                   	leave  
    8e41:	c3                   	ret    

00008e42 <lodepng_palette_add>:

unsigned lodepng_palette_add(LodePNGColorMode* info,
                             unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    8e42:	55                   	push   %ebp
    8e43:	89 e5                	mov    %esp,%ebp
    8e45:	53                   	push   %ebx
    8e46:	83 ec 14             	sub    $0x14,%esp
    8e49:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    8e4c:	8b 4d 10             	mov    0x10(%ebp),%ecx
    8e4f:	8b 55 14             	mov    0x14(%ebp),%edx
    8e52:	8b 45 18             	mov    0x18(%ebp),%eax
    8e55:	88 5d f4             	mov    %bl,-0xc(%ebp)
    8e58:	88 4d f0             	mov    %cl,-0x10(%ebp)
    8e5b:	88 55 ec             	mov    %dl,-0x14(%ebp)
    8e5e:	88 45 e8             	mov    %al,-0x18(%ebp)
  if(!info->palette) /*allocate palette if empty*/ {
    8e61:	8b 45 08             	mov    0x8(%ebp),%eax
    8e64:	8b 40 08             	mov    0x8(%eax),%eax
    8e67:	85 c0                	test   %eax,%eax
    8e69:	75 22                	jne    8e8d <lodepng_palette_add+0x4b>
    lodepng_color_mode_alloc_palette(info);
    8e6b:	83 ec 0c             	sub    $0xc,%esp
    8e6e:	ff 75 08             	pushl  0x8(%ebp)
    8e71:	e8 f5 fc ff ff       	call   8b6b <lodepng_color_mode_alloc_palette>
    8e76:	83 c4 10             	add    $0x10,%esp
    if(!info->palette) return 83; /*alloc fail*/
    8e79:	8b 45 08             	mov    0x8(%ebp),%eax
    8e7c:	8b 40 08             	mov    0x8(%eax),%eax
    8e7f:	85 c0                	test   %eax,%eax
    8e81:	75 0a                	jne    8e8d <lodepng_palette_add+0x4b>
    8e83:	b8 53 00 00 00       	mov    $0x53,%eax
    8e88:	e9 8d 00 00 00       	jmp    8f1a <lodepng_palette_add+0xd8>
  }
  if(info->palettesize >= 256) {
    8e8d:	8b 45 08             	mov    0x8(%ebp),%eax
    8e90:	8b 40 0c             	mov    0xc(%eax),%eax
    8e93:	3d ff 00 00 00       	cmp    $0xff,%eax
    8e98:	7e 07                	jle    8ea1 <lodepng_palette_add+0x5f>
    return 108; /*too many palette values*/
    8e9a:	b8 6c 00 00 00       	mov    $0x6c,%eax
    8e9f:	eb 79                	jmp    8f1a <lodepng_palette_add+0xd8>
  }
  info->palette[4 * info->palettesize + 0] = r;
    8ea1:	8b 45 08             	mov    0x8(%ebp),%eax
    8ea4:	8b 50 08             	mov    0x8(%eax),%edx
    8ea7:	8b 45 08             	mov    0x8(%ebp),%eax
    8eaa:	8b 40 0c             	mov    0xc(%eax),%eax
    8ead:	c1 e0 02             	shl    $0x2,%eax
    8eb0:	01 c2                	add    %eax,%edx
    8eb2:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
    8eb6:	88 02                	mov    %al,(%edx)
  info->palette[4 * info->palettesize + 1] = g;
    8eb8:	8b 45 08             	mov    0x8(%ebp),%eax
    8ebb:	8b 50 08             	mov    0x8(%eax),%edx
    8ebe:	8b 45 08             	mov    0x8(%ebp),%eax
    8ec1:	8b 40 0c             	mov    0xc(%eax),%eax
    8ec4:	c1 e0 02             	shl    $0x2,%eax
    8ec7:	83 c0 01             	add    $0x1,%eax
    8eca:	01 c2                	add    %eax,%edx
    8ecc:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
    8ed0:	88 02                	mov    %al,(%edx)
  info->palette[4 * info->palettesize + 2] = b;
    8ed2:	8b 45 08             	mov    0x8(%ebp),%eax
    8ed5:	8b 50 08             	mov    0x8(%eax),%edx
    8ed8:	8b 45 08             	mov    0x8(%ebp),%eax
    8edb:	8b 40 0c             	mov    0xc(%eax),%eax
    8ede:	c1 e0 02             	shl    $0x2,%eax
    8ee1:	83 c0 02             	add    $0x2,%eax
    8ee4:	01 c2                	add    %eax,%edx
    8ee6:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
    8eea:	88 02                	mov    %al,(%edx)
  info->palette[4 * info->palettesize + 3] = a;
    8eec:	8b 45 08             	mov    0x8(%ebp),%eax
    8eef:	8b 50 08             	mov    0x8(%eax),%edx
    8ef2:	8b 45 08             	mov    0x8(%ebp),%eax
    8ef5:	8b 40 0c             	mov    0xc(%eax),%eax
    8ef8:	c1 e0 02             	shl    $0x2,%eax
    8efb:	83 c0 03             	add    $0x3,%eax
    8efe:	01 c2                	add    %eax,%edx
    8f00:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    8f04:	88 02                	mov    %al,(%edx)
  ++info->palettesize;
    8f06:	8b 45 08             	mov    0x8(%ebp),%eax
    8f09:	8b 40 0c             	mov    0xc(%eax),%eax
    8f0c:	8d 50 01             	lea    0x1(%eax),%edx
    8f0f:	8b 45 08             	mov    0x8(%ebp),%eax
    8f12:	89 50 0c             	mov    %edx,0xc(%eax)
  return 0;
    8f15:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8f1a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    8f1d:	c9                   	leave  
    8f1e:	c3                   	ret    

00008f1f <lodepng_get_bpp>:

/*calculate bits per pixel out of colortype and bitdepth*/
unsigned lodepng_get_bpp(const LodePNGColorMode* info) {
    8f1f:	55                   	push   %ebp
    8f20:	89 e5                	mov    %esp,%ebp
  return lodepng_get_bpp_lct(info->colortype, info->bitdepth);
    8f22:	8b 45 08             	mov    0x8(%ebp),%eax
    8f25:	8b 50 04             	mov    0x4(%eax),%edx
    8f28:	8b 45 08             	mov    0x8(%ebp),%eax
    8f2b:	8b 00                	mov    (%eax),%eax
    8f2d:	52                   	push   %edx
    8f2e:	50                   	push   %eax
    8f2f:	e8 ca fb ff ff       	call   8afe <lodepng_get_bpp_lct>
    8f34:	83 c4 08             	add    $0x8,%esp
}
    8f37:	c9                   	leave  
    8f38:	c3                   	ret    

00008f39 <lodepng_get_channels>:

unsigned lodepng_get_channels(const LodePNGColorMode* info) {
    8f39:	55                   	push   %ebp
    8f3a:	89 e5                	mov    %esp,%ebp
  return getNumColorChannels(info->colortype);
    8f3c:	8b 45 08             	mov    0x8(%ebp),%eax
    8f3f:	8b 00                	mov    (%eax),%eax
    8f41:	50                   	push   %eax
    8f42:	e8 58 fb ff ff       	call   8a9f <getNumColorChannels>
    8f47:	83 c4 04             	add    $0x4,%esp
}
    8f4a:	c9                   	leave  
    8f4b:	c3                   	ret    

00008f4c <lodepng_is_greyscale_type>:

unsigned lodepng_is_greyscale_type(const LodePNGColorMode* info) {
    8f4c:	55                   	push   %ebp
    8f4d:	89 e5                	mov    %esp,%ebp
  return info->colortype == LCT_GREY || info->colortype == LCT_GREY_ALPHA;
    8f4f:	8b 45 08             	mov    0x8(%ebp),%eax
    8f52:	8b 00                	mov    (%eax),%eax
    8f54:	85 c0                	test   %eax,%eax
    8f56:	74 0a                	je     8f62 <lodepng_is_greyscale_type+0x16>
    8f58:	8b 45 08             	mov    0x8(%ebp),%eax
    8f5b:	8b 00                	mov    (%eax),%eax
    8f5d:	83 f8 04             	cmp    $0x4,%eax
    8f60:	75 07                	jne    8f69 <lodepng_is_greyscale_type+0x1d>
    8f62:	b8 01 00 00 00       	mov    $0x1,%eax
    8f67:	eb 05                	jmp    8f6e <lodepng_is_greyscale_type+0x22>
    8f69:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8f6e:	5d                   	pop    %ebp
    8f6f:	c3                   	ret    

00008f70 <lodepng_is_alpha_type>:

unsigned lodepng_is_alpha_type(const LodePNGColorMode* info) {
    8f70:	55                   	push   %ebp
    8f71:	89 e5                	mov    %esp,%ebp
  return (info->colortype & 4) != 0; /*4 or 6*/
    8f73:	8b 45 08             	mov    0x8(%ebp),%eax
    8f76:	8b 00                	mov    (%eax),%eax
    8f78:	83 e0 04             	and    $0x4,%eax
    8f7b:	85 c0                	test   %eax,%eax
    8f7d:	0f 95 c0             	setne  %al
    8f80:	0f b6 c0             	movzbl %al,%eax
}
    8f83:	5d                   	pop    %ebp
    8f84:	c3                   	ret    

00008f85 <lodepng_is_palette_type>:

unsigned lodepng_is_palette_type(const LodePNGColorMode* info) {
    8f85:	55                   	push   %ebp
    8f86:	89 e5                	mov    %esp,%ebp
  return info->colortype == LCT_PALETTE;
    8f88:	8b 45 08             	mov    0x8(%ebp),%eax
    8f8b:	8b 00                	mov    (%eax),%eax
    8f8d:	83 f8 03             	cmp    $0x3,%eax
    8f90:	0f 94 c0             	sete   %al
    8f93:	0f b6 c0             	movzbl %al,%eax
}
    8f96:	5d                   	pop    %ebp
    8f97:	c3                   	ret    

00008f98 <lodepng_has_palette_alpha>:

unsigned lodepng_has_palette_alpha(const LodePNGColorMode* info) {
    8f98:	55                   	push   %ebp
    8f99:	89 e5                	mov    %esp,%ebp
    8f9b:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i != info->palettesize; ++i) {
    8f9e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    8fa5:	eb 23                	jmp    8fca <lodepng_has_palette_alpha+0x32>
    if(info->palette[i * 4 + 3] < 255) return 1;
    8fa7:	8b 45 08             	mov    0x8(%ebp),%eax
    8faa:	8b 40 08             	mov    0x8(%eax),%eax
    8fad:	8b 55 fc             	mov    -0x4(%ebp),%edx
    8fb0:	c1 e2 02             	shl    $0x2,%edx
    8fb3:	83 c2 03             	add    $0x3,%edx
    8fb6:	01 d0                	add    %edx,%eax
    8fb8:	0f b6 00             	movzbl (%eax),%eax
    8fbb:	3c ff                	cmp    $0xff,%al
    8fbd:	74 07                	je     8fc6 <lodepng_has_palette_alpha+0x2e>
    8fbf:	b8 01 00 00 00       	mov    $0x1,%eax
    8fc4:	eb 14                	jmp    8fda <lodepng_has_palette_alpha+0x42>
  return info->colortype == LCT_PALETTE;
}

unsigned lodepng_has_palette_alpha(const LodePNGColorMode* info) {
  size_t i;
  for(i = 0; i != info->palettesize; ++i) {
    8fc6:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    8fca:	8b 45 08             	mov    0x8(%ebp),%eax
    8fcd:	8b 40 0c             	mov    0xc(%eax),%eax
    8fd0:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    8fd3:	75 d2                	jne    8fa7 <lodepng_has_palette_alpha+0xf>
    if(info->palette[i * 4 + 3] < 255) return 1;
  }
  return 0;
    8fd5:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8fda:	c9                   	leave  
    8fdb:	c3                   	ret    

00008fdc <lodepng_can_have_alpha>:

unsigned lodepng_can_have_alpha(const LodePNGColorMode* info) {
    8fdc:	55                   	push   %ebp
    8fdd:	89 e5                	mov    %esp,%ebp
  return info->key_defined
    8fdf:	8b 45 08             	mov    0x8(%ebp),%eax
    8fe2:	8b 40 10             	mov    0x10(%eax),%eax
      || lodepng_is_alpha_type(info)
      || lodepng_has_palette_alpha(info);
    8fe5:	85 c0                	test   %eax,%eax
    8fe7:	75 1e                	jne    9007 <lodepng_can_have_alpha+0x2b>
  return 0;
}

unsigned lodepng_can_have_alpha(const LodePNGColorMode* info) {
  return info->key_defined
      || lodepng_is_alpha_type(info)
    8fe9:	ff 75 08             	pushl  0x8(%ebp)
    8fec:	e8 7f ff ff ff       	call   8f70 <lodepng_is_alpha_type>
    8ff1:	83 c4 04             	add    $0x4,%esp
    8ff4:	85 c0                	test   %eax,%eax
    8ff6:	75 0f                	jne    9007 <lodepng_can_have_alpha+0x2b>
      || lodepng_has_palette_alpha(info);
    8ff8:	ff 75 08             	pushl  0x8(%ebp)
    8ffb:	e8 98 ff ff ff       	call   8f98 <lodepng_has_palette_alpha>
    9000:	83 c4 04             	add    $0x4,%esp
    9003:	85 c0                	test   %eax,%eax
    9005:	74 07                	je     900e <lodepng_can_have_alpha+0x32>
    9007:	b8 01 00 00 00       	mov    $0x1,%eax
    900c:	eb 05                	jmp    9013 <lodepng_can_have_alpha+0x37>
    900e:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9013:	c9                   	leave  
    9014:	c3                   	ret    

00009015 <lodepng_get_raw_size_lct>:

static size_t lodepng_get_raw_size_lct(unsigned w, unsigned h, LodePNGColorType colortype, unsigned bitdepth) {
    9015:	55                   	push   %ebp
    9016:	89 e5                	mov    %esp,%ebp
    9018:	83 ec 10             	sub    $0x10,%esp
  size_t bpp = lodepng_get_bpp_lct(colortype, bitdepth);
    901b:	ff 75 14             	pushl  0x14(%ebp)
    901e:	ff 75 10             	pushl  0x10(%ebp)
    9021:	e8 d8 fa ff ff       	call   8afe <lodepng_get_bpp_lct>
    9026:	83 c4 08             	add    $0x8,%esp
    9029:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t n = (size_t)w * (size_t)h;
    902c:	8b 55 08             	mov    0x8(%ebp),%edx
    902f:	8b 45 0c             	mov    0xc(%ebp),%eax
    9032:	0f af c2             	imul   %edx,%eax
    9035:	89 45 f8             	mov    %eax,-0x8(%ebp)
  return ((n / 8u) * bpp) + ((n & 7u) * bpp + 7u) / 8u;
    9038:	8b 45 f8             	mov    -0x8(%ebp),%eax
    903b:	c1 e8 03             	shr    $0x3,%eax
    903e:	89 c2                	mov    %eax,%edx
    9040:	8b 45 fc             	mov    -0x4(%ebp),%eax
    9043:	0f af c2             	imul   %edx,%eax
    9046:	8b 55 f8             	mov    -0x8(%ebp),%edx
    9049:	89 d1                	mov    %edx,%ecx
    904b:	83 e1 07             	and    $0x7,%ecx
    904e:	8b 55 fc             	mov    -0x4(%ebp),%edx
    9051:	0f af d1             	imul   %ecx,%edx
    9054:	83 c2 07             	add    $0x7,%edx
    9057:	c1 ea 03             	shr    $0x3,%edx
    905a:	01 d0                	add    %edx,%eax
}
    905c:	c9                   	leave  
    905d:	c3                   	ret    

0000905e <lodepng_get_raw_size>:

size_t lodepng_get_raw_size(unsigned w, unsigned h, const LodePNGColorMode* color) {
    905e:	55                   	push   %ebp
    905f:	89 e5                	mov    %esp,%ebp
  return lodepng_get_raw_size_lct(w, h, color->colortype, color->bitdepth);
    9061:	8b 45 10             	mov    0x10(%ebp),%eax
    9064:	8b 50 04             	mov    0x4(%eax),%edx
    9067:	8b 45 10             	mov    0x10(%ebp),%eax
    906a:	8b 00                	mov    (%eax),%eax
    906c:	52                   	push   %edx
    906d:	50                   	push   %eax
    906e:	ff 75 0c             	pushl  0xc(%ebp)
    9071:	ff 75 08             	pushl  0x8(%ebp)
    9074:	e8 9c ff ff ff       	call   9015 <lodepng_get_raw_size_lct>
    9079:	83 c4 10             	add    $0x10,%esp
}
    907c:	c9                   	leave  
    907d:	c3                   	ret    

0000907e <lodepng_get_raw_size_idat>:
#ifdef LODEPNG_COMPILE_PNG

/*in an idat chunk, each scanline is a multiple of 8 bits, unlike the lodepng output buffer,
and in addition has one extra byte per line: the filter byte. So this gives a larger
result than lodepng_get_raw_size. Set h to 1 to get the size of 1 row including filter byte. */
static size_t lodepng_get_raw_size_idat(unsigned w, unsigned h, unsigned bpp) {
    907e:	55                   	push   %ebp
    907f:	89 e5                	mov    %esp,%ebp
    9081:	83 ec 10             	sub    $0x10,%esp
  /* + 1 for the filter byte, and possibly plus padding bits per line. */
  /* Ignoring casts, the expression is equal to (w * bpp + 7) / 8 + 1, but avoids overflow of w * bpp */
  size_t line = ((size_t)(w / 8u) * bpp) + 1u + ((w & 7u) * bpp + 7u) / 8u;
    9084:	8b 45 08             	mov    0x8(%ebp),%eax
    9087:	c1 e8 03             	shr    $0x3,%eax
    908a:	0f af 45 10          	imul   0x10(%ebp),%eax
    908e:	8b 55 08             	mov    0x8(%ebp),%edx
    9091:	83 e2 07             	and    $0x7,%edx
    9094:	0f af 55 10          	imul   0x10(%ebp),%edx
    9098:	83 c2 07             	add    $0x7,%edx
    909b:	c1 ea 03             	shr    $0x3,%edx
    909e:	01 d0                	add    %edx,%eax
    90a0:	83 c0 01             	add    $0x1,%eax
    90a3:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return (size_t)h * line;
    90a6:	8b 45 0c             	mov    0xc(%ebp),%eax
    90a9:	0f af 45 fc          	imul   -0x4(%ebp),%eax
}
    90ad:	c9                   	leave  
    90ae:	c3                   	ret    

000090af <lodepng_pixel_overflow>:
-amount of bytes in IDAT (including filter, padding and Adam7 bytes)
-amount of bytes in raw color model
Returns 1 if overflow possible, 0 if not.
*/
static int lodepng_pixel_overflow(unsigned w, unsigned h,
                                  const LodePNGColorMode* pngcolor, const LodePNGColorMode* rawcolor) {
    90af:	55                   	push   %ebp
    90b0:	89 e5                	mov    %esp,%ebp
    90b2:	53                   	push   %ebx
    90b3:	83 ec 10             	sub    $0x10,%esp
  size_t bpp = LODEPNG_MAX(lodepng_get_bpp(pngcolor), lodepng_get_bpp(rawcolor));
    90b6:	ff 75 10             	pushl  0x10(%ebp)
    90b9:	e8 61 fe ff ff       	call   8f1f <lodepng_get_bpp>
    90be:	83 c4 04             	add    $0x4,%esp
    90c1:	89 c3                	mov    %eax,%ebx
    90c3:	ff 75 14             	pushl  0x14(%ebp)
    90c6:	e8 54 fe ff ff       	call   8f1f <lodepng_get_bpp>
    90cb:	83 c4 04             	add    $0x4,%esp
    90ce:	39 c3                	cmp    %eax,%ebx
    90d0:	76 0d                	jbe    90df <lodepng_pixel_overflow+0x30>
    90d2:	ff 75 10             	pushl  0x10(%ebp)
    90d5:	e8 45 fe ff ff       	call   8f1f <lodepng_get_bpp>
    90da:	83 c4 04             	add    $0x4,%esp
    90dd:	eb 0b                	jmp    90ea <lodepng_pixel_overflow+0x3b>
    90df:	ff 75 14             	pushl  0x14(%ebp)
    90e2:	e8 38 fe ff ff       	call   8f1f <lodepng_get_bpp>
    90e7:	83 c4 04             	add    $0x4,%esp
    90ea:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t numpixels, total;
  size_t line; /* bytes per line in worst case */

  if(lodepng_mulofl((size_t)w, (size_t)h, &numpixels)) return 1;
    90ed:	8b 55 0c             	mov    0xc(%ebp),%edx
    90f0:	8b 45 08             	mov    0x8(%ebp),%eax
    90f3:	8d 4d f4             	lea    -0xc(%ebp),%ecx
    90f6:	51                   	push   %ecx
    90f7:	52                   	push   %edx
    90f8:	50                   	push   %eax
    90f9:	e8 e9 a3 ff ff       	call   34e7 <lodepng_mulofl>
    90fe:	83 c4 0c             	add    $0xc,%esp
    9101:	85 c0                	test   %eax,%eax
    9103:	74 0a                	je     910f <lodepng_pixel_overflow+0x60>
    9105:	b8 01 00 00 00       	mov    $0x1,%eax
    910a:	e9 b6 00 00 00       	jmp    91c5 <lodepng_pixel_overflow+0x116>
  if(lodepng_mulofl(numpixels, 8, &total)) return 1; /* bit pointer with 8-bit color, or 8 bytes per channel color */
    910f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9112:	8d 55 f0             	lea    -0x10(%ebp),%edx
    9115:	52                   	push   %edx
    9116:	6a 08                	push   $0x8
    9118:	50                   	push   %eax
    9119:	e8 c9 a3 ff ff       	call   34e7 <lodepng_mulofl>
    911e:	83 c4 0c             	add    $0xc,%esp
    9121:	85 c0                	test   %eax,%eax
    9123:	74 0a                	je     912f <lodepng_pixel_overflow+0x80>
    9125:	b8 01 00 00 00       	mov    $0x1,%eax
    912a:	e9 96 00 00 00       	jmp    91c5 <lodepng_pixel_overflow+0x116>

  /* Bytes per scanline with the expression "(w / 8u) * bpp) + ((w & 7u) * bpp + 7u) / 8u" */
  if(lodepng_mulofl((size_t)(w / 8u), bpp, &line)) return 1;
    912f:	8b 45 08             	mov    0x8(%ebp),%eax
    9132:	c1 e8 03             	shr    $0x3,%eax
    9135:	89 c2                	mov    %eax,%edx
    9137:	8d 45 ec             	lea    -0x14(%ebp),%eax
    913a:	50                   	push   %eax
    913b:	ff 75 f8             	pushl  -0x8(%ebp)
    913e:	52                   	push   %edx
    913f:	e8 a3 a3 ff ff       	call   34e7 <lodepng_mulofl>
    9144:	83 c4 0c             	add    $0xc,%esp
    9147:	85 c0                	test   %eax,%eax
    9149:	74 07                	je     9152 <lodepng_pixel_overflow+0xa3>
    914b:	b8 01 00 00 00       	mov    $0x1,%eax
    9150:	eb 73                	jmp    91c5 <lodepng_pixel_overflow+0x116>
  if(lodepng_addofl(line, ((w & 7u) * bpp + 7u) / 8u, &line)) return 1;
    9152:	8b 45 08             	mov    0x8(%ebp),%eax
    9155:	83 e0 07             	and    $0x7,%eax
    9158:	89 c2                	mov    %eax,%edx
    915a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    915d:	0f af c2             	imul   %edx,%eax
    9160:	83 c0 07             	add    $0x7,%eax
    9163:	c1 e8 03             	shr    $0x3,%eax
    9166:	89 c1                	mov    %eax,%ecx
    9168:	8b 45 ec             	mov    -0x14(%ebp),%eax
    916b:	8d 55 ec             	lea    -0x14(%ebp),%edx
    916e:	52                   	push   %edx
    916f:	51                   	push   %ecx
    9170:	50                   	push   %eax
    9171:	e8 51 a3 ff ff       	call   34c7 <lodepng_addofl>
    9176:	83 c4 0c             	add    $0xc,%esp
    9179:	85 c0                	test   %eax,%eax
    917b:	74 07                	je     9184 <lodepng_pixel_overflow+0xd5>
    917d:	b8 01 00 00 00       	mov    $0x1,%eax
    9182:	eb 41                	jmp    91c5 <lodepng_pixel_overflow+0x116>

  if(lodepng_addofl(line, 5, &line)) return 1; /* 5 bytes overhead per line: 1 filterbyte, 4 for Adam7 worst case */
    9184:	8b 45 ec             	mov    -0x14(%ebp),%eax
    9187:	8d 55 ec             	lea    -0x14(%ebp),%edx
    918a:	52                   	push   %edx
    918b:	6a 05                	push   $0x5
    918d:	50                   	push   %eax
    918e:	e8 34 a3 ff ff       	call   34c7 <lodepng_addofl>
    9193:	83 c4 0c             	add    $0xc,%esp
    9196:	85 c0                	test   %eax,%eax
    9198:	74 07                	je     91a1 <lodepng_pixel_overflow+0xf2>
    919a:	b8 01 00 00 00       	mov    $0x1,%eax
    919f:	eb 24                	jmp    91c5 <lodepng_pixel_overflow+0x116>
  if(lodepng_mulofl(line, h, &total)) return 1; /* Total bytes in worst case */
    91a1:	8b 55 0c             	mov    0xc(%ebp),%edx
    91a4:	8b 45 ec             	mov    -0x14(%ebp),%eax
    91a7:	8d 4d f0             	lea    -0x10(%ebp),%ecx
    91aa:	51                   	push   %ecx
    91ab:	52                   	push   %edx
    91ac:	50                   	push   %eax
    91ad:	e8 35 a3 ff ff       	call   34e7 <lodepng_mulofl>
    91b2:	83 c4 0c             	add    $0xc,%esp
    91b5:	85 c0                	test   %eax,%eax
    91b7:	74 07                	je     91c0 <lodepng_pixel_overflow+0x111>
    91b9:	b8 01 00 00 00       	mov    $0x1,%eax
    91be:	eb 05                	jmp    91c5 <lodepng_pixel_overflow+0x116>

  return 0; /* no overflow */
    91c0:	b8 00 00 00 00       	mov    $0x0,%eax
}
    91c5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    91c8:	c9                   	leave  
    91c9:	c3                   	ret    

000091ca <LodePNGUnknownChunks_init>:
#endif /*LODEPNG_COMPILE_DECODER*/
#endif /*LODEPNG_COMPILE_PNG*/

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

static void LodePNGUnknownChunks_init(LodePNGInfo* info) {
    91ca:	55                   	push   %ebp
    91cb:	89 e5                	mov    %esp,%ebp
    91cd:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  for(i = 0; i != 3; ++i) info->unknown_chunks_data[i] = 0;
    91d0:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    91d7:	eb 15                	jmp    91ee <LodePNGUnknownChunks_init+0x24>
    91d9:	8b 45 08             	mov    0x8(%ebp),%eax
    91dc:	8b 55 fc             	mov    -0x4(%ebp),%edx
    91df:	83 c2 30             	add    $0x30,%edx
    91e2:	c7 44 90 0c 00 00 00 	movl   $0x0,0xc(%eax,%edx,4)
    91e9:	00 
    91ea:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    91ee:	83 7d fc 03          	cmpl   $0x3,-0x4(%ebp)
    91f2:	75 e5                	jne    91d9 <LodePNGUnknownChunks_init+0xf>
  for(i = 0; i != 3; ++i) info->unknown_chunks_size[i] = 0;
    91f4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    91fb:	eb 15                	jmp    9212 <LodePNGUnknownChunks_init+0x48>
    91fd:	8b 45 08             	mov    0x8(%ebp),%eax
    9200:	8b 55 fc             	mov    -0x4(%ebp),%edx
    9203:	83 c2 34             	add    $0x34,%edx
    9206:	c7 44 90 08 00 00 00 	movl   $0x0,0x8(%eax,%edx,4)
    920d:	00 
    920e:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    9212:	83 7d fc 03          	cmpl   $0x3,-0x4(%ebp)
    9216:	75 e5                	jne    91fd <LodePNGUnknownChunks_init+0x33>
}
    9218:	90                   	nop
    9219:	c9                   	leave  
    921a:	c3                   	ret    

0000921b <LodePNGUnknownChunks_cleanup>:

static void LodePNGUnknownChunks_cleanup(LodePNGInfo* info) {
    921b:	55                   	push   %ebp
    921c:	89 e5                	mov    %esp,%ebp
    921e:	83 ec 18             	sub    $0x18,%esp
  unsigned i;
  for(i = 0; i != 3; ++i) lodepng_free(info->unknown_chunks_data[i]);
    9221:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9228:	eb 1d                	jmp    9247 <LodePNGUnknownChunks_cleanup+0x2c>
    922a:	8b 45 08             	mov    0x8(%ebp),%eax
    922d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9230:	83 c2 30             	add    $0x30,%edx
    9233:	8b 44 90 0c          	mov    0xc(%eax,%edx,4),%eax
    9237:	83 ec 0c             	sub    $0xc,%esp
    923a:	50                   	push   %eax
    923b:	e8 e4 a1 ff ff       	call   3424 <lodepng_free>
    9240:	83 c4 10             	add    $0x10,%esp
    9243:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9247:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
    924b:	75 dd                	jne    922a <LodePNGUnknownChunks_cleanup+0xf>
}
    924d:	90                   	nop
    924e:	c9                   	leave  
    924f:	c3                   	ret    

00009250 <LodePNGUnknownChunks_copy>:

static unsigned LodePNGUnknownChunks_copy(LodePNGInfo* dest, const LodePNGInfo* src) {
    9250:	55                   	push   %ebp
    9251:	89 e5                	mov    %esp,%ebp
    9253:	83 ec 18             	sub    $0x18,%esp
  unsigned i;

  LodePNGUnknownChunks_cleanup(dest);
    9256:	83 ec 0c             	sub    $0xc,%esp
    9259:	ff 75 08             	pushl  0x8(%ebp)
    925c:	e8 ba ff ff ff       	call   921b <LodePNGUnknownChunks_cleanup>
    9261:	83 c4 10             	add    $0x10,%esp

  for(i = 0; i != 3; ++i) {
    9264:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    926b:	e9 b7 00 00 00       	jmp    9327 <LodePNGUnknownChunks_copy+0xd7>
    size_t j;
    dest->unknown_chunks_size[i] = src->unknown_chunks_size[i];
    9270:	8b 45 0c             	mov    0xc(%ebp),%eax
    9273:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9276:	83 c2 34             	add    $0x34,%edx
    9279:	8b 54 90 08          	mov    0x8(%eax,%edx,4),%edx
    927d:	8b 45 08             	mov    0x8(%ebp),%eax
    9280:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    9283:	83 c1 34             	add    $0x34,%ecx
    9286:	89 54 88 08          	mov    %edx,0x8(%eax,%ecx,4)
    dest->unknown_chunks_data[i] = (unsigned char*)lodepng_malloc(src->unknown_chunks_size[i]);
    928a:	8b 45 0c             	mov    0xc(%ebp),%eax
    928d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9290:	83 c2 34             	add    $0x34,%edx
    9293:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    9297:	83 ec 0c             	sub    $0xc,%esp
    929a:	50                   	push   %eax
    929b:	e8 63 a1 ff ff       	call   3403 <lodepng_malloc>
    92a0:	83 c4 10             	add    $0x10,%esp
    92a3:	89 c1                	mov    %eax,%ecx
    92a5:	8b 45 08             	mov    0x8(%ebp),%eax
    92a8:	8b 55 f4             	mov    -0xc(%ebp),%edx
    92ab:	83 c2 30             	add    $0x30,%edx
    92ae:	89 4c 90 0c          	mov    %ecx,0xc(%eax,%edx,4)
    if(!dest->unknown_chunks_data[i] && dest->unknown_chunks_size[i]) return 83; /*alloc fail*/
    92b2:	8b 45 08             	mov    0x8(%ebp),%eax
    92b5:	8b 55 f4             	mov    -0xc(%ebp),%edx
    92b8:	83 c2 30             	add    $0x30,%edx
    92bb:	8b 44 90 0c          	mov    0xc(%eax,%edx,4),%eax
    92bf:	85 c0                	test   %eax,%eax
    92c1:	75 18                	jne    92db <LodePNGUnknownChunks_copy+0x8b>
    92c3:	8b 45 08             	mov    0x8(%ebp),%eax
    92c6:	8b 55 f4             	mov    -0xc(%ebp),%edx
    92c9:	83 c2 34             	add    $0x34,%edx
    92cc:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    92d0:	85 c0                	test   %eax,%eax
    92d2:	74 07                	je     92db <LodePNGUnknownChunks_copy+0x8b>
    92d4:	b8 53 00 00 00       	mov    $0x53,%eax
    92d9:	eb 5b                	jmp    9336 <LodePNGUnknownChunks_copy+0xe6>
    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {
    92db:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    92e2:	eb 2d                	jmp    9311 <LodePNGUnknownChunks_copy+0xc1>
      dest->unknown_chunks_data[i][j] = src->unknown_chunks_data[i][j];
    92e4:	8b 45 08             	mov    0x8(%ebp),%eax
    92e7:	8b 55 f4             	mov    -0xc(%ebp),%edx
    92ea:	83 c2 30             	add    $0x30,%edx
    92ed:	8b 54 90 0c          	mov    0xc(%eax,%edx,4),%edx
    92f1:	8b 45 f0             	mov    -0x10(%ebp),%eax
    92f4:	01 c2                	add    %eax,%edx
    92f6:	8b 45 0c             	mov    0xc(%ebp),%eax
    92f9:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    92fc:	83 c1 30             	add    $0x30,%ecx
    92ff:	8b 4c 88 0c          	mov    0xc(%eax,%ecx,4),%ecx
    9303:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9306:	01 c8                	add    %ecx,%eax
    9308:	0f b6 00             	movzbl (%eax),%eax
    930b:	88 02                	mov    %al,(%edx)
  for(i = 0; i != 3; ++i) {
    size_t j;
    dest->unknown_chunks_size[i] = src->unknown_chunks_size[i];
    dest->unknown_chunks_data[i] = (unsigned char*)lodepng_malloc(src->unknown_chunks_size[i]);
    if(!dest->unknown_chunks_data[i] && dest->unknown_chunks_size[i]) return 83; /*alloc fail*/
    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {
    930d:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    9311:	8b 45 0c             	mov    0xc(%ebp),%eax
    9314:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9317:	83 c2 34             	add    $0x34,%edx
    931a:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    931e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    9321:	7f c1                	jg     92e4 <LodePNGUnknownChunks_copy+0x94>
static unsigned LodePNGUnknownChunks_copy(LodePNGInfo* dest, const LodePNGInfo* src) {
  unsigned i;

  LodePNGUnknownChunks_cleanup(dest);

  for(i = 0; i != 3; ++i) {
    9323:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9327:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
    932b:	0f 85 3f ff ff ff    	jne    9270 <LodePNGUnknownChunks_copy+0x20>
    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {
      dest->unknown_chunks_data[i][j] = src->unknown_chunks_data[i][j];
    }
  }

  return 0;
    9331:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9336:	c9                   	leave  
    9337:	c3                   	ret    

00009338 <LodePNGText_init>:

/******************************************************************************/

static void LodePNGText_init(LodePNGInfo* info) {
    9338:	55                   	push   %ebp
    9339:	89 e5                	mov    %esp,%ebp
  info->text_num = 0;
    933b:	8b 45 08             	mov    0x8(%ebp),%eax
    933e:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%eax)
  info->text_keys = NULL;
    9345:	8b 45 08             	mov    0x8(%ebp),%eax
    9348:	c7 40 40 00 00 00 00 	movl   $0x0,0x40(%eax)
  info->text_strings = NULL;
    934f:	8b 45 08             	mov    0x8(%ebp),%eax
    9352:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
}
    9359:	90                   	nop
    935a:	5d                   	pop    %ebp
    935b:	c3                   	ret    

0000935c <LodePNGText_cleanup>:

static void LodePNGText_cleanup(LodePNGInfo* info) {
    935c:	55                   	push   %ebp
    935d:	89 e5                	mov    %esp,%ebp
    935f:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  for(i = 0; i != info->text_num; ++i) {
    9362:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9369:	eb 38                	jmp    93a3 <LodePNGText_cleanup+0x47>
    string_cleanup(&info->text_keys[i]);
    936b:	8b 45 08             	mov    0x8(%ebp),%eax
    936e:	8b 40 40             	mov    0x40(%eax),%eax
    9371:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9374:	c1 e2 02             	shl    $0x2,%edx
    9377:	01 d0                	add    %edx,%eax
    9379:	83 ec 0c             	sub    $0xc,%esp
    937c:	50                   	push   %eax
    937d:	e8 75 a3 ff ff       	call   36f7 <string_cleanup>
    9382:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->text_strings[i]);
    9385:	8b 45 08             	mov    0x8(%ebp),%eax
    9388:	8b 40 44             	mov    0x44(%eax),%eax
    938b:	8b 55 f4             	mov    -0xc(%ebp),%edx
    938e:	c1 e2 02             	shl    $0x2,%edx
    9391:	01 d0                	add    %edx,%eax
    9393:	83 ec 0c             	sub    $0xc,%esp
    9396:	50                   	push   %eax
    9397:	e8 5b a3 ff ff       	call   36f7 <string_cleanup>
    939c:	83 c4 10             	add    $0x10,%esp
  info->text_strings = NULL;
}

static void LodePNGText_cleanup(LodePNGInfo* info) {
  size_t i;
  for(i = 0; i != info->text_num; ++i) {
    939f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    93a3:	8b 45 08             	mov    0x8(%ebp),%eax
    93a6:	8b 40 3c             	mov    0x3c(%eax),%eax
    93a9:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    93ac:	75 bd                	jne    936b <LodePNGText_cleanup+0xf>
    string_cleanup(&info->text_keys[i]);
    string_cleanup(&info->text_strings[i]);
  }
  lodepng_free(info->text_keys);
    93ae:	8b 45 08             	mov    0x8(%ebp),%eax
    93b1:	8b 40 40             	mov    0x40(%eax),%eax
    93b4:	83 ec 0c             	sub    $0xc,%esp
    93b7:	50                   	push   %eax
    93b8:	e8 67 a0 ff ff       	call   3424 <lodepng_free>
    93bd:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->text_strings);
    93c0:	8b 45 08             	mov    0x8(%ebp),%eax
    93c3:	8b 40 44             	mov    0x44(%eax),%eax
    93c6:	83 ec 0c             	sub    $0xc,%esp
    93c9:	50                   	push   %eax
    93ca:	e8 55 a0 ff ff       	call   3424 <lodepng_free>
    93cf:	83 c4 10             	add    $0x10,%esp
}
    93d2:	90                   	nop
    93d3:	c9                   	leave  
    93d4:	c3                   	ret    

000093d5 <LodePNGText_copy>:

static unsigned LodePNGText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
    93d5:	55                   	push   %ebp
    93d6:	89 e5                	mov    %esp,%ebp
    93d8:	83 ec 18             	sub    $0x18,%esp
  size_t i = 0;
    93db:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  dest->text_keys = NULL;
    93e2:	8b 45 08             	mov    0x8(%ebp),%eax
    93e5:	c7 40 40 00 00 00 00 	movl   $0x0,0x40(%eax)
  dest->text_strings = NULL;
    93ec:	8b 45 08             	mov    0x8(%ebp),%eax
    93ef:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
  dest->text_num = 0;
    93f6:	8b 45 08             	mov    0x8(%ebp),%eax
    93f9:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%eax)
  for(i = 0; i != source->text_num; ++i) {
    9400:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9407:	eb 42                	jmp    944b <LodePNGText_copy+0x76>
    CERROR_TRY_RETURN(lodepng_add_text(dest, source->text_keys[i], source->text_strings[i]));
    9409:	8b 45 0c             	mov    0xc(%ebp),%eax
    940c:	8b 40 44             	mov    0x44(%eax),%eax
    940f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9412:	c1 e2 02             	shl    $0x2,%edx
    9415:	01 d0                	add    %edx,%eax
    9417:	8b 10                	mov    (%eax),%edx
    9419:	8b 45 0c             	mov    0xc(%ebp),%eax
    941c:	8b 40 40             	mov    0x40(%eax),%eax
    941f:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    9422:	c1 e1 02             	shl    $0x2,%ecx
    9425:	01 c8                	add    %ecx,%eax
    9427:	8b 00                	mov    (%eax),%eax
    9429:	83 ec 04             	sub    $0x4,%esp
    942c:	52                   	push   %edx
    942d:	50                   	push   %eax
    942e:	ff 75 08             	pushl  0x8(%ebp)
    9431:	e8 4d 01 00 00       	call   9583 <lodepng_add_text>
    9436:	83 c4 10             	add    $0x10,%esp
    9439:	89 45 f0             	mov    %eax,-0x10(%ebp)
    943c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    9440:	74 05                	je     9447 <LodePNGText_copy+0x72>
    9442:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9445:	eb 14                	jmp    945b <LodePNGText_copy+0x86>
static unsigned LodePNGText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
  size_t i = 0;
  dest->text_keys = NULL;
  dest->text_strings = NULL;
  dest->text_num = 0;
  for(i = 0; i != source->text_num; ++i) {
    9447:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    944b:	8b 45 0c             	mov    0xc(%ebp),%eax
    944e:	8b 40 3c             	mov    0x3c(%eax),%eax
    9451:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    9454:	75 b3                	jne    9409 <LodePNGText_copy+0x34>
    CERROR_TRY_RETURN(lodepng_add_text(dest, source->text_keys[i], source->text_strings[i]));
  }
  return 0;
    9456:	b8 00 00 00 00       	mov    $0x0,%eax
}
    945b:	c9                   	leave  
    945c:	c3                   	ret    

0000945d <lodepng_add_text_sized>:

static unsigned lodepng_add_text_sized(LodePNGInfo* info, const char* key, const char* str, size_t size) {
    945d:	55                   	push   %ebp
    945e:	89 e5                	mov    %esp,%ebp
    9460:	53                   	push   %ebx
    9461:	83 ec 14             	sub    $0x14,%esp
  char** new_keys = (char**)(lodepng_realloc(info->text_keys, sizeof(char*) * (info->text_num + 1)));
    9464:	8b 45 08             	mov    0x8(%ebp),%eax
    9467:	8b 40 3c             	mov    0x3c(%eax),%eax
    946a:	83 c0 01             	add    $0x1,%eax
    946d:	c1 e0 02             	shl    $0x2,%eax
    9470:	89 c2                	mov    %eax,%edx
    9472:	8b 45 08             	mov    0x8(%ebp),%eax
    9475:	8b 40 40             	mov    0x40(%eax),%eax
    9478:	52                   	push   %edx
    9479:	50                   	push   %eax
    947a:	e8 9b 9f ff ff       	call   341a <lodepng_realloc>
    947f:	83 c4 08             	add    $0x8,%esp
    9482:	89 45 f4             	mov    %eax,-0xc(%ebp)
  char** new_strings = (char**)(lodepng_realloc(info->text_strings, sizeof(char*) * (info->text_num + 1)));
    9485:	8b 45 08             	mov    0x8(%ebp),%eax
    9488:	8b 40 3c             	mov    0x3c(%eax),%eax
    948b:	83 c0 01             	add    $0x1,%eax
    948e:	c1 e0 02             	shl    $0x2,%eax
    9491:	89 c2                	mov    %eax,%edx
    9493:	8b 45 08             	mov    0x8(%ebp),%eax
    9496:	8b 40 44             	mov    0x44(%eax),%eax
    9499:	52                   	push   %edx
    949a:	50                   	push   %eax
    949b:	e8 7a 9f ff ff       	call   341a <lodepng_realloc>
    94a0:	83 c4 08             	add    $0x8,%esp
    94a3:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if(new_keys) info->text_keys = new_keys;
    94a6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    94aa:	74 09                	je     94b5 <lodepng_add_text_sized+0x58>
    94ac:	8b 45 08             	mov    0x8(%ebp),%eax
    94af:	8b 55 f4             	mov    -0xc(%ebp),%edx
    94b2:	89 50 40             	mov    %edx,0x40(%eax)
  if(new_strings) info->text_strings = new_strings;
    94b5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    94b9:	74 09                	je     94c4 <lodepng_add_text_sized+0x67>
    94bb:	8b 45 08             	mov    0x8(%ebp),%eax
    94be:	8b 55 f0             	mov    -0x10(%ebp),%edx
    94c1:	89 50 44             	mov    %edx,0x44(%eax)

  if(!new_keys || !new_strings) return 83; /*alloc fail*/
    94c4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    94c8:	74 06                	je     94d0 <lodepng_add_text_sized+0x73>
    94ca:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    94ce:	75 0a                	jne    94da <lodepng_add_text_sized+0x7d>
    94d0:	b8 53 00 00 00       	mov    $0x53,%eax
    94d5:	e9 a4 00 00 00       	jmp    957e <lodepng_add_text_sized+0x121>

  ++info->text_num;
    94da:	8b 45 08             	mov    0x8(%ebp),%eax
    94dd:	8b 40 3c             	mov    0x3c(%eax),%eax
    94e0:	8d 50 01             	lea    0x1(%eax),%edx
    94e3:	8b 45 08             	mov    0x8(%ebp),%eax
    94e6:	89 50 3c             	mov    %edx,0x3c(%eax)
  info->text_keys[info->text_num - 1] = alloc_string(key);
    94e9:	8b 45 08             	mov    0x8(%ebp),%eax
    94ec:	8b 50 40             	mov    0x40(%eax),%edx
    94ef:	8b 45 08             	mov    0x8(%ebp),%eax
    94f2:	8b 40 3c             	mov    0x3c(%eax),%eax
    94f5:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    94fa:	c1 e0 02             	shl    $0x2,%eax
    94fd:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    9500:	83 ec 0c             	sub    $0xc,%esp
    9503:	ff 75 0c             	pushl  0xc(%ebp)
    9506:	e8 54 a2 ff ff       	call   375f <alloc_string>
    950b:	83 c4 10             	add    $0x10,%esp
    950e:	89 03                	mov    %eax,(%ebx)
  info->text_strings[info->text_num - 1] = alloc_string_sized(str, size);
    9510:	8b 45 08             	mov    0x8(%ebp),%eax
    9513:	8b 50 44             	mov    0x44(%eax),%edx
    9516:	8b 45 08             	mov    0x8(%ebp),%eax
    9519:	8b 40 3c             	mov    0x3c(%eax),%eax
    951c:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    9521:	c1 e0 02             	shl    $0x2,%eax
    9524:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    9527:	83 ec 08             	sub    $0x8,%esp
    952a:	ff 75 14             	pushl  0x14(%ebp)
    952d:	ff 75 10             	pushl  0x10(%ebp)
    9530:	e8 e5 a1 ff ff       	call   371a <alloc_string_sized>
    9535:	83 c4 10             	add    $0x10,%esp
    9538:	89 03                	mov    %eax,(%ebx)
  if(!info->text_keys[info->text_num - 1] || !info->text_strings[info->text_num - 1]) return 83; /*alloc fail*/
    953a:	8b 45 08             	mov    0x8(%ebp),%eax
    953d:	8b 50 40             	mov    0x40(%eax),%edx
    9540:	8b 45 08             	mov    0x8(%ebp),%eax
    9543:	8b 40 3c             	mov    0x3c(%eax),%eax
    9546:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    954b:	c1 e0 02             	shl    $0x2,%eax
    954e:	01 d0                	add    %edx,%eax
    9550:	8b 00                	mov    (%eax),%eax
    9552:	85 c0                	test   %eax,%eax
    9554:	74 1c                	je     9572 <lodepng_add_text_sized+0x115>
    9556:	8b 45 08             	mov    0x8(%ebp),%eax
    9559:	8b 50 44             	mov    0x44(%eax),%edx
    955c:	8b 45 08             	mov    0x8(%ebp),%eax
    955f:	8b 40 3c             	mov    0x3c(%eax),%eax
    9562:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    9567:	c1 e0 02             	shl    $0x2,%eax
    956a:	01 d0                	add    %edx,%eax
    956c:	8b 00                	mov    (%eax),%eax
    956e:	85 c0                	test   %eax,%eax
    9570:	75 07                	jne    9579 <lodepng_add_text_sized+0x11c>
    9572:	b8 53 00 00 00       	mov    $0x53,%eax
    9577:	eb 05                	jmp    957e <lodepng_add_text_sized+0x121>

  return 0;
    9579:	b8 00 00 00 00       	mov    $0x0,%eax
}
    957e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    9581:	c9                   	leave  
    9582:	c3                   	ret    

00009583 <lodepng_add_text>:

unsigned lodepng_add_text(LodePNGInfo* info, const char* key, const char* str) {
    9583:	55                   	push   %ebp
    9584:	89 e5                	mov    %esp,%ebp
    9586:	83 ec 08             	sub    $0x8,%esp
  return lodepng_add_text_sized(info, key, str, lodepng_strlen(str));
    9589:	ff 75 10             	pushl  0x10(%ebp)
    958c:	e8 0e 9f ff ff       	call   349f <lodepng_strlen>
    9591:	83 c4 04             	add    $0x4,%esp
    9594:	50                   	push   %eax
    9595:	ff 75 10             	pushl  0x10(%ebp)
    9598:	ff 75 0c             	pushl  0xc(%ebp)
    959b:	ff 75 08             	pushl  0x8(%ebp)
    959e:	e8 ba fe ff ff       	call   945d <lodepng_add_text_sized>
    95a3:	83 c4 10             	add    $0x10,%esp
}
    95a6:	c9                   	leave  
    95a7:	c3                   	ret    

000095a8 <lodepng_clear_text>:

void lodepng_clear_text(LodePNGInfo* info) {
    95a8:	55                   	push   %ebp
    95a9:	89 e5                	mov    %esp,%ebp
    95ab:	83 ec 08             	sub    $0x8,%esp
  LodePNGText_cleanup(info);
    95ae:	83 ec 0c             	sub    $0xc,%esp
    95b1:	ff 75 08             	pushl  0x8(%ebp)
    95b4:	e8 a3 fd ff ff       	call   935c <LodePNGText_cleanup>
    95b9:	83 c4 10             	add    $0x10,%esp
}
    95bc:	90                   	nop
    95bd:	c9                   	leave  
    95be:	c3                   	ret    

000095bf <LodePNGIText_init>:

/******************************************************************************/

static void LodePNGIText_init(LodePNGInfo* info) {
    95bf:	55                   	push   %ebp
    95c0:	89 e5                	mov    %esp,%ebp
  info->itext_num = 0;
    95c2:	8b 45 08             	mov    0x8(%ebp),%eax
    95c5:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
  info->itext_keys = NULL;
    95cc:	8b 45 08             	mov    0x8(%ebp),%eax
    95cf:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
  info->itext_langtags = NULL;
    95d6:	8b 45 08             	mov    0x8(%ebp),%eax
    95d9:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
  info->itext_transkeys = NULL;
    95e0:	8b 45 08             	mov    0x8(%ebp),%eax
    95e3:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%eax)
  info->itext_strings = NULL;
    95ea:	8b 45 08             	mov    0x8(%ebp),%eax
    95ed:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
}
    95f4:	90                   	nop
    95f5:	5d                   	pop    %ebp
    95f6:	c3                   	ret    

000095f7 <LodePNGIText_cleanup>:

static void LodePNGIText_cleanup(LodePNGInfo* info) {
    95f7:	55                   	push   %ebp
    95f8:	89 e5                	mov    %esp,%ebp
    95fa:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  for(i = 0; i != info->itext_num; ++i) {
    95fd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9604:	eb 6c                	jmp    9672 <LodePNGIText_cleanup+0x7b>
    string_cleanup(&info->itext_keys[i]);
    9606:	8b 45 08             	mov    0x8(%ebp),%eax
    9609:	8b 40 4c             	mov    0x4c(%eax),%eax
    960c:	8b 55 f4             	mov    -0xc(%ebp),%edx
    960f:	c1 e2 02             	shl    $0x2,%edx
    9612:	01 d0                	add    %edx,%eax
    9614:	83 ec 0c             	sub    $0xc,%esp
    9617:	50                   	push   %eax
    9618:	e8 da a0 ff ff       	call   36f7 <string_cleanup>
    961d:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->itext_langtags[i]);
    9620:	8b 45 08             	mov    0x8(%ebp),%eax
    9623:	8b 40 50             	mov    0x50(%eax),%eax
    9626:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9629:	c1 e2 02             	shl    $0x2,%edx
    962c:	01 d0                	add    %edx,%eax
    962e:	83 ec 0c             	sub    $0xc,%esp
    9631:	50                   	push   %eax
    9632:	e8 c0 a0 ff ff       	call   36f7 <string_cleanup>
    9637:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->itext_transkeys[i]);
    963a:	8b 45 08             	mov    0x8(%ebp),%eax
    963d:	8b 40 54             	mov    0x54(%eax),%eax
    9640:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9643:	c1 e2 02             	shl    $0x2,%edx
    9646:	01 d0                	add    %edx,%eax
    9648:	83 ec 0c             	sub    $0xc,%esp
    964b:	50                   	push   %eax
    964c:	e8 a6 a0 ff ff       	call   36f7 <string_cleanup>
    9651:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->itext_strings[i]);
    9654:	8b 45 08             	mov    0x8(%ebp),%eax
    9657:	8b 40 58             	mov    0x58(%eax),%eax
    965a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    965d:	c1 e2 02             	shl    $0x2,%edx
    9660:	01 d0                	add    %edx,%eax
    9662:	83 ec 0c             	sub    $0xc,%esp
    9665:	50                   	push   %eax
    9666:	e8 8c a0 ff ff       	call   36f7 <string_cleanup>
    966b:	83 c4 10             	add    $0x10,%esp
  info->itext_strings = NULL;
}

static void LodePNGIText_cleanup(LodePNGInfo* info) {
  size_t i;
  for(i = 0; i != info->itext_num; ++i) {
    966e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9672:	8b 45 08             	mov    0x8(%ebp),%eax
    9675:	8b 40 48             	mov    0x48(%eax),%eax
    9678:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    967b:	75 89                	jne    9606 <LodePNGIText_cleanup+0xf>
    string_cleanup(&info->itext_keys[i]);
    string_cleanup(&info->itext_langtags[i]);
    string_cleanup(&info->itext_transkeys[i]);
    string_cleanup(&info->itext_strings[i]);
  }
  lodepng_free(info->itext_keys);
    967d:	8b 45 08             	mov    0x8(%ebp),%eax
    9680:	8b 40 4c             	mov    0x4c(%eax),%eax
    9683:	83 ec 0c             	sub    $0xc,%esp
    9686:	50                   	push   %eax
    9687:	e8 98 9d ff ff       	call   3424 <lodepng_free>
    968c:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->itext_langtags);
    968f:	8b 45 08             	mov    0x8(%ebp),%eax
    9692:	8b 40 50             	mov    0x50(%eax),%eax
    9695:	83 ec 0c             	sub    $0xc,%esp
    9698:	50                   	push   %eax
    9699:	e8 86 9d ff ff       	call   3424 <lodepng_free>
    969e:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->itext_transkeys);
    96a1:	8b 45 08             	mov    0x8(%ebp),%eax
    96a4:	8b 40 54             	mov    0x54(%eax),%eax
    96a7:	83 ec 0c             	sub    $0xc,%esp
    96aa:	50                   	push   %eax
    96ab:	e8 74 9d ff ff       	call   3424 <lodepng_free>
    96b0:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->itext_strings);
    96b3:	8b 45 08             	mov    0x8(%ebp),%eax
    96b6:	8b 40 58             	mov    0x58(%eax),%eax
    96b9:	83 ec 0c             	sub    $0xc,%esp
    96bc:	50                   	push   %eax
    96bd:	e8 62 9d ff ff       	call   3424 <lodepng_free>
    96c2:	83 c4 10             	add    $0x10,%esp
}
    96c5:	90                   	nop
    96c6:	c9                   	leave  
    96c7:	c3                   	ret    

000096c8 <LodePNGIText_copy>:

static unsigned LodePNGIText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
    96c8:	55                   	push   %ebp
    96c9:	89 e5                	mov    %esp,%ebp
    96cb:	56                   	push   %esi
    96cc:	53                   	push   %ebx
    96cd:	83 ec 10             	sub    $0x10,%esp
  size_t i = 0;
    96d0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  dest->itext_keys = NULL;
    96d7:	8b 45 08             	mov    0x8(%ebp),%eax
    96da:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
  dest->itext_langtags = NULL;
    96e1:	8b 45 08             	mov    0x8(%ebp),%eax
    96e4:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
  dest->itext_transkeys = NULL;
    96eb:	8b 45 08             	mov    0x8(%ebp),%eax
    96ee:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%eax)
  dest->itext_strings = NULL;
    96f5:	8b 45 08             	mov    0x8(%ebp),%eax
    96f8:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
  dest->itext_num = 0;
    96ff:	8b 45 08             	mov    0x8(%ebp),%eax
    9702:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
  for(i = 0; i != source->itext_num; ++i) {
    9709:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9710:	eb 64                	jmp    9776 <LodePNGIText_copy+0xae>
    CERROR_TRY_RETURN(lodepng_add_itext(dest, source->itext_keys[i], source->itext_langtags[i],
    9712:	8b 45 0c             	mov    0xc(%ebp),%eax
    9715:	8b 40 58             	mov    0x58(%eax),%eax
    9718:	8b 55 f4             	mov    -0xc(%ebp),%edx
    971b:	c1 e2 02             	shl    $0x2,%edx
    971e:	01 d0                	add    %edx,%eax
    9720:	8b 18                	mov    (%eax),%ebx
    9722:	8b 45 0c             	mov    0xc(%ebp),%eax
    9725:	8b 40 54             	mov    0x54(%eax),%eax
    9728:	8b 55 f4             	mov    -0xc(%ebp),%edx
    972b:	c1 e2 02             	shl    $0x2,%edx
    972e:	01 d0                	add    %edx,%eax
    9730:	8b 08                	mov    (%eax),%ecx
    9732:	8b 45 0c             	mov    0xc(%ebp),%eax
    9735:	8b 40 50             	mov    0x50(%eax),%eax
    9738:	8b 55 f4             	mov    -0xc(%ebp),%edx
    973b:	c1 e2 02             	shl    $0x2,%edx
    973e:	01 d0                	add    %edx,%eax
    9740:	8b 10                	mov    (%eax),%edx
    9742:	8b 45 0c             	mov    0xc(%ebp),%eax
    9745:	8b 40 4c             	mov    0x4c(%eax),%eax
    9748:	8b 75 f4             	mov    -0xc(%ebp),%esi
    974b:	c1 e6 02             	shl    $0x2,%esi
    974e:	01 f0                	add    %esi,%eax
    9750:	8b 00                	mov    (%eax),%eax
    9752:	83 ec 0c             	sub    $0xc,%esp
    9755:	53                   	push   %ebx
    9756:	51                   	push   %ecx
    9757:	52                   	push   %edx
    9758:	50                   	push   %eax
    9759:	ff 75 08             	pushl  0x8(%ebp)
    975c:	e8 e4 01 00 00       	call   9945 <lodepng_add_itext>
    9761:	83 c4 20             	add    $0x20,%esp
    9764:	89 45 f0             	mov    %eax,-0x10(%ebp)
    9767:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    976b:	74 05                	je     9772 <LodePNGIText_copy+0xaa>
    976d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9770:	eb 14                	jmp    9786 <LodePNGIText_copy+0xbe>
  dest->itext_keys = NULL;
  dest->itext_langtags = NULL;
  dest->itext_transkeys = NULL;
  dest->itext_strings = NULL;
  dest->itext_num = 0;
  for(i = 0; i != source->itext_num; ++i) {
    9772:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9776:	8b 45 0c             	mov    0xc(%ebp),%eax
    9779:	8b 40 48             	mov    0x48(%eax),%eax
    977c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    977f:	75 91                	jne    9712 <LodePNGIText_copy+0x4a>
    CERROR_TRY_RETURN(lodepng_add_itext(dest, source->itext_keys[i], source->itext_langtags[i],
                                        source->itext_transkeys[i], source->itext_strings[i]));
  }
  return 0;
    9781:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9786:	8d 65 f8             	lea    -0x8(%ebp),%esp
    9789:	5b                   	pop    %ebx
    978a:	5e                   	pop    %esi
    978b:	5d                   	pop    %ebp
    978c:	c3                   	ret    

0000978d <lodepng_clear_itext>:

void lodepng_clear_itext(LodePNGInfo* info) {
    978d:	55                   	push   %ebp
    978e:	89 e5                	mov    %esp,%ebp
    9790:	83 ec 08             	sub    $0x8,%esp
  LodePNGIText_cleanup(info);
    9793:	83 ec 0c             	sub    $0xc,%esp
    9796:	ff 75 08             	pushl  0x8(%ebp)
    9799:	e8 59 fe ff ff       	call   95f7 <LodePNGIText_cleanup>
    979e:	83 c4 10             	add    $0x10,%esp
}
    97a1:	90                   	nop
    97a2:	c9                   	leave  
    97a3:	c3                   	ret    

000097a4 <lodepng_add_itext_sized>:

static unsigned lodepng_add_itext_sized(LodePNGInfo* info, const char* key, const char* langtag,
                                        const char* transkey, const char* str, size_t size) {
    97a4:	55                   	push   %ebp
    97a5:	89 e5                	mov    %esp,%ebp
    97a7:	53                   	push   %ebx
    97a8:	83 ec 14             	sub    $0x14,%esp
  char** new_keys = (char**)(lodepng_realloc(info->itext_keys, sizeof(char*) * (info->itext_num + 1)));
    97ab:	8b 45 08             	mov    0x8(%ebp),%eax
    97ae:	8b 40 48             	mov    0x48(%eax),%eax
    97b1:	83 c0 01             	add    $0x1,%eax
    97b4:	c1 e0 02             	shl    $0x2,%eax
    97b7:	89 c2                	mov    %eax,%edx
    97b9:	8b 45 08             	mov    0x8(%ebp),%eax
    97bc:	8b 40 4c             	mov    0x4c(%eax),%eax
    97bf:	52                   	push   %edx
    97c0:	50                   	push   %eax
    97c1:	e8 54 9c ff ff       	call   341a <lodepng_realloc>
    97c6:	83 c4 08             	add    $0x8,%esp
    97c9:	89 45 f4             	mov    %eax,-0xc(%ebp)
  char** new_langtags = (char**)(lodepng_realloc(info->itext_langtags, sizeof(char*) * (info->itext_num + 1)));
    97cc:	8b 45 08             	mov    0x8(%ebp),%eax
    97cf:	8b 40 48             	mov    0x48(%eax),%eax
    97d2:	83 c0 01             	add    $0x1,%eax
    97d5:	c1 e0 02             	shl    $0x2,%eax
    97d8:	89 c2                	mov    %eax,%edx
    97da:	8b 45 08             	mov    0x8(%ebp),%eax
    97dd:	8b 40 50             	mov    0x50(%eax),%eax
    97e0:	52                   	push   %edx
    97e1:	50                   	push   %eax
    97e2:	e8 33 9c ff ff       	call   341a <lodepng_realloc>
    97e7:	83 c4 08             	add    $0x8,%esp
    97ea:	89 45 f0             	mov    %eax,-0x10(%ebp)
  char** new_transkeys = (char**)(lodepng_realloc(info->itext_transkeys, sizeof(char*) * (info->itext_num + 1)));
    97ed:	8b 45 08             	mov    0x8(%ebp),%eax
    97f0:	8b 40 48             	mov    0x48(%eax),%eax
    97f3:	83 c0 01             	add    $0x1,%eax
    97f6:	c1 e0 02             	shl    $0x2,%eax
    97f9:	89 c2                	mov    %eax,%edx
    97fb:	8b 45 08             	mov    0x8(%ebp),%eax
    97fe:	8b 40 54             	mov    0x54(%eax),%eax
    9801:	52                   	push   %edx
    9802:	50                   	push   %eax
    9803:	e8 12 9c ff ff       	call   341a <lodepng_realloc>
    9808:	83 c4 08             	add    $0x8,%esp
    980b:	89 45 ec             	mov    %eax,-0x14(%ebp)
  char** new_strings = (char**)(lodepng_realloc(info->itext_strings, sizeof(char*) * (info->itext_num + 1)));
    980e:	8b 45 08             	mov    0x8(%ebp),%eax
    9811:	8b 40 48             	mov    0x48(%eax),%eax
    9814:	83 c0 01             	add    $0x1,%eax
    9817:	c1 e0 02             	shl    $0x2,%eax
    981a:	89 c2                	mov    %eax,%edx
    981c:	8b 45 08             	mov    0x8(%ebp),%eax
    981f:	8b 40 58             	mov    0x58(%eax),%eax
    9822:	52                   	push   %edx
    9823:	50                   	push   %eax
    9824:	e8 f1 9b ff ff       	call   341a <lodepng_realloc>
    9829:	83 c4 08             	add    $0x8,%esp
    982c:	89 45 e8             	mov    %eax,-0x18(%ebp)

  if(new_keys) info->itext_keys = new_keys;
    982f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    9833:	74 09                	je     983e <lodepng_add_itext_sized+0x9a>
    9835:	8b 45 08             	mov    0x8(%ebp),%eax
    9838:	8b 55 f4             	mov    -0xc(%ebp),%edx
    983b:	89 50 4c             	mov    %edx,0x4c(%eax)
  if(new_langtags) info->itext_langtags = new_langtags;
    983e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    9842:	74 09                	je     984d <lodepng_add_itext_sized+0xa9>
    9844:	8b 45 08             	mov    0x8(%ebp),%eax
    9847:	8b 55 f0             	mov    -0x10(%ebp),%edx
    984a:	89 50 50             	mov    %edx,0x50(%eax)
  if(new_transkeys) info->itext_transkeys = new_transkeys;
    984d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    9851:	74 09                	je     985c <lodepng_add_itext_sized+0xb8>
    9853:	8b 45 08             	mov    0x8(%ebp),%eax
    9856:	8b 55 ec             	mov    -0x14(%ebp),%edx
    9859:	89 50 54             	mov    %edx,0x54(%eax)
  if(new_strings) info->itext_strings = new_strings;
    985c:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    9860:	74 09                	je     986b <lodepng_add_itext_sized+0xc7>
    9862:	8b 45 08             	mov    0x8(%ebp),%eax
    9865:	8b 55 e8             	mov    -0x18(%ebp),%edx
    9868:	89 50 58             	mov    %edx,0x58(%eax)

  if(!new_keys || !new_langtags || !new_transkeys || !new_strings) return 83; /*alloc fail*/
    986b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    986f:	74 12                	je     9883 <lodepng_add_itext_sized+0xdf>
    9871:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    9875:	74 0c                	je     9883 <lodepng_add_itext_sized+0xdf>
    9877:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    987b:	74 06                	je     9883 <lodepng_add_itext_sized+0xdf>
    987d:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    9881:	75 0a                	jne    988d <lodepng_add_itext_sized+0xe9>
    9883:	b8 53 00 00 00       	mov    $0x53,%eax
    9888:	e9 b3 00 00 00       	jmp    9940 <lodepng_add_itext_sized+0x19c>

  ++info->itext_num;
    988d:	8b 45 08             	mov    0x8(%ebp),%eax
    9890:	8b 40 48             	mov    0x48(%eax),%eax
    9893:	8d 50 01             	lea    0x1(%eax),%edx
    9896:	8b 45 08             	mov    0x8(%ebp),%eax
    9899:	89 50 48             	mov    %edx,0x48(%eax)

  info->itext_keys[info->itext_num - 1] = alloc_string(key);
    989c:	8b 45 08             	mov    0x8(%ebp),%eax
    989f:	8b 50 4c             	mov    0x4c(%eax),%edx
    98a2:	8b 45 08             	mov    0x8(%ebp),%eax
    98a5:	8b 40 48             	mov    0x48(%eax),%eax
    98a8:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    98ad:	c1 e0 02             	shl    $0x2,%eax
    98b0:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    98b3:	83 ec 0c             	sub    $0xc,%esp
    98b6:	ff 75 0c             	pushl  0xc(%ebp)
    98b9:	e8 a1 9e ff ff       	call   375f <alloc_string>
    98be:	83 c4 10             	add    $0x10,%esp
    98c1:	89 03                	mov    %eax,(%ebx)
  info->itext_langtags[info->itext_num - 1] = alloc_string(langtag);
    98c3:	8b 45 08             	mov    0x8(%ebp),%eax
    98c6:	8b 50 50             	mov    0x50(%eax),%edx
    98c9:	8b 45 08             	mov    0x8(%ebp),%eax
    98cc:	8b 40 48             	mov    0x48(%eax),%eax
    98cf:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    98d4:	c1 e0 02             	shl    $0x2,%eax
    98d7:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    98da:	83 ec 0c             	sub    $0xc,%esp
    98dd:	ff 75 10             	pushl  0x10(%ebp)
    98e0:	e8 7a 9e ff ff       	call   375f <alloc_string>
    98e5:	83 c4 10             	add    $0x10,%esp
    98e8:	89 03                	mov    %eax,(%ebx)
  info->itext_transkeys[info->itext_num - 1] = alloc_string(transkey);
    98ea:	8b 45 08             	mov    0x8(%ebp),%eax
    98ed:	8b 50 54             	mov    0x54(%eax),%edx
    98f0:	8b 45 08             	mov    0x8(%ebp),%eax
    98f3:	8b 40 48             	mov    0x48(%eax),%eax
    98f6:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    98fb:	c1 e0 02             	shl    $0x2,%eax
    98fe:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    9901:	83 ec 0c             	sub    $0xc,%esp
    9904:	ff 75 14             	pushl  0x14(%ebp)
    9907:	e8 53 9e ff ff       	call   375f <alloc_string>
    990c:	83 c4 10             	add    $0x10,%esp
    990f:	89 03                	mov    %eax,(%ebx)
  info->itext_strings[info->itext_num - 1] = alloc_string_sized(str, size);
    9911:	8b 45 08             	mov    0x8(%ebp),%eax
    9914:	8b 50 58             	mov    0x58(%eax),%edx
    9917:	8b 45 08             	mov    0x8(%ebp),%eax
    991a:	8b 40 48             	mov    0x48(%eax),%eax
    991d:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    9922:	c1 e0 02             	shl    $0x2,%eax
    9925:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    9928:	83 ec 08             	sub    $0x8,%esp
    992b:	ff 75 1c             	pushl  0x1c(%ebp)
    992e:	ff 75 18             	pushl  0x18(%ebp)
    9931:	e8 e4 9d ff ff       	call   371a <alloc_string_sized>
    9936:	83 c4 10             	add    $0x10,%esp
    9939:	89 03                	mov    %eax,(%ebx)

  return 0;
    993b:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9940:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    9943:	c9                   	leave  
    9944:	c3                   	ret    

00009945 <lodepng_add_itext>:

unsigned lodepng_add_itext(LodePNGInfo* info, const char* key, const char* langtag,
                           const char* transkey, const char* str) {
    9945:	55                   	push   %ebp
    9946:	89 e5                	mov    %esp,%ebp
    9948:	83 ec 08             	sub    $0x8,%esp
  return lodepng_add_itext_sized(info, key, langtag, transkey, str, lodepng_strlen(str));
    994b:	ff 75 18             	pushl  0x18(%ebp)
    994e:	e8 4c 9b ff ff       	call   349f <lodepng_strlen>
    9953:	83 c4 04             	add    $0x4,%esp
    9956:	83 ec 08             	sub    $0x8,%esp
    9959:	50                   	push   %eax
    995a:	ff 75 18             	pushl  0x18(%ebp)
    995d:	ff 75 14             	pushl  0x14(%ebp)
    9960:	ff 75 10             	pushl  0x10(%ebp)
    9963:	ff 75 0c             	pushl  0xc(%ebp)
    9966:	ff 75 08             	pushl  0x8(%ebp)
    9969:	e8 36 fe ff ff       	call   97a4 <lodepng_add_itext_sized>
    996e:	83 c4 20             	add    $0x20,%esp
}
    9971:	c9                   	leave  
    9972:	c3                   	ret    

00009973 <lodepng_assign_icc>:

/* same as set but does not delete */
static unsigned lodepng_assign_icc(LodePNGInfo* info, const char* name, const unsigned char* profile, unsigned profile_size) {
    9973:	55                   	push   %ebp
    9974:	89 e5                	mov    %esp,%ebp
    9976:	83 ec 08             	sub    $0x8,%esp
  if(profile_size == 0) return 100; /*invalid ICC profile size*/
    9979:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    997d:	75 0a                	jne    9989 <lodepng_assign_icc+0x16>
    997f:	b8 64 00 00 00       	mov    $0x64,%eax
    9984:	e9 81 00 00 00       	jmp    9a0a <lodepng_assign_icc+0x97>

  info->iccp_name = alloc_string(name);
    9989:	83 ec 0c             	sub    $0xc,%esp
    998c:	ff 75 0c             	pushl  0xc(%ebp)
    998f:	e8 cb 9d ff ff       	call   375f <alloc_string>
    9994:	83 c4 10             	add    $0x10,%esp
    9997:	89 c2                	mov    %eax,%edx
    9999:	8b 45 08             	mov    0x8(%ebp),%eax
    999c:	89 90 c0 00 00 00    	mov    %edx,0xc0(%eax)
  info->iccp_profile = (unsigned char*)lodepng_malloc(profile_size);
    99a2:	8b 45 14             	mov    0x14(%ebp),%eax
    99a5:	83 ec 0c             	sub    $0xc,%esp
    99a8:	50                   	push   %eax
    99a9:	e8 55 9a ff ff       	call   3403 <lodepng_malloc>
    99ae:	83 c4 10             	add    $0x10,%esp
    99b1:	89 c2                	mov    %eax,%edx
    99b3:	8b 45 08             	mov    0x8(%ebp),%eax
    99b6:	89 90 c4 00 00 00    	mov    %edx,0xc4(%eax)

  if(!info->iccp_name || !info->iccp_profile) return 83; /*alloc fail*/
    99bc:	8b 45 08             	mov    0x8(%ebp),%eax
    99bf:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    99c5:	85 c0                	test   %eax,%eax
    99c7:	74 0d                	je     99d6 <lodepng_assign_icc+0x63>
    99c9:	8b 45 08             	mov    0x8(%ebp),%eax
    99cc:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
    99d2:	85 c0                	test   %eax,%eax
    99d4:	75 07                	jne    99dd <lodepng_assign_icc+0x6a>
    99d6:	b8 53 00 00 00       	mov    $0x53,%eax
    99db:	eb 2d                	jmp    9a0a <lodepng_assign_icc+0x97>

  lodepng_memcpy(info->iccp_profile, profile, profile_size);
    99dd:	8b 55 14             	mov    0x14(%ebp),%edx
    99e0:	8b 45 08             	mov    0x8(%ebp),%eax
    99e3:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
    99e9:	83 ec 04             	sub    $0x4,%esp
    99ec:	52                   	push   %edx
    99ed:	ff 75 10             	pushl  0x10(%ebp)
    99f0:	50                   	push   %eax
    99f1:	e8 4b 9a ff ff       	call   3441 <lodepng_memcpy>
    99f6:	83 c4 10             	add    $0x10,%esp
  info->iccp_profile_size = profile_size;
    99f9:	8b 45 08             	mov    0x8(%ebp),%eax
    99fc:	8b 55 14             	mov    0x14(%ebp),%edx
    99ff:	89 90 c8 00 00 00    	mov    %edx,0xc8(%eax)

  return 0; /*ok*/
    9a05:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9a0a:	c9                   	leave  
    9a0b:	c3                   	ret    

00009a0c <lodepng_set_icc>:

unsigned lodepng_set_icc(LodePNGInfo* info, const char* name, const unsigned char* profile, unsigned profile_size) {
    9a0c:	55                   	push   %ebp
    9a0d:	89 e5                	mov    %esp,%ebp
    9a0f:	83 ec 08             	sub    $0x8,%esp
  if(info->iccp_name) lodepng_clear_icc(info);
    9a12:	8b 45 08             	mov    0x8(%ebp),%eax
    9a15:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    9a1b:	85 c0                	test   %eax,%eax
    9a1d:	74 0e                	je     9a2d <lodepng_set_icc+0x21>
    9a1f:	83 ec 0c             	sub    $0xc,%esp
    9a22:	ff 75 08             	pushl  0x8(%ebp)
    9a25:	e8 26 00 00 00       	call   9a50 <lodepng_clear_icc>
    9a2a:	83 c4 10             	add    $0x10,%esp
  info->iccp_defined = 1;
    9a2d:	8b 45 08             	mov    0x8(%ebp),%eax
    9a30:	c7 80 bc 00 00 00 01 	movl   $0x1,0xbc(%eax)
    9a37:	00 00 00 

  return lodepng_assign_icc(info, name, profile, profile_size);
    9a3a:	ff 75 14             	pushl  0x14(%ebp)
    9a3d:	ff 75 10             	pushl  0x10(%ebp)
    9a40:	ff 75 0c             	pushl  0xc(%ebp)
    9a43:	ff 75 08             	pushl  0x8(%ebp)
    9a46:	e8 28 ff ff ff       	call   9973 <lodepng_assign_icc>
    9a4b:	83 c4 10             	add    $0x10,%esp
}
    9a4e:	c9                   	leave  
    9a4f:	c3                   	ret    

00009a50 <lodepng_clear_icc>:

void lodepng_clear_icc(LodePNGInfo* info) {
    9a50:	55                   	push   %ebp
    9a51:	89 e5                	mov    %esp,%ebp
    9a53:	83 ec 08             	sub    $0x8,%esp
  string_cleanup(&info->iccp_name);
    9a56:	8b 45 08             	mov    0x8(%ebp),%eax
    9a59:	05 c0 00 00 00       	add    $0xc0,%eax
    9a5e:	83 ec 0c             	sub    $0xc,%esp
    9a61:	50                   	push   %eax
    9a62:	e8 90 9c ff ff       	call   36f7 <string_cleanup>
    9a67:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->iccp_profile);
    9a6a:	8b 45 08             	mov    0x8(%ebp),%eax
    9a6d:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
    9a73:	83 ec 0c             	sub    $0xc,%esp
    9a76:	50                   	push   %eax
    9a77:	e8 a8 99 ff ff       	call   3424 <lodepng_free>
    9a7c:	83 c4 10             	add    $0x10,%esp
  info->iccp_profile = NULL;
    9a7f:	8b 45 08             	mov    0x8(%ebp),%eax
    9a82:	c7 80 c4 00 00 00 00 	movl   $0x0,0xc4(%eax)
    9a89:	00 00 00 
  info->iccp_profile_size = 0;
    9a8c:	8b 45 08             	mov    0x8(%ebp),%eax
    9a8f:	c7 80 c8 00 00 00 00 	movl   $0x0,0xc8(%eax)
    9a96:	00 00 00 
  info->iccp_defined = 0;
    9a99:	8b 45 08             	mov    0x8(%ebp),%eax
    9a9c:	c7 80 bc 00 00 00 00 	movl   $0x0,0xbc(%eax)
    9aa3:	00 00 00 
}
    9aa6:	90                   	nop
    9aa7:	c9                   	leave  
    9aa8:	c3                   	ret    

00009aa9 <lodepng_info_init>:
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

void lodepng_info_init(LodePNGInfo* info) {
    9aa9:	55                   	push   %ebp
    9aaa:	89 e5                	mov    %esp,%ebp
  lodepng_color_mode_init(&info->color);
    9aac:	8b 45 08             	mov    0x8(%ebp),%eax
    9aaf:	83 c0 0c             	add    $0xc,%eax
    9ab2:	50                   	push   %eax
    9ab3:	e8 5a f0 ff ff       	call   8b12 <lodepng_color_mode_init>
    9ab8:	83 c4 04             	add    $0x4,%esp
  info->interlace_method = 0;
    9abb:	8b 45 08             	mov    0x8(%ebp),%eax
    9abe:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  info->compression_method = 0;
    9ac5:	8b 45 08             	mov    0x8(%ebp),%eax
    9ac8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  info->filter_method = 0;
    9ace:	8b 45 08             	mov    0x8(%ebp),%eax
    9ad1:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  info->background_defined = 0;
    9ad8:	8b 45 08             	mov    0x8(%ebp),%eax
    9adb:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
  info->background_r = info->background_g = info->background_b = 0;
    9ae2:	8b 45 08             	mov    0x8(%ebp),%eax
    9ae5:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
    9aec:	8b 45 08             	mov    0x8(%ebp),%eax
    9aef:	8b 50 38             	mov    0x38(%eax),%edx
    9af2:	8b 45 08             	mov    0x8(%ebp),%eax
    9af5:	89 50 34             	mov    %edx,0x34(%eax)
    9af8:	8b 45 08             	mov    0x8(%ebp),%eax
    9afb:	8b 50 34             	mov    0x34(%eax),%edx
    9afe:	8b 45 08             	mov    0x8(%ebp),%eax
    9b01:	89 50 30             	mov    %edx,0x30(%eax)

  LodePNGText_init(info);
    9b04:	ff 75 08             	pushl  0x8(%ebp)
    9b07:	e8 2c f8 ff ff       	call   9338 <LodePNGText_init>
    9b0c:	83 c4 04             	add    $0x4,%esp
  LodePNGIText_init(info);
    9b0f:	ff 75 08             	pushl  0x8(%ebp)
    9b12:	e8 a8 fa ff ff       	call   95bf <LodePNGIText_init>
    9b17:	83 c4 04             	add    $0x4,%esp

  info->time_defined = 0;
    9b1a:	8b 45 08             	mov    0x8(%ebp),%eax
    9b1d:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%eax)
  info->phys_defined = 0;
    9b24:	8b 45 08             	mov    0x8(%ebp),%eax
    9b27:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)

  info->gama_defined = 0;
    9b2e:	8b 45 08             	mov    0x8(%ebp),%eax
    9b31:	c7 80 88 00 00 00 00 	movl   $0x0,0x88(%eax)
    9b38:	00 00 00 
  info->chrm_defined = 0;
    9b3b:	8b 45 08             	mov    0x8(%ebp),%eax
    9b3e:	c7 80 90 00 00 00 00 	movl   $0x0,0x90(%eax)
    9b45:	00 00 00 
  info->srgb_defined = 0;
    9b48:	8b 45 08             	mov    0x8(%ebp),%eax
    9b4b:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
    9b52:	00 00 00 
  info->iccp_defined = 0;
    9b55:	8b 45 08             	mov    0x8(%ebp),%eax
    9b58:	c7 80 bc 00 00 00 00 	movl   $0x0,0xbc(%eax)
    9b5f:	00 00 00 
  info->iccp_name = NULL;
    9b62:	8b 45 08             	mov    0x8(%ebp),%eax
    9b65:	c7 80 c0 00 00 00 00 	movl   $0x0,0xc0(%eax)
    9b6c:	00 00 00 
  info->iccp_profile = NULL;
    9b6f:	8b 45 08             	mov    0x8(%ebp),%eax
    9b72:	c7 80 c4 00 00 00 00 	movl   $0x0,0xc4(%eax)
    9b79:	00 00 00 

  LodePNGUnknownChunks_init(info);
    9b7c:	ff 75 08             	pushl  0x8(%ebp)
    9b7f:	e8 46 f6 ff ff       	call   91ca <LodePNGUnknownChunks_init>
    9b84:	83 c4 04             	add    $0x4,%esp
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}
    9b87:	90                   	nop
    9b88:	c9                   	leave  
    9b89:	c3                   	ret    

00009b8a <lodepng_info_cleanup>:

void lodepng_info_cleanup(LodePNGInfo* info) {
    9b8a:	55                   	push   %ebp
    9b8b:	89 e5                	mov    %esp,%ebp
    9b8d:	83 ec 08             	sub    $0x8,%esp
  lodepng_color_mode_cleanup(&info->color);
    9b90:	8b 45 08             	mov    0x8(%ebp),%eax
    9b93:	83 c0 0c             	add    $0xc,%eax
    9b96:	83 ec 0c             	sub    $0xc,%esp
    9b99:	50                   	push   %eax
    9b9a:	e8 66 f0 ff ff       	call   8c05 <lodepng_color_mode_cleanup>
    9b9f:	83 c4 10             	add    $0x10,%esp
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  LodePNGText_cleanup(info);
    9ba2:	83 ec 0c             	sub    $0xc,%esp
    9ba5:	ff 75 08             	pushl  0x8(%ebp)
    9ba8:	e8 af f7 ff ff       	call   935c <LodePNGText_cleanup>
    9bad:	83 c4 10             	add    $0x10,%esp
  LodePNGIText_cleanup(info);
    9bb0:	83 ec 0c             	sub    $0xc,%esp
    9bb3:	ff 75 08             	pushl  0x8(%ebp)
    9bb6:	e8 3c fa ff ff       	call   95f7 <LodePNGIText_cleanup>
    9bbb:	83 c4 10             	add    $0x10,%esp

  lodepng_clear_icc(info);
    9bbe:	83 ec 0c             	sub    $0xc,%esp
    9bc1:	ff 75 08             	pushl  0x8(%ebp)
    9bc4:	e8 87 fe ff ff       	call   9a50 <lodepng_clear_icc>
    9bc9:	83 c4 10             	add    $0x10,%esp

  LodePNGUnknownChunks_cleanup(info);
    9bcc:	83 ec 0c             	sub    $0xc,%esp
    9bcf:	ff 75 08             	pushl  0x8(%ebp)
    9bd2:	e8 44 f6 ff ff       	call   921b <LodePNGUnknownChunks_cleanup>
    9bd7:	83 c4 10             	add    $0x10,%esp
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}
    9bda:	90                   	nop
    9bdb:	c9                   	leave  
    9bdc:	c3                   	ret    

00009bdd <lodepng_info_copy>:

unsigned lodepng_info_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
    9bdd:	55                   	push   %ebp
    9bde:	89 e5                	mov    %esp,%ebp
    9be0:	83 ec 28             	sub    $0x28,%esp
  lodepng_info_cleanup(dest);
    9be3:	83 ec 0c             	sub    $0xc,%esp
    9be6:	ff 75 08             	pushl  0x8(%ebp)
    9be9:	e8 9c ff ff ff       	call   9b8a <lodepng_info_cleanup>
    9bee:	83 c4 10             	add    $0x10,%esp
  lodepng_memcpy(dest, source, sizeof(LodePNGInfo));
    9bf1:	83 ec 04             	sub    $0x4,%esp
    9bf4:	68 e4 00 00 00       	push   $0xe4
    9bf9:	ff 75 0c             	pushl  0xc(%ebp)
    9bfc:	ff 75 08             	pushl  0x8(%ebp)
    9bff:	e8 3d 98 ff ff       	call   3441 <lodepng_memcpy>
    9c04:	83 c4 10             	add    $0x10,%esp
  lodepng_color_mode_init(&dest->color);
    9c07:	8b 45 08             	mov    0x8(%ebp),%eax
    9c0a:	83 c0 0c             	add    $0xc,%eax
    9c0d:	83 ec 0c             	sub    $0xc,%esp
    9c10:	50                   	push   %eax
    9c11:	e8 fc ee ff ff       	call   8b12 <lodepng_color_mode_init>
    9c16:	83 c4 10             	add    $0x10,%esp
  CERROR_TRY_RETURN(lodepng_color_mode_copy(&dest->color, &source->color));
    9c19:	8b 45 0c             	mov    0xc(%ebp),%eax
    9c1c:	8d 50 0c             	lea    0xc(%eax),%edx
    9c1f:	8b 45 08             	mov    0x8(%ebp),%eax
    9c22:	83 c0 0c             	add    $0xc,%eax
    9c25:	83 ec 08             	sub    $0x8,%esp
    9c28:	52                   	push   %edx
    9c29:	50                   	push   %eax
    9c2a:	e8 ed ef ff ff       	call   8c1c <lodepng_color_mode_copy>
    9c2f:	83 c4 10             	add    $0x10,%esp
    9c32:	89 45 f4             	mov    %eax,-0xc(%ebp)
    9c35:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    9c39:	74 08                	je     9c43 <lodepng_info_copy+0x66>
    9c3b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9c3e:	e9 b7 00 00 00       	jmp    9cfa <lodepng_info_copy+0x11d>

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  CERROR_TRY_RETURN(LodePNGText_copy(dest, source));
    9c43:	83 ec 08             	sub    $0x8,%esp
    9c46:	ff 75 0c             	pushl  0xc(%ebp)
    9c49:	ff 75 08             	pushl  0x8(%ebp)
    9c4c:	e8 84 f7 ff ff       	call   93d5 <LodePNGText_copy>
    9c51:	83 c4 10             	add    $0x10,%esp
    9c54:	89 45 f0             	mov    %eax,-0x10(%ebp)
    9c57:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    9c5b:	74 08                	je     9c65 <lodepng_info_copy+0x88>
    9c5d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9c60:	e9 95 00 00 00       	jmp    9cfa <lodepng_info_copy+0x11d>
  CERROR_TRY_RETURN(LodePNGIText_copy(dest, source));
    9c65:	83 ec 08             	sub    $0x8,%esp
    9c68:	ff 75 0c             	pushl  0xc(%ebp)
    9c6b:	ff 75 08             	pushl  0x8(%ebp)
    9c6e:	e8 55 fa ff ff       	call   96c8 <LodePNGIText_copy>
    9c73:	83 c4 10             	add    $0x10,%esp
    9c76:	89 45 ec             	mov    %eax,-0x14(%ebp)
    9c79:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    9c7d:	74 05                	je     9c84 <lodepng_info_copy+0xa7>
    9c7f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    9c82:	eb 76                	jmp    9cfa <lodepng_info_copy+0x11d>
  if(source->iccp_defined) {
    9c84:	8b 45 0c             	mov    0xc(%ebp),%eax
    9c87:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
    9c8d:	85 c0                	test   %eax,%eax
    9c8f:	74 37                	je     9cc8 <lodepng_info_copy+0xeb>
    CERROR_TRY_RETURN(lodepng_assign_icc(dest, source->iccp_name, source->iccp_profile, source->iccp_profile_size));
    9c91:	8b 45 0c             	mov    0xc(%ebp),%eax
    9c94:	8b 88 c8 00 00 00    	mov    0xc8(%eax),%ecx
    9c9a:	8b 45 0c             	mov    0xc(%ebp),%eax
    9c9d:	8b 90 c4 00 00 00    	mov    0xc4(%eax),%edx
    9ca3:	8b 45 0c             	mov    0xc(%ebp),%eax
    9ca6:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    9cac:	51                   	push   %ecx
    9cad:	52                   	push   %edx
    9cae:	50                   	push   %eax
    9caf:	ff 75 08             	pushl  0x8(%ebp)
    9cb2:	e8 bc fc ff ff       	call   9973 <lodepng_assign_icc>
    9cb7:	83 c4 10             	add    $0x10,%esp
    9cba:	89 45 e8             	mov    %eax,-0x18(%ebp)
    9cbd:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    9cc1:	74 05                	je     9cc8 <lodepng_info_copy+0xeb>
    9cc3:	8b 45 e8             	mov    -0x18(%ebp),%eax
    9cc6:	eb 32                	jmp    9cfa <lodepng_info_copy+0x11d>
  }

  LodePNGUnknownChunks_init(dest);
    9cc8:	83 ec 0c             	sub    $0xc,%esp
    9ccb:	ff 75 08             	pushl  0x8(%ebp)
    9cce:	e8 f7 f4 ff ff       	call   91ca <LodePNGUnknownChunks_init>
    9cd3:	83 c4 10             	add    $0x10,%esp
  CERROR_TRY_RETURN(LodePNGUnknownChunks_copy(dest, source));
    9cd6:	83 ec 08             	sub    $0x8,%esp
    9cd9:	ff 75 0c             	pushl  0xc(%ebp)
    9cdc:	ff 75 08             	pushl  0x8(%ebp)
    9cdf:	e8 6c f5 ff ff       	call   9250 <LodePNGUnknownChunks_copy>
    9ce4:	83 c4 10             	add    $0x10,%esp
    9ce7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    9cea:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    9cee:	74 05                	je     9cf5 <lodepng_info_copy+0x118>
    9cf0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    9cf3:	eb 05                	jmp    9cfa <lodepng_info_copy+0x11d>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  return 0;
    9cf5:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9cfa:	c9                   	leave  
    9cfb:	c3                   	ret    

00009cfc <addColorBits>:

/* ////////////////////////////////////////////////////////////////////////// */

/*index: bitgroup index, bits: bitgroup size(1, 2 or 4), in: bitgroup value, out: octet array to add bits to*/
static void addColorBits(unsigned char* out, size_t index, unsigned bits, unsigned in) {
    9cfc:	55                   	push   %ebp
    9cfd:	89 e5                	mov    %esp,%ebp
    9cff:	83 ec 10             	sub    $0x10,%esp
  unsigned m = bits == 1 ? 7 : bits == 2 ? 3 : 1; /*8 / bits - 1*/
    9d02:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    9d06:	74 14                	je     9d1c <addColorBits+0x20>
    9d08:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
    9d0c:	75 07                	jne    9d15 <addColorBits+0x19>
    9d0e:	b8 03 00 00 00       	mov    $0x3,%eax
    9d13:	eb 0c                	jmp    9d21 <addColorBits+0x25>
    9d15:	b8 01 00 00 00       	mov    $0x1,%eax
    9d1a:	eb 05                	jmp    9d21 <addColorBits+0x25>
    9d1c:	b8 07 00 00 00       	mov    $0x7,%eax
    9d21:	89 45 fc             	mov    %eax,-0x4(%ebp)
  /*p = the partial index in the byte, e.g. with 4 palettebits it is 0 for first half or 1 for second half*/
  unsigned p = index & m;
    9d24:	8b 45 0c             	mov    0xc(%ebp),%eax
    9d27:	23 45 fc             	and    -0x4(%ebp),%eax
    9d2a:	89 45 f8             	mov    %eax,-0x8(%ebp)
  in &= (1u << bits) - 1u; /*filter out any other bits of the input value*/
    9d2d:	8b 45 10             	mov    0x10(%ebp),%eax
    9d30:	ba 01 00 00 00       	mov    $0x1,%edx
    9d35:	89 c1                	mov    %eax,%ecx
    9d37:	d3 e2                	shl    %cl,%edx
    9d39:	89 d0                	mov    %edx,%eax
    9d3b:	83 e8 01             	sub    $0x1,%eax
    9d3e:	21 45 14             	and    %eax,0x14(%ebp)
  in = in << (bits * (m - p));
    9d41:	8b 45 fc             	mov    -0x4(%ebp),%eax
    9d44:	2b 45 f8             	sub    -0x8(%ebp),%eax
    9d47:	0f af 45 10          	imul   0x10(%ebp),%eax
    9d4b:	89 c1                	mov    %eax,%ecx
    9d4d:	d3 65 14             	shll   %cl,0x14(%ebp)
  if(p == 0) out[index * bits / 8u] = in;
    9d50:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    9d54:	75 18                	jne    9d6e <addColorBits+0x72>
    9d56:	8b 45 0c             	mov    0xc(%ebp),%eax
    9d59:	0f af 45 10          	imul   0x10(%ebp),%eax
    9d5d:	c1 e8 03             	shr    $0x3,%eax
    9d60:	89 c2                	mov    %eax,%edx
    9d62:	8b 45 08             	mov    0x8(%ebp),%eax
    9d65:	01 d0                	add    %edx,%eax
    9d67:	8b 55 14             	mov    0x14(%ebp),%edx
    9d6a:	88 10                	mov    %dl,(%eax)
  else out[index * bits / 8u] |= in;
}
    9d6c:	eb 1e                	jmp    9d8c <addColorBits+0x90>
  /*p = the partial index in the byte, e.g. with 4 palettebits it is 0 for first half or 1 for second half*/
  unsigned p = index & m;
  in &= (1u << bits) - 1u; /*filter out any other bits of the input value*/
  in = in << (bits * (m - p));
  if(p == 0) out[index * bits / 8u] = in;
  else out[index * bits / 8u] |= in;
    9d6e:	8b 45 0c             	mov    0xc(%ebp),%eax
    9d71:	0f af 45 10          	imul   0x10(%ebp),%eax
    9d75:	c1 e8 03             	shr    $0x3,%eax
    9d78:	8b 55 08             	mov    0x8(%ebp),%edx
    9d7b:	01 c2                	add    %eax,%edx
    9d7d:	8b 4d 08             	mov    0x8(%ebp),%ecx
    9d80:	01 c8                	add    %ecx,%eax
    9d82:	0f b6 08             	movzbl (%eax),%ecx
    9d85:	8b 45 14             	mov    0x14(%ebp),%eax
    9d88:	09 c8                	or     %ecx,%eax
    9d8a:	88 02                	mov    %al,(%edx)
}
    9d8c:	90                   	nop
    9d8d:	c9                   	leave  
    9d8e:	c3                   	ret    

00009d8f <color_tree_init>:
struct ColorTree {
  ColorTree* children[16]; /*up to 16 pointers to ColorTree of next level*/
  int index; /*the payload. Only has a meaningful value if this is in the last level*/
};

static void color_tree_init(ColorTree* tree) {
    9d8f:	55                   	push   %ebp
    9d90:	89 e5                	mov    %esp,%ebp
  lodepng_memset(tree->children, 0, 16 * sizeof(*tree->children));
    9d92:	8b 45 08             	mov    0x8(%ebp),%eax
    9d95:	6a 40                	push   $0x40
    9d97:	6a 00                	push   $0x0
    9d99:	50                   	push   %eax
    9d9a:	e8 d5 96 ff ff       	call   3474 <lodepng_memset>
    9d9f:	83 c4 0c             	add    $0xc,%esp
  tree->index = -1;
    9da2:	8b 45 08             	mov    0x8(%ebp),%eax
    9da5:	c7 40 40 ff ff ff ff 	movl   $0xffffffff,0x40(%eax)
}
    9dac:	90                   	nop
    9dad:	c9                   	leave  
    9dae:	c3                   	ret    

00009daf <color_tree_cleanup>:

static void color_tree_cleanup(ColorTree* tree) {
    9daf:	55                   	push   %ebp
    9db0:	89 e5                	mov    %esp,%ebp
    9db2:	83 ec 18             	sub    $0x18,%esp
  int i;
  for(i = 0; i != 16; ++i) {
    9db5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9dbc:	eb 3b                	jmp    9df9 <color_tree_cleanup+0x4a>
    if(tree->children[i]) {
    9dbe:	8b 45 08             	mov    0x8(%ebp),%eax
    9dc1:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9dc4:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9dc7:	85 c0                	test   %eax,%eax
    9dc9:	74 2a                	je     9df5 <color_tree_cleanup+0x46>
      color_tree_cleanup(tree->children[i]);
    9dcb:	8b 45 08             	mov    0x8(%ebp),%eax
    9dce:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9dd1:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9dd4:	83 ec 0c             	sub    $0xc,%esp
    9dd7:	50                   	push   %eax
    9dd8:	e8 d2 ff ff ff       	call   9daf <color_tree_cleanup>
    9ddd:	83 c4 10             	add    $0x10,%esp
      lodepng_free(tree->children[i]);
    9de0:	8b 45 08             	mov    0x8(%ebp),%eax
    9de3:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9de6:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9de9:	83 ec 0c             	sub    $0xc,%esp
    9dec:	50                   	push   %eax
    9ded:	e8 32 96 ff ff       	call   3424 <lodepng_free>
    9df2:	83 c4 10             	add    $0x10,%esp
  tree->index = -1;
}

static void color_tree_cleanup(ColorTree* tree) {
  int i;
  for(i = 0; i != 16; ++i) {
    9df5:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9df9:	83 7d f4 10          	cmpl   $0x10,-0xc(%ebp)
    9dfd:	75 bf                	jne    9dbe <color_tree_cleanup+0xf>
    if(tree->children[i]) {
      color_tree_cleanup(tree->children[i]);
      lodepng_free(tree->children[i]);
    }
  }
}
    9dff:	90                   	nop
    9e00:	c9                   	leave  
    9e01:	c3                   	ret    

00009e02 <color_tree_get>:

/*returns -1 if color not present, its index otherwise*/
static int color_tree_get(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    9e02:	55                   	push   %ebp
    9e03:	89 e5                	mov    %esp,%ebp
    9e05:	53                   	push   %ebx
    9e06:	83 ec 20             	sub    $0x20,%esp
    9e09:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    9e0c:	8b 4d 10             	mov    0x10(%ebp),%ecx
    9e0f:	8b 55 14             	mov    0x14(%ebp),%edx
    9e12:	8b 45 18             	mov    0x18(%ebp),%eax
    9e15:	88 5d e8             	mov    %bl,-0x18(%ebp)
    9e18:	88 4d e4             	mov    %cl,-0x1c(%ebp)
    9e1b:	88 55 e0             	mov    %dl,-0x20(%ebp)
    9e1e:	88 45 dc             	mov    %al,-0x24(%ebp)
  int bit = 0;
    9e21:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  for(bit = 0; bit < 8; ++bit) {
    9e28:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    9e2f:	eb 76                	jmp    9ea7 <color_tree_get+0xa5>
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
    9e31:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
    9e35:	8b 45 f8             	mov    -0x8(%ebp),%eax
    9e38:	89 c1                	mov    %eax,%ecx
    9e3a:	d3 fa                	sar    %cl,%edx
    9e3c:	89 d0                	mov    %edx,%eax
    9e3e:	83 e0 01             	and    $0x1,%eax
    9e41:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    9e44:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    9e48:	8b 45 f8             	mov    -0x8(%ebp),%eax
    9e4b:	89 c1                	mov    %eax,%ecx
    9e4d:	d3 fa                	sar    %cl,%edx
    9e4f:	89 d0                	mov    %edx,%eax
    9e51:	83 e0 01             	and    $0x1,%eax
    9e54:	01 d8                	add    %ebx,%eax
    9e56:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    9e59:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    9e5d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    9e60:	89 c1                	mov    %eax,%ecx
    9e62:	d3 fa                	sar    %cl,%edx
    9e64:	89 d0                	mov    %edx,%eax
    9e66:	83 e0 01             	and    $0x1,%eax
    9e69:	01 d8                	add    %ebx,%eax
    9e6b:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    9e6e:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    9e72:	8b 45 f8             	mov    -0x8(%ebp),%eax
    9e75:	89 c1                	mov    %eax,%ecx
    9e77:	d3 fa                	sar    %cl,%edx
    9e79:	89 d0                	mov    %edx,%eax
    9e7b:	83 e0 01             	and    $0x1,%eax
    9e7e:	01 d8                	add    %ebx,%eax
    9e80:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(!tree->children[i]) return -1;
    9e83:	8b 45 08             	mov    0x8(%ebp),%eax
    9e86:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9e89:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9e8c:	85 c0                	test   %eax,%eax
    9e8e:	75 07                	jne    9e97 <color_tree_get+0x95>
    9e90:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    9e95:	eb 2a                	jmp    9ec1 <color_tree_get+0xbf>
    else tree = tree->children[i];
    9e97:	8b 45 08             	mov    0x8(%ebp),%eax
    9e9a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9e9d:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9ea0:	89 45 08             	mov    %eax,0x8(%ebp)
}

/*returns -1 if color not present, its index otherwise*/
static int color_tree_get(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
  int bit = 0;
  for(bit = 0; bit < 8; ++bit) {
    9ea3:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    9ea7:	83 7d f8 07          	cmpl   $0x7,-0x8(%ebp)
    9eab:	7e 84                	jle    9e31 <color_tree_get+0x2f>
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
    if(!tree->children[i]) return -1;
    else tree = tree->children[i];
  }
  return tree ? tree->index : -1;
    9ead:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    9eb1:	74 08                	je     9ebb <color_tree_get+0xb9>
    9eb3:	8b 45 08             	mov    0x8(%ebp),%eax
    9eb6:	8b 40 40             	mov    0x40(%eax),%eax
    9eb9:	eb 05                	jmp    9ec0 <color_tree_get+0xbe>
    9ebb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    9ec0:	90                   	nop
}
    9ec1:	83 c4 20             	add    $0x20,%esp
    9ec4:	5b                   	pop    %ebx
    9ec5:	5d                   	pop    %ebp
    9ec6:	c3                   	ret    

00009ec7 <color_tree_has>:

#ifdef LODEPNG_COMPILE_ENCODER
static int color_tree_has(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    9ec7:	55                   	push   %ebp
    9ec8:	89 e5                	mov    %esp,%ebp
    9eca:	53                   	push   %ebx
    9ecb:	83 ec 10             	sub    $0x10,%esp
    9ece:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    9ed1:	8b 4d 10             	mov    0x10(%ebp),%ecx
    9ed4:	8b 55 14             	mov    0x14(%ebp),%edx
    9ed7:	8b 45 18             	mov    0x18(%ebp),%eax
    9eda:	88 5d f8             	mov    %bl,-0x8(%ebp)
    9edd:	88 4d f4             	mov    %cl,-0xc(%ebp)
    9ee0:	88 55 f0             	mov    %dl,-0x10(%ebp)
    9ee3:	88 45 ec             	mov    %al,-0x14(%ebp)
  return color_tree_get(tree, r, g, b, a) >= 0;
    9ee6:	0f b6 5d ec          	movzbl -0x14(%ebp),%ebx
    9eea:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
    9eee:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
    9ef2:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
    9ef6:	53                   	push   %ebx
    9ef7:	51                   	push   %ecx
    9ef8:	52                   	push   %edx
    9ef9:	50                   	push   %eax
    9efa:	ff 75 08             	pushl  0x8(%ebp)
    9efd:	e8 00 ff ff ff       	call   9e02 <color_tree_get>
    9f02:	83 c4 14             	add    $0x14,%esp
    9f05:	f7 d0                	not    %eax
    9f07:	c1 e8 1f             	shr    $0x1f,%eax
    9f0a:	0f b6 c0             	movzbl %al,%eax
}
    9f0d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    9f10:	c9                   	leave  
    9f11:	c3                   	ret    

00009f12 <color_tree_add>:

/*color is not allowed to already exist.
Index should be >= 0 (it's signed to be compatible with using -1 for "doesn't exist")
Returns error code, or 0 if ok*/
static unsigned color_tree_add(ColorTree* tree,
                               unsigned char r, unsigned char g, unsigned char b, unsigned char a, unsigned index) {
    9f12:	55                   	push   %ebp
    9f13:	89 e5                	mov    %esp,%ebp
    9f15:	53                   	push   %ebx
    9f16:	83 ec 24             	sub    $0x24,%esp
    9f19:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    9f1c:	8b 4d 10             	mov    0x10(%ebp),%ecx
    9f1f:	8b 55 14             	mov    0x14(%ebp),%edx
    9f22:	8b 45 18             	mov    0x18(%ebp),%eax
    9f25:	88 5d e4             	mov    %bl,-0x1c(%ebp)
    9f28:	88 4d e0             	mov    %cl,-0x20(%ebp)
    9f2b:	88 55 dc             	mov    %dl,-0x24(%ebp)
    9f2e:	88 45 d8             	mov    %al,-0x28(%ebp)
  int bit;
  for(bit = 0; bit < 8; ++bit) {
    9f31:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9f38:	e9 b0 00 00 00       	jmp    9fed <color_tree_add+0xdb>
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
    9f3d:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    9f41:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9f44:	89 c1                	mov    %eax,%ecx
    9f46:	d3 fa                	sar    %cl,%edx
    9f48:	89 d0                	mov    %edx,%eax
    9f4a:	83 e0 01             	and    $0x1,%eax
    9f4d:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    9f50:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    9f54:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9f57:	89 c1                	mov    %eax,%ecx
    9f59:	d3 fa                	sar    %cl,%edx
    9f5b:	89 d0                	mov    %edx,%eax
    9f5d:	83 e0 01             	and    $0x1,%eax
    9f60:	01 d8                	add    %ebx,%eax
    9f62:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    9f65:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    9f69:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9f6c:	89 c1                	mov    %eax,%ecx
    9f6e:	d3 fa                	sar    %cl,%edx
    9f70:	89 d0                	mov    %edx,%eax
    9f72:	83 e0 01             	and    $0x1,%eax
    9f75:	01 d8                	add    %ebx,%eax
    9f77:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    9f7a:	0f b6 55 d8          	movzbl -0x28(%ebp),%edx
    9f7e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9f81:	89 c1                	mov    %eax,%ecx
    9f83:	d3 fa                	sar    %cl,%edx
    9f85:	89 d0                	mov    %edx,%eax
    9f87:	83 e0 01             	and    $0x1,%eax
    9f8a:	01 d8                	add    %ebx,%eax
    9f8c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!tree->children[i]) {
    9f8f:	8b 45 08             	mov    0x8(%ebp),%eax
    9f92:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9f95:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9f98:	85 c0                	test   %eax,%eax
    9f9a:	75 41                	jne    9fdd <color_tree_add+0xcb>
      tree->children[i] = (ColorTree*)lodepng_malloc(sizeof(ColorTree));
    9f9c:	83 ec 0c             	sub    $0xc,%esp
    9f9f:	6a 44                	push   $0x44
    9fa1:	e8 5d 94 ff ff       	call   3403 <lodepng_malloc>
    9fa6:	83 c4 10             	add    $0x10,%esp
    9fa9:	89 c1                	mov    %eax,%ecx
    9fab:	8b 45 08             	mov    0x8(%ebp),%eax
    9fae:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9fb1:	89 0c 90             	mov    %ecx,(%eax,%edx,4)
      if(!tree->children[i]) return 83; /*alloc fail*/
    9fb4:	8b 45 08             	mov    0x8(%ebp),%eax
    9fb7:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9fba:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9fbd:	85 c0                	test   %eax,%eax
    9fbf:	75 07                	jne    9fc8 <color_tree_add+0xb6>
    9fc1:	b8 53 00 00 00       	mov    $0x53,%eax
    9fc6:	eb 3d                	jmp    a005 <color_tree_add+0xf3>
      color_tree_init(tree->children[i]);
    9fc8:	8b 45 08             	mov    0x8(%ebp),%eax
    9fcb:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9fce:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9fd1:	83 ec 0c             	sub    $0xc,%esp
    9fd4:	50                   	push   %eax
    9fd5:	e8 b5 fd ff ff       	call   9d8f <color_tree_init>
    9fda:	83 c4 10             	add    $0x10,%esp
    }
    tree = tree->children[i];
    9fdd:	8b 45 08             	mov    0x8(%ebp),%eax
    9fe0:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9fe3:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9fe6:	89 45 08             	mov    %eax,0x8(%ebp)
Index should be >= 0 (it's signed to be compatible with using -1 for "doesn't exist")
Returns error code, or 0 if ok*/
static unsigned color_tree_add(ColorTree* tree,
                               unsigned char r, unsigned char g, unsigned char b, unsigned char a, unsigned index) {
  int bit;
  for(bit = 0; bit < 8; ++bit) {
    9fe9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9fed:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
    9ff1:	0f 8e 46 ff ff ff    	jle    9f3d <color_tree_add+0x2b>
      if(!tree->children[i]) return 83; /*alloc fail*/
      color_tree_init(tree->children[i]);
    }
    tree = tree->children[i];
  }
  tree->index = (int)index;
    9ff7:	8b 55 1c             	mov    0x1c(%ebp),%edx
    9ffa:	8b 45 08             	mov    0x8(%ebp),%eax
    9ffd:	89 50 40             	mov    %edx,0x40(%eax)
  return 0;
    a000:	b8 00 00 00 00       	mov    $0x0,%eax
}
    a005:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    a008:	c9                   	leave  
    a009:	c3                   	ret    

0000a00a <rgba8ToPixel>:

/*put a pixel, given its RGBA color, into image of any color type*/
static unsigned rgba8ToPixel(unsigned char* out, size_t i,
                             const LodePNGColorMode* mode, ColorTree* tree /*for palette*/,
                             unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    a00a:	55                   	push   %ebp
    a00b:	89 e5                	mov    %esp,%ebp
    a00d:	53                   	push   %ebx
    a00e:	83 ec 20             	sub    $0x20,%esp
    a011:	8b 5d 18             	mov    0x18(%ebp),%ebx
    a014:	8b 4d 1c             	mov    0x1c(%ebp),%ecx
    a017:	8b 55 20             	mov    0x20(%ebp),%edx
    a01a:	8b 45 24             	mov    0x24(%ebp),%eax
    a01d:	88 5d e8             	mov    %bl,-0x18(%ebp)
    a020:	88 4d e4             	mov    %cl,-0x1c(%ebp)
    a023:	88 55 e0             	mov    %dl,-0x20(%ebp)
    a026:	88 45 dc             	mov    %al,-0x24(%ebp)
  if(mode->colortype == LCT_GREY) {
    a029:	8b 45 10             	mov    0x10(%ebp),%eax
    a02c:	8b 00                	mov    (%eax),%eax
    a02e:	85 c0                	test   %eax,%eax
    a030:	0f 85 ad 00 00 00    	jne    a0e3 <rgba8ToPixel+0xd9>
    unsigned char gray = r; /*((unsigned short)r + g + b) / 3u;*/
    a036:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a03a:	88 45 f6             	mov    %al,-0xa(%ebp)
    if(mode->bitdepth == 8) out[i] = gray;
    a03d:	8b 45 10             	mov    0x10(%ebp),%eax
    a040:	8b 40 04             	mov    0x4(%eax),%eax
    a043:	83 f8 08             	cmp    $0x8,%eax
    a046:	75 13                	jne    a05b <rgba8ToPixel+0x51>
    a048:	8b 55 0c             	mov    0xc(%ebp),%edx
    a04b:	8b 45 08             	mov    0x8(%ebp),%eax
    a04e:	01 c2                	add    %eax,%edx
    a050:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
    a054:	88 02                	mov    %al,(%edx)
    a056:	e9 b4 03 00 00       	jmp    a40f <rgba8ToPixel+0x405>
    else if(mode->bitdepth == 16) out[i * 2 + 0] = out[i * 2 + 1] = gray;
    a05b:	8b 45 10             	mov    0x10(%ebp),%eax
    a05e:	8b 40 04             	mov    0x4(%eax),%eax
    a061:	83 f8 10             	cmp    $0x10,%eax
    a064:	75 2a                	jne    a090 <rgba8ToPixel+0x86>
    a066:	8b 45 0c             	mov    0xc(%ebp),%eax
    a069:	01 c0                	add    %eax,%eax
    a06b:	89 c2                	mov    %eax,%edx
    a06d:	8b 45 08             	mov    0x8(%ebp),%eax
    a070:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a073:	8b 45 0c             	mov    0xc(%ebp),%eax
    a076:	01 c0                	add    %eax,%eax
    a078:	8d 50 01             	lea    0x1(%eax),%edx
    a07b:	8b 45 08             	mov    0x8(%ebp),%eax
    a07e:	01 d0                	add    %edx,%eax
    a080:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
    a084:	88 10                	mov    %dl,(%eax)
    a086:	0f b6 00             	movzbl (%eax),%eax
    a089:	88 01                	mov    %al,(%ecx)
    a08b:	e9 7f 03 00 00       	jmp    a40f <rgba8ToPixel+0x405>
    else {
      /*take the most significant bits of gray*/
      gray = ((unsigned)gray >> (8u - mode->bitdepth)) & ((1u << mode->bitdepth) - 1u);
    a090:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
    a094:	8b 45 10             	mov    0x10(%ebp),%eax
    a097:	8b 40 04             	mov    0x4(%eax),%eax
    a09a:	b9 08 00 00 00       	mov    $0x8,%ecx
    a09f:	29 c1                	sub    %eax,%ecx
    a0a1:	89 c8                	mov    %ecx,%eax
    a0a3:	89 c1                	mov    %eax,%ecx
    a0a5:	d3 ea                	shr    %cl,%edx
    a0a7:	89 d0                	mov    %edx,%eax
    a0a9:	89 c2                	mov    %eax,%edx
    a0ab:	8b 45 10             	mov    0x10(%ebp),%eax
    a0ae:	8b 40 04             	mov    0x4(%eax),%eax
    a0b1:	bb 01 00 00 00       	mov    $0x1,%ebx
    a0b6:	89 c1                	mov    %eax,%ecx
    a0b8:	d3 e3                	shl    %cl,%ebx
    a0ba:	89 d8                	mov    %ebx,%eax
    a0bc:	83 e8 01             	sub    $0x1,%eax
    a0bf:	21 d0                	and    %edx,%eax
    a0c1:	88 45 f6             	mov    %al,-0xa(%ebp)
      addColorBits(out, i, mode->bitdepth, gray);
    a0c4:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
    a0c8:	8b 45 10             	mov    0x10(%ebp),%eax
    a0cb:	8b 40 04             	mov    0x4(%eax),%eax
    a0ce:	52                   	push   %edx
    a0cf:	50                   	push   %eax
    a0d0:	ff 75 0c             	pushl  0xc(%ebp)
    a0d3:	ff 75 08             	pushl  0x8(%ebp)
    a0d6:	e8 21 fc ff ff       	call   9cfc <addColorBits>
    a0db:	83 c4 10             	add    $0x10,%esp
    a0de:	e9 2c 03 00 00       	jmp    a40f <rgba8ToPixel+0x405>
    }
  } else if(mode->colortype == LCT_RGB) {
    a0e3:	8b 45 10             	mov    0x10(%ebp),%eax
    a0e6:	8b 00                	mov    (%eax),%eax
    a0e8:	83 f8 02             	cmp    $0x2,%eax
    a0eb:	0f 85 ee 00 00 00    	jne    a1df <rgba8ToPixel+0x1d5>
    if(mode->bitdepth == 8) {
    a0f1:	8b 45 10             	mov    0x10(%ebp),%eax
    a0f4:	8b 40 04             	mov    0x4(%eax),%eax
    a0f7:	83 f8 08             	cmp    $0x8,%eax
    a0fa:	75 49                	jne    a145 <rgba8ToPixel+0x13b>
      out[i * 3 + 0] = r;
    a0fc:	8b 55 0c             	mov    0xc(%ebp),%edx
    a0ff:	89 d0                	mov    %edx,%eax
    a101:	01 c0                	add    %eax,%eax
    a103:	01 d0                	add    %edx,%eax
    a105:	89 c2                	mov    %eax,%edx
    a107:	8b 45 08             	mov    0x8(%ebp),%eax
    a10a:	01 c2                	add    %eax,%edx
    a10c:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a110:	88 02                	mov    %al,(%edx)
      out[i * 3 + 1] = g;
    a112:	8b 55 0c             	mov    0xc(%ebp),%edx
    a115:	89 d0                	mov    %edx,%eax
    a117:	01 c0                	add    %eax,%eax
    a119:	01 d0                	add    %edx,%eax
    a11b:	8d 50 01             	lea    0x1(%eax),%edx
    a11e:	8b 45 08             	mov    0x8(%ebp),%eax
    a121:	01 c2                	add    %eax,%edx
    a123:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
    a127:	88 02                	mov    %al,(%edx)
      out[i * 3 + 2] = b;
    a129:	8b 55 0c             	mov    0xc(%ebp),%edx
    a12c:	89 d0                	mov    %edx,%eax
    a12e:	01 c0                	add    %eax,%eax
    a130:	01 d0                	add    %edx,%eax
    a132:	8d 50 02             	lea    0x2(%eax),%edx
    a135:	8b 45 08             	mov    0x8(%ebp),%eax
    a138:	01 c2                	add    %eax,%edx
    a13a:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
    a13e:	88 02                	mov    %al,(%edx)
    a140:	e9 ca 02 00 00       	jmp    a40f <rgba8ToPixel+0x405>
    } else {
      out[i * 6 + 0] = out[i * 6 + 1] = r;
    a145:	8b 55 0c             	mov    0xc(%ebp),%edx
    a148:	89 d0                	mov    %edx,%eax
    a14a:	01 c0                	add    %eax,%eax
    a14c:	01 d0                	add    %edx,%eax
    a14e:	01 c0                	add    %eax,%eax
    a150:	89 c2                	mov    %eax,%edx
    a152:	8b 45 08             	mov    0x8(%ebp),%eax
    a155:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a158:	8b 55 0c             	mov    0xc(%ebp),%edx
    a15b:	89 d0                	mov    %edx,%eax
    a15d:	01 c0                	add    %eax,%eax
    a15f:	01 d0                	add    %edx,%eax
    a161:	01 c0                	add    %eax,%eax
    a163:	8d 50 01             	lea    0x1(%eax),%edx
    a166:	8b 45 08             	mov    0x8(%ebp),%eax
    a169:	01 d0                	add    %edx,%eax
    a16b:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
    a16f:	88 10                	mov    %dl,(%eax)
    a171:	0f b6 00             	movzbl (%eax),%eax
    a174:	88 01                	mov    %al,(%ecx)
      out[i * 6 + 2] = out[i * 6 + 3] = g;
    a176:	8b 55 0c             	mov    0xc(%ebp),%edx
    a179:	89 d0                	mov    %edx,%eax
    a17b:	01 c0                	add    %eax,%eax
    a17d:	01 d0                	add    %edx,%eax
    a17f:	01 c0                	add    %eax,%eax
    a181:	8d 50 02             	lea    0x2(%eax),%edx
    a184:	8b 45 08             	mov    0x8(%ebp),%eax
    a187:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a18a:	8b 55 0c             	mov    0xc(%ebp),%edx
    a18d:	89 d0                	mov    %edx,%eax
    a18f:	01 c0                	add    %eax,%eax
    a191:	01 d0                	add    %edx,%eax
    a193:	01 c0                	add    %eax,%eax
    a195:	8d 50 03             	lea    0x3(%eax),%edx
    a198:	8b 45 08             	mov    0x8(%ebp),%eax
    a19b:	01 d0                	add    %edx,%eax
    a19d:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    a1a1:	88 10                	mov    %dl,(%eax)
    a1a3:	0f b6 00             	movzbl (%eax),%eax
    a1a6:	88 01                	mov    %al,(%ecx)
      out[i * 6 + 4] = out[i * 6 + 5] = b;
    a1a8:	8b 55 0c             	mov    0xc(%ebp),%edx
    a1ab:	89 d0                	mov    %edx,%eax
    a1ad:	01 c0                	add    %eax,%eax
    a1af:	01 d0                	add    %edx,%eax
    a1b1:	01 c0                	add    %eax,%eax
    a1b3:	8d 50 04             	lea    0x4(%eax),%edx
    a1b6:	8b 45 08             	mov    0x8(%ebp),%eax
    a1b9:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a1bc:	8b 55 0c             	mov    0xc(%ebp),%edx
    a1bf:	89 d0                	mov    %edx,%eax
    a1c1:	01 c0                	add    %eax,%eax
    a1c3:	01 d0                	add    %edx,%eax
    a1c5:	01 c0                	add    %eax,%eax
    a1c7:	8d 50 05             	lea    0x5(%eax),%edx
    a1ca:	8b 45 08             	mov    0x8(%ebp),%eax
    a1cd:	01 d0                	add    %edx,%eax
    a1cf:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    a1d3:	88 10                	mov    %dl,(%eax)
    a1d5:	0f b6 00             	movzbl (%eax),%eax
    a1d8:	88 01                	mov    %al,(%ecx)
    a1da:	e9 30 02 00 00       	jmp    a40f <rgba8ToPixel+0x405>
    }
  } else if(mode->colortype == LCT_PALETTE) {
    a1df:	8b 45 10             	mov    0x10(%ebp),%eax
    a1e2:	8b 00                	mov    (%eax),%eax
    a1e4:	83 f8 03             	cmp    $0x3,%eax
    a1e7:	75 6d                	jne    a256 <rgba8ToPixel+0x24c>
    int index = color_tree_get(tree, r, g, b, a);
    a1e9:	0f b6 5d dc          	movzbl -0x24(%ebp),%ebx
    a1ed:	0f b6 4d e0          	movzbl -0x20(%ebp),%ecx
    a1f1:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    a1f5:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a1f9:	53                   	push   %ebx
    a1fa:	51                   	push   %ecx
    a1fb:	52                   	push   %edx
    a1fc:	50                   	push   %eax
    a1fd:	ff 75 14             	pushl  0x14(%ebp)
    a200:	e8 fd fb ff ff       	call   9e02 <color_tree_get>
    a205:	83 c4 14             	add    $0x14,%esp
    a208:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(index < 0) return 82; /*color not in palette*/
    a20b:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    a20f:	79 0a                	jns    a21b <rgba8ToPixel+0x211>
    a211:	b8 52 00 00 00       	mov    $0x52,%eax
    a216:	e9 f9 01 00 00       	jmp    a414 <rgba8ToPixel+0x40a>
    if(mode->bitdepth == 8) out[i] = index;
    a21b:	8b 45 10             	mov    0x10(%ebp),%eax
    a21e:	8b 40 04             	mov    0x4(%eax),%eax
    a221:	83 f8 08             	cmp    $0x8,%eax
    a224:	75 12                	jne    a238 <rgba8ToPixel+0x22e>
    a226:	8b 55 0c             	mov    0xc(%ebp),%edx
    a229:	8b 45 08             	mov    0x8(%ebp),%eax
    a22c:	01 d0                	add    %edx,%eax
    a22e:	8b 55 f8             	mov    -0x8(%ebp),%edx
    a231:	88 10                	mov    %dl,(%eax)
    a233:	e9 d7 01 00 00       	jmp    a40f <rgba8ToPixel+0x405>
    else addColorBits(out, i, mode->bitdepth, (unsigned)index);
    a238:	8b 55 f8             	mov    -0x8(%ebp),%edx
    a23b:	8b 45 10             	mov    0x10(%ebp),%eax
    a23e:	8b 40 04             	mov    0x4(%eax),%eax
    a241:	52                   	push   %edx
    a242:	50                   	push   %eax
    a243:	ff 75 0c             	pushl  0xc(%ebp)
    a246:	ff 75 08             	pushl  0x8(%ebp)
    a249:	e8 ae fa ff ff       	call   9cfc <addColorBits>
    a24e:	83 c4 10             	add    $0x10,%esp
    a251:	e9 b9 01 00 00       	jmp    a40f <rgba8ToPixel+0x405>
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    a256:	8b 45 10             	mov    0x10(%ebp),%eax
    a259:	8b 00                	mov    (%eax),%eax
    a25b:	83 f8 04             	cmp    $0x4,%eax
    a25e:	0f 85 9f 00 00 00    	jne    a303 <rgba8ToPixel+0x2f9>
    unsigned char gray = r; /*((unsigned short)r + g + b) / 3u;*/
    a264:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a268:	88 45 f7             	mov    %al,-0x9(%ebp)
    if(mode->bitdepth == 8) {
    a26b:	8b 45 10             	mov    0x10(%ebp),%eax
    a26e:	8b 40 04             	mov    0x4(%eax),%eax
    a271:	83 f8 08             	cmp    $0x8,%eax
    a274:	75 2a                	jne    a2a0 <rgba8ToPixel+0x296>
      out[i * 2 + 0] = gray;
    a276:	8b 45 0c             	mov    0xc(%ebp),%eax
    a279:	01 c0                	add    %eax,%eax
    a27b:	89 c2                	mov    %eax,%edx
    a27d:	8b 45 08             	mov    0x8(%ebp),%eax
    a280:	01 c2                	add    %eax,%edx
    a282:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
    a286:	88 02                	mov    %al,(%edx)
      out[i * 2 + 1] = a;
    a288:	8b 45 0c             	mov    0xc(%ebp),%eax
    a28b:	01 c0                	add    %eax,%eax
    a28d:	8d 50 01             	lea    0x1(%eax),%edx
    a290:	8b 45 08             	mov    0x8(%ebp),%eax
    a293:	01 c2                	add    %eax,%edx
    a295:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
    a299:	88 02                	mov    %al,(%edx)
    a29b:	e9 6f 01 00 00       	jmp    a40f <rgba8ToPixel+0x405>
    } else if(mode->bitdepth == 16) {
    a2a0:	8b 45 10             	mov    0x10(%ebp),%eax
    a2a3:	8b 40 04             	mov    0x4(%eax),%eax
    a2a6:	83 f8 10             	cmp    $0x10,%eax
    a2a9:	0f 85 60 01 00 00    	jne    a40f <rgba8ToPixel+0x405>
      out[i * 4 + 0] = out[i * 4 + 1] = gray;
    a2af:	8b 45 0c             	mov    0xc(%ebp),%eax
    a2b2:	c1 e0 02             	shl    $0x2,%eax
    a2b5:	89 c2                	mov    %eax,%edx
    a2b7:	8b 45 08             	mov    0x8(%ebp),%eax
    a2ba:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a2bd:	8b 45 0c             	mov    0xc(%ebp),%eax
    a2c0:	c1 e0 02             	shl    $0x2,%eax
    a2c3:	8d 50 01             	lea    0x1(%eax),%edx
    a2c6:	8b 45 08             	mov    0x8(%ebp),%eax
    a2c9:	01 d0                	add    %edx,%eax
    a2cb:	0f b6 55 f7          	movzbl -0x9(%ebp),%edx
    a2cf:	88 10                	mov    %dl,(%eax)
    a2d1:	0f b6 00             	movzbl (%eax),%eax
    a2d4:	88 01                	mov    %al,(%ecx)
      out[i * 4 + 2] = out[i * 4 + 3] = a;
    a2d6:	8b 45 0c             	mov    0xc(%ebp),%eax
    a2d9:	c1 e0 02             	shl    $0x2,%eax
    a2dc:	8d 50 02             	lea    0x2(%eax),%edx
    a2df:	8b 45 08             	mov    0x8(%ebp),%eax
    a2e2:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a2e5:	8b 45 0c             	mov    0xc(%ebp),%eax
    a2e8:	c1 e0 02             	shl    $0x2,%eax
    a2eb:	8d 50 03             	lea    0x3(%eax),%edx
    a2ee:	8b 45 08             	mov    0x8(%ebp),%eax
    a2f1:	01 d0                	add    %edx,%eax
    a2f3:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    a2f7:	88 10                	mov    %dl,(%eax)
    a2f9:	0f b6 00             	movzbl (%eax),%eax
    a2fc:	88 01                	mov    %al,(%ecx)
    a2fe:	e9 0c 01 00 00       	jmp    a40f <rgba8ToPixel+0x405>
    }
  } else if(mode->colortype == LCT_RGBA) {
    a303:	8b 45 10             	mov    0x10(%ebp),%eax
    a306:	8b 00                	mov    (%eax),%eax
    a308:	83 f8 06             	cmp    $0x6,%eax
    a30b:	0f 85 fe 00 00 00    	jne    a40f <rgba8ToPixel+0x405>
    if(mode->bitdepth == 8) {
    a311:	8b 45 10             	mov    0x10(%ebp),%eax
    a314:	8b 40 04             	mov    0x4(%eax),%eax
    a317:	83 f8 08             	cmp    $0x8,%eax
    a31a:	75 54                	jne    a370 <rgba8ToPixel+0x366>
      out[i * 4 + 0] = r;
    a31c:	8b 45 0c             	mov    0xc(%ebp),%eax
    a31f:	c1 e0 02             	shl    $0x2,%eax
    a322:	89 c2                	mov    %eax,%edx
    a324:	8b 45 08             	mov    0x8(%ebp),%eax
    a327:	01 c2                	add    %eax,%edx
    a329:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a32d:	88 02                	mov    %al,(%edx)
      out[i * 4 + 1] = g;
    a32f:	8b 45 0c             	mov    0xc(%ebp),%eax
    a332:	c1 e0 02             	shl    $0x2,%eax
    a335:	8d 50 01             	lea    0x1(%eax),%edx
    a338:	8b 45 08             	mov    0x8(%ebp),%eax
    a33b:	01 c2                	add    %eax,%edx
    a33d:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
    a341:	88 02                	mov    %al,(%edx)
      out[i * 4 + 2] = b;
    a343:	8b 45 0c             	mov    0xc(%ebp),%eax
    a346:	c1 e0 02             	shl    $0x2,%eax
    a349:	8d 50 02             	lea    0x2(%eax),%edx
    a34c:	8b 45 08             	mov    0x8(%ebp),%eax
    a34f:	01 c2                	add    %eax,%edx
    a351:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
    a355:	88 02                	mov    %al,(%edx)
      out[i * 4 + 3] = a;
    a357:	8b 45 0c             	mov    0xc(%ebp),%eax
    a35a:	c1 e0 02             	shl    $0x2,%eax
    a35d:	8d 50 03             	lea    0x3(%eax),%edx
    a360:	8b 45 08             	mov    0x8(%ebp),%eax
    a363:	01 c2                	add    %eax,%edx
    a365:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
    a369:	88 02                	mov    %al,(%edx)
    a36b:	e9 9f 00 00 00       	jmp    a40f <rgba8ToPixel+0x405>
    } else {
      out[i * 8 + 0] = out[i * 8 + 1] = r;
    a370:	8b 45 0c             	mov    0xc(%ebp),%eax
    a373:	c1 e0 03             	shl    $0x3,%eax
    a376:	89 c2                	mov    %eax,%edx
    a378:	8b 45 08             	mov    0x8(%ebp),%eax
    a37b:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a37e:	8b 45 0c             	mov    0xc(%ebp),%eax
    a381:	c1 e0 03             	shl    $0x3,%eax
    a384:	8d 50 01             	lea    0x1(%eax),%edx
    a387:	8b 45 08             	mov    0x8(%ebp),%eax
    a38a:	01 d0                	add    %edx,%eax
    a38c:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
    a390:	88 10                	mov    %dl,(%eax)
    a392:	0f b6 00             	movzbl (%eax),%eax
    a395:	88 01                	mov    %al,(%ecx)
      out[i * 8 + 2] = out[i * 8 + 3] = g;
    a397:	8b 45 0c             	mov    0xc(%ebp),%eax
    a39a:	c1 e0 03             	shl    $0x3,%eax
    a39d:	8d 50 02             	lea    0x2(%eax),%edx
    a3a0:	8b 45 08             	mov    0x8(%ebp),%eax
    a3a3:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a3a6:	8b 45 0c             	mov    0xc(%ebp),%eax
    a3a9:	c1 e0 03             	shl    $0x3,%eax
    a3ac:	8d 50 03             	lea    0x3(%eax),%edx
    a3af:	8b 45 08             	mov    0x8(%ebp),%eax
    a3b2:	01 d0                	add    %edx,%eax
    a3b4:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    a3b8:	88 10                	mov    %dl,(%eax)
    a3ba:	0f b6 00             	movzbl (%eax),%eax
    a3bd:	88 01                	mov    %al,(%ecx)
      out[i * 8 + 4] = out[i * 8 + 5] = b;
    a3bf:	8b 45 0c             	mov    0xc(%ebp),%eax
    a3c2:	c1 e0 03             	shl    $0x3,%eax
    a3c5:	8d 50 04             	lea    0x4(%eax),%edx
    a3c8:	8b 45 08             	mov    0x8(%ebp),%eax
    a3cb:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a3ce:	8b 45 0c             	mov    0xc(%ebp),%eax
    a3d1:	c1 e0 03             	shl    $0x3,%eax
    a3d4:	8d 50 05             	lea    0x5(%eax),%edx
    a3d7:	8b 45 08             	mov    0x8(%ebp),%eax
    a3da:	01 d0                	add    %edx,%eax
    a3dc:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    a3e0:	88 10                	mov    %dl,(%eax)
    a3e2:	0f b6 00             	movzbl (%eax),%eax
    a3e5:	88 01                	mov    %al,(%ecx)
      out[i * 8 + 6] = out[i * 8 + 7] = a;
    a3e7:	8b 45 0c             	mov    0xc(%ebp),%eax
    a3ea:	c1 e0 03             	shl    $0x3,%eax
    a3ed:	8d 50 06             	lea    0x6(%eax),%edx
    a3f0:	8b 45 08             	mov    0x8(%ebp),%eax
    a3f3:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a3f6:	8b 45 0c             	mov    0xc(%ebp),%eax
    a3f9:	c1 e0 03             	shl    $0x3,%eax
    a3fc:	8d 50 07             	lea    0x7(%eax),%edx
    a3ff:	8b 45 08             	mov    0x8(%ebp),%eax
    a402:	01 d0                	add    %edx,%eax
    a404:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    a408:	88 10                	mov    %dl,(%eax)
    a40a:	0f b6 00             	movzbl (%eax),%eax
    a40d:	88 01                	mov    %al,(%ecx)
    }
  }

  return 0; /*no error*/
    a40f:	b8 00 00 00 00       	mov    $0x0,%eax
}
    a414:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    a417:	c9                   	leave  
    a418:	c3                   	ret    

0000a419 <rgba16ToPixel>:

/*put a pixel, given its RGBA16 color, into image of any color 16-bitdepth type*/
static void rgba16ToPixel(unsigned char* out, size_t i,
                         const LodePNGColorMode* mode,
                         unsigned short r, unsigned short g, unsigned short b, unsigned short a) {
    a419:	55                   	push   %ebp
    a41a:	89 e5                	mov    %esp,%ebp
    a41c:	53                   	push   %ebx
    a41d:	83 ec 20             	sub    $0x20,%esp
    a420:	8b 5d 14             	mov    0x14(%ebp),%ebx
    a423:	8b 4d 18             	mov    0x18(%ebp),%ecx
    a426:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a429:	8b 45 20             	mov    0x20(%ebp),%eax
    a42c:	66 89 5d e8          	mov    %bx,-0x18(%ebp)
    a430:	66 89 4d e4          	mov    %cx,-0x1c(%ebp)
    a434:	66 89 55 e0          	mov    %dx,-0x20(%ebp)
    a438:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
  if(mode->colortype == LCT_GREY) {
    a43c:	8b 45 10             	mov    0x10(%ebp),%eax
    a43f:	8b 00                	mov    (%eax),%eax
    a441:	85 c0                	test   %eax,%eax
    a443:	75 36                	jne    a47b <rgba16ToPixel+0x62>
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    a445:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
    a449:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
    out[i * 2 + 0] = (gray >> 8) & 255;
    a44d:	8b 45 0c             	mov    0xc(%ebp),%eax
    a450:	01 c0                	add    %eax,%eax
    a452:	89 c2                	mov    %eax,%edx
    a454:	8b 45 08             	mov    0x8(%ebp),%eax
    a457:	01 d0                	add    %edx,%eax
    a459:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
    a45d:	66 c1 ea 08          	shr    $0x8,%dx
    a461:	88 10                	mov    %dl,(%eax)
    out[i * 2 + 1] = gray & 255;
    a463:	8b 45 0c             	mov    0xc(%ebp),%eax
    a466:	01 c0                	add    %eax,%eax
    a468:	8d 50 01             	lea    0x1(%eax),%edx
    a46b:	8b 45 08             	mov    0x8(%ebp),%eax
    a46e:	01 d0                	add    %edx,%eax
    a470:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
    a474:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    out[i * 8 + 5] = b & 255;
    out[i * 8 + 6] = (a >> 8) & 255;
    out[i * 8 + 7] = a & 255;
  }
}
    a476:	e9 df 01 00 00       	jmp    a65a <rgba16ToPixel+0x241>
                         unsigned short r, unsigned short g, unsigned short b, unsigned short a) {
  if(mode->colortype == LCT_GREY) {
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    out[i * 2 + 0] = (gray >> 8) & 255;
    out[i * 2 + 1] = gray & 255;
  } else if(mode->colortype == LCT_RGB) {
    a47b:	8b 45 10             	mov    0x10(%ebp),%eax
    a47e:	8b 00                	mov    (%eax),%eax
    a480:	83 f8 02             	cmp    $0x2,%eax
    a483:	0f 85 a6 00 00 00    	jne    a52f <rgba16ToPixel+0x116>
    out[i * 6 + 0] = (r >> 8) & 255;
    a489:	8b 55 0c             	mov    0xc(%ebp),%edx
    a48c:	89 d0                	mov    %edx,%eax
    a48e:	01 c0                	add    %eax,%eax
    a490:	01 d0                	add    %edx,%eax
    a492:	01 c0                	add    %eax,%eax
    a494:	89 c2                	mov    %eax,%edx
    a496:	8b 45 08             	mov    0x8(%ebp),%eax
    a499:	01 d0                	add    %edx,%eax
    a49b:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    a49f:	66 c1 ea 08          	shr    $0x8,%dx
    a4a3:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 1] = r & 255;
    a4a5:	8b 55 0c             	mov    0xc(%ebp),%edx
    a4a8:	89 d0                	mov    %edx,%eax
    a4aa:	01 c0                	add    %eax,%eax
    a4ac:	01 d0                	add    %edx,%eax
    a4ae:	01 c0                	add    %eax,%eax
    a4b0:	8d 50 01             	lea    0x1(%eax),%edx
    a4b3:	8b 45 08             	mov    0x8(%ebp),%eax
    a4b6:	01 d0                	add    %edx,%eax
    a4b8:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    a4bc:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 2] = (g >> 8) & 255;
    a4be:	8b 55 0c             	mov    0xc(%ebp),%edx
    a4c1:	89 d0                	mov    %edx,%eax
    a4c3:	01 c0                	add    %eax,%eax
    a4c5:	01 d0                	add    %edx,%eax
    a4c7:	01 c0                	add    %eax,%eax
    a4c9:	8d 50 02             	lea    0x2(%eax),%edx
    a4cc:	8b 45 08             	mov    0x8(%ebp),%eax
    a4cf:	01 d0                	add    %edx,%eax
    a4d1:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    a4d5:	66 c1 ea 08          	shr    $0x8,%dx
    a4d9:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 3] = g & 255;
    a4db:	8b 55 0c             	mov    0xc(%ebp),%edx
    a4de:	89 d0                	mov    %edx,%eax
    a4e0:	01 c0                	add    %eax,%eax
    a4e2:	01 d0                	add    %edx,%eax
    a4e4:	01 c0                	add    %eax,%eax
    a4e6:	8d 50 03             	lea    0x3(%eax),%edx
    a4e9:	8b 45 08             	mov    0x8(%ebp),%eax
    a4ec:	01 d0                	add    %edx,%eax
    a4ee:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    a4f2:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 4] = (b >> 8) & 255;
    a4f4:	8b 55 0c             	mov    0xc(%ebp),%edx
    a4f7:	89 d0                	mov    %edx,%eax
    a4f9:	01 c0                	add    %eax,%eax
    a4fb:	01 d0                	add    %edx,%eax
    a4fd:	01 c0                	add    %eax,%eax
    a4ff:	8d 50 04             	lea    0x4(%eax),%edx
    a502:	8b 45 08             	mov    0x8(%ebp),%eax
    a505:	01 d0                	add    %edx,%eax
    a507:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    a50b:	66 c1 ea 08          	shr    $0x8,%dx
    a50f:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 5] = b & 255;
    a511:	8b 55 0c             	mov    0xc(%ebp),%edx
    a514:	89 d0                	mov    %edx,%eax
    a516:	01 c0                	add    %eax,%eax
    a518:	01 d0                	add    %edx,%eax
    a51a:	01 c0                	add    %eax,%eax
    a51c:	8d 50 05             	lea    0x5(%eax),%edx
    a51f:	8b 45 08             	mov    0x8(%ebp),%eax
    a522:	01 d0                	add    %edx,%eax
    a524:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    a528:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    out[i * 8 + 5] = b & 255;
    out[i * 8 + 6] = (a >> 8) & 255;
    out[i * 8 + 7] = a & 255;
  }
}
    a52a:	e9 2b 01 00 00       	jmp    a65a <rgba16ToPixel+0x241>
    out[i * 6 + 1] = r & 255;
    out[i * 6 + 2] = (g >> 8) & 255;
    out[i * 6 + 3] = g & 255;
    out[i * 6 + 4] = (b >> 8) & 255;
    out[i * 6 + 5] = b & 255;
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    a52f:	8b 45 10             	mov    0x10(%ebp),%eax
    a532:	8b 00                	mov    (%eax),%eax
    a534:	83 f8 04             	cmp    $0x4,%eax
    a537:	75 64                	jne    a59d <rgba16ToPixel+0x184>
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    a539:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
    a53d:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
    out[i * 4 + 0] = (gray >> 8) & 255;
    a541:	8b 45 0c             	mov    0xc(%ebp),%eax
    a544:	c1 e0 02             	shl    $0x2,%eax
    a547:	89 c2                	mov    %eax,%edx
    a549:	8b 45 08             	mov    0x8(%ebp),%eax
    a54c:	01 d0                	add    %edx,%eax
    a54e:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
    a552:	66 c1 ea 08          	shr    $0x8,%dx
    a556:	88 10                	mov    %dl,(%eax)
    out[i * 4 + 1] = gray & 255;
    a558:	8b 45 0c             	mov    0xc(%ebp),%eax
    a55b:	c1 e0 02             	shl    $0x2,%eax
    a55e:	8d 50 01             	lea    0x1(%eax),%edx
    a561:	8b 45 08             	mov    0x8(%ebp),%eax
    a564:	01 d0                	add    %edx,%eax
    a566:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
    a56a:	88 10                	mov    %dl,(%eax)
    out[i * 4 + 2] = (a >> 8) & 255;
    a56c:	8b 45 0c             	mov    0xc(%ebp),%eax
    a56f:	c1 e0 02             	shl    $0x2,%eax
    a572:	8d 50 02             	lea    0x2(%eax),%edx
    a575:	8b 45 08             	mov    0x8(%ebp),%eax
    a578:	01 d0                	add    %edx,%eax
    a57a:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    a57e:	66 c1 ea 08          	shr    $0x8,%dx
    a582:	88 10                	mov    %dl,(%eax)
    out[i * 4 + 3] = a & 255;
    a584:	8b 45 0c             	mov    0xc(%ebp),%eax
    a587:	c1 e0 02             	shl    $0x2,%eax
    a58a:	8d 50 03             	lea    0x3(%eax),%edx
    a58d:	8b 45 08             	mov    0x8(%ebp),%eax
    a590:	01 d0                	add    %edx,%eax
    a592:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    a596:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    out[i * 8 + 5] = b & 255;
    out[i * 8 + 6] = (a >> 8) & 255;
    out[i * 8 + 7] = a & 255;
  }
}
    a598:	e9 bd 00 00 00       	jmp    a65a <rgba16ToPixel+0x241>
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    out[i * 4 + 0] = (gray >> 8) & 255;
    out[i * 4 + 1] = gray & 255;
    out[i * 4 + 2] = (a >> 8) & 255;
    out[i * 4 + 3] = a & 255;
  } else if(mode->colortype == LCT_RGBA) {
    a59d:	8b 45 10             	mov    0x10(%ebp),%eax
    a5a0:	8b 00                	mov    (%eax),%eax
    a5a2:	83 f8 06             	cmp    $0x6,%eax
    a5a5:	0f 85 af 00 00 00    	jne    a65a <rgba16ToPixel+0x241>
    out[i * 8 + 0] = (r >> 8) & 255;
    a5ab:	8b 45 0c             	mov    0xc(%ebp),%eax
    a5ae:	c1 e0 03             	shl    $0x3,%eax
    a5b1:	89 c2                	mov    %eax,%edx
    a5b3:	8b 45 08             	mov    0x8(%ebp),%eax
    a5b6:	01 d0                	add    %edx,%eax
    a5b8:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    a5bc:	66 c1 ea 08          	shr    $0x8,%dx
    a5c0:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 1] = r & 255;
    a5c2:	8b 45 0c             	mov    0xc(%ebp),%eax
    a5c5:	c1 e0 03             	shl    $0x3,%eax
    a5c8:	8d 50 01             	lea    0x1(%eax),%edx
    a5cb:	8b 45 08             	mov    0x8(%ebp),%eax
    a5ce:	01 d0                	add    %edx,%eax
    a5d0:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    a5d4:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 2] = (g >> 8) & 255;
    a5d6:	8b 45 0c             	mov    0xc(%ebp),%eax
    a5d9:	c1 e0 03             	shl    $0x3,%eax
    a5dc:	8d 50 02             	lea    0x2(%eax),%edx
    a5df:	8b 45 08             	mov    0x8(%ebp),%eax
    a5e2:	01 d0                	add    %edx,%eax
    a5e4:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    a5e8:	66 c1 ea 08          	shr    $0x8,%dx
    a5ec:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 3] = g & 255;
    a5ee:	8b 45 0c             	mov    0xc(%ebp),%eax
    a5f1:	c1 e0 03             	shl    $0x3,%eax
    a5f4:	8d 50 03             	lea    0x3(%eax),%edx
    a5f7:	8b 45 08             	mov    0x8(%ebp),%eax
    a5fa:	01 d0                	add    %edx,%eax
    a5fc:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    a600:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    a602:	8b 45 0c             	mov    0xc(%ebp),%eax
    a605:	c1 e0 03             	shl    $0x3,%eax
    a608:	8d 50 04             	lea    0x4(%eax),%edx
    a60b:	8b 45 08             	mov    0x8(%ebp),%eax
    a60e:	01 d0                	add    %edx,%eax
    a610:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    a614:	66 c1 ea 08          	shr    $0x8,%dx
    a618:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 5] = b & 255;
    a61a:	8b 45 0c             	mov    0xc(%ebp),%eax
    a61d:	c1 e0 03             	shl    $0x3,%eax
    a620:	8d 50 05             	lea    0x5(%eax),%edx
    a623:	8b 45 08             	mov    0x8(%ebp),%eax
    a626:	01 d0                	add    %edx,%eax
    a628:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    a62c:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 6] = (a >> 8) & 255;
    a62e:	8b 45 0c             	mov    0xc(%ebp),%eax
    a631:	c1 e0 03             	shl    $0x3,%eax
    a634:	8d 50 06             	lea    0x6(%eax),%edx
    a637:	8b 45 08             	mov    0x8(%ebp),%eax
    a63a:	01 d0                	add    %edx,%eax
    a63c:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    a640:	66 c1 ea 08          	shr    $0x8,%dx
    a644:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 7] = a & 255;
    a646:	8b 45 0c             	mov    0xc(%ebp),%eax
    a649:	c1 e0 03             	shl    $0x3,%eax
    a64c:	8d 50 07             	lea    0x7(%eax),%edx
    a64f:	8b 45 08             	mov    0x8(%ebp),%eax
    a652:	01 d0                	add    %edx,%eax
    a654:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    a658:	88 10                	mov    %dl,(%eax)
  }
}
    a65a:	90                   	nop
    a65b:	83 c4 20             	add    $0x20,%esp
    a65e:	5b                   	pop    %ebx
    a65f:	5d                   	pop    %ebp
    a660:	c3                   	ret    

0000a661 <getPixelColorRGBA8>:

/*Get RGBA8 color of pixel with index i (y * width + x) from the raw image with given color type.*/
static void getPixelColorRGBA8(unsigned char* r, unsigned char* g,
                               unsigned char* b, unsigned char* a,
                               const unsigned char* in, size_t i,
                               const LodePNGColorMode* mode) {
    a661:	55                   	push   %ebp
    a662:	89 e5                	mov    %esp,%ebp
    a664:	83 ec 20             	sub    $0x20,%esp
  if(mode->colortype == LCT_GREY) {
    a667:	8b 45 20             	mov    0x20(%ebp),%eax
    a66a:	8b 00                	mov    (%eax),%eax
    a66c:	85 c0                	test   %eax,%eax
    a66e:	0f 85 8c 01 00 00    	jne    a800 <getPixelColorRGBA8+0x19f>
    if(mode->bitdepth == 8) {
    a674:	8b 45 20             	mov    0x20(%ebp),%eax
    a677:	8b 40 04             	mov    0x4(%eax),%eax
    a67a:	83 f8 08             	cmp    $0x8,%eax
    a67d:	75 59                	jne    a6d8 <getPixelColorRGBA8+0x77>
      *r = *g = *b = in[i];
    a67f:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a682:	8b 45 18             	mov    0x18(%ebp),%eax
    a685:	01 d0                	add    %edx,%eax
    a687:	0f b6 10             	movzbl (%eax),%edx
    a68a:	8b 45 10             	mov    0x10(%ebp),%eax
    a68d:	88 10                	mov    %dl,(%eax)
    a68f:	8b 45 10             	mov    0x10(%ebp),%eax
    a692:	0f b6 10             	movzbl (%eax),%edx
    a695:	8b 45 0c             	mov    0xc(%ebp),%eax
    a698:	88 10                	mov    %dl,(%eax)
    a69a:	8b 45 0c             	mov    0xc(%ebp),%eax
    a69d:	0f b6 10             	movzbl (%eax),%edx
    a6a0:	8b 45 08             	mov    0x8(%ebp),%eax
    a6a3:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && *r == mode->key_r) *a = 0;
    a6a5:	8b 45 20             	mov    0x20(%ebp),%eax
    a6a8:	8b 40 10             	mov    0x10(%eax),%eax
    a6ab:	85 c0                	test   %eax,%eax
    a6ad:	74 1e                	je     a6cd <getPixelColorRGBA8+0x6c>
    a6af:	8b 45 08             	mov    0x8(%ebp),%eax
    a6b2:	0f b6 00             	movzbl (%eax),%eax
    a6b5:	0f b6 d0             	movzbl %al,%edx
    a6b8:	8b 45 20             	mov    0x20(%ebp),%eax
    a6bb:	8b 40 14             	mov    0x14(%eax),%eax
    a6be:	39 c2                	cmp    %eax,%edx
    a6c0:	75 0b                	jne    a6cd <getPixelColorRGBA8+0x6c>
    a6c2:	8b 45 14             	mov    0x14(%ebp),%eax
    a6c5:	c6 00 00             	movb   $0x0,(%eax)
    a6c8:	e9 5e 05 00 00       	jmp    ac2b <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    a6cd:	8b 45 14             	mov    0x14(%ebp),%eax
    a6d0:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    a6d3:	e9 53 05 00 00       	jmp    ac2b <getPixelColorRGBA8+0x5ca>
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      *r = *g = *b = in[i];
      if(mode->key_defined && *r == mode->key_r) *a = 0;
      else *a = 255;
    } else if(mode->bitdepth == 16) {
    a6d8:	8b 45 20             	mov    0x20(%ebp),%eax
    a6db:	8b 40 04             	mov    0x4(%eax),%eax
    a6de:	83 f8 10             	cmp    $0x10,%eax
    a6e1:	0f 85 80 00 00 00    	jne    a767 <getPixelColorRGBA8+0x106>
      *r = *g = *b = in[i * 2 + 0];
    a6e7:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a6ea:	01 c0                	add    %eax,%eax
    a6ec:	89 c2                	mov    %eax,%edx
    a6ee:	8b 45 18             	mov    0x18(%ebp),%eax
    a6f1:	01 d0                	add    %edx,%eax
    a6f3:	0f b6 10             	movzbl (%eax),%edx
    a6f6:	8b 45 10             	mov    0x10(%ebp),%eax
    a6f9:	88 10                	mov    %dl,(%eax)
    a6fb:	8b 45 10             	mov    0x10(%ebp),%eax
    a6fe:	0f b6 10             	movzbl (%eax),%edx
    a701:	8b 45 0c             	mov    0xc(%ebp),%eax
    a704:	88 10                	mov    %dl,(%eax)
    a706:	8b 45 0c             	mov    0xc(%ebp),%eax
    a709:	0f b6 10             	movzbl (%eax),%edx
    a70c:	8b 45 08             	mov    0x8(%ebp),%eax
    a70f:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
    a711:	8b 45 20             	mov    0x20(%ebp),%eax
    a714:	8b 40 10             	mov    0x10(%eax),%eax
    a717:	85 c0                	test   %eax,%eax
    a719:	74 41                	je     a75c <getPixelColorRGBA8+0xfb>
    a71b:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a71e:	01 c0                	add    %eax,%eax
    a720:	89 c2                	mov    %eax,%edx
    a722:	8b 45 18             	mov    0x18(%ebp),%eax
    a725:	01 d0                	add    %edx,%eax
    a727:	0f b6 00             	movzbl (%eax),%eax
    a72a:	0f b6 c0             	movzbl %al,%eax
    a72d:	c1 e0 08             	shl    $0x8,%eax
    a730:	89 c2                	mov    %eax,%edx
    a732:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a735:	01 c0                	add    %eax,%eax
    a737:	8d 48 01             	lea    0x1(%eax),%ecx
    a73a:	8b 45 18             	mov    0x18(%ebp),%eax
    a73d:	01 c8                	add    %ecx,%eax
    a73f:	0f b6 00             	movzbl (%eax),%eax
    a742:	0f b6 c0             	movzbl %al,%eax
    a745:	01 c2                	add    %eax,%edx
    a747:	8b 45 20             	mov    0x20(%ebp),%eax
    a74a:	8b 40 14             	mov    0x14(%eax),%eax
    a74d:	39 c2                	cmp    %eax,%edx
    a74f:	75 0b                	jne    a75c <getPixelColorRGBA8+0xfb>
    a751:	8b 45 14             	mov    0x14(%ebp),%eax
    a754:	c6 00 00             	movb   $0x0,(%eax)
    a757:	e9 cf 04 00 00       	jmp    ac2b <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    a75c:	8b 45 14             	mov    0x14(%ebp),%eax
    a75f:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    a762:	e9 c4 04 00 00       	jmp    ac2b <getPixelColorRGBA8+0x5ca>
    } else if(mode->bitdepth == 16) {
      *r = *g = *b = in[i * 2 + 0];
      if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
      else *a = 255;
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
    a767:	8b 45 20             	mov    0x20(%ebp),%eax
    a76a:	8b 40 04             	mov    0x4(%eax),%eax
    a76d:	ba 01 00 00 00       	mov    $0x1,%edx
    a772:	89 c1                	mov    %eax,%ecx
    a774:	d3 e2                	shl    %cl,%edx
    a776:	89 d0                	mov    %edx,%eax
    a778:	83 e8 01             	sub    $0x1,%eax
    a77b:	89 45 f8             	mov    %eax,-0x8(%ebp)
      size_t j = i * mode->bitdepth;
    a77e:	8b 45 20             	mov    0x20(%ebp),%eax
    a781:	8b 50 04             	mov    0x4(%eax),%edx
    a784:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a787:	0f af c2             	imul   %edx,%eax
    a78a:	89 45 f0             	mov    %eax,-0x10(%ebp)
      unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
    a78d:	8b 45 20             	mov    0x20(%ebp),%eax
    a790:	8b 40 04             	mov    0x4(%eax),%eax
    a793:	50                   	push   %eax
    a794:	ff 75 18             	pushl  0x18(%ebp)
    a797:	8d 45 f0             	lea    -0x10(%ebp),%eax
    a79a:	50                   	push   %eax
    a79b:	e8 06 db ff ff       	call   82a6 <readBitsFromReversedStream>
    a7a0:	83 c4 0c             	add    $0xc,%esp
    a7a3:	89 45 f4             	mov    %eax,-0xc(%ebp)
      *r = *g = *b = (value * 255) / highest;
    a7a6:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a7a9:	89 d0                	mov    %edx,%eax
    a7ab:	c1 e0 08             	shl    $0x8,%eax
    a7ae:	29 d0                	sub    %edx,%eax
    a7b0:	ba 00 00 00 00       	mov    $0x0,%edx
    a7b5:	f7 75 f8             	divl   -0x8(%ebp)
    a7b8:	89 c2                	mov    %eax,%edx
    a7ba:	8b 45 10             	mov    0x10(%ebp),%eax
    a7bd:	88 10                	mov    %dl,(%eax)
    a7bf:	8b 45 10             	mov    0x10(%ebp),%eax
    a7c2:	0f b6 10             	movzbl (%eax),%edx
    a7c5:	8b 45 0c             	mov    0xc(%ebp),%eax
    a7c8:	88 10                	mov    %dl,(%eax)
    a7ca:	8b 45 0c             	mov    0xc(%ebp),%eax
    a7cd:	0f b6 10             	movzbl (%eax),%edx
    a7d0:	8b 45 08             	mov    0x8(%ebp),%eax
    a7d3:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && value == mode->key_r) *a = 0;
    a7d5:	8b 45 20             	mov    0x20(%ebp),%eax
    a7d8:	8b 40 10             	mov    0x10(%eax),%eax
    a7db:	85 c0                	test   %eax,%eax
    a7dd:	74 16                	je     a7f5 <getPixelColorRGBA8+0x194>
    a7df:	8b 45 20             	mov    0x20(%ebp),%eax
    a7e2:	8b 40 14             	mov    0x14(%eax),%eax
    a7e5:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    a7e8:	75 0b                	jne    a7f5 <getPixelColorRGBA8+0x194>
    a7ea:	8b 45 14             	mov    0x14(%ebp),%eax
    a7ed:	c6 00 00             	movb   $0x0,(%eax)
    a7f0:	e9 36 04 00 00       	jmp    ac2b <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    a7f5:	8b 45 14             	mov    0x14(%ebp),%eax
    a7f8:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    a7fb:	e9 2b 04 00 00       	jmp    ac2b <getPixelColorRGBA8+0x5ca>
      unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
      *r = *g = *b = (value * 255) / highest;
      if(mode->key_defined && value == mode->key_r) *a = 0;
      else *a = 255;
    }
  } else if(mode->colortype == LCT_RGB) {
    a800:	8b 45 20             	mov    0x20(%ebp),%eax
    a803:	8b 00                	mov    (%eax),%eax
    a805:	83 f8 02             	cmp    $0x2,%eax
    a808:	0f 85 f5 01 00 00    	jne    aa03 <getPixelColorRGBA8+0x3a2>
    if(mode->bitdepth == 8) {
    a80e:	8b 45 20             	mov    0x20(%ebp),%eax
    a811:	8b 40 04             	mov    0x4(%eax),%eax
    a814:	83 f8 08             	cmp    $0x8,%eax
    a817:	0f 85 a3 00 00 00    	jne    a8c0 <getPixelColorRGBA8+0x25f>
      *r = in[i * 3 + 0]; *g = in[i * 3 + 1]; *b = in[i * 3 + 2];
    a81d:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a820:	89 d0                	mov    %edx,%eax
    a822:	01 c0                	add    %eax,%eax
    a824:	01 d0                	add    %edx,%eax
    a826:	89 c2                	mov    %eax,%edx
    a828:	8b 45 18             	mov    0x18(%ebp),%eax
    a82b:	01 d0                	add    %edx,%eax
    a82d:	0f b6 10             	movzbl (%eax),%edx
    a830:	8b 45 08             	mov    0x8(%ebp),%eax
    a833:	88 10                	mov    %dl,(%eax)
    a835:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a838:	89 d0                	mov    %edx,%eax
    a83a:	01 c0                	add    %eax,%eax
    a83c:	01 d0                	add    %edx,%eax
    a83e:	8d 50 01             	lea    0x1(%eax),%edx
    a841:	8b 45 18             	mov    0x18(%ebp),%eax
    a844:	01 d0                	add    %edx,%eax
    a846:	0f b6 10             	movzbl (%eax),%edx
    a849:	8b 45 0c             	mov    0xc(%ebp),%eax
    a84c:	88 10                	mov    %dl,(%eax)
    a84e:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a851:	89 d0                	mov    %edx,%eax
    a853:	01 c0                	add    %eax,%eax
    a855:	01 d0                	add    %edx,%eax
    a857:	8d 50 02             	lea    0x2(%eax),%edx
    a85a:	8b 45 18             	mov    0x18(%ebp),%eax
    a85d:	01 d0                	add    %edx,%eax
    a85f:	0f b6 10             	movzbl (%eax),%edx
    a862:	8b 45 10             	mov    0x10(%ebp),%eax
    a865:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && *r == mode->key_r && *g == mode->key_g && *b == mode->key_b) *a = 0;
    a867:	8b 45 20             	mov    0x20(%ebp),%eax
    a86a:	8b 40 10             	mov    0x10(%eax),%eax
    a86d:	85 c0                	test   %eax,%eax
    a86f:	74 44                	je     a8b5 <getPixelColorRGBA8+0x254>
    a871:	8b 45 08             	mov    0x8(%ebp),%eax
    a874:	0f b6 00             	movzbl (%eax),%eax
    a877:	0f b6 d0             	movzbl %al,%edx
    a87a:	8b 45 20             	mov    0x20(%ebp),%eax
    a87d:	8b 40 14             	mov    0x14(%eax),%eax
    a880:	39 c2                	cmp    %eax,%edx
    a882:	75 31                	jne    a8b5 <getPixelColorRGBA8+0x254>
    a884:	8b 45 0c             	mov    0xc(%ebp),%eax
    a887:	0f b6 00             	movzbl (%eax),%eax
    a88a:	0f b6 d0             	movzbl %al,%edx
    a88d:	8b 45 20             	mov    0x20(%ebp),%eax
    a890:	8b 40 18             	mov    0x18(%eax),%eax
    a893:	39 c2                	cmp    %eax,%edx
    a895:	75 1e                	jne    a8b5 <getPixelColorRGBA8+0x254>
    a897:	8b 45 10             	mov    0x10(%ebp),%eax
    a89a:	0f b6 00             	movzbl (%eax),%eax
    a89d:	0f b6 d0             	movzbl %al,%edx
    a8a0:	8b 45 20             	mov    0x20(%ebp),%eax
    a8a3:	8b 40 1c             	mov    0x1c(%eax),%eax
    a8a6:	39 c2                	cmp    %eax,%edx
    a8a8:	75 0b                	jne    a8b5 <getPixelColorRGBA8+0x254>
    a8aa:	8b 45 14             	mov    0x14(%ebp),%eax
    a8ad:	c6 00 00             	movb   $0x0,(%eax)
    a8b0:	e9 76 03 00 00       	jmp    ac2b <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    a8b5:	8b 45 14             	mov    0x14(%ebp),%eax
    a8b8:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    a8bb:	e9 6b 03 00 00       	jmp    ac2b <getPixelColorRGBA8+0x5ca>
    if(mode->bitdepth == 8) {
      *r = in[i * 3 + 0]; *g = in[i * 3 + 1]; *b = in[i * 3 + 2];
      if(mode->key_defined && *r == mode->key_r && *g == mode->key_g && *b == mode->key_b) *a = 0;
      else *a = 255;
    } else {
      *r = in[i * 6 + 0];
    a8c0:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a8c3:	89 d0                	mov    %edx,%eax
    a8c5:	01 c0                	add    %eax,%eax
    a8c7:	01 d0                	add    %edx,%eax
    a8c9:	01 c0                	add    %eax,%eax
    a8cb:	89 c2                	mov    %eax,%edx
    a8cd:	8b 45 18             	mov    0x18(%ebp),%eax
    a8d0:	01 d0                	add    %edx,%eax
    a8d2:	0f b6 10             	movzbl (%eax),%edx
    a8d5:	8b 45 08             	mov    0x8(%ebp),%eax
    a8d8:	88 10                	mov    %dl,(%eax)
      *g = in[i * 6 + 2];
    a8da:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a8dd:	89 d0                	mov    %edx,%eax
    a8df:	01 c0                	add    %eax,%eax
    a8e1:	01 d0                	add    %edx,%eax
    a8e3:	01 c0                	add    %eax,%eax
    a8e5:	8d 50 02             	lea    0x2(%eax),%edx
    a8e8:	8b 45 18             	mov    0x18(%ebp),%eax
    a8eb:	01 d0                	add    %edx,%eax
    a8ed:	0f b6 10             	movzbl (%eax),%edx
    a8f0:	8b 45 0c             	mov    0xc(%ebp),%eax
    a8f3:	88 10                	mov    %dl,(%eax)
      *b = in[i * 6 + 4];
    a8f5:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a8f8:	89 d0                	mov    %edx,%eax
    a8fa:	01 c0                	add    %eax,%eax
    a8fc:	01 d0                	add    %edx,%eax
    a8fe:	01 c0                	add    %eax,%eax
    a900:	8d 50 04             	lea    0x4(%eax),%edx
    a903:	8b 45 18             	mov    0x18(%ebp),%eax
    a906:	01 d0                	add    %edx,%eax
    a908:	0f b6 10             	movzbl (%eax),%edx
    a90b:	8b 45 10             	mov    0x10(%ebp),%eax
    a90e:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
    a910:	8b 45 20             	mov    0x20(%ebp),%eax
    a913:	8b 40 10             	mov    0x10(%eax),%eax
    a916:	85 c0                	test   %eax,%eax
    a918:	0f 84 da 00 00 00    	je     a9f8 <getPixelColorRGBA8+0x397>
    a91e:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a921:	89 d0                	mov    %edx,%eax
    a923:	01 c0                	add    %eax,%eax
    a925:	01 d0                	add    %edx,%eax
    a927:	01 c0                	add    %eax,%eax
    a929:	89 c2                	mov    %eax,%edx
    a92b:	8b 45 18             	mov    0x18(%ebp),%eax
    a92e:	01 d0                	add    %edx,%eax
    a930:	0f b6 00             	movzbl (%eax),%eax
    a933:	0f b6 c0             	movzbl %al,%eax
    a936:	c1 e0 08             	shl    $0x8,%eax
    a939:	89 c1                	mov    %eax,%ecx
    a93b:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a93e:	89 d0                	mov    %edx,%eax
    a940:	01 c0                	add    %eax,%eax
    a942:	01 d0                	add    %edx,%eax
    a944:	01 c0                	add    %eax,%eax
    a946:	8d 50 01             	lea    0x1(%eax),%edx
    a949:	8b 45 18             	mov    0x18(%ebp),%eax
    a94c:	01 d0                	add    %edx,%eax
    a94e:	0f b6 00             	movzbl (%eax),%eax
    a951:	0f b6 c0             	movzbl %al,%eax
    a954:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    a957:	8b 45 20             	mov    0x20(%ebp),%eax
    a95a:	8b 40 14             	mov    0x14(%eax),%eax
    a95d:	39 c2                	cmp    %eax,%edx
    a95f:	0f 85 93 00 00 00    	jne    a9f8 <getPixelColorRGBA8+0x397>
         && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
    a965:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a968:	89 d0                	mov    %edx,%eax
    a96a:	01 c0                	add    %eax,%eax
    a96c:	01 d0                	add    %edx,%eax
    a96e:	01 c0                	add    %eax,%eax
    a970:	8d 50 02             	lea    0x2(%eax),%edx
    a973:	8b 45 18             	mov    0x18(%ebp),%eax
    a976:	01 d0                	add    %edx,%eax
    a978:	0f b6 00             	movzbl (%eax),%eax
    a97b:	0f b6 c0             	movzbl %al,%eax
    a97e:	c1 e0 08             	shl    $0x8,%eax
    a981:	89 c1                	mov    %eax,%ecx
    a983:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a986:	89 d0                	mov    %edx,%eax
    a988:	01 c0                	add    %eax,%eax
    a98a:	01 d0                	add    %edx,%eax
    a98c:	01 c0                	add    %eax,%eax
    a98e:	8d 50 03             	lea    0x3(%eax),%edx
    a991:	8b 45 18             	mov    0x18(%ebp),%eax
    a994:	01 d0                	add    %edx,%eax
    a996:	0f b6 00             	movzbl (%eax),%eax
    a999:	0f b6 c0             	movzbl %al,%eax
    a99c:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    a99f:	8b 45 20             	mov    0x20(%ebp),%eax
    a9a2:	8b 40 18             	mov    0x18(%eax),%eax
    a9a5:	39 c2                	cmp    %eax,%edx
    a9a7:	75 4f                	jne    a9f8 <getPixelColorRGBA8+0x397>
         && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    a9a9:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a9ac:	89 d0                	mov    %edx,%eax
    a9ae:	01 c0                	add    %eax,%eax
    a9b0:	01 d0                	add    %edx,%eax
    a9b2:	01 c0                	add    %eax,%eax
    a9b4:	8d 50 04             	lea    0x4(%eax),%edx
    a9b7:	8b 45 18             	mov    0x18(%ebp),%eax
    a9ba:	01 d0                	add    %edx,%eax
    a9bc:	0f b6 00             	movzbl (%eax),%eax
    a9bf:	0f b6 c0             	movzbl %al,%eax
    a9c2:	c1 e0 08             	shl    $0x8,%eax
    a9c5:	89 c1                	mov    %eax,%ecx
    a9c7:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a9ca:	89 d0                	mov    %edx,%eax
    a9cc:	01 c0                	add    %eax,%eax
    a9ce:	01 d0                	add    %edx,%eax
    a9d0:	01 c0                	add    %eax,%eax
    a9d2:	8d 50 05             	lea    0x5(%eax),%edx
    a9d5:	8b 45 18             	mov    0x18(%ebp),%eax
    a9d8:	01 d0                	add    %edx,%eax
    a9da:	0f b6 00             	movzbl (%eax),%eax
    a9dd:	0f b6 c0             	movzbl %al,%eax
    a9e0:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    a9e3:	8b 45 20             	mov    0x20(%ebp),%eax
    a9e6:	8b 40 1c             	mov    0x1c(%eax),%eax
    a9e9:	39 c2                	cmp    %eax,%edx
    a9eb:	75 0b                	jne    a9f8 <getPixelColorRGBA8+0x397>
    a9ed:	8b 45 14             	mov    0x14(%ebp),%eax
    a9f0:	c6 00 00             	movb   $0x0,(%eax)
    a9f3:	e9 33 02 00 00       	jmp    ac2b <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    a9f8:	8b 45 14             	mov    0x14(%ebp),%eax
    a9fb:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    a9fe:	e9 28 02 00 00       	jmp    ac2b <getPixelColorRGBA8+0x5ca>
      if(mode->key_defined && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
         && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
         && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
      else *a = 255;
    }
  } else if(mode->colortype == LCT_PALETTE) {
    aa03:	8b 45 20             	mov    0x20(%ebp),%eax
    aa06:	8b 00                	mov    (%eax),%eax
    aa08:	83 f8 03             	cmp    $0x3,%eax
    aa0b:	0f 85 ac 00 00 00    	jne    aabd <getPixelColorRGBA8+0x45c>
    unsigned index;
    if(mode->bitdepth == 8) index = in[i];
    aa11:	8b 45 20             	mov    0x20(%ebp),%eax
    aa14:	8b 40 04             	mov    0x4(%eax),%eax
    aa17:	83 f8 08             	cmp    $0x8,%eax
    aa1a:	75 13                	jne    aa2f <getPixelColorRGBA8+0x3ce>
    aa1c:	8b 55 1c             	mov    0x1c(%ebp),%edx
    aa1f:	8b 45 18             	mov    0x18(%ebp),%eax
    aa22:	01 d0                	add    %edx,%eax
    aa24:	0f b6 00             	movzbl (%eax),%eax
    aa27:	0f b6 c0             	movzbl %al,%eax
    aa2a:	89 45 fc             	mov    %eax,-0x4(%ebp)
    aa2d:	eb 28                	jmp    aa57 <getPixelColorRGBA8+0x3f6>
    else {
      size_t j = i * mode->bitdepth;
    aa2f:	8b 45 20             	mov    0x20(%ebp),%eax
    aa32:	8b 50 04             	mov    0x4(%eax),%edx
    aa35:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aa38:	0f af c2             	imul   %edx,%eax
    aa3b:	89 45 ec             	mov    %eax,-0x14(%ebp)
      index = readBitsFromReversedStream(&j, in, mode->bitdepth);
    aa3e:	8b 45 20             	mov    0x20(%ebp),%eax
    aa41:	8b 40 04             	mov    0x4(%eax),%eax
    aa44:	50                   	push   %eax
    aa45:	ff 75 18             	pushl  0x18(%ebp)
    aa48:	8d 45 ec             	lea    -0x14(%ebp),%eax
    aa4b:	50                   	push   %eax
    aa4c:	e8 55 d8 ff ff       	call   82a6 <readBitsFromReversedStream>
    aa51:	83 c4 0c             	add    $0xc,%esp
    aa54:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
    /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
    *r = mode->palette[index * 4 + 0];
    aa57:	8b 45 20             	mov    0x20(%ebp),%eax
    aa5a:	8b 40 08             	mov    0x8(%eax),%eax
    aa5d:	8b 55 fc             	mov    -0x4(%ebp),%edx
    aa60:	c1 e2 02             	shl    $0x2,%edx
    aa63:	01 d0                	add    %edx,%eax
    aa65:	0f b6 10             	movzbl (%eax),%edx
    aa68:	8b 45 08             	mov    0x8(%ebp),%eax
    aa6b:	88 10                	mov    %dl,(%eax)
    *g = mode->palette[index * 4 + 1];
    aa6d:	8b 45 20             	mov    0x20(%ebp),%eax
    aa70:	8b 40 08             	mov    0x8(%eax),%eax
    aa73:	8b 55 fc             	mov    -0x4(%ebp),%edx
    aa76:	c1 e2 02             	shl    $0x2,%edx
    aa79:	83 c2 01             	add    $0x1,%edx
    aa7c:	01 d0                	add    %edx,%eax
    aa7e:	0f b6 10             	movzbl (%eax),%edx
    aa81:	8b 45 0c             	mov    0xc(%ebp),%eax
    aa84:	88 10                	mov    %dl,(%eax)
    *b = mode->palette[index * 4 + 2];
    aa86:	8b 45 20             	mov    0x20(%ebp),%eax
    aa89:	8b 40 08             	mov    0x8(%eax),%eax
    aa8c:	8b 55 fc             	mov    -0x4(%ebp),%edx
    aa8f:	c1 e2 02             	shl    $0x2,%edx
    aa92:	83 c2 02             	add    $0x2,%edx
    aa95:	01 d0                	add    %edx,%eax
    aa97:	0f b6 10             	movzbl (%eax),%edx
    aa9a:	8b 45 10             	mov    0x10(%ebp),%eax
    aa9d:	88 10                	mov    %dl,(%eax)
    *a = mode->palette[index * 4 + 3];
    aa9f:	8b 45 20             	mov    0x20(%ebp),%eax
    aaa2:	8b 40 08             	mov    0x8(%eax),%eax
    aaa5:	8b 55 fc             	mov    -0x4(%ebp),%edx
    aaa8:	c1 e2 02             	shl    $0x2,%edx
    aaab:	83 c2 03             	add    $0x3,%edx
    aaae:	01 d0                	add    %edx,%eax
    aab0:	0f b6 10             	movzbl (%eax),%edx
    aab3:	8b 45 14             	mov    0x14(%ebp),%eax
    aab6:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    aab8:	e9 6e 01 00 00       	jmp    ac2b <getPixelColorRGBA8+0x5ca>
    /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
    *r = mode->palette[index * 4 + 0];
    *g = mode->palette[index * 4 + 1];
    *b = mode->palette[index * 4 + 2];
    *a = mode->palette[index * 4 + 3];
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    aabd:	8b 45 20             	mov    0x20(%ebp),%eax
    aac0:	8b 00                	mov    (%eax),%eax
    aac2:	83 f8 04             	cmp    $0x4,%eax
    aac5:	0f 85 95 00 00 00    	jne    ab60 <getPixelColorRGBA8+0x4ff>
    if(mode->bitdepth == 8) {
    aacb:	8b 45 20             	mov    0x20(%ebp),%eax
    aace:	8b 40 04             	mov    0x4(%eax),%eax
    aad1:	83 f8 08             	cmp    $0x8,%eax
    aad4:	75 44                	jne    ab1a <getPixelColorRGBA8+0x4b9>
      *r = *g = *b = in[i * 2 + 0];
    aad6:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aad9:	01 c0                	add    %eax,%eax
    aadb:	89 c2                	mov    %eax,%edx
    aadd:	8b 45 18             	mov    0x18(%ebp),%eax
    aae0:	01 d0                	add    %edx,%eax
    aae2:	0f b6 10             	movzbl (%eax),%edx
    aae5:	8b 45 10             	mov    0x10(%ebp),%eax
    aae8:	88 10                	mov    %dl,(%eax)
    aaea:	8b 45 10             	mov    0x10(%ebp),%eax
    aaed:	0f b6 10             	movzbl (%eax),%edx
    aaf0:	8b 45 0c             	mov    0xc(%ebp),%eax
    aaf3:	88 10                	mov    %dl,(%eax)
    aaf5:	8b 45 0c             	mov    0xc(%ebp),%eax
    aaf8:	0f b6 10             	movzbl (%eax),%edx
    aafb:	8b 45 08             	mov    0x8(%ebp),%eax
    aafe:	88 10                	mov    %dl,(%eax)
      *a = in[i * 2 + 1];
    ab00:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ab03:	01 c0                	add    %eax,%eax
    ab05:	8d 50 01             	lea    0x1(%eax),%edx
    ab08:	8b 45 18             	mov    0x18(%ebp),%eax
    ab0b:	01 d0                	add    %edx,%eax
    ab0d:	0f b6 10             	movzbl (%eax),%edx
    ab10:	8b 45 14             	mov    0x14(%ebp),%eax
    ab13:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    ab15:	e9 11 01 00 00       	jmp    ac2b <getPixelColorRGBA8+0x5ca>
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    if(mode->bitdepth == 8) {
      *r = *g = *b = in[i * 2 + 0];
      *a = in[i * 2 + 1];
    } else {
      *r = *g = *b = in[i * 4 + 0];
    ab1a:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ab1d:	c1 e0 02             	shl    $0x2,%eax
    ab20:	89 c2                	mov    %eax,%edx
    ab22:	8b 45 18             	mov    0x18(%ebp),%eax
    ab25:	01 d0                	add    %edx,%eax
    ab27:	0f b6 10             	movzbl (%eax),%edx
    ab2a:	8b 45 10             	mov    0x10(%ebp),%eax
    ab2d:	88 10                	mov    %dl,(%eax)
    ab2f:	8b 45 10             	mov    0x10(%ebp),%eax
    ab32:	0f b6 10             	movzbl (%eax),%edx
    ab35:	8b 45 0c             	mov    0xc(%ebp),%eax
    ab38:	88 10                	mov    %dl,(%eax)
    ab3a:	8b 45 0c             	mov    0xc(%ebp),%eax
    ab3d:	0f b6 10             	movzbl (%eax),%edx
    ab40:	8b 45 08             	mov    0x8(%ebp),%eax
    ab43:	88 10                	mov    %dl,(%eax)
      *a = in[i * 4 + 2];
    ab45:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ab48:	c1 e0 02             	shl    $0x2,%eax
    ab4b:	8d 50 02             	lea    0x2(%eax),%edx
    ab4e:	8b 45 18             	mov    0x18(%ebp),%eax
    ab51:	01 d0                	add    %edx,%eax
    ab53:	0f b6 10             	movzbl (%eax),%edx
    ab56:	8b 45 14             	mov    0x14(%ebp),%eax
    ab59:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    ab5b:	e9 cb 00 00 00       	jmp    ac2b <getPixelColorRGBA8+0x5ca>
      *a = in[i * 2 + 1];
    } else {
      *r = *g = *b = in[i * 4 + 0];
      *a = in[i * 4 + 2];
    }
  } else if(mode->colortype == LCT_RGBA) {
    ab60:	8b 45 20             	mov    0x20(%ebp),%eax
    ab63:	8b 00                	mov    (%eax),%eax
    ab65:	83 f8 06             	cmp    $0x6,%eax
    ab68:	0f 85 bd 00 00 00    	jne    ac2b <getPixelColorRGBA8+0x5ca>
    if(mode->bitdepth == 8) {
    ab6e:	8b 45 20             	mov    0x20(%ebp),%eax
    ab71:	8b 40 04             	mov    0x4(%eax),%eax
    ab74:	83 f8 08             	cmp    $0x8,%eax
    ab77:	75 59                	jne    abd2 <getPixelColorRGBA8+0x571>
      *r = in[i * 4 + 0];
    ab79:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ab7c:	c1 e0 02             	shl    $0x2,%eax
    ab7f:	89 c2                	mov    %eax,%edx
    ab81:	8b 45 18             	mov    0x18(%ebp),%eax
    ab84:	01 d0                	add    %edx,%eax
    ab86:	0f b6 10             	movzbl (%eax),%edx
    ab89:	8b 45 08             	mov    0x8(%ebp),%eax
    ab8c:	88 10                	mov    %dl,(%eax)
      *g = in[i * 4 + 1];
    ab8e:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ab91:	c1 e0 02             	shl    $0x2,%eax
    ab94:	8d 50 01             	lea    0x1(%eax),%edx
    ab97:	8b 45 18             	mov    0x18(%ebp),%eax
    ab9a:	01 d0                	add    %edx,%eax
    ab9c:	0f b6 10             	movzbl (%eax),%edx
    ab9f:	8b 45 0c             	mov    0xc(%ebp),%eax
    aba2:	88 10                	mov    %dl,(%eax)
      *b = in[i * 4 + 2];
    aba4:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aba7:	c1 e0 02             	shl    $0x2,%eax
    abaa:	8d 50 02             	lea    0x2(%eax),%edx
    abad:	8b 45 18             	mov    0x18(%ebp),%eax
    abb0:	01 d0                	add    %edx,%eax
    abb2:	0f b6 10             	movzbl (%eax),%edx
    abb5:	8b 45 10             	mov    0x10(%ebp),%eax
    abb8:	88 10                	mov    %dl,(%eax)
      *a = in[i * 4 + 3];
    abba:	8b 45 1c             	mov    0x1c(%ebp),%eax
    abbd:	c1 e0 02             	shl    $0x2,%eax
    abc0:	8d 50 03             	lea    0x3(%eax),%edx
    abc3:	8b 45 18             	mov    0x18(%ebp),%eax
    abc6:	01 d0                	add    %edx,%eax
    abc8:	0f b6 10             	movzbl (%eax),%edx
    abcb:	8b 45 14             	mov    0x14(%ebp),%eax
    abce:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    abd0:	eb 59                	jmp    ac2b <getPixelColorRGBA8+0x5ca>
      *r = in[i * 4 + 0];
      *g = in[i * 4 + 1];
      *b = in[i * 4 + 2];
      *a = in[i * 4 + 3];
    } else {
      *r = in[i * 8 + 0];
    abd2:	8b 45 1c             	mov    0x1c(%ebp),%eax
    abd5:	c1 e0 03             	shl    $0x3,%eax
    abd8:	89 c2                	mov    %eax,%edx
    abda:	8b 45 18             	mov    0x18(%ebp),%eax
    abdd:	01 d0                	add    %edx,%eax
    abdf:	0f b6 10             	movzbl (%eax),%edx
    abe2:	8b 45 08             	mov    0x8(%ebp),%eax
    abe5:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
    abe7:	8b 45 1c             	mov    0x1c(%ebp),%eax
    abea:	c1 e0 03             	shl    $0x3,%eax
    abed:	8d 50 02             	lea    0x2(%eax),%edx
    abf0:	8b 45 18             	mov    0x18(%ebp),%eax
    abf3:	01 d0                	add    %edx,%eax
    abf5:	0f b6 10             	movzbl (%eax),%edx
    abf8:	8b 45 0c             	mov    0xc(%ebp),%eax
    abfb:	88 10                	mov    %dl,(%eax)
      *b = in[i * 8 + 4];
    abfd:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ac00:	c1 e0 03             	shl    $0x3,%eax
    ac03:	8d 50 04             	lea    0x4(%eax),%edx
    ac06:	8b 45 18             	mov    0x18(%ebp),%eax
    ac09:	01 d0                	add    %edx,%eax
    ac0b:	0f b6 10             	movzbl (%eax),%edx
    ac0e:	8b 45 10             	mov    0x10(%ebp),%eax
    ac11:	88 10                	mov    %dl,(%eax)
      *a = in[i * 8 + 6];
    ac13:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ac16:	c1 e0 03             	shl    $0x3,%eax
    ac19:	8d 50 06             	lea    0x6(%eax),%edx
    ac1c:	8b 45 18             	mov    0x18(%ebp),%eax
    ac1f:	01 d0                	add    %edx,%eax
    ac21:	0f b6 10             	movzbl (%eax),%edx
    ac24:	8b 45 14             	mov    0x14(%ebp),%eax
    ac27:	88 10                	mov    %dl,(%eax)
    }
  }
}
    ac29:	eb 00                	jmp    ac2b <getPixelColorRGBA8+0x5ca>
    ac2b:	90                   	nop
    ac2c:	c9                   	leave  
    ac2d:	c3                   	ret    

0000ac2e <getPixelColorsRGBA8>:
mode test cases, optimized to convert the colors much faster, when converting
to the common case of RGBA with 8 bit per channel. buffer must be RGBA with
enough memory.*/
static void getPixelColorsRGBA8(unsigned char* LODEPNG_RESTRICT buffer, size_t numpixels,
                                const unsigned char* LODEPNG_RESTRICT in,
                                const LodePNGColorMode* mode) {
    ac2e:	55                   	push   %ebp
    ac2f:	89 e5                	mov    %esp,%ebp
    ac31:	53                   	push   %ebx
    ac32:	83 ec 20             	sub    $0x20,%esp
  unsigned num_channels = 4;
    ac35:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%ebp)
  size_t i;
  if(mode->colortype == LCT_GREY) {
    ac3c:	8b 45 14             	mov    0x14(%ebp),%eax
    ac3f:	8b 00                	mov    (%eax),%eax
    ac41:	85 c0                	test   %eax,%eax
    ac43:	0f 85 14 02 00 00    	jne    ae5d <getPixelColorsRGBA8+0x22f>
    if(mode->bitdepth == 8) {
    ac49:	8b 45 14             	mov    0x14(%ebp),%eax
    ac4c:	8b 40 04             	mov    0x4(%eax),%eax
    ac4f:	83 f8 08             	cmp    $0x8,%eax
    ac52:	0f 85 a0 00 00 00    	jne    acf8 <getPixelColorsRGBA8+0xca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ac58:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ac5f:	eb 39                	jmp    ac9a <getPixelColorsRGBA8+0x6c>
        buffer[0] = buffer[1] = buffer[2] = in[i];
    ac61:	8b 45 08             	mov    0x8(%ebp),%eax
    ac64:	83 c0 01             	add    $0x1,%eax
    ac67:	8b 55 08             	mov    0x8(%ebp),%edx
    ac6a:	83 c2 02             	add    $0x2,%edx
    ac6d:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    ac70:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ac73:	01 d9                	add    %ebx,%ecx
    ac75:	0f b6 09             	movzbl (%ecx),%ecx
    ac78:	88 0a                	mov    %cl,(%edx)
    ac7a:	0f b6 12             	movzbl (%edx),%edx
    ac7d:	88 10                	mov    %dl,(%eax)
    ac7f:	0f b6 10             	movzbl (%eax),%edx
    ac82:	8b 45 08             	mov    0x8(%ebp),%eax
    ac85:	88 10                	mov    %dl,(%eax)
        buffer[3] = 255;
    ac87:	8b 45 08             	mov    0x8(%ebp),%eax
    ac8a:	83 c0 03             	add    $0x3,%eax
    ac8d:	c6 00 ff             	movb   $0xff,(%eax)
                                const LodePNGColorMode* mode) {
  unsigned num_channels = 4;
  size_t i;
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ac90:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    ac94:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ac97:	01 45 08             	add    %eax,0x8(%ebp)
    ac9a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ac9d:	3b 45 0c             	cmp    0xc(%ebp),%eax
    aca0:	75 bf                	jne    ac61 <getPixelColorsRGBA8+0x33>
        buffer[0] = buffer[1] = buffer[2] = in[i];
        buffer[3] = 255;
      }
      if(mode->key_defined) {
    aca2:	8b 45 14             	mov    0x14(%ebp),%eax
    aca5:	8b 40 10             	mov    0x10(%eax),%eax
    aca8:	85 c0                	test   %eax,%eax
    acaa:	0f 84 48 06 00 00    	je     b2f8 <getPixelColorsRGBA8+0x6ca>
        buffer -= numpixels * num_channels;
    acb0:	8b 45 0c             	mov    0xc(%ebp),%eax
    acb3:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    acb7:	f7 d8                	neg    %eax
    acb9:	01 45 08             	add    %eax,0x8(%ebp)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    acbc:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    acc3:	eb 26                	jmp    aceb <getPixelColorsRGBA8+0xbd>
          if(buffer[0] == mode->key_r) buffer[3] = 0;
    acc5:	8b 45 08             	mov    0x8(%ebp),%eax
    acc8:	0f b6 00             	movzbl (%eax),%eax
    accb:	0f b6 d0             	movzbl %al,%edx
    acce:	8b 45 14             	mov    0x14(%ebp),%eax
    acd1:	8b 40 14             	mov    0x14(%eax),%eax
    acd4:	39 c2                	cmp    %eax,%edx
    acd6:	75 09                	jne    ace1 <getPixelColorsRGBA8+0xb3>
    acd8:	8b 45 08             	mov    0x8(%ebp),%eax
    acdb:	83 c0 03             	add    $0x3,%eax
    acde:	c6 00 00             	movb   $0x0,(%eax)
        buffer[0] = buffer[1] = buffer[2] = in[i];
        buffer[3] = 255;
      }
      if(mode->key_defined) {
        buffer -= numpixels * num_channels;
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ace1:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    ace5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ace8:	01 45 08             	add    %eax,0x8(%ebp)
    aceb:	8b 45 f8             	mov    -0x8(%ebp),%eax
    acee:	3b 45 0c             	cmp    0xc(%ebp),%eax
    acf1:	75 d2                	jne    acc5 <getPixelColorsRGBA8+0x97>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    acf3:	e9 00 06 00 00       	jmp    b2f8 <getPixelColorsRGBA8+0x6ca>
        buffer -= numpixels * num_channels;
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r) buffer[3] = 0;
        }
      }
    } else if(mode->bitdepth == 16) {
    acf8:	8b 45 14             	mov    0x14(%ebp),%eax
    acfb:	8b 40 04             	mov    0x4(%eax),%eax
    acfe:	83 f8 10             	cmp    $0x10,%eax
    ad01:	0f 85 a5 00 00 00    	jne    adac <getPixelColorsRGBA8+0x17e>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ad07:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ad0e:	e9 88 00 00 00       	jmp    ad9b <getPixelColorsRGBA8+0x16d>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
    ad13:	8b 45 08             	mov    0x8(%ebp),%eax
    ad16:	83 c0 01             	add    $0x1,%eax
    ad19:	8b 55 08             	mov    0x8(%ebp),%edx
    ad1c:	83 c2 02             	add    $0x2,%edx
    ad1f:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    ad22:	01 c9                	add    %ecx,%ecx
    ad24:	89 cb                	mov    %ecx,%ebx
    ad26:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ad29:	01 d9                	add    %ebx,%ecx
    ad2b:	0f b6 09             	movzbl (%ecx),%ecx
    ad2e:	88 0a                	mov    %cl,(%edx)
    ad30:	0f b6 12             	movzbl (%edx),%edx
    ad33:	88 10                	mov    %dl,(%eax)
    ad35:	0f b6 10             	movzbl (%eax),%edx
    ad38:	8b 45 08             	mov    0x8(%ebp),%eax
    ad3b:	88 10                	mov    %dl,(%eax)
        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
    ad3d:	8b 45 08             	mov    0x8(%ebp),%eax
    ad40:	8d 50 03             	lea    0x3(%eax),%edx
    ad43:	8b 45 14             	mov    0x14(%ebp),%eax
    ad46:	8b 40 10             	mov    0x10(%eax),%eax
    ad49:	85 c0                	test   %eax,%eax
    ad4b:	74 3d                	je     ad8a <getPixelColorsRGBA8+0x15c>
    ad4d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ad50:	01 c0                	add    %eax,%eax
    ad52:	89 c1                	mov    %eax,%ecx
    ad54:	8b 45 10             	mov    0x10(%ebp),%eax
    ad57:	01 c8                	add    %ecx,%eax
    ad59:	0f b6 00             	movzbl (%eax),%eax
    ad5c:	0f b6 c0             	movzbl %al,%eax
    ad5f:	c1 e0 08             	shl    $0x8,%eax
    ad62:	89 c1                	mov    %eax,%ecx
    ad64:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ad67:	01 c0                	add    %eax,%eax
    ad69:	8d 58 01             	lea    0x1(%eax),%ebx
    ad6c:	8b 45 10             	mov    0x10(%ebp),%eax
    ad6f:	01 d8                	add    %ebx,%eax
    ad71:	0f b6 00             	movzbl (%eax),%eax
    ad74:	0f b6 c0             	movzbl %al,%eax
    ad77:	01 c1                	add    %eax,%ecx
    ad79:	8b 45 14             	mov    0x14(%ebp),%eax
    ad7c:	8b 40 14             	mov    0x14(%eax),%eax
    ad7f:	39 c1                	cmp    %eax,%ecx
    ad81:	75 07                	jne    ad8a <getPixelColorsRGBA8+0x15c>
    ad83:	b8 00 00 00 00       	mov    $0x0,%eax
    ad88:	eb 05                	jmp    ad8f <getPixelColorsRGBA8+0x161>
    ad8a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    ad8f:	88 02                	mov    %al,(%edx)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r) buffer[3] = 0;
        }
      }
    } else if(mode->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ad91:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    ad95:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ad98:	01 45 08             	add    %eax,0x8(%ebp)
    ad9b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ad9e:	3b 45 0c             	cmp    0xc(%ebp),%eax
    ada1:	0f 85 6c ff ff ff    	jne    ad13 <getPixelColorsRGBA8+0xe5>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    ada7:	e9 4c 05 00 00       	jmp    b2f8 <getPixelColorsRGBA8+0x6ca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
    adac:	8b 45 14             	mov    0x14(%ebp),%eax
    adaf:	8b 40 04             	mov    0x4(%eax),%eax
    adb2:	ba 01 00 00 00       	mov    $0x1,%edx
    adb7:	89 c1                	mov    %eax,%ecx
    adb9:	d3 e2                	shl    %cl,%edx
    adbb:	89 d0                	mov    %edx,%eax
    adbd:	83 e8 01             	sub    $0x1,%eax
    adc0:	89 45 f0             	mov    %eax,-0x10(%ebp)
      size_t j = 0;
    adc3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    adca:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    add1:	eb 79                	jmp    ae4c <getPixelColorsRGBA8+0x21e>
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
    add3:	8b 45 14             	mov    0x14(%ebp),%eax
    add6:	8b 40 04             	mov    0x4(%eax),%eax
    add9:	50                   	push   %eax
    adda:	ff 75 10             	pushl  0x10(%ebp)
    addd:	8d 45 e0             	lea    -0x20(%ebp),%eax
    ade0:	50                   	push   %eax
    ade1:	e8 c0 d4 ff ff       	call   82a6 <readBitsFromReversedStream>
    ade6:	83 c4 0c             	add    $0xc,%esp
    ade9:	89 45 ec             	mov    %eax,-0x14(%ebp)
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
    adec:	8b 45 08             	mov    0x8(%ebp),%eax
    adef:	8d 48 01             	lea    0x1(%eax),%ecx
    adf2:	8b 45 08             	mov    0x8(%ebp),%eax
    adf5:	8d 58 02             	lea    0x2(%eax),%ebx
    adf8:	8b 55 ec             	mov    -0x14(%ebp),%edx
    adfb:	89 d0                	mov    %edx,%eax
    adfd:	c1 e0 08             	shl    $0x8,%eax
    ae00:	29 d0                	sub    %edx,%eax
    ae02:	ba 00 00 00 00       	mov    $0x0,%edx
    ae07:	f7 75 f0             	divl   -0x10(%ebp)
    ae0a:	88 03                	mov    %al,(%ebx)
    ae0c:	0f b6 03             	movzbl (%ebx),%eax
    ae0f:	88 01                	mov    %al,(%ecx)
    ae11:	0f b6 11             	movzbl (%ecx),%edx
    ae14:	8b 45 08             	mov    0x8(%ebp),%eax
    ae17:	88 10                	mov    %dl,(%eax)
        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
    ae19:	8b 45 08             	mov    0x8(%ebp),%eax
    ae1c:	8d 50 03             	lea    0x3(%eax),%edx
    ae1f:	8b 45 14             	mov    0x14(%ebp),%eax
    ae22:	8b 40 10             	mov    0x10(%eax),%eax
    ae25:	85 c0                	test   %eax,%eax
    ae27:	74 12                	je     ae3b <getPixelColorsRGBA8+0x20d>
    ae29:	8b 45 14             	mov    0x14(%ebp),%eax
    ae2c:	8b 40 14             	mov    0x14(%eax),%eax
    ae2f:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    ae32:	75 07                	jne    ae3b <getPixelColorsRGBA8+0x20d>
    ae34:	b8 00 00 00 00       	mov    $0x0,%eax
    ae39:	eb 05                	jmp    ae40 <getPixelColorsRGBA8+0x212>
    ae3b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    ae40:	88 02                	mov    %al,(%edx)
        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ae42:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    ae46:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ae49:	01 45 08             	add    %eax,0x8(%ebp)
    ae4c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ae4f:	3b 45 0c             	cmp    0xc(%ebp),%eax
    ae52:	0f 85 7b ff ff ff    	jne    add3 <getPixelColorsRGBA8+0x1a5>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    ae58:	e9 9b 04 00 00       	jmp    b2f8 <getPixelColorsRGBA8+0x6ca>
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_RGB) {
    ae5d:	8b 45 14             	mov    0x14(%ebp),%eax
    ae60:	8b 00                	mov    (%eax),%eax
    ae62:	83 f8 02             	cmp    $0x2,%eax
    ae65:	0f 85 41 02 00 00    	jne    b0ac <getPixelColorsRGBA8+0x47e>
    if(mode->bitdepth == 8) {
    ae6b:	8b 45 14             	mov    0x14(%ebp),%eax
    ae6e:	8b 40 04             	mov    0x4(%eax),%eax
    ae71:	83 f8 08             	cmp    $0x8,%eax
    ae74:	0f 85 c4 00 00 00    	jne    af3e <getPixelColorsRGBA8+0x310>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ae7a:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ae81:	eb 31                	jmp    aeb4 <getPixelColorsRGBA8+0x286>
        lodepng_memcpy(buffer, &in[i * 3], 3);
    ae83:	8b 55 f8             	mov    -0x8(%ebp),%edx
    ae86:	89 d0                	mov    %edx,%eax
    ae88:	01 c0                	add    %eax,%eax
    ae8a:	01 d0                	add    %edx,%eax
    ae8c:	89 c2                	mov    %eax,%edx
    ae8e:	8b 45 10             	mov    0x10(%ebp),%eax
    ae91:	01 d0                	add    %edx,%eax
    ae93:	6a 03                	push   $0x3
    ae95:	50                   	push   %eax
    ae96:	ff 75 08             	pushl  0x8(%ebp)
    ae99:	e8 a3 85 ff ff       	call   3441 <lodepng_memcpy>
    ae9e:	83 c4 0c             	add    $0xc,%esp
        buffer[3] = 255;
    aea1:	8b 45 08             	mov    0x8(%ebp),%eax
    aea4:	83 c0 03             	add    $0x3,%eax
    aea7:	c6 00 ff             	movb   $0xff,(%eax)
        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_RGB) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    aeaa:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    aeae:	8b 45 f4             	mov    -0xc(%ebp),%eax
    aeb1:	01 45 08             	add    %eax,0x8(%ebp)
    aeb4:	8b 45 f8             	mov    -0x8(%ebp),%eax
    aeb7:	3b 45 0c             	cmp    0xc(%ebp),%eax
    aeba:	75 c7                	jne    ae83 <getPixelColorsRGBA8+0x255>
        lodepng_memcpy(buffer, &in[i * 3], 3);
        buffer[3] = 255;
      }
      if(mode->key_defined) {
    aebc:	8b 45 14             	mov    0x14(%ebp),%eax
    aebf:	8b 40 10             	mov    0x10(%eax),%eax
    aec2:	85 c0                	test   %eax,%eax
    aec4:	0f 84 2e 04 00 00    	je     b2f8 <getPixelColorsRGBA8+0x6ca>
        buffer -= numpixels * num_channels;
    aeca:	8b 45 0c             	mov    0xc(%ebp),%eax
    aecd:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    aed1:	f7 d8                	neg    %eax
    aed3:	01 45 08             	add    %eax,0x8(%ebp)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    aed6:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    aedd:	eb 52                	jmp    af31 <getPixelColorsRGBA8+0x303>
          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;
    aedf:	8b 45 08             	mov    0x8(%ebp),%eax
    aee2:	0f b6 00             	movzbl (%eax),%eax
    aee5:	0f b6 d0             	movzbl %al,%edx
    aee8:	8b 45 14             	mov    0x14(%ebp),%eax
    aeeb:	8b 40 14             	mov    0x14(%eax),%eax
    aeee:	39 c2                	cmp    %eax,%edx
    aef0:	75 35                	jne    af27 <getPixelColorsRGBA8+0x2f9>
    aef2:	8b 45 08             	mov    0x8(%ebp),%eax
    aef5:	83 c0 01             	add    $0x1,%eax
    aef8:	0f b6 00             	movzbl (%eax),%eax
    aefb:	0f b6 d0             	movzbl %al,%edx
    aefe:	8b 45 14             	mov    0x14(%ebp),%eax
    af01:	8b 40 18             	mov    0x18(%eax),%eax
    af04:	39 c2                	cmp    %eax,%edx
    af06:	75 1f                	jne    af27 <getPixelColorsRGBA8+0x2f9>
    af08:	8b 45 08             	mov    0x8(%ebp),%eax
    af0b:	83 c0 02             	add    $0x2,%eax
    af0e:	0f b6 00             	movzbl (%eax),%eax
    af11:	0f b6 d0             	movzbl %al,%edx
    af14:	8b 45 14             	mov    0x14(%ebp),%eax
    af17:	8b 40 1c             	mov    0x1c(%eax),%eax
    af1a:	39 c2                	cmp    %eax,%edx
    af1c:	75 09                	jne    af27 <getPixelColorsRGBA8+0x2f9>
    af1e:	8b 45 08             	mov    0x8(%ebp),%eax
    af21:	83 c0 03             	add    $0x3,%eax
    af24:	c6 00 00             	movb   $0x0,(%eax)
        lodepng_memcpy(buffer, &in[i * 3], 3);
        buffer[3] = 255;
      }
      if(mode->key_defined) {
        buffer -= numpixels * num_channels;
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    af27:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    af2b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    af2e:	01 45 08             	add    %eax,0x8(%ebp)
    af31:	8b 45 f8             	mov    -0x8(%ebp),%eax
    af34:	3b 45 0c             	cmp    0xc(%ebp),%eax
    af37:	75 a6                	jne    aedf <getPixelColorsRGBA8+0x2b1>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    af39:	e9 ba 03 00 00       	jmp    b2f8 <getPixelColorsRGBA8+0x6ca>
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;
        }
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    af3e:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    af45:	e9 51 01 00 00       	jmp    b09b <getPixelColorsRGBA8+0x46d>
        buffer[0] = in[i * 6 + 0];
    af4a:	8b 55 f8             	mov    -0x8(%ebp),%edx
    af4d:	89 d0                	mov    %edx,%eax
    af4f:	01 c0                	add    %eax,%eax
    af51:	01 d0                	add    %edx,%eax
    af53:	01 c0                	add    %eax,%eax
    af55:	89 c2                	mov    %eax,%edx
    af57:	8b 45 10             	mov    0x10(%ebp),%eax
    af5a:	01 d0                	add    %edx,%eax
    af5c:	0f b6 10             	movzbl (%eax),%edx
    af5f:	8b 45 08             	mov    0x8(%ebp),%eax
    af62:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 6 + 2];
    af64:	8b 45 08             	mov    0x8(%ebp),%eax
    af67:	8d 48 01             	lea    0x1(%eax),%ecx
    af6a:	8b 55 f8             	mov    -0x8(%ebp),%edx
    af6d:	89 d0                	mov    %edx,%eax
    af6f:	01 c0                	add    %eax,%eax
    af71:	01 d0                	add    %edx,%eax
    af73:	01 c0                	add    %eax,%eax
    af75:	8d 50 02             	lea    0x2(%eax),%edx
    af78:	8b 45 10             	mov    0x10(%ebp),%eax
    af7b:	01 d0                	add    %edx,%eax
    af7d:	0f b6 00             	movzbl (%eax),%eax
    af80:	88 01                	mov    %al,(%ecx)
        buffer[2] = in[i * 6 + 4];
    af82:	8b 45 08             	mov    0x8(%ebp),%eax
    af85:	8d 48 02             	lea    0x2(%eax),%ecx
    af88:	8b 55 f8             	mov    -0x8(%ebp),%edx
    af8b:	89 d0                	mov    %edx,%eax
    af8d:	01 c0                	add    %eax,%eax
    af8f:	01 d0                	add    %edx,%eax
    af91:	01 c0                	add    %eax,%eax
    af93:	8d 50 04             	lea    0x4(%eax),%edx
    af96:	8b 45 10             	mov    0x10(%ebp),%eax
    af99:	01 d0                	add    %edx,%eax
    af9b:	0f b6 00             	movzbl (%eax),%eax
    af9e:	88 01                	mov    %al,(%ecx)
        buffer[3] = mode->key_defined
    afa0:	8b 45 08             	mov    0x8(%ebp),%eax
    afa3:	8d 48 03             	lea    0x3(%eax),%ecx
    afa6:	8b 45 14             	mov    0x14(%ebp),%eax
    afa9:	8b 40 10             	mov    0x10(%eax),%eax
    afac:	85 c0                	test   %eax,%eax
    afae:	0f 84 d6 00 00 00    	je     b08a <getPixelColorsRGBA8+0x45c>
           && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
    afb4:	8b 55 f8             	mov    -0x8(%ebp),%edx
    afb7:	89 d0                	mov    %edx,%eax
    afb9:	01 c0                	add    %eax,%eax
    afbb:	01 d0                	add    %edx,%eax
    afbd:	01 c0                	add    %eax,%eax
    afbf:	89 c2                	mov    %eax,%edx
    afc1:	8b 45 10             	mov    0x10(%ebp),%eax
    afc4:	01 d0                	add    %edx,%eax
    afc6:	0f b6 00             	movzbl (%eax),%eax
    afc9:	0f b6 c0             	movzbl %al,%eax
    afcc:	c1 e0 08             	shl    $0x8,%eax
    afcf:	89 c3                	mov    %eax,%ebx
    afd1:	8b 55 f8             	mov    -0x8(%ebp),%edx
    afd4:	89 d0                	mov    %edx,%eax
    afd6:	01 c0                	add    %eax,%eax
    afd8:	01 d0                	add    %edx,%eax
    afda:	01 c0                	add    %eax,%eax
    afdc:	8d 50 01             	lea    0x1(%eax),%edx
    afdf:	8b 45 10             	mov    0x10(%ebp),%eax
    afe2:	01 d0                	add    %edx,%eax
    afe4:	0f b6 00             	movzbl (%eax),%eax
    afe7:	0f b6 c0             	movzbl %al,%eax
    afea:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    afed:	8b 45 14             	mov    0x14(%ebp),%eax
    aff0:	8b 40 14             	mov    0x14(%eax),%eax
    aff3:	39 c2                	cmp    %eax,%edx
    aff5:	0f 85 8f 00 00 00    	jne    b08a <getPixelColorsRGBA8+0x45c>
           && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
    affb:	8b 55 f8             	mov    -0x8(%ebp),%edx
    affe:	89 d0                	mov    %edx,%eax
    b000:	01 c0                	add    %eax,%eax
    b002:	01 d0                	add    %edx,%eax
    b004:	01 c0                	add    %eax,%eax
    b006:	8d 50 02             	lea    0x2(%eax),%edx
    b009:	8b 45 10             	mov    0x10(%ebp),%eax
    b00c:	01 d0                	add    %edx,%eax
    b00e:	0f b6 00             	movzbl (%eax),%eax
    b011:	0f b6 c0             	movzbl %al,%eax
    b014:	c1 e0 08             	shl    $0x8,%eax
    b017:	89 c3                	mov    %eax,%ebx
    b019:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b01c:	89 d0                	mov    %edx,%eax
    b01e:	01 c0                	add    %eax,%eax
    b020:	01 d0                	add    %edx,%eax
    b022:	01 c0                	add    %eax,%eax
    b024:	8d 50 03             	lea    0x3(%eax),%edx
    b027:	8b 45 10             	mov    0x10(%ebp),%eax
    b02a:	01 d0                	add    %edx,%eax
    b02c:	0f b6 00             	movzbl (%eax),%eax
    b02f:	0f b6 c0             	movzbl %al,%eax
    b032:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    b035:	8b 45 14             	mov    0x14(%ebp),%eax
    b038:	8b 40 18             	mov    0x18(%eax),%eax
    b03b:	39 c2                	cmp    %eax,%edx
    b03d:	75 4b                	jne    b08a <getPixelColorsRGBA8+0x45c>
           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
    b03f:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b042:	89 d0                	mov    %edx,%eax
    b044:	01 c0                	add    %eax,%eax
    b046:	01 d0                	add    %edx,%eax
    b048:	01 c0                	add    %eax,%eax
    b04a:	8d 50 04             	lea    0x4(%eax),%edx
    b04d:	8b 45 10             	mov    0x10(%ebp),%eax
    b050:	01 d0                	add    %edx,%eax
    b052:	0f b6 00             	movzbl (%eax),%eax
    b055:	0f b6 c0             	movzbl %al,%eax
    b058:	c1 e0 08             	shl    $0x8,%eax
    b05b:	89 c3                	mov    %eax,%ebx
    b05d:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b060:	89 d0                	mov    %edx,%eax
    b062:	01 c0                	add    %eax,%eax
    b064:	01 d0                	add    %edx,%eax
    b066:	01 c0                	add    %eax,%eax
    b068:	8d 50 05             	lea    0x5(%eax),%edx
    b06b:	8b 45 10             	mov    0x10(%ebp),%eax
    b06e:	01 d0                	add    %edx,%eax
    b070:	0f b6 00             	movzbl (%eax),%eax
    b073:	0f b6 c0             	movzbl %al,%eax
    b076:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    b079:	8b 45 14             	mov    0x14(%ebp),%eax
    b07c:	8b 40 1c             	mov    0x1c(%eax),%eax
    b07f:	39 c2                	cmp    %eax,%edx
    b081:	75 07                	jne    b08a <getPixelColorsRGBA8+0x45c>
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = in[i * 6 + 0];
        buffer[1] = in[i * 6 + 2];
        buffer[2] = in[i * 6 + 4];
        buffer[3] = mode->key_defined
    b083:	b8 00 00 00 00       	mov    $0x0,%eax
    b088:	eb 05                	jmp    b08f <getPixelColorsRGBA8+0x461>
    b08a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    b08f:	88 01                	mov    %al,(%ecx)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;
        }
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b091:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b095:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b098:	01 45 08             	add    %eax,0x8(%ebp)
    b09b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b09e:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b0a1:	0f 85 a3 fe ff ff    	jne    af4a <getPixelColorsRGBA8+0x31c>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b0a7:	e9 4c 02 00 00       	jmp    b2f8 <getPixelColorsRGBA8+0x6ca>
           && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
           && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    b0ac:	8b 45 14             	mov    0x14(%ebp),%eax
    b0af:	8b 00                	mov    (%eax),%eax
    b0b1:	83 f8 03             	cmp    $0x3,%eax
    b0b4:	0f 85 b4 00 00 00    	jne    b16e <getPixelColorsRGBA8+0x540>
    if(mode->bitdepth == 8) {
    b0ba:	8b 45 14             	mov    0x14(%ebp),%eax
    b0bd:	8b 40 04             	mov    0x4(%eax),%eax
    b0c0:	83 f8 08             	cmp    $0x8,%eax
    b0c3:	75 4d                	jne    b112 <getPixelColorsRGBA8+0x4e4>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b0c5:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b0cc:	eb 37                	jmp    b105 <getPixelColorsRGBA8+0x4d7>
        unsigned index = in[i];
    b0ce:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b0d1:	8b 45 10             	mov    0x10(%ebp),%eax
    b0d4:	01 d0                	add    %edx,%eax
    b0d6:	0f b6 00             	movzbl (%eax),%eax
    b0d9:	0f b6 c0             	movzbl %al,%eax
    b0dc:	89 45 e8             	mov    %eax,-0x18(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
    b0df:	8b 45 14             	mov    0x14(%ebp),%eax
    b0e2:	8b 40 08             	mov    0x8(%eax),%eax
    b0e5:	8b 55 e8             	mov    -0x18(%ebp),%edx
    b0e8:	c1 e2 02             	shl    $0x2,%edx
    b0eb:	01 d0                	add    %edx,%eax
    b0ed:	6a 04                	push   $0x4
    b0ef:	50                   	push   %eax
    b0f0:	ff 75 08             	pushl  0x8(%ebp)
    b0f3:	e8 49 83 ff ff       	call   3441 <lodepng_memcpy>
    b0f8:	83 c4 0c             	add    $0xc,%esp
           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b0fb:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b0ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b102:	01 45 08             	add    %eax,0x8(%ebp)
    b105:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b108:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b10b:	75 c1                	jne    b0ce <getPixelColorsRGBA8+0x4a0>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b10d:	e9 e6 01 00 00       	jmp    b2f8 <getPixelColorsRGBA8+0x6ca>
        unsigned index = in[i];
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    } else {
      size_t j = 0;
    b112:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b119:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b120:	eb 3f                	jmp    b161 <getPixelColorsRGBA8+0x533>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
    b122:	8b 45 14             	mov    0x14(%ebp),%eax
    b125:	8b 40 04             	mov    0x4(%eax),%eax
    b128:	50                   	push   %eax
    b129:	ff 75 10             	pushl  0x10(%ebp)
    b12c:	8d 45 dc             	lea    -0x24(%ebp),%eax
    b12f:	50                   	push   %eax
    b130:	e8 71 d1 ff ff       	call   82a6 <readBitsFromReversedStream>
    b135:	83 c4 0c             	add    $0xc,%esp
    b138:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
    b13b:	8b 45 14             	mov    0x14(%ebp),%eax
    b13e:	8b 40 08             	mov    0x8(%eax),%eax
    b141:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    b144:	c1 e2 02             	shl    $0x2,%edx
    b147:	01 d0                	add    %edx,%eax
    b149:	6a 04                	push   $0x4
    b14b:	50                   	push   %eax
    b14c:	ff 75 08             	pushl  0x8(%ebp)
    b14f:	e8 ed 82 ff ff       	call   3441 <lodepng_memcpy>
    b154:	83 c4 0c             	add    $0xc,%esp
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    } else {
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b157:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b15b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b15e:	01 45 08             	add    %eax,0x8(%ebp)
    b161:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b164:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b167:	75 b9                	jne    b122 <getPixelColorsRGBA8+0x4f4>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b169:	e9 8a 01 00 00       	jmp    b2f8 <getPixelColorsRGBA8+0x6ca>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    b16e:	8b 45 14             	mov    0x14(%ebp),%eax
    b171:	8b 00                	mov    (%eax),%eax
    b173:	83 f8 04             	cmp    $0x4,%eax
    b176:	0f 85 d1 00 00 00    	jne    b24d <getPixelColorsRGBA8+0x61f>
    if(mode->bitdepth == 8) {
    b17c:	8b 45 14             	mov    0x14(%ebp),%eax
    b17f:	8b 40 04             	mov    0x4(%eax),%eax
    b182:	83 f8 08             	cmp    $0x8,%eax
    b185:	75 62                	jne    b1e9 <getPixelColorsRGBA8+0x5bb>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b187:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b18e:	eb 4c                	jmp    b1dc <getPixelColorsRGBA8+0x5ae>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
    b190:	8b 45 08             	mov    0x8(%ebp),%eax
    b193:	83 c0 01             	add    $0x1,%eax
    b196:	8b 55 08             	mov    0x8(%ebp),%edx
    b199:	83 c2 02             	add    $0x2,%edx
    b19c:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b19f:	01 c9                	add    %ecx,%ecx
    b1a1:	89 cb                	mov    %ecx,%ebx
    b1a3:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b1a6:	01 d9                	add    %ebx,%ecx
    b1a8:	0f b6 09             	movzbl (%ecx),%ecx
    b1ab:	88 0a                	mov    %cl,(%edx)
    b1ad:	0f b6 12             	movzbl (%edx),%edx
    b1b0:	88 10                	mov    %dl,(%eax)
    b1b2:	0f b6 10             	movzbl (%eax),%edx
    b1b5:	8b 45 08             	mov    0x8(%ebp),%eax
    b1b8:	88 10                	mov    %dl,(%eax)
        buffer[3] = in[i * 2 + 1];
    b1ba:	8b 45 08             	mov    0x8(%ebp),%eax
    b1bd:	8d 50 03             	lea    0x3(%eax),%edx
    b1c0:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b1c3:	01 c0                	add    %eax,%eax
    b1c5:	8d 48 01             	lea    0x1(%eax),%ecx
    b1c8:	8b 45 10             	mov    0x10(%ebp),%eax
    b1cb:	01 c8                	add    %ecx,%eax
    b1cd:	0f b6 00             	movzbl (%eax),%eax
    b1d0:	88 02                	mov    %al,(%edx)
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b1d2:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b1d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b1d9:	01 45 08             	add    %eax,0x8(%ebp)
    b1dc:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b1df:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b1e2:	75 ac                	jne    b190 <getPixelColorsRGBA8+0x562>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b1e4:	e9 0f 01 00 00       	jmp    b2f8 <getPixelColorsRGBA8+0x6ca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
        buffer[3] = in[i * 2 + 1];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b1e9:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b1f0:	eb 4e                	jmp    b240 <getPixelColorsRGBA8+0x612>
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
    b1f2:	8b 45 08             	mov    0x8(%ebp),%eax
    b1f5:	83 c0 01             	add    $0x1,%eax
    b1f8:	8b 55 08             	mov    0x8(%ebp),%edx
    b1fb:	83 c2 02             	add    $0x2,%edx
    b1fe:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b201:	c1 e1 02             	shl    $0x2,%ecx
    b204:	89 cb                	mov    %ecx,%ebx
    b206:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b209:	01 d9                	add    %ebx,%ecx
    b20b:	0f b6 09             	movzbl (%ecx),%ecx
    b20e:	88 0a                	mov    %cl,(%edx)
    b210:	0f b6 12             	movzbl (%edx),%edx
    b213:	88 10                	mov    %dl,(%eax)
    b215:	0f b6 10             	movzbl (%eax),%edx
    b218:	8b 45 08             	mov    0x8(%ebp),%eax
    b21b:	88 10                	mov    %dl,(%eax)
        buffer[3] = in[i * 4 + 2];
    b21d:	8b 45 08             	mov    0x8(%ebp),%eax
    b220:	8d 50 03             	lea    0x3(%eax),%edx
    b223:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b226:	c1 e0 02             	shl    $0x2,%eax
    b229:	8d 48 02             	lea    0x2(%eax),%ecx
    b22c:	8b 45 10             	mov    0x10(%ebp),%eax
    b22f:	01 c8                	add    %ecx,%eax
    b231:	0f b6 00             	movzbl (%eax),%eax
    b234:	88 02                	mov    %al,(%edx)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
        buffer[3] = in[i * 2 + 1];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b236:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b23a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b23d:	01 45 08             	add    %eax,0x8(%ebp)
    b240:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b243:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b246:	75 aa                	jne    b1f2 <getPixelColorsRGBA8+0x5c4>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b248:	e9 ab 00 00 00       	jmp    b2f8 <getPixelColorsRGBA8+0x6ca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
        buffer[3] = in[i * 4 + 2];
      }
    }
  } else if(mode->colortype == LCT_RGBA) {
    b24d:	8b 45 14             	mov    0x14(%ebp),%eax
    b250:	8b 00                	mov    (%eax),%eax
    b252:	83 f8 06             	cmp    $0x6,%eax
    b255:	0f 85 9d 00 00 00    	jne    b2f8 <getPixelColorsRGBA8+0x6ca>
    if(mode->bitdepth == 8) {
    b25b:	8b 45 14             	mov    0x14(%ebp),%eax
    b25e:	8b 40 04             	mov    0x4(%eax),%eax
    b261:	83 f8 08             	cmp    $0x8,%eax
    b264:	75 17                	jne    b27d <getPixelColorsRGBA8+0x64f>
      lodepng_memcpy(buffer, in, numpixels * 4);
    b266:	8b 45 0c             	mov    0xc(%ebp),%eax
    b269:	c1 e0 02             	shl    $0x2,%eax
    b26c:	50                   	push   %eax
    b26d:	ff 75 10             	pushl  0x10(%ebp)
    b270:	ff 75 08             	pushl  0x8(%ebp)
    b273:	e8 c9 81 ff ff       	call   3441 <lodepng_memcpy>
    b278:	83 c4 0c             	add    $0xc,%esp
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b27b:	eb 7b                	jmp    b2f8 <getPixelColorsRGBA8+0x6ca>
    }
  } else if(mode->colortype == LCT_RGBA) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 4);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b27d:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b284:	eb 6a                	jmp    b2f0 <getPixelColorsRGBA8+0x6c2>
        buffer[0] = in[i * 8 + 0];
    b286:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b289:	c1 e0 03             	shl    $0x3,%eax
    b28c:	89 c2                	mov    %eax,%edx
    b28e:	8b 45 10             	mov    0x10(%ebp),%eax
    b291:	01 d0                	add    %edx,%eax
    b293:	0f b6 10             	movzbl (%eax),%edx
    b296:	8b 45 08             	mov    0x8(%ebp),%eax
    b299:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 8 + 2];
    b29b:	8b 45 08             	mov    0x8(%ebp),%eax
    b29e:	8d 50 01             	lea    0x1(%eax),%edx
    b2a1:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b2a4:	c1 e0 03             	shl    $0x3,%eax
    b2a7:	8d 48 02             	lea    0x2(%eax),%ecx
    b2aa:	8b 45 10             	mov    0x10(%ebp),%eax
    b2ad:	01 c8                	add    %ecx,%eax
    b2af:	0f b6 00             	movzbl (%eax),%eax
    b2b2:	88 02                	mov    %al,(%edx)
        buffer[2] = in[i * 8 + 4];
    b2b4:	8b 45 08             	mov    0x8(%ebp),%eax
    b2b7:	8d 50 02             	lea    0x2(%eax),%edx
    b2ba:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b2bd:	c1 e0 03             	shl    $0x3,%eax
    b2c0:	8d 48 04             	lea    0x4(%eax),%ecx
    b2c3:	8b 45 10             	mov    0x10(%ebp),%eax
    b2c6:	01 c8                	add    %ecx,%eax
    b2c8:	0f b6 00             	movzbl (%eax),%eax
    b2cb:	88 02                	mov    %al,(%edx)
        buffer[3] = in[i * 8 + 6];
    b2cd:	8b 45 08             	mov    0x8(%ebp),%eax
    b2d0:	8d 50 03             	lea    0x3(%eax),%edx
    b2d3:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b2d6:	c1 e0 03             	shl    $0x3,%eax
    b2d9:	8d 48 06             	lea    0x6(%eax),%ecx
    b2dc:	8b 45 10             	mov    0x10(%ebp),%eax
    b2df:	01 c8                	add    %ecx,%eax
    b2e1:	0f b6 00             	movzbl (%eax),%eax
    b2e4:	88 02                	mov    %al,(%edx)
    }
  } else if(mode->colortype == LCT_RGBA) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 4);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b2e6:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b2ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b2ed:	01 45 08             	add    %eax,0x8(%ebp)
    b2f0:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b2f3:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b2f6:	75 8e                	jne    b286 <getPixelColorsRGBA8+0x658>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b2f8:	90                   	nop
    b2f9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    b2fc:	c9                   	leave  
    b2fd:	c3                   	ret    

0000b2fe <getPixelColorsRGB8>:

/*Similar to getPixelColorsRGBA8, but with 3-channel RGB output.*/
static void getPixelColorsRGB8(unsigned char* LODEPNG_RESTRICT buffer, size_t numpixels,
                               const unsigned char* LODEPNG_RESTRICT in,
                               const LodePNGColorMode* mode) {
    b2fe:	55                   	push   %ebp
    b2ff:	89 e5                	mov    %esp,%ebp
    b301:	53                   	push   %ebx
    b302:	83 ec 20             	sub    $0x20,%esp
  const unsigned num_channels = 3;
    b305:	c7 45 f4 03 00 00 00 	movl   $0x3,-0xc(%ebp)
  size_t i;
  if(mode->colortype == LCT_GREY) {
    b30c:	8b 45 14             	mov    0x14(%ebp),%eax
    b30f:	8b 00                	mov    (%eax),%eax
    b311:	85 c0                	test   %eax,%eax
    b313:	0f 85 2a 01 00 00    	jne    b443 <getPixelColorsRGB8+0x145>
    if(mode->bitdepth == 8) {
    b319:	8b 45 14             	mov    0x14(%ebp),%eax
    b31c:	8b 40 04             	mov    0x4(%eax),%eax
    b31f:	83 f8 08             	cmp    $0x8,%eax
    b322:	75 46                	jne    b36a <getPixelColorsRGB8+0x6c>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b324:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b32b:	eb 30                	jmp    b35d <getPixelColorsRGB8+0x5f>
        buffer[0] = buffer[1] = buffer[2] = in[i];
    b32d:	8b 45 08             	mov    0x8(%ebp),%eax
    b330:	83 c0 01             	add    $0x1,%eax
    b333:	8b 55 08             	mov    0x8(%ebp),%edx
    b336:	83 c2 02             	add    $0x2,%edx
    b339:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    b33c:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b33f:	01 d9                	add    %ebx,%ecx
    b341:	0f b6 09             	movzbl (%ecx),%ecx
    b344:	88 0a                	mov    %cl,(%edx)
    b346:	0f b6 12             	movzbl (%edx),%edx
    b349:	88 10                	mov    %dl,(%eax)
    b34b:	0f b6 10             	movzbl (%eax),%edx
    b34e:	8b 45 08             	mov    0x8(%ebp),%eax
    b351:	88 10                	mov    %dl,(%eax)
                               const LodePNGColorMode* mode) {
  const unsigned num_channels = 3;
  size_t i;
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b353:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b357:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b35a:	01 45 08             	add    %eax,0x8(%ebp)
    b35d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b360:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b363:	75 c8                	jne    b32d <getPixelColorsRGB8+0x2f>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b365:	e9 a8 03 00 00       	jmp    b712 <getPixelColorsRGB8+0x414>
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i];
      }
    } else if(mode->bitdepth == 16) {
    b36a:	8b 45 14             	mov    0x14(%ebp),%eax
    b36d:	8b 40 04             	mov    0x4(%eax),%eax
    b370:	83 f8 10             	cmp    $0x10,%eax
    b373:	75 4a                	jne    b3bf <getPixelColorsRGB8+0xc1>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b375:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b37c:	eb 34                	jmp    b3b2 <getPixelColorsRGB8+0xb4>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
    b37e:	8b 45 08             	mov    0x8(%ebp),%eax
    b381:	83 c0 01             	add    $0x1,%eax
    b384:	8b 55 08             	mov    0x8(%ebp),%edx
    b387:	83 c2 02             	add    $0x2,%edx
    b38a:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b38d:	01 c9                	add    %ecx,%ecx
    b38f:	89 cb                	mov    %ecx,%ebx
    b391:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b394:	01 d9                	add    %ebx,%ecx
    b396:	0f b6 09             	movzbl (%ecx),%ecx
    b399:	88 0a                	mov    %cl,(%edx)
    b39b:	0f b6 12             	movzbl (%edx),%edx
    b39e:	88 10                	mov    %dl,(%eax)
    b3a0:	0f b6 10             	movzbl (%eax),%edx
    b3a3:	8b 45 08             	mov    0x8(%ebp),%eax
    b3a6:	88 10                	mov    %dl,(%eax)
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i];
      }
    } else if(mode->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b3a8:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b3ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b3af:	01 45 08             	add    %eax,0x8(%ebp)
    b3b2:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b3b5:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b3b8:	75 c4                	jne    b37e <getPixelColorsRGB8+0x80>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b3ba:	e9 53 03 00 00       	jmp    b712 <getPixelColorsRGB8+0x414>
    } else if(mode->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
    b3bf:	8b 45 14             	mov    0x14(%ebp),%eax
    b3c2:	8b 40 04             	mov    0x4(%eax),%eax
    b3c5:	ba 01 00 00 00       	mov    $0x1,%edx
    b3ca:	89 c1                	mov    %eax,%ecx
    b3cc:	d3 e2                	shl    %cl,%edx
    b3ce:	89 d0                	mov    %edx,%eax
    b3d0:	83 e8 01             	sub    $0x1,%eax
    b3d3:	89 45 f0             	mov    %eax,-0x10(%ebp)
      size_t j = 0;
    b3d6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b3dd:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b3e4:	eb 50                	jmp    b436 <getPixelColorsRGB8+0x138>
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
    b3e6:	8b 45 14             	mov    0x14(%ebp),%eax
    b3e9:	8b 40 04             	mov    0x4(%eax),%eax
    b3ec:	50                   	push   %eax
    b3ed:	ff 75 10             	pushl  0x10(%ebp)
    b3f0:	8d 45 e0             	lea    -0x20(%ebp),%eax
    b3f3:	50                   	push   %eax
    b3f4:	e8 ad ce ff ff       	call   82a6 <readBitsFromReversedStream>
    b3f9:	83 c4 0c             	add    $0xc,%esp
    b3fc:	89 45 ec             	mov    %eax,-0x14(%ebp)
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
    b3ff:	8b 45 08             	mov    0x8(%ebp),%eax
    b402:	8d 48 01             	lea    0x1(%eax),%ecx
    b405:	8b 45 08             	mov    0x8(%ebp),%eax
    b408:	8d 58 02             	lea    0x2(%eax),%ebx
    b40b:	8b 55 ec             	mov    -0x14(%ebp),%edx
    b40e:	89 d0                	mov    %edx,%eax
    b410:	c1 e0 08             	shl    $0x8,%eax
    b413:	29 d0                	sub    %edx,%eax
    b415:	ba 00 00 00 00       	mov    $0x0,%edx
    b41a:	f7 75 f0             	divl   -0x10(%ebp)
    b41d:	88 03                	mov    %al,(%ebx)
    b41f:	0f b6 03             	movzbl (%ebx),%eax
    b422:	88 01                	mov    %al,(%ecx)
    b424:	0f b6 11             	movzbl (%ecx),%edx
    b427:	8b 45 08             	mov    0x8(%ebp),%eax
    b42a:	88 10                	mov    %dl,(%eax)
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b42c:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b430:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b433:	01 45 08             	add    %eax,0x8(%ebp)
    b436:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b439:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b43c:	75 a8                	jne    b3e6 <getPixelColorsRGB8+0xe8>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b43e:	e9 cf 02 00 00       	jmp    b712 <getPixelColorsRGB8+0x414>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
      }
    }
  } else if(mode->colortype == LCT_RGB) {
    b443:	8b 45 14             	mov    0x14(%ebp),%eax
    b446:	8b 00                	mov    (%eax),%eax
    b448:	83 f8 02             	cmp    $0x2,%eax
    b44b:	0f 85 9e 00 00 00    	jne    b4ef <getPixelColorsRGB8+0x1f1>
    if(mode->bitdepth == 8) {
    b451:	8b 45 14             	mov    0x14(%ebp),%eax
    b454:	8b 40 04             	mov    0x4(%eax),%eax
    b457:	83 f8 08             	cmp    $0x8,%eax
    b45a:	75 1d                	jne    b479 <getPixelColorsRGB8+0x17b>
      lodepng_memcpy(buffer, in, numpixels * 3);
    b45c:	8b 55 0c             	mov    0xc(%ebp),%edx
    b45f:	89 d0                	mov    %edx,%eax
    b461:	01 c0                	add    %eax,%eax
    b463:	01 d0                	add    %edx,%eax
    b465:	50                   	push   %eax
    b466:	ff 75 10             	pushl  0x10(%ebp)
    b469:	ff 75 08             	pushl  0x8(%ebp)
    b46c:	e8 d0 7f ff ff       	call   3441 <lodepng_memcpy>
    b471:	83 c4 0c             	add    $0xc,%esp
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b474:	e9 99 02 00 00       	jmp    b712 <getPixelColorsRGB8+0x414>
    }
  } else if(mode->colortype == LCT_RGB) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 3);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b479:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b480:	eb 60                	jmp    b4e2 <getPixelColorsRGB8+0x1e4>
        buffer[0] = in[i * 6 + 0];
    b482:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b485:	89 d0                	mov    %edx,%eax
    b487:	01 c0                	add    %eax,%eax
    b489:	01 d0                	add    %edx,%eax
    b48b:	01 c0                	add    %eax,%eax
    b48d:	89 c2                	mov    %eax,%edx
    b48f:	8b 45 10             	mov    0x10(%ebp),%eax
    b492:	01 d0                	add    %edx,%eax
    b494:	0f b6 10             	movzbl (%eax),%edx
    b497:	8b 45 08             	mov    0x8(%ebp),%eax
    b49a:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 6 + 2];
    b49c:	8b 45 08             	mov    0x8(%ebp),%eax
    b49f:	8d 48 01             	lea    0x1(%eax),%ecx
    b4a2:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b4a5:	89 d0                	mov    %edx,%eax
    b4a7:	01 c0                	add    %eax,%eax
    b4a9:	01 d0                	add    %edx,%eax
    b4ab:	01 c0                	add    %eax,%eax
    b4ad:	8d 50 02             	lea    0x2(%eax),%edx
    b4b0:	8b 45 10             	mov    0x10(%ebp),%eax
    b4b3:	01 d0                	add    %edx,%eax
    b4b5:	0f b6 00             	movzbl (%eax),%eax
    b4b8:	88 01                	mov    %al,(%ecx)
        buffer[2] = in[i * 6 + 4];
    b4ba:	8b 45 08             	mov    0x8(%ebp),%eax
    b4bd:	8d 48 02             	lea    0x2(%eax),%ecx
    b4c0:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b4c3:	89 d0                	mov    %edx,%eax
    b4c5:	01 c0                	add    %eax,%eax
    b4c7:	01 d0                	add    %edx,%eax
    b4c9:	01 c0                	add    %eax,%eax
    b4cb:	8d 50 04             	lea    0x4(%eax),%edx
    b4ce:	8b 45 10             	mov    0x10(%ebp),%eax
    b4d1:	01 d0                	add    %edx,%eax
    b4d3:	0f b6 00             	movzbl (%eax),%eax
    b4d6:	88 01                	mov    %al,(%ecx)
    }
  } else if(mode->colortype == LCT_RGB) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 3);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b4d8:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b4dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b4df:	01 45 08             	add    %eax,0x8(%ebp)
    b4e2:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b4e5:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b4e8:	75 98                	jne    b482 <getPixelColorsRGB8+0x184>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b4ea:	e9 23 02 00 00       	jmp    b712 <getPixelColorsRGB8+0x414>
        buffer[0] = in[i * 6 + 0];
        buffer[1] = in[i * 6 + 2];
        buffer[2] = in[i * 6 + 4];
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    b4ef:	8b 45 14             	mov    0x14(%ebp),%eax
    b4f2:	8b 00                	mov    (%eax),%eax
    b4f4:	83 f8 03             	cmp    $0x3,%eax
    b4f7:	0f 85 b4 00 00 00    	jne    b5b1 <getPixelColorsRGB8+0x2b3>
    if(mode->bitdepth == 8) {
    b4fd:	8b 45 14             	mov    0x14(%ebp),%eax
    b500:	8b 40 04             	mov    0x4(%eax),%eax
    b503:	83 f8 08             	cmp    $0x8,%eax
    b506:	75 4d                	jne    b555 <getPixelColorsRGB8+0x257>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b508:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b50f:	eb 37                	jmp    b548 <getPixelColorsRGB8+0x24a>
        unsigned index = in[i];
    b511:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b514:	8b 45 10             	mov    0x10(%ebp),%eax
    b517:	01 d0                	add    %edx,%eax
    b519:	0f b6 00             	movzbl (%eax),%eax
    b51c:	0f b6 c0             	movzbl %al,%eax
    b51f:	89 45 e8             	mov    %eax,-0x18(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
    b522:	8b 45 14             	mov    0x14(%ebp),%eax
    b525:	8b 40 08             	mov    0x8(%eax),%eax
    b528:	8b 55 e8             	mov    -0x18(%ebp),%edx
    b52b:	c1 e2 02             	shl    $0x2,%edx
    b52e:	01 d0                	add    %edx,%eax
    b530:	6a 03                	push   $0x3
    b532:	50                   	push   %eax
    b533:	ff 75 08             	pushl  0x8(%ebp)
    b536:	e8 06 7f ff ff       	call   3441 <lodepng_memcpy>
    b53b:	83 c4 0c             	add    $0xc,%esp
        buffer[2] = in[i * 6 + 4];
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b53e:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b542:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b545:	01 45 08             	add    %eax,0x8(%ebp)
    b548:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b54b:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b54e:	75 c1                	jne    b511 <getPixelColorsRGB8+0x213>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b550:	e9 bd 01 00 00       	jmp    b712 <getPixelColorsRGB8+0x414>
        unsigned index = in[i];
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    } else {
      size_t j = 0;
    b555:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b55c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b563:	eb 3f                	jmp    b5a4 <getPixelColorsRGB8+0x2a6>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
    b565:	8b 45 14             	mov    0x14(%ebp),%eax
    b568:	8b 40 04             	mov    0x4(%eax),%eax
    b56b:	50                   	push   %eax
    b56c:	ff 75 10             	pushl  0x10(%ebp)
    b56f:	8d 45 dc             	lea    -0x24(%ebp),%eax
    b572:	50                   	push   %eax
    b573:	e8 2e cd ff ff       	call   82a6 <readBitsFromReversedStream>
    b578:	83 c4 0c             	add    $0xc,%esp
    b57b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
    b57e:	8b 45 14             	mov    0x14(%ebp),%eax
    b581:	8b 40 08             	mov    0x8(%eax),%eax
    b584:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    b587:	c1 e2 02             	shl    $0x2,%edx
    b58a:	01 d0                	add    %edx,%eax
    b58c:	6a 03                	push   $0x3
    b58e:	50                   	push   %eax
    b58f:	ff 75 08             	pushl  0x8(%ebp)
    b592:	e8 aa 7e ff ff       	call   3441 <lodepng_memcpy>
    b597:	83 c4 0c             	add    $0xc,%esp
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    } else {
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b59a:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b59e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b5a1:	01 45 08             	add    %eax,0x8(%ebp)
    b5a4:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b5a7:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b5aa:	75 b9                	jne    b565 <getPixelColorsRGB8+0x267>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b5ac:	e9 61 01 00 00       	jmp    b712 <getPixelColorsRGB8+0x414>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    b5b1:	8b 45 14             	mov    0x14(%ebp),%eax
    b5b4:	8b 00                	mov    (%eax),%eax
    b5b6:	83 f8 04             	cmp    $0x4,%eax
    b5b9:	0f 85 a0 00 00 00    	jne    b65f <getPixelColorsRGB8+0x361>
    if(mode->bitdepth == 8) {
    b5bf:	8b 45 14             	mov    0x14(%ebp),%eax
    b5c2:	8b 40 04             	mov    0x4(%eax),%eax
    b5c5:	83 f8 08             	cmp    $0x8,%eax
    b5c8:	75 4a                	jne    b614 <getPixelColorsRGB8+0x316>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b5ca:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b5d1:	eb 34                	jmp    b607 <getPixelColorsRGB8+0x309>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
    b5d3:	8b 45 08             	mov    0x8(%ebp),%eax
    b5d6:	83 c0 01             	add    $0x1,%eax
    b5d9:	8b 55 08             	mov    0x8(%ebp),%edx
    b5dc:	83 c2 02             	add    $0x2,%edx
    b5df:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b5e2:	01 c9                	add    %ecx,%ecx
    b5e4:	89 cb                	mov    %ecx,%ebx
    b5e6:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b5e9:	01 d9                	add    %ebx,%ecx
    b5eb:	0f b6 09             	movzbl (%ecx),%ecx
    b5ee:	88 0a                	mov    %cl,(%edx)
    b5f0:	0f b6 12             	movzbl (%edx),%edx
    b5f3:	88 10                	mov    %dl,(%eax)
    b5f5:	0f b6 10             	movzbl (%eax),%edx
    b5f8:	8b 45 08             	mov    0x8(%ebp),%eax
    b5fb:	88 10                	mov    %dl,(%eax)
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b5fd:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b601:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b604:	01 45 08             	add    %eax,0x8(%ebp)
    b607:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b60a:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b60d:	75 c4                	jne    b5d3 <getPixelColorsRGB8+0x2d5>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b60f:	e9 fe 00 00 00       	jmp    b712 <getPixelColorsRGB8+0x414>
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b614:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b61b:	eb 35                	jmp    b652 <getPixelColorsRGB8+0x354>
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
    b61d:	8b 45 08             	mov    0x8(%ebp),%eax
    b620:	83 c0 01             	add    $0x1,%eax
    b623:	8b 55 08             	mov    0x8(%ebp),%edx
    b626:	83 c2 02             	add    $0x2,%edx
    b629:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b62c:	c1 e1 02             	shl    $0x2,%ecx
    b62f:	89 cb                	mov    %ecx,%ebx
    b631:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b634:	01 d9                	add    %ebx,%ecx
    b636:	0f b6 09             	movzbl (%ecx),%ecx
    b639:	88 0a                	mov    %cl,(%edx)
    b63b:	0f b6 12             	movzbl (%edx),%edx
    b63e:	88 10                	mov    %dl,(%eax)
    b640:	0f b6 10             	movzbl (%eax),%edx
    b643:	8b 45 08             	mov    0x8(%ebp),%eax
    b646:	88 10                	mov    %dl,(%eax)
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b648:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b64c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b64f:	01 45 08             	add    %eax,0x8(%ebp)
    b652:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b655:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b658:	75 c3                	jne    b61d <getPixelColorsRGB8+0x31f>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b65a:	e9 b3 00 00 00       	jmp    b712 <getPixelColorsRGB8+0x414>
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
      }
    }
  } else if(mode->colortype == LCT_RGBA) {
    b65f:	8b 45 14             	mov    0x14(%ebp),%eax
    b662:	8b 00                	mov    (%eax),%eax
    b664:	83 f8 06             	cmp    $0x6,%eax
    b667:	0f 85 a5 00 00 00    	jne    b712 <getPixelColorsRGB8+0x414>
    if(mode->bitdepth == 8) {
    b66d:	8b 45 14             	mov    0x14(%ebp),%eax
    b670:	8b 40 04             	mov    0x4(%eax),%eax
    b673:	83 f8 08             	cmp    $0x8,%eax
    b676:	75 38                	jne    b6b0 <getPixelColorsRGB8+0x3b2>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b678:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b67f:	eb 25                	jmp    b6a6 <getPixelColorsRGB8+0x3a8>
        lodepng_memcpy(buffer, &in[i * 4], 3);
    b681:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b684:	c1 e0 02             	shl    $0x2,%eax
    b687:	89 c2                	mov    %eax,%edx
    b689:	8b 45 10             	mov    0x10(%ebp),%eax
    b68c:	01 d0                	add    %edx,%eax
    b68e:	6a 03                	push   $0x3
    b690:	50                   	push   %eax
    b691:	ff 75 08             	pushl  0x8(%ebp)
    b694:	e8 a8 7d ff ff       	call   3441 <lodepng_memcpy>
    b699:	83 c4 0c             	add    $0xc,%esp
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
      }
    }
  } else if(mode->colortype == LCT_RGBA) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b69c:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b6a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b6a3:	01 45 08             	add    %eax,0x8(%ebp)
    b6a6:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b6a9:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b6ac:	75 d3                	jne    b681 <getPixelColorsRGB8+0x383>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b6ae:	eb 62                	jmp    b712 <getPixelColorsRGB8+0x414>
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        lodepng_memcpy(buffer, &in[i * 4], 3);
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b6b0:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b6b7:	eb 51                	jmp    b70a <getPixelColorsRGB8+0x40c>
        buffer[0] = in[i * 8 + 0];
    b6b9:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b6bc:	c1 e0 03             	shl    $0x3,%eax
    b6bf:	89 c2                	mov    %eax,%edx
    b6c1:	8b 45 10             	mov    0x10(%ebp),%eax
    b6c4:	01 d0                	add    %edx,%eax
    b6c6:	0f b6 10             	movzbl (%eax),%edx
    b6c9:	8b 45 08             	mov    0x8(%ebp),%eax
    b6cc:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 8 + 2];
    b6ce:	8b 45 08             	mov    0x8(%ebp),%eax
    b6d1:	8d 50 01             	lea    0x1(%eax),%edx
    b6d4:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b6d7:	c1 e0 03             	shl    $0x3,%eax
    b6da:	8d 48 02             	lea    0x2(%eax),%ecx
    b6dd:	8b 45 10             	mov    0x10(%ebp),%eax
    b6e0:	01 c8                	add    %ecx,%eax
    b6e2:	0f b6 00             	movzbl (%eax),%eax
    b6e5:	88 02                	mov    %al,(%edx)
        buffer[2] = in[i * 8 + 4];
    b6e7:	8b 45 08             	mov    0x8(%ebp),%eax
    b6ea:	8d 50 02             	lea    0x2(%eax),%edx
    b6ed:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b6f0:	c1 e0 03             	shl    $0x3,%eax
    b6f3:	8d 48 04             	lea    0x4(%eax),%ecx
    b6f6:	8b 45 10             	mov    0x10(%ebp),%eax
    b6f9:	01 c8                	add    %ecx,%eax
    b6fb:	0f b6 00             	movzbl (%eax),%eax
    b6fe:	88 02                	mov    %al,(%edx)
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        lodepng_memcpy(buffer, &in[i * 4], 3);
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b700:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b704:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b707:	01 45 08             	add    %eax,0x8(%ebp)
    b70a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b70d:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b710:	75 a7                	jne    b6b9 <getPixelColorsRGB8+0x3bb>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b712:	90                   	nop
    b713:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    b716:	c9                   	leave  
    b717:	c3                   	ret    

0000b718 <getPixelColorRGBA16>:

/*Get RGBA16 color of pixel with index i (y * width + x) from the raw image with
given color type, but the given color type must be 16-bit itself.*/
static void getPixelColorRGBA16(unsigned short* r, unsigned short* g, unsigned short* b, unsigned short* a,
                                const unsigned char* in, size_t i, const LodePNGColorMode* mode) {
    b718:	55                   	push   %ebp
    b719:	89 e5                	mov    %esp,%ebp
  if(mode->colortype == LCT_GREY) {
    b71b:	8b 45 20             	mov    0x20(%ebp),%eax
    b71e:	8b 00                	mov    (%eax),%eax
    b720:	85 c0                	test   %eax,%eax
    b722:	0f 85 a4 00 00 00    	jne    b7cc <getPixelColorRGBA16+0xb4>
    *r = *g = *b = 256 * in[i * 2 + 0] + in[i * 2 + 1];
    b728:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b72b:	01 c0                	add    %eax,%eax
    b72d:	89 c2                	mov    %eax,%edx
    b72f:	8b 45 18             	mov    0x18(%ebp),%eax
    b732:	01 d0                	add    %edx,%eax
    b734:	0f b6 00             	movzbl (%eax),%eax
    b737:	0f b6 c0             	movzbl %al,%eax
    b73a:	c1 e0 08             	shl    $0x8,%eax
    b73d:	89 c2                	mov    %eax,%edx
    b73f:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b742:	01 c0                	add    %eax,%eax
    b744:	8d 48 01             	lea    0x1(%eax),%ecx
    b747:	8b 45 18             	mov    0x18(%ebp),%eax
    b74a:	01 c8                	add    %ecx,%eax
    b74c:	0f b6 00             	movzbl (%eax),%eax
    b74f:	0f b6 c0             	movzbl %al,%eax
    b752:	01 c2                	add    %eax,%edx
    b754:	8b 45 10             	mov    0x10(%ebp),%eax
    b757:	66 89 10             	mov    %dx,(%eax)
    b75a:	8b 45 10             	mov    0x10(%ebp),%eax
    b75d:	0f b7 10             	movzwl (%eax),%edx
    b760:	8b 45 0c             	mov    0xc(%ebp),%eax
    b763:	66 89 10             	mov    %dx,(%eax)
    b766:	8b 45 0c             	mov    0xc(%ebp),%eax
    b769:	0f b7 10             	movzwl (%eax),%edx
    b76c:	8b 45 08             	mov    0x8(%ebp),%eax
    b76f:	66 89 10             	mov    %dx,(%eax)
    if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
    b772:	8b 45 20             	mov    0x20(%ebp),%eax
    b775:	8b 40 10             	mov    0x10(%eax),%eax
    b778:	85 c0                	test   %eax,%eax
    b77a:	74 43                	je     b7bf <getPixelColorRGBA16+0xa7>
    b77c:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b77f:	01 c0                	add    %eax,%eax
    b781:	89 c2                	mov    %eax,%edx
    b783:	8b 45 18             	mov    0x18(%ebp),%eax
    b786:	01 d0                	add    %edx,%eax
    b788:	0f b6 00             	movzbl (%eax),%eax
    b78b:	0f b6 c0             	movzbl %al,%eax
    b78e:	c1 e0 08             	shl    $0x8,%eax
    b791:	89 c2                	mov    %eax,%edx
    b793:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b796:	01 c0                	add    %eax,%eax
    b798:	8d 48 01             	lea    0x1(%eax),%ecx
    b79b:	8b 45 18             	mov    0x18(%ebp),%eax
    b79e:	01 c8                	add    %ecx,%eax
    b7a0:	0f b6 00             	movzbl (%eax),%eax
    b7a3:	0f b6 c0             	movzbl %al,%eax
    b7a6:	01 c2                	add    %eax,%edx
    b7a8:	8b 45 20             	mov    0x20(%ebp),%eax
    b7ab:	8b 40 14             	mov    0x14(%eax),%eax
    b7ae:	39 c2                	cmp    %eax,%edx
    b7b0:	75 0d                	jne    b7bf <getPixelColorRGBA16+0xa7>
    b7b2:	8b 45 14             	mov    0x14(%ebp),%eax
    b7b5:	66 c7 00 00 00       	movw   $0x0,(%eax)
    b7ba:	e9 48 03 00 00       	jmp    bb07 <getPixelColorRGBA16+0x3ef>
    else *a = 65535;
    b7bf:	8b 45 14             	mov    0x14(%ebp),%eax
    b7c2:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
  }
}
    b7c7:	e9 3b 03 00 00       	jmp    bb07 <getPixelColorRGBA16+0x3ef>
                                const unsigned char* in, size_t i, const LodePNGColorMode* mode) {
  if(mode->colortype == LCT_GREY) {
    *r = *g = *b = 256 * in[i * 2 + 0] + in[i * 2 + 1];
    if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
    else *a = 65535;
  } else if(mode->colortype == LCT_RGB) {
    b7cc:	8b 45 20             	mov    0x20(%ebp),%eax
    b7cf:	8b 00                	mov    (%eax),%eax
    b7d1:	83 f8 02             	cmp    $0x2,%eax
    b7d4:	0f 85 b6 01 00 00    	jne    b990 <getPixelColorRGBA16+0x278>
    *r = 256u * in[i * 6 + 0] + in[i * 6 + 1];
    b7da:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b7dd:	89 d0                	mov    %edx,%eax
    b7df:	01 c0                	add    %eax,%eax
    b7e1:	01 d0                	add    %edx,%eax
    b7e3:	01 c0                	add    %eax,%eax
    b7e5:	89 c2                	mov    %eax,%edx
    b7e7:	8b 45 18             	mov    0x18(%ebp),%eax
    b7ea:	01 d0                	add    %edx,%eax
    b7ec:	0f b6 00             	movzbl (%eax),%eax
    b7ef:	0f b6 c0             	movzbl %al,%eax
    b7f2:	c1 e0 08             	shl    $0x8,%eax
    b7f5:	89 c1                	mov    %eax,%ecx
    b7f7:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b7fa:	89 d0                	mov    %edx,%eax
    b7fc:	01 c0                	add    %eax,%eax
    b7fe:	01 d0                	add    %edx,%eax
    b800:	01 c0                	add    %eax,%eax
    b802:	8d 50 01             	lea    0x1(%eax),%edx
    b805:	8b 45 18             	mov    0x18(%ebp),%eax
    b808:	01 d0                	add    %edx,%eax
    b80a:	0f b6 00             	movzbl (%eax),%eax
    b80d:	0f b6 c0             	movzbl %al,%eax
    b810:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b813:	8b 45 08             	mov    0x8(%ebp),%eax
    b816:	66 89 10             	mov    %dx,(%eax)
    *g = 256u * in[i * 6 + 2] + in[i * 6 + 3];
    b819:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b81c:	89 d0                	mov    %edx,%eax
    b81e:	01 c0                	add    %eax,%eax
    b820:	01 d0                	add    %edx,%eax
    b822:	01 c0                	add    %eax,%eax
    b824:	8d 50 02             	lea    0x2(%eax),%edx
    b827:	8b 45 18             	mov    0x18(%ebp),%eax
    b82a:	01 d0                	add    %edx,%eax
    b82c:	0f b6 00             	movzbl (%eax),%eax
    b82f:	0f b6 c0             	movzbl %al,%eax
    b832:	c1 e0 08             	shl    $0x8,%eax
    b835:	89 c1                	mov    %eax,%ecx
    b837:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b83a:	89 d0                	mov    %edx,%eax
    b83c:	01 c0                	add    %eax,%eax
    b83e:	01 d0                	add    %edx,%eax
    b840:	01 c0                	add    %eax,%eax
    b842:	8d 50 03             	lea    0x3(%eax),%edx
    b845:	8b 45 18             	mov    0x18(%ebp),%eax
    b848:	01 d0                	add    %edx,%eax
    b84a:	0f b6 00             	movzbl (%eax),%eax
    b84d:	0f b6 c0             	movzbl %al,%eax
    b850:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b853:	8b 45 0c             	mov    0xc(%ebp),%eax
    b856:	66 89 10             	mov    %dx,(%eax)
    *b = 256u * in[i * 6 + 4] + in[i * 6 + 5];
    b859:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b85c:	89 d0                	mov    %edx,%eax
    b85e:	01 c0                	add    %eax,%eax
    b860:	01 d0                	add    %edx,%eax
    b862:	01 c0                	add    %eax,%eax
    b864:	8d 50 04             	lea    0x4(%eax),%edx
    b867:	8b 45 18             	mov    0x18(%ebp),%eax
    b86a:	01 d0                	add    %edx,%eax
    b86c:	0f b6 00             	movzbl (%eax),%eax
    b86f:	0f b6 c0             	movzbl %al,%eax
    b872:	c1 e0 08             	shl    $0x8,%eax
    b875:	89 c1                	mov    %eax,%ecx
    b877:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b87a:	89 d0                	mov    %edx,%eax
    b87c:	01 c0                	add    %eax,%eax
    b87e:	01 d0                	add    %edx,%eax
    b880:	01 c0                	add    %eax,%eax
    b882:	8d 50 05             	lea    0x5(%eax),%edx
    b885:	8b 45 18             	mov    0x18(%ebp),%eax
    b888:	01 d0                	add    %edx,%eax
    b88a:	0f b6 00             	movzbl (%eax),%eax
    b88d:	0f b6 c0             	movzbl %al,%eax
    b890:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b893:	8b 45 10             	mov    0x10(%ebp),%eax
    b896:	66 89 10             	mov    %dx,(%eax)
    if(mode->key_defined
    b899:	8b 45 20             	mov    0x20(%ebp),%eax
    b89c:	8b 40 10             	mov    0x10(%eax),%eax
    b89f:	85 c0                	test   %eax,%eax
    b8a1:	0f 84 dc 00 00 00    	je     b983 <getPixelColorRGBA16+0x26b>
       && 256u * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
    b8a7:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b8aa:	89 d0                	mov    %edx,%eax
    b8ac:	01 c0                	add    %eax,%eax
    b8ae:	01 d0                	add    %edx,%eax
    b8b0:	01 c0                	add    %eax,%eax
    b8b2:	89 c2                	mov    %eax,%edx
    b8b4:	8b 45 18             	mov    0x18(%ebp),%eax
    b8b7:	01 d0                	add    %edx,%eax
    b8b9:	0f b6 00             	movzbl (%eax),%eax
    b8bc:	0f b6 c0             	movzbl %al,%eax
    b8bf:	c1 e0 08             	shl    $0x8,%eax
    b8c2:	89 c1                	mov    %eax,%ecx
    b8c4:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b8c7:	89 d0                	mov    %edx,%eax
    b8c9:	01 c0                	add    %eax,%eax
    b8cb:	01 d0                	add    %edx,%eax
    b8cd:	01 c0                	add    %eax,%eax
    b8cf:	8d 50 01             	lea    0x1(%eax),%edx
    b8d2:	8b 45 18             	mov    0x18(%ebp),%eax
    b8d5:	01 d0                	add    %edx,%eax
    b8d7:	0f b6 00             	movzbl (%eax),%eax
    b8da:	0f b6 c0             	movzbl %al,%eax
    b8dd:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b8e0:	8b 45 20             	mov    0x20(%ebp),%eax
    b8e3:	8b 40 14             	mov    0x14(%eax),%eax
    b8e6:	39 c2                	cmp    %eax,%edx
    b8e8:	0f 85 95 00 00 00    	jne    b983 <getPixelColorRGBA16+0x26b>
       && 256u * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
    b8ee:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b8f1:	89 d0                	mov    %edx,%eax
    b8f3:	01 c0                	add    %eax,%eax
    b8f5:	01 d0                	add    %edx,%eax
    b8f7:	01 c0                	add    %eax,%eax
    b8f9:	8d 50 02             	lea    0x2(%eax),%edx
    b8fc:	8b 45 18             	mov    0x18(%ebp),%eax
    b8ff:	01 d0                	add    %edx,%eax
    b901:	0f b6 00             	movzbl (%eax),%eax
    b904:	0f b6 c0             	movzbl %al,%eax
    b907:	c1 e0 08             	shl    $0x8,%eax
    b90a:	89 c1                	mov    %eax,%ecx
    b90c:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b90f:	89 d0                	mov    %edx,%eax
    b911:	01 c0                	add    %eax,%eax
    b913:	01 d0                	add    %edx,%eax
    b915:	01 c0                	add    %eax,%eax
    b917:	8d 50 03             	lea    0x3(%eax),%edx
    b91a:	8b 45 18             	mov    0x18(%ebp),%eax
    b91d:	01 d0                	add    %edx,%eax
    b91f:	0f b6 00             	movzbl (%eax),%eax
    b922:	0f b6 c0             	movzbl %al,%eax
    b925:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b928:	8b 45 20             	mov    0x20(%ebp),%eax
    b92b:	8b 40 18             	mov    0x18(%eax),%eax
    b92e:	39 c2                	cmp    %eax,%edx
    b930:	75 51                	jne    b983 <getPixelColorRGBA16+0x26b>
       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    b932:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b935:	89 d0                	mov    %edx,%eax
    b937:	01 c0                	add    %eax,%eax
    b939:	01 d0                	add    %edx,%eax
    b93b:	01 c0                	add    %eax,%eax
    b93d:	8d 50 04             	lea    0x4(%eax),%edx
    b940:	8b 45 18             	mov    0x18(%ebp),%eax
    b943:	01 d0                	add    %edx,%eax
    b945:	0f b6 00             	movzbl (%eax),%eax
    b948:	0f b6 c0             	movzbl %al,%eax
    b94b:	c1 e0 08             	shl    $0x8,%eax
    b94e:	89 c1                	mov    %eax,%ecx
    b950:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b953:	89 d0                	mov    %edx,%eax
    b955:	01 c0                	add    %eax,%eax
    b957:	01 d0                	add    %edx,%eax
    b959:	01 c0                	add    %eax,%eax
    b95b:	8d 50 05             	lea    0x5(%eax),%edx
    b95e:	8b 45 18             	mov    0x18(%ebp),%eax
    b961:	01 d0                	add    %edx,%eax
    b963:	0f b6 00             	movzbl (%eax),%eax
    b966:	0f b6 c0             	movzbl %al,%eax
    b969:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b96c:	8b 45 20             	mov    0x20(%ebp),%eax
    b96f:	8b 40 1c             	mov    0x1c(%eax),%eax
    b972:	39 c2                	cmp    %eax,%edx
    b974:	75 0d                	jne    b983 <getPixelColorRGBA16+0x26b>
    b976:	8b 45 14             	mov    0x14(%ebp),%eax
    b979:	66 c7 00 00 00       	movw   $0x0,(%eax)
    b97e:	e9 84 01 00 00       	jmp    bb07 <getPixelColorRGBA16+0x3ef>
    else *a = 65535;
    b983:	8b 45 14             	mov    0x14(%ebp),%eax
    b986:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
  }
}
    b98b:	e9 77 01 00 00       	jmp    bb07 <getPixelColorRGBA16+0x3ef>
    if(mode->key_defined
       && 256u * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
       && 256u * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    else *a = 65535;
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    b990:	8b 45 20             	mov    0x20(%ebp),%eax
    b993:	8b 00                	mov    (%eax),%eax
    b995:	83 f8 04             	cmp    $0x4,%eax
    b998:	0f 85 86 00 00 00    	jne    ba24 <getPixelColorRGBA16+0x30c>
    *r = *g = *b = 256u * in[i * 4 + 0] + in[i * 4 + 1];
    b99e:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b9a1:	c1 e0 02             	shl    $0x2,%eax
    b9a4:	89 c2                	mov    %eax,%edx
    b9a6:	8b 45 18             	mov    0x18(%ebp),%eax
    b9a9:	01 d0                	add    %edx,%eax
    b9ab:	0f b6 00             	movzbl (%eax),%eax
    b9ae:	0f b6 c0             	movzbl %al,%eax
    b9b1:	c1 e0 08             	shl    $0x8,%eax
    b9b4:	89 c2                	mov    %eax,%edx
    b9b6:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b9b9:	c1 e0 02             	shl    $0x2,%eax
    b9bc:	8d 48 01             	lea    0x1(%eax),%ecx
    b9bf:	8b 45 18             	mov    0x18(%ebp),%eax
    b9c2:	01 c8                	add    %ecx,%eax
    b9c4:	0f b6 00             	movzbl (%eax),%eax
    b9c7:	0f b6 c0             	movzbl %al,%eax
    b9ca:	01 c2                	add    %eax,%edx
    b9cc:	8b 45 10             	mov    0x10(%ebp),%eax
    b9cf:	66 89 10             	mov    %dx,(%eax)
    b9d2:	8b 45 10             	mov    0x10(%ebp),%eax
    b9d5:	0f b7 10             	movzwl (%eax),%edx
    b9d8:	8b 45 0c             	mov    0xc(%ebp),%eax
    b9db:	66 89 10             	mov    %dx,(%eax)
    b9de:	8b 45 0c             	mov    0xc(%ebp),%eax
    b9e1:	0f b7 10             	movzwl (%eax),%edx
    b9e4:	8b 45 08             	mov    0x8(%ebp),%eax
    b9e7:	66 89 10             	mov    %dx,(%eax)
    *a = 256u * in[i * 4 + 2] + in[i * 4 + 3];
    b9ea:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b9ed:	c1 e0 02             	shl    $0x2,%eax
    b9f0:	8d 50 02             	lea    0x2(%eax),%edx
    b9f3:	8b 45 18             	mov    0x18(%ebp),%eax
    b9f6:	01 d0                	add    %edx,%eax
    b9f8:	0f b6 00             	movzbl (%eax),%eax
    b9fb:	0f b6 c0             	movzbl %al,%eax
    b9fe:	c1 e0 08             	shl    $0x8,%eax
    ba01:	89 c2                	mov    %eax,%edx
    ba03:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ba06:	c1 e0 02             	shl    $0x2,%eax
    ba09:	8d 48 03             	lea    0x3(%eax),%ecx
    ba0c:	8b 45 18             	mov    0x18(%ebp),%eax
    ba0f:	01 c8                	add    %ecx,%eax
    ba11:	0f b6 00             	movzbl (%eax),%eax
    ba14:	0f b6 c0             	movzbl %al,%eax
    ba17:	01 c2                	add    %eax,%edx
    ba19:	8b 45 14             	mov    0x14(%ebp),%eax
    ba1c:	66 89 10             	mov    %dx,(%eax)
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
  }
}
    ba1f:	e9 e3 00 00 00       	jmp    bb07 <getPixelColorRGBA16+0x3ef>
       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    else *a = 65535;
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    *r = *g = *b = 256u * in[i * 4 + 0] + in[i * 4 + 1];
    *a = 256u * in[i * 4 + 2] + in[i * 4 + 3];
  } else if(mode->colortype == LCT_RGBA) {
    ba24:	8b 45 20             	mov    0x20(%ebp),%eax
    ba27:	8b 00                	mov    (%eax),%eax
    ba29:	83 f8 06             	cmp    $0x6,%eax
    ba2c:	0f 85 d5 00 00 00    	jne    bb07 <getPixelColorRGBA16+0x3ef>
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    ba32:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ba35:	c1 e0 03             	shl    $0x3,%eax
    ba38:	89 c2                	mov    %eax,%edx
    ba3a:	8b 45 18             	mov    0x18(%ebp),%eax
    ba3d:	01 d0                	add    %edx,%eax
    ba3f:	0f b6 00             	movzbl (%eax),%eax
    ba42:	0f b6 c0             	movzbl %al,%eax
    ba45:	c1 e0 08             	shl    $0x8,%eax
    ba48:	89 c2                	mov    %eax,%edx
    ba4a:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ba4d:	c1 e0 03             	shl    $0x3,%eax
    ba50:	8d 48 01             	lea    0x1(%eax),%ecx
    ba53:	8b 45 18             	mov    0x18(%ebp),%eax
    ba56:	01 c8                	add    %ecx,%eax
    ba58:	0f b6 00             	movzbl (%eax),%eax
    ba5b:	0f b6 c0             	movzbl %al,%eax
    ba5e:	01 c2                	add    %eax,%edx
    ba60:	8b 45 08             	mov    0x8(%ebp),%eax
    ba63:	66 89 10             	mov    %dx,(%eax)
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    ba66:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ba69:	c1 e0 03             	shl    $0x3,%eax
    ba6c:	8d 50 02             	lea    0x2(%eax),%edx
    ba6f:	8b 45 18             	mov    0x18(%ebp),%eax
    ba72:	01 d0                	add    %edx,%eax
    ba74:	0f b6 00             	movzbl (%eax),%eax
    ba77:	0f b6 c0             	movzbl %al,%eax
    ba7a:	c1 e0 08             	shl    $0x8,%eax
    ba7d:	89 c2                	mov    %eax,%edx
    ba7f:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ba82:	c1 e0 03             	shl    $0x3,%eax
    ba85:	8d 48 03             	lea    0x3(%eax),%ecx
    ba88:	8b 45 18             	mov    0x18(%ebp),%eax
    ba8b:	01 c8                	add    %ecx,%eax
    ba8d:	0f b6 00             	movzbl (%eax),%eax
    ba90:	0f b6 c0             	movzbl %al,%eax
    ba93:	01 c2                	add    %eax,%edx
    ba95:	8b 45 0c             	mov    0xc(%ebp),%eax
    ba98:	66 89 10             	mov    %dx,(%eax)
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    ba9b:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ba9e:	c1 e0 03             	shl    $0x3,%eax
    baa1:	8d 50 04             	lea    0x4(%eax),%edx
    baa4:	8b 45 18             	mov    0x18(%ebp),%eax
    baa7:	01 d0                	add    %edx,%eax
    baa9:	0f b6 00             	movzbl (%eax),%eax
    baac:	0f b6 c0             	movzbl %al,%eax
    baaf:	c1 e0 08             	shl    $0x8,%eax
    bab2:	89 c2                	mov    %eax,%edx
    bab4:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bab7:	c1 e0 03             	shl    $0x3,%eax
    baba:	8d 48 05             	lea    0x5(%eax),%ecx
    babd:	8b 45 18             	mov    0x18(%ebp),%eax
    bac0:	01 c8                	add    %ecx,%eax
    bac2:	0f b6 00             	movzbl (%eax),%eax
    bac5:	0f b6 c0             	movzbl %al,%eax
    bac8:	01 c2                	add    %eax,%edx
    baca:	8b 45 10             	mov    0x10(%ebp),%eax
    bacd:	66 89 10             	mov    %dx,(%eax)
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
    bad0:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bad3:	c1 e0 03             	shl    $0x3,%eax
    bad6:	8d 50 06             	lea    0x6(%eax),%edx
    bad9:	8b 45 18             	mov    0x18(%ebp),%eax
    badc:	01 d0                	add    %edx,%eax
    bade:	0f b6 00             	movzbl (%eax),%eax
    bae1:	0f b6 c0             	movzbl %al,%eax
    bae4:	c1 e0 08             	shl    $0x8,%eax
    bae7:	89 c2                	mov    %eax,%edx
    bae9:	8b 45 1c             	mov    0x1c(%ebp),%eax
    baec:	c1 e0 03             	shl    $0x3,%eax
    baef:	8d 48 07             	lea    0x7(%eax),%ecx
    baf2:	8b 45 18             	mov    0x18(%ebp),%eax
    baf5:	01 c8                	add    %ecx,%eax
    baf7:	0f b6 00             	movzbl (%eax),%eax
    bafa:	0f b6 c0             	movzbl %al,%eax
    bafd:	01 c2                	add    %eax,%edx
    baff:	8b 45 14             	mov    0x14(%ebp),%eax
    bb02:	66 89 10             	mov    %dx,(%eax)
  }
}
    bb05:	eb 00                	jmp    bb07 <getPixelColorRGBA16+0x3ef>
    bb07:	90                   	nop
    bb08:	5d                   	pop    %ebp
    bb09:	c3                   	ret    

0000bb0a <lodepng_convert>:

unsigned lodepng_convert(unsigned char* out, const unsigned char* in,
                         const LodePNGColorMode* mode_out, const LodePNGColorMode* mode_in,
                         unsigned w, unsigned h) {
    bb0a:	55                   	push   %ebp
    bb0b:	89 e5                	mov    %esp,%ebp
    bb0d:	56                   	push   %esi
    bb0e:	53                   	push   %ebx
    bb0f:	83 c4 80             	add    $0xffffff80,%esp
  size_t i;
  ColorTree tree;
  size_t numpixels = (size_t)w * (size_t)h;
    bb12:	8b 55 18             	mov    0x18(%ebp),%edx
    bb15:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bb18:	0f af c2             	imul   %edx,%eax
    bb1b:	89 45 e0             	mov    %eax,-0x20(%ebp)
  unsigned error = 0;
    bb1e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  if(mode_in->colortype == LCT_PALETTE && !mode_in->palette) {
    bb25:	8b 45 14             	mov    0x14(%ebp),%eax
    bb28:	8b 00                	mov    (%eax),%eax
    bb2a:	83 f8 03             	cmp    $0x3,%eax
    bb2d:	75 14                	jne    bb43 <lodepng_convert+0x39>
    bb2f:	8b 45 14             	mov    0x14(%ebp),%eax
    bb32:	8b 40 08             	mov    0x8(%eax),%eax
    bb35:	85 c0                	test   %eax,%eax
    bb37:	75 0a                	jne    bb43 <lodepng_convert+0x39>
    return 107; /* error: must provide palette if input mode is palette */
    bb39:	b8 6b 00 00 00       	mov    $0x6b,%eax
    bb3e:	e9 19 03 00 00       	jmp    be5c <lodepng_convert+0x352>
  }

  if(lodepng_color_mode_equal(mode_out, mode_in)) {
    bb43:	ff 75 14             	pushl  0x14(%ebp)
    bb46:	ff 75 10             	pushl  0x10(%ebp)
    bb49:	e8 b7 d1 ff ff       	call   8d05 <lodepng_color_mode_equal>
    bb4e:	83 c4 08             	add    $0x8,%esp
    bb51:	85 c0                	test   %eax,%eax
    bb53:	74 2f                	je     bb84 <lodepng_convert+0x7a>
    size_t numbytes = lodepng_get_raw_size(w, h, mode_in);
    bb55:	ff 75 14             	pushl  0x14(%ebp)
    bb58:	ff 75 1c             	pushl  0x1c(%ebp)
    bb5b:	ff 75 18             	pushl  0x18(%ebp)
    bb5e:	e8 fb d4 ff ff       	call   905e <lodepng_get_raw_size>
    bb63:	83 c4 0c             	add    $0xc,%esp
    bb66:	89 45 dc             	mov    %eax,-0x24(%ebp)
    lodepng_memcpy(out, in, numbytes);
    bb69:	ff 75 dc             	pushl  -0x24(%ebp)
    bb6c:	ff 75 0c             	pushl  0xc(%ebp)
    bb6f:	ff 75 08             	pushl  0x8(%ebp)
    bb72:	e8 ca 78 ff ff       	call   3441 <lodepng_memcpy>
    bb77:	83 c4 0c             	add    $0xc,%esp
    return 0;
    bb7a:	b8 00 00 00 00       	mov    $0x0,%eax
    bb7f:	e9 d8 02 00 00       	jmp    be5c <lodepng_convert+0x352>
  }

  if(mode_out->colortype == LCT_PALETTE) {
    bb84:	8b 45 10             	mov    0x10(%ebp),%eax
    bb87:	8b 00                	mov    (%eax),%eax
    bb89:	83 f8 03             	cmp    $0x3,%eax
    bb8c:	0f 85 16 01 00 00    	jne    bca8 <lodepng_convert+0x19e>
    size_t palettesize = mode_out->palettesize;
    bb92:	8b 45 10             	mov    0x10(%ebp),%eax
    bb95:	8b 40 0c             	mov    0xc(%eax),%eax
    bb98:	89 45 ec             	mov    %eax,-0x14(%ebp)
    const unsigned char* palette = mode_out->palette;
    bb9b:	8b 45 10             	mov    0x10(%ebp),%eax
    bb9e:	8b 40 08             	mov    0x8(%eax),%eax
    bba1:	89 45 e8             	mov    %eax,-0x18(%ebp)
    size_t palsize = (size_t)1u << mode_out->bitdepth;
    bba4:	8b 45 10             	mov    0x10(%ebp),%eax
    bba7:	8b 40 04             	mov    0x4(%eax),%eax
    bbaa:	ba 01 00 00 00       	mov    $0x1,%edx
    bbaf:	89 c1                	mov    %eax,%ecx
    bbb1:	d3 e2                	shl    %cl,%edx
    bbb3:	89 d0                	mov    %edx,%eax
    bbb5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    /*if the user specified output palette but did not give the values, assume
    they want the values of the input color type (assuming that one is palette).
    Note that we never create a new palette ourselves.*/
    if(palettesize == 0) {
    bbb8:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    bbbc:	75 5b                	jne    bc19 <lodepng_convert+0x10f>
      palettesize = mode_in->palettesize;
    bbbe:	8b 45 14             	mov    0x14(%ebp),%eax
    bbc1:	8b 40 0c             	mov    0xc(%eax),%eax
    bbc4:	89 45 ec             	mov    %eax,-0x14(%ebp)
      palette = mode_in->palette;
    bbc7:	8b 45 14             	mov    0x14(%ebp),%eax
    bbca:	8b 40 08             	mov    0x8(%eax),%eax
    bbcd:	89 45 e8             	mov    %eax,-0x18(%ebp)
      /*if the input was also palette with same bitdepth, then the color types are also
      equal, so copy literally. This to preserve the exact indices that were in the PNG
      even in case there are duplicate colors in the palette.*/
      if(mode_in->colortype == LCT_PALETTE && mode_in->bitdepth == mode_out->bitdepth) {
    bbd0:	8b 45 14             	mov    0x14(%ebp),%eax
    bbd3:	8b 00                	mov    (%eax),%eax
    bbd5:	83 f8 03             	cmp    $0x3,%eax
    bbd8:	75 3f                	jne    bc19 <lodepng_convert+0x10f>
    bbda:	8b 45 14             	mov    0x14(%ebp),%eax
    bbdd:	8b 50 04             	mov    0x4(%eax),%edx
    bbe0:	8b 45 10             	mov    0x10(%ebp),%eax
    bbe3:	8b 40 04             	mov    0x4(%eax),%eax
    bbe6:	39 c2                	cmp    %eax,%edx
    bbe8:	75 2f                	jne    bc19 <lodepng_convert+0x10f>
        size_t numbytes = lodepng_get_raw_size(w, h, mode_in);
    bbea:	ff 75 14             	pushl  0x14(%ebp)
    bbed:	ff 75 1c             	pushl  0x1c(%ebp)
    bbf0:	ff 75 18             	pushl  0x18(%ebp)
    bbf3:	e8 66 d4 ff ff       	call   905e <lodepng_get_raw_size>
    bbf8:	83 c4 0c             	add    $0xc,%esp
    bbfb:	89 45 d8             	mov    %eax,-0x28(%ebp)
        lodepng_memcpy(out, in, numbytes);
    bbfe:	ff 75 d8             	pushl  -0x28(%ebp)
    bc01:	ff 75 0c             	pushl  0xc(%ebp)
    bc04:	ff 75 08             	pushl  0x8(%ebp)
    bc07:	e8 35 78 ff ff       	call   3441 <lodepng_memcpy>
    bc0c:	83 c4 0c             	add    $0xc,%esp
        return 0;
    bc0f:	b8 00 00 00 00       	mov    $0x0,%eax
    bc14:	e9 43 02 00 00       	jmp    be5c <lodepng_convert+0x352>
      }
    }
    if(palettesize < palsize) palsize = palettesize;
    bc19:	8b 45 ec             	mov    -0x14(%ebp),%eax
    bc1c:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    bc1f:	7d 06                	jge    bc27 <lodepng_convert+0x11d>
    bc21:	8b 45 ec             	mov    -0x14(%ebp),%eax
    bc24:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    color_tree_init(&tree);
    bc27:	8d 45 90             	lea    -0x70(%ebp),%eax
    bc2a:	50                   	push   %eax
    bc2b:	e8 5f e1 ff ff       	call   9d8f <color_tree_init>
    bc30:	83 c4 04             	add    $0x4,%esp
    for(i = 0; i != palsize; ++i) {
    bc33:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    bc3a:	eb 61                	jmp    bc9d <lodepng_convert+0x193>
      const unsigned char* p = &palette[i * 4];
    bc3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bc3f:	c1 e0 02             	shl    $0x2,%eax
    bc42:	89 c2                	mov    %eax,%edx
    bc44:	8b 45 e8             	mov    -0x18(%ebp),%eax
    bc47:	01 d0                	add    %edx,%eax
    bc49:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      error = color_tree_add(&tree, p[0], p[1], p[2], p[3], (unsigned)i);
    bc4c:	8b 75 f4             	mov    -0xc(%ebp),%esi
    bc4f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    bc52:	83 c0 03             	add    $0x3,%eax
    bc55:	0f b6 00             	movzbl (%eax),%eax
    bc58:	0f b6 d8             	movzbl %al,%ebx
    bc5b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    bc5e:	83 c0 02             	add    $0x2,%eax
    bc61:	0f b6 00             	movzbl (%eax),%eax
    bc64:	0f b6 c8             	movzbl %al,%ecx
    bc67:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    bc6a:	83 c0 01             	add    $0x1,%eax
    bc6d:	0f b6 00             	movzbl (%eax),%eax
    bc70:	0f b6 d0             	movzbl %al,%edx
    bc73:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    bc76:	0f b6 00             	movzbl (%eax),%eax
    bc79:	0f b6 c0             	movzbl %al,%eax
    bc7c:	83 ec 08             	sub    $0x8,%esp
    bc7f:	56                   	push   %esi
    bc80:	53                   	push   %ebx
    bc81:	51                   	push   %ecx
    bc82:	52                   	push   %edx
    bc83:	50                   	push   %eax
    bc84:	8d 45 90             	lea    -0x70(%ebp),%eax
    bc87:	50                   	push   %eax
    bc88:	e8 85 e2 ff ff       	call   9f12 <color_tree_add>
    bc8d:	83 c4 20             	add    $0x20,%esp
    bc90:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if(error) break;
    bc93:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    bc97:	75 0e                	jne    bca7 <lodepng_convert+0x19d>
        return 0;
      }
    }
    if(palettesize < palsize) palsize = palettesize;
    color_tree_init(&tree);
    for(i = 0; i != palsize; ++i) {
    bc99:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    bc9d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bca0:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    bca3:	75 97                	jne    bc3c <lodepng_convert+0x132>
    bca5:	eb 01                	jmp    bca8 <lodepng_convert+0x19e>
      const unsigned char* p = &palette[i * 4];
      error = color_tree_add(&tree, p[0], p[1], p[2], p[3], (unsigned)i);
      if(error) break;
    bca7:	90                   	nop
    }
  }

  if(!error) {
    bca8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    bcac:	0f 85 8e 01 00 00    	jne    be40 <lodepng_convert+0x336>
    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {
    bcb2:	8b 45 14             	mov    0x14(%ebp),%eax
    bcb5:	8b 40 04             	mov    0x4(%eax),%eax
    bcb8:	83 f8 10             	cmp    $0x10,%eax
    bcbb:	0f 85 99 00 00 00    	jne    bd5a <lodepng_convert+0x250>
    bcc1:	8b 45 10             	mov    0x10(%ebp),%eax
    bcc4:	8b 40 04             	mov    0x4(%eax),%eax
    bcc7:	83 f8 10             	cmp    $0x10,%eax
    bcca:	0f 85 8a 00 00 00    	jne    bd5a <lodepng_convert+0x250>
      for(i = 0; i != numpixels; ++i) {
    bcd0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    bcd7:	eb 74                	jmp    bd4d <lodepng_convert+0x243>
        unsigned short r = 0, g = 0, b = 0, a = 0;
    bcd9:	66 c7 45 8e 00 00    	movw   $0x0,-0x72(%ebp)
    bcdf:	66 c7 45 8c 00 00    	movw   $0x0,-0x74(%ebp)
    bce5:	66 c7 45 8a 00 00    	movw   $0x0,-0x76(%ebp)
    bceb:	66 c7 45 88 00 00    	movw   $0x0,-0x78(%ebp)
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    bcf1:	83 ec 04             	sub    $0x4,%esp
    bcf4:	ff 75 14             	pushl  0x14(%ebp)
    bcf7:	ff 75 f4             	pushl  -0xc(%ebp)
    bcfa:	ff 75 0c             	pushl  0xc(%ebp)
    bcfd:	8d 45 88             	lea    -0x78(%ebp),%eax
    bd00:	50                   	push   %eax
    bd01:	8d 45 8a             	lea    -0x76(%ebp),%eax
    bd04:	50                   	push   %eax
    bd05:	8d 45 8c             	lea    -0x74(%ebp),%eax
    bd08:	50                   	push   %eax
    bd09:	8d 45 8e             	lea    -0x72(%ebp),%eax
    bd0c:	50                   	push   %eax
    bd0d:	e8 06 fa ff ff       	call   b718 <getPixelColorRGBA16>
    bd12:	83 c4 20             	add    $0x20,%esp
        rgba16ToPixel(out, i, mode_out, r, g, b, a);
    bd15:	0f b7 45 88          	movzwl -0x78(%ebp),%eax
    bd19:	0f b7 d8             	movzwl %ax,%ebx
    bd1c:	0f b7 45 8a          	movzwl -0x76(%ebp),%eax
    bd20:	0f b7 c8             	movzwl %ax,%ecx
    bd23:	0f b7 45 8c          	movzwl -0x74(%ebp),%eax
    bd27:	0f b7 d0             	movzwl %ax,%edx
    bd2a:	0f b7 45 8e          	movzwl -0x72(%ebp),%eax
    bd2e:	0f b7 c0             	movzwl %ax,%eax
    bd31:	83 ec 04             	sub    $0x4,%esp
    bd34:	53                   	push   %ebx
    bd35:	51                   	push   %ecx
    bd36:	52                   	push   %edx
    bd37:	50                   	push   %eax
    bd38:	ff 75 10             	pushl  0x10(%ebp)
    bd3b:	ff 75 f4             	pushl  -0xc(%ebp)
    bd3e:	ff 75 08             	pushl  0x8(%ebp)
    bd41:	e8 d3 e6 ff ff       	call   a419 <rgba16ToPixel>
    bd46:	83 c4 20             	add    $0x20,%esp
    }
  }

  if(!error) {
    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i) {
    bd49:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    bd4d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bd50:	3b 45 e0             	cmp    -0x20(%ebp),%eax
    bd53:	75 84                	jne    bcd9 <lodepng_convert+0x1cf>
      if(error) break;
    }
  }

  if(!error) {
    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {
    bd55:	e9 e6 00 00 00       	jmp    be40 <lodepng_convert+0x336>
      for(i = 0; i != numpixels; ++i) {
        unsigned short r = 0, g = 0, b = 0, a = 0;
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
        rgba16ToPixel(out, i, mode_out, r, g, b, a);
      }
    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGBA) {
    bd5a:	8b 45 10             	mov    0x10(%ebp),%eax
    bd5d:	8b 40 04             	mov    0x4(%eax),%eax
    bd60:	83 f8 08             	cmp    $0x8,%eax
    bd63:	75 23                	jne    bd88 <lodepng_convert+0x27e>
    bd65:	8b 45 10             	mov    0x10(%ebp),%eax
    bd68:	8b 00                	mov    (%eax),%eax
    bd6a:	83 f8 06             	cmp    $0x6,%eax
    bd6d:	75 19                	jne    bd88 <lodepng_convert+0x27e>
      getPixelColorsRGBA8(out, numpixels, in, mode_in);
    bd6f:	ff 75 14             	pushl  0x14(%ebp)
    bd72:	ff 75 0c             	pushl  0xc(%ebp)
    bd75:	ff 75 e0             	pushl  -0x20(%ebp)
    bd78:	ff 75 08             	pushl  0x8(%ebp)
    bd7b:	e8 ae ee ff ff       	call   ac2e <getPixelColorsRGBA8>
    bd80:	83 c4 10             	add    $0x10,%esp
    bd83:	e9 b8 00 00 00       	jmp    be40 <lodepng_convert+0x336>
    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGB) {
    bd88:	8b 45 10             	mov    0x10(%ebp),%eax
    bd8b:	8b 40 04             	mov    0x4(%eax),%eax
    bd8e:	83 f8 08             	cmp    $0x8,%eax
    bd91:	75 23                	jne    bdb6 <lodepng_convert+0x2ac>
    bd93:	8b 45 10             	mov    0x10(%ebp),%eax
    bd96:	8b 00                	mov    (%eax),%eax
    bd98:	83 f8 02             	cmp    $0x2,%eax
    bd9b:	75 19                	jne    bdb6 <lodepng_convert+0x2ac>
      getPixelColorsRGB8(out, numpixels, in, mode_in);
    bd9d:	ff 75 14             	pushl  0x14(%ebp)
    bda0:	ff 75 0c             	pushl  0xc(%ebp)
    bda3:	ff 75 e0             	pushl  -0x20(%ebp)
    bda6:	ff 75 08             	pushl  0x8(%ebp)
    bda9:	e8 50 f5 ff ff       	call   b2fe <getPixelColorsRGB8>
    bdae:	83 c4 10             	add    $0x10,%esp
    bdb1:	e9 8a 00 00 00       	jmp    be40 <lodepng_convert+0x336>
    } else {
      unsigned char r = 0, g = 0, b = 0, a = 0;
    bdb6:	c6 45 87 00          	movb   $0x0,-0x79(%ebp)
    bdba:	c6 45 86 00          	movb   $0x0,-0x7a(%ebp)
    bdbe:	c6 45 85 00          	movb   $0x0,-0x7b(%ebp)
    bdc2:	c6 45 84 00          	movb   $0x0,-0x7c(%ebp)
      for(i = 0; i != numpixels; ++i) {
    bdc6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    bdcd:	eb 66                	jmp    be35 <lodepng_convert+0x32b>
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
    bdcf:	83 ec 04             	sub    $0x4,%esp
    bdd2:	ff 75 14             	pushl  0x14(%ebp)
    bdd5:	ff 75 f4             	pushl  -0xc(%ebp)
    bdd8:	ff 75 0c             	pushl  0xc(%ebp)
    bddb:	8d 45 84             	lea    -0x7c(%ebp),%eax
    bdde:	50                   	push   %eax
    bddf:	8d 45 85             	lea    -0x7b(%ebp),%eax
    bde2:	50                   	push   %eax
    bde3:	8d 45 86             	lea    -0x7a(%ebp),%eax
    bde6:	50                   	push   %eax
    bde7:	8d 45 87             	lea    -0x79(%ebp),%eax
    bdea:	50                   	push   %eax
    bdeb:	e8 71 e8 ff ff       	call   a661 <getPixelColorRGBA8>
    bdf0:	83 c4 20             	add    $0x20,%esp
        error = rgba8ToPixel(out, i, mode_out, &tree, r, g, b, a);
    bdf3:	0f b6 45 84          	movzbl -0x7c(%ebp),%eax
    bdf7:	0f b6 d8             	movzbl %al,%ebx
    bdfa:	0f b6 45 85          	movzbl -0x7b(%ebp),%eax
    bdfe:	0f b6 c8             	movzbl %al,%ecx
    be01:	0f b6 45 86          	movzbl -0x7a(%ebp),%eax
    be05:	0f b6 d0             	movzbl %al,%edx
    be08:	0f b6 45 87          	movzbl -0x79(%ebp),%eax
    be0c:	0f b6 c0             	movzbl %al,%eax
    be0f:	53                   	push   %ebx
    be10:	51                   	push   %ecx
    be11:	52                   	push   %edx
    be12:	50                   	push   %eax
    be13:	8d 45 90             	lea    -0x70(%ebp),%eax
    be16:	50                   	push   %eax
    be17:	ff 75 10             	pushl  0x10(%ebp)
    be1a:	ff 75 f4             	pushl  -0xc(%ebp)
    be1d:	ff 75 08             	pushl  0x8(%ebp)
    be20:	e8 e5 e1 ff ff       	call   a00a <rgba8ToPixel>
    be25:	83 c4 20             	add    $0x20,%esp
    be28:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(error) break;
    be2b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    be2f:	75 0e                	jne    be3f <lodepng_convert+0x335>
      getPixelColorsRGBA8(out, numpixels, in, mode_in);
    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGB) {
      getPixelColorsRGB8(out, numpixels, in, mode_in);
    } else {
      unsigned char r = 0, g = 0, b = 0, a = 0;
      for(i = 0; i != numpixels; ++i) {
    be31:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    be35:	8b 45 f4             	mov    -0xc(%ebp),%eax
    be38:	3b 45 e0             	cmp    -0x20(%ebp),%eax
    be3b:	75 92                	jne    bdcf <lodepng_convert+0x2c5>
    be3d:	eb 01                	jmp    be40 <lodepng_convert+0x336>
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
        error = rgba8ToPixel(out, i, mode_out, &tree, r, g, b, a);
        if(error) break;
    be3f:	90                   	nop
      }
    }
  }

  if(mode_out->colortype == LCT_PALETTE) {
    be40:	8b 45 10             	mov    0x10(%ebp),%eax
    be43:	8b 00                	mov    (%eax),%eax
    be45:	83 f8 03             	cmp    $0x3,%eax
    be48:	75 0f                	jne    be59 <lodepng_convert+0x34f>
    color_tree_cleanup(&tree);
    be4a:	83 ec 0c             	sub    $0xc,%esp
    be4d:	8d 45 90             	lea    -0x70(%ebp),%eax
    be50:	50                   	push   %eax
    be51:	e8 59 df ff ff       	call   9daf <color_tree_cleanup>
    be56:	83 c4 10             	add    $0x10,%esp
  }

  return error;
    be59:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    be5c:	8d 65 f8             	lea    -0x8(%ebp),%esp
    be5f:	5b                   	pop    %ebx
    be60:	5e                   	pop    %esi
    be61:	5d                   	pop    %ebp
    be62:	c3                   	ret    

0000be63 <lodepng_convert_rgb>:
specification it looks like bKGD should ignore the alpha values of the palette since it can use
any palette index but doesn't have an alpha channel. Idem with ignoring color key. */
unsigned lodepng_convert_rgb(
    unsigned* r_out, unsigned* g_out, unsigned* b_out,
    unsigned r_in, unsigned g_in, unsigned b_in,
    const LodePNGColorMode* mode_out, const LodePNGColorMode* mode_in) {
    be63:	55                   	push   %ebp
    be64:	89 e5                	mov    %esp,%ebp
    be66:	83 ec 20             	sub    $0x20,%esp
  unsigned r = 0, g = 0, b = 0;
    be69:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    be70:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    be77:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned mul = 65535 / ((1u << mode_in->bitdepth) - 1u); /*65535, 21845, 4369, 257, 1*/
    be7e:	8b 45 24             	mov    0x24(%ebp),%eax
    be81:	8b 40 04             	mov    0x4(%eax),%eax
    be84:	ba 01 00 00 00       	mov    $0x1,%edx
    be89:	89 c1                	mov    %eax,%ecx
    be8b:	d3 e2                	shl    %cl,%edx
    be8d:	89 d0                	mov    %edx,%eax
    be8f:	8d 48 ff             	lea    -0x1(%eax),%ecx
    be92:	b8 ff ff 00 00       	mov    $0xffff,%eax
    be97:	ba 00 00 00 00       	mov    $0x0,%edx
    be9c:	f7 f1                	div    %ecx
    be9e:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned shift = 16 - mode_out->bitdepth;
    bea1:	8b 45 20             	mov    0x20(%ebp),%eax
    bea4:	8b 40 04             	mov    0x4(%eax),%eax
    bea7:	ba 10 00 00 00       	mov    $0x10,%edx
    beac:	29 c2                	sub    %eax,%edx
    beae:	89 d0                	mov    %edx,%eax
    beb0:	89 45 e8             	mov    %eax,-0x18(%ebp)

  if(mode_in->colortype == LCT_GREY || mode_in->colortype == LCT_GREY_ALPHA) {
    beb3:	8b 45 24             	mov    0x24(%ebp),%eax
    beb6:	8b 00                	mov    (%eax),%eax
    beb8:	85 c0                	test   %eax,%eax
    beba:	74 0a                	je     bec6 <lodepng_convert_rgb+0x63>
    bebc:	8b 45 24             	mov    0x24(%ebp),%eax
    bebf:	8b 00                	mov    (%eax),%eax
    bec1:	83 f8 04             	cmp    $0x4,%eax
    bec4:	75 1b                	jne    bee1 <lodepng_convert_rgb+0x7e>
    r = g = b = r_in * mul;
    bec6:	8b 45 14             	mov    0x14(%ebp),%eax
    bec9:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    becd:	89 45 f4             	mov    %eax,-0xc(%ebp)
    bed0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bed3:	89 45 f8             	mov    %eax,-0x8(%ebp)
    bed6:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bed9:	89 45 fc             	mov    %eax,-0x4(%ebp)
    bedc:	e9 c2 00 00 00       	jmp    bfa3 <lodepng_convert_rgb+0x140>
  } else if(mode_in->colortype == LCT_RGB || mode_in->colortype == LCT_RGBA) {
    bee1:	8b 45 24             	mov    0x24(%ebp),%eax
    bee4:	8b 00                	mov    (%eax),%eax
    bee6:	83 f8 02             	cmp    $0x2,%eax
    bee9:	74 0a                	je     bef5 <lodepng_convert_rgb+0x92>
    beeb:	8b 45 24             	mov    0x24(%ebp),%eax
    beee:	8b 00                	mov    (%eax),%eax
    bef0:	83 f8 06             	cmp    $0x6,%eax
    bef3:	75 23                	jne    bf18 <lodepng_convert_rgb+0xb5>
    r = r_in * mul;
    bef5:	8b 45 14             	mov    0x14(%ebp),%eax
    bef8:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    befc:	89 45 fc             	mov    %eax,-0x4(%ebp)
    g = g_in * mul;
    beff:	8b 45 18             	mov    0x18(%ebp),%eax
    bf02:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    bf06:	89 45 f8             	mov    %eax,-0x8(%ebp)
    b = b_in * mul;
    bf09:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bf0c:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    bf10:	89 45 f4             	mov    %eax,-0xc(%ebp)
    bf13:	e9 8b 00 00 00       	jmp    bfa3 <lodepng_convert_rgb+0x140>
  } else if(mode_in->colortype == LCT_PALETTE) {
    bf18:	8b 45 24             	mov    0x24(%ebp),%eax
    bf1b:	8b 00                	mov    (%eax),%eax
    bf1d:	83 f8 03             	cmp    $0x3,%eax
    bf20:	75 77                	jne    bf99 <lodepng_convert_rgb+0x136>
    if(r_in >= mode_in->palettesize) return 82;
    bf22:	8b 45 24             	mov    0x24(%ebp),%eax
    bf25:	8b 40 0c             	mov    0xc(%eax),%eax
    bf28:	3b 45 14             	cmp    0x14(%ebp),%eax
    bf2b:	77 0a                	ja     bf37 <lodepng_convert_rgb+0xd4>
    bf2d:	b8 52 00 00 00       	mov    $0x52,%eax
    bf32:	e9 cb 01 00 00       	jmp    c102 <lodepng_convert_rgb+0x29f>
    r = mode_in->palette[r_in * 4 + 0] * 257u;
    bf37:	8b 45 24             	mov    0x24(%ebp),%eax
    bf3a:	8b 40 08             	mov    0x8(%eax),%eax
    bf3d:	8b 55 14             	mov    0x14(%ebp),%edx
    bf40:	c1 e2 02             	shl    $0x2,%edx
    bf43:	01 d0                	add    %edx,%eax
    bf45:	0f b6 00             	movzbl (%eax),%eax
    bf48:	0f b6 d0             	movzbl %al,%edx
    bf4b:	89 d0                	mov    %edx,%eax
    bf4d:	c1 e0 08             	shl    $0x8,%eax
    bf50:	01 d0                	add    %edx,%eax
    bf52:	89 45 fc             	mov    %eax,-0x4(%ebp)
    g = mode_in->palette[r_in * 4 + 1] * 257u;
    bf55:	8b 45 24             	mov    0x24(%ebp),%eax
    bf58:	8b 40 08             	mov    0x8(%eax),%eax
    bf5b:	8b 55 14             	mov    0x14(%ebp),%edx
    bf5e:	c1 e2 02             	shl    $0x2,%edx
    bf61:	83 c2 01             	add    $0x1,%edx
    bf64:	01 d0                	add    %edx,%eax
    bf66:	0f b6 00             	movzbl (%eax),%eax
    bf69:	0f b6 d0             	movzbl %al,%edx
    bf6c:	89 d0                	mov    %edx,%eax
    bf6e:	c1 e0 08             	shl    $0x8,%eax
    bf71:	01 d0                	add    %edx,%eax
    bf73:	89 45 f8             	mov    %eax,-0x8(%ebp)
    b = mode_in->palette[r_in * 4 + 2] * 257u;
    bf76:	8b 45 24             	mov    0x24(%ebp),%eax
    bf79:	8b 40 08             	mov    0x8(%eax),%eax
    bf7c:	8b 55 14             	mov    0x14(%ebp),%edx
    bf7f:	c1 e2 02             	shl    $0x2,%edx
    bf82:	83 c2 02             	add    $0x2,%edx
    bf85:	01 d0                	add    %edx,%eax
    bf87:	0f b6 00             	movzbl (%eax),%eax
    bf8a:	0f b6 d0             	movzbl %al,%edx
    bf8d:	89 d0                	mov    %edx,%eax
    bf8f:	c1 e0 08             	shl    $0x8,%eax
    bf92:	01 d0                	add    %edx,%eax
    bf94:	89 45 f4             	mov    %eax,-0xc(%ebp)
    bf97:	eb 0a                	jmp    bfa3 <lodepng_convert_rgb+0x140>
  } else {
    return 31;
    bf99:	b8 1f 00 00 00       	mov    $0x1f,%eax
    bf9e:	e9 5f 01 00 00       	jmp    c102 <lodepng_convert_rgb+0x29f>
  }

  /* now convert to output format */
  if(mode_out->colortype == LCT_GREY || mode_out->colortype == LCT_GREY_ALPHA) {
    bfa3:	8b 45 20             	mov    0x20(%ebp),%eax
    bfa6:	8b 00                	mov    (%eax),%eax
    bfa8:	85 c0                	test   %eax,%eax
    bfaa:	74 0a                	je     bfb6 <lodepng_convert_rgb+0x153>
    bfac:	8b 45 20             	mov    0x20(%ebp),%eax
    bfaf:	8b 00                	mov    (%eax),%eax
    bfb1:	83 f8 04             	cmp    $0x4,%eax
    bfb4:	75 14                	jne    bfca <lodepng_convert_rgb+0x167>
    *r_out = r >> shift ;
    bfb6:	8b 45 e8             	mov    -0x18(%ebp),%eax
    bfb9:	8b 55 fc             	mov    -0x4(%ebp),%edx
    bfbc:	89 c1                	mov    %eax,%ecx
    bfbe:	d3 ea                	shr    %cl,%edx
    bfc0:	8b 45 08             	mov    0x8(%ebp),%eax
    bfc3:	89 10                	mov    %edx,(%eax)
    bfc5:	e9 33 01 00 00       	jmp    c0fd <lodepng_convert_rgb+0x29a>
  } else if(mode_out->colortype == LCT_RGB || mode_out->colortype == LCT_RGBA) {
    bfca:	8b 45 20             	mov    0x20(%ebp),%eax
    bfcd:	8b 00                	mov    (%eax),%eax
    bfcf:	83 f8 02             	cmp    $0x2,%eax
    bfd2:	74 0a                	je     bfde <lodepng_convert_rgb+0x17b>
    bfd4:	8b 45 20             	mov    0x20(%ebp),%eax
    bfd7:	8b 00                	mov    (%eax),%eax
    bfd9:	83 f8 06             	cmp    $0x6,%eax
    bfdc:	75 32                	jne    c010 <lodepng_convert_rgb+0x1ad>
    *r_out = r >> shift ;
    bfde:	8b 45 e8             	mov    -0x18(%ebp),%eax
    bfe1:	8b 55 fc             	mov    -0x4(%ebp),%edx
    bfe4:	89 c1                	mov    %eax,%ecx
    bfe6:	d3 ea                	shr    %cl,%edx
    bfe8:	8b 45 08             	mov    0x8(%ebp),%eax
    bfeb:	89 10                	mov    %edx,(%eax)
    *g_out = g >> shift ;
    bfed:	8b 45 e8             	mov    -0x18(%ebp),%eax
    bff0:	8b 55 f8             	mov    -0x8(%ebp),%edx
    bff3:	89 c1                	mov    %eax,%ecx
    bff5:	d3 ea                	shr    %cl,%edx
    bff7:	8b 45 0c             	mov    0xc(%ebp),%eax
    bffa:	89 10                	mov    %edx,(%eax)
    *b_out = b >> shift ;
    bffc:	8b 45 e8             	mov    -0x18(%ebp),%eax
    bfff:	8b 55 f4             	mov    -0xc(%ebp),%edx
    c002:	89 c1                	mov    %eax,%ecx
    c004:	d3 ea                	shr    %cl,%edx
    c006:	8b 45 10             	mov    0x10(%ebp),%eax
    c009:	89 10                	mov    %edx,(%eax)
    c00b:	e9 ed 00 00 00       	jmp    c0fd <lodepng_convert_rgb+0x29a>
  } else if(mode_out->colortype == LCT_PALETTE) {
    c010:	8b 45 20             	mov    0x20(%ebp),%eax
    c013:	8b 00                	mov    (%eax),%eax
    c015:	83 f8 03             	cmp    $0x3,%eax
    c018:	0f 85 d8 00 00 00    	jne    c0f6 <lodepng_convert_rgb+0x293>
    unsigned i;
    /* a 16-bit color cannot be in the palette */
    if((r >> 8) != (r & 255) || (g >> 8) != (g & 255) || (b >> 8) != (b & 255)) return 82;
    c01e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    c021:	c1 e8 08             	shr    $0x8,%eax
    c024:	89 c2                	mov    %eax,%edx
    c026:	8b 45 fc             	mov    -0x4(%ebp),%eax
    c029:	0f b6 c0             	movzbl %al,%eax
    c02c:	39 c2                	cmp    %eax,%edx
    c02e:	75 24                	jne    c054 <lodepng_convert_rgb+0x1f1>
    c030:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c033:	c1 e8 08             	shr    $0x8,%eax
    c036:	89 c2                	mov    %eax,%edx
    c038:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c03b:	0f b6 c0             	movzbl %al,%eax
    c03e:	39 c2                	cmp    %eax,%edx
    c040:	75 12                	jne    c054 <lodepng_convert_rgb+0x1f1>
    c042:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c045:	c1 e8 08             	shr    $0x8,%eax
    c048:	89 c2                	mov    %eax,%edx
    c04a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c04d:	0f b6 c0             	movzbl %al,%eax
    c050:	39 c2                	cmp    %eax,%edx
    c052:	74 0a                	je     c05e <lodepng_convert_rgb+0x1fb>
    c054:	b8 52 00 00 00       	mov    $0x52,%eax
    c059:	e9 a4 00 00 00       	jmp    c102 <lodepng_convert_rgb+0x29f>
    for(i = 0; i < mode_out->palettesize; i++) {
    c05e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    c065:	eb 79                	jmp    c0e0 <lodepng_convert_rgb+0x27d>
      unsigned j = i * 4;
    c067:	8b 45 f0             	mov    -0x10(%ebp),%eax
    c06a:	c1 e0 02             	shl    $0x2,%eax
    c06d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      if((r >> 8) == mode_out->palette[j + 0] && (g >> 8) == mode_out->palette[j + 1] &&
    c070:	8b 45 fc             	mov    -0x4(%ebp),%eax
    c073:	c1 e8 08             	shr    $0x8,%eax
    c076:	89 c1                	mov    %eax,%ecx
    c078:	8b 45 20             	mov    0x20(%ebp),%eax
    c07b:	8b 50 08             	mov    0x8(%eax),%edx
    c07e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    c081:	01 d0                	add    %edx,%eax
    c083:	0f b6 00             	movzbl (%eax),%eax
    c086:	0f b6 c0             	movzbl %al,%eax
    c089:	39 c1                	cmp    %eax,%ecx
    c08b:	75 4f                	jne    c0dc <lodepng_convert_rgb+0x279>
    c08d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c090:	c1 e8 08             	shr    $0x8,%eax
    c093:	89 c1                	mov    %eax,%ecx
    c095:	8b 45 20             	mov    0x20(%ebp),%eax
    c098:	8b 40 08             	mov    0x8(%eax),%eax
    c09b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    c09e:	83 c2 01             	add    $0x1,%edx
    c0a1:	01 d0                	add    %edx,%eax
    c0a3:	0f b6 00             	movzbl (%eax),%eax
    c0a6:	0f b6 c0             	movzbl %al,%eax
    c0a9:	39 c1                	cmp    %eax,%ecx
    c0ab:	75 2f                	jne    c0dc <lodepng_convert_rgb+0x279>
          (b >> 8) == mode_out->palette[j + 2]) {
    c0ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c0b0:	c1 e8 08             	shr    $0x8,%eax
    c0b3:	89 c1                	mov    %eax,%ecx
    c0b5:	8b 45 20             	mov    0x20(%ebp),%eax
    c0b8:	8b 40 08             	mov    0x8(%eax),%eax
    c0bb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    c0be:	83 c2 02             	add    $0x2,%edx
    c0c1:	01 d0                	add    %edx,%eax
    c0c3:	0f b6 00             	movzbl (%eax),%eax
    c0c6:	0f b6 c0             	movzbl %al,%eax
    unsigned i;
    /* a 16-bit color cannot be in the palette */
    if((r >> 8) != (r & 255) || (g >> 8) != (g & 255) || (b >> 8) != (b & 255)) return 82;
    for(i = 0; i < mode_out->palettesize; i++) {
      unsigned j = i * 4;
      if((r >> 8) == mode_out->palette[j + 0] && (g >> 8) == mode_out->palette[j + 1] &&
    c0c9:	39 c1                	cmp    %eax,%ecx
    c0cb:	75 0f                	jne    c0dc <lodepng_convert_rgb+0x279>
          (b >> 8) == mode_out->palette[j + 2]) {
        *r_out = i;
    c0cd:	8b 45 08             	mov    0x8(%ebp),%eax
    c0d0:	8b 55 f0             	mov    -0x10(%ebp),%edx
    c0d3:	89 10                	mov    %edx,(%eax)
        return 0;
    c0d5:	b8 00 00 00 00       	mov    $0x0,%eax
    c0da:	eb 26                	jmp    c102 <lodepng_convert_rgb+0x29f>
    *b_out = b >> shift ;
  } else if(mode_out->colortype == LCT_PALETTE) {
    unsigned i;
    /* a 16-bit color cannot be in the palette */
    if((r >> 8) != (r & 255) || (g >> 8) != (g & 255) || (b >> 8) != (b & 255)) return 82;
    for(i = 0; i < mode_out->palettesize; i++) {
    c0dc:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    c0e0:	8b 45 20             	mov    0x20(%ebp),%eax
    c0e3:	8b 40 0c             	mov    0xc(%eax),%eax
    c0e6:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    c0e9:	0f 87 78 ff ff ff    	ja     c067 <lodepng_convert_rgb+0x204>
          (b >> 8) == mode_out->palette[j + 2]) {
        *r_out = i;
        return 0;
      }
    }
    return 82;
    c0ef:	b8 52 00 00 00       	mov    $0x52,%eax
    c0f4:	eb 0c                	jmp    c102 <lodepng_convert_rgb+0x29f>
  } else {
    return 31;
    c0f6:	b8 1f 00 00 00       	mov    $0x1f,%eax
    c0fb:	eb 05                	jmp    c102 <lodepng_convert_rgb+0x29f>
  }

  return 0;
    c0fd:	b8 00 00 00 00       	mov    $0x0,%eax
}
    c102:	c9                   	leave  
    c103:	c3                   	ret    

0000c104 <lodepng_color_stats_init>:

#ifdef LODEPNG_COMPILE_ENCODER

void lodepng_color_stats_init(LodePNGColorStats* stats) {
    c104:	55                   	push   %ebp
    c105:	89 e5                	mov    %esp,%ebp
  /*stats*/
  stats->colored = 0;
    c107:	8b 45 08             	mov    0x8(%ebp),%eax
    c10a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  stats->key = 0;
    c110:	8b 45 08             	mov    0x8(%ebp),%eax
    c113:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  stats->key_r = stats->key_g = stats->key_b = 0;
    c11a:	8b 45 08             	mov    0x8(%ebp),%eax
    c11d:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
    c123:	8b 45 08             	mov    0x8(%ebp),%eax
    c126:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    c12a:	8b 45 08             	mov    0x8(%ebp),%eax
    c12d:	66 89 50 0a          	mov    %dx,0xa(%eax)
    c131:	8b 45 08             	mov    0x8(%ebp),%eax
    c134:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    c138:	8b 45 08             	mov    0x8(%ebp),%eax
    c13b:	66 89 50 08          	mov    %dx,0x8(%eax)
  stats->alpha = 0;
    c13f:	8b 45 08             	mov    0x8(%ebp),%eax
    c142:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  stats->numcolors = 0;
    c149:	8b 45 08             	mov    0x8(%ebp),%eax
    c14c:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  stats->bits = 1;
    c153:	8b 45 08             	mov    0x8(%ebp),%eax
    c156:	c7 80 18 04 00 00 01 	movl   $0x1,0x418(%eax)
    c15d:	00 00 00 
  stats->numpixels = 0;
    c160:	8b 45 08             	mov    0x8(%ebp),%eax
    c163:	c7 80 1c 04 00 00 00 	movl   $0x0,0x41c(%eax)
    c16a:	00 00 00 
  /*settings*/
  stats->allow_palette = 1;
    c16d:	8b 45 08             	mov    0x8(%ebp),%eax
    c170:	c7 80 20 04 00 00 01 	movl   $0x1,0x420(%eax)
    c177:	00 00 00 
  stats->allow_greyscale = 1;
    c17a:	8b 45 08             	mov    0x8(%ebp),%eax
    c17d:	c7 80 24 04 00 00 01 	movl   $0x1,0x424(%eax)
    c184:	00 00 00 
}
    c187:	90                   	nop
    c188:	5d                   	pop    %ebp
    c189:	c3                   	ret    

0000c18a <getValueRequiredBits>:
  std::cout << "numcolors: " << (int)p->numcolors << ", ";
  std::cout << "bits: " << (int)p->bits << std::endl;
}*/

/*Returns how many bits needed to represent given value (max 8 bit)*/
static unsigned getValueRequiredBits(unsigned char value) {
    c18a:	55                   	push   %ebp
    c18b:	89 e5                	mov    %esp,%ebp
    c18d:	53                   	push   %ebx
    c18e:	83 ec 04             	sub    $0x4,%esp
    c191:	8b 45 08             	mov    0x8(%ebp),%eax
    c194:	88 45 f8             	mov    %al,-0x8(%ebp)
  if(value == 0 || value == 255) return 1;
    c197:	80 7d f8 00          	cmpb   $0x0,-0x8(%ebp)
    c19b:	74 06                	je     c1a3 <getValueRequiredBits+0x19>
    c19d:	80 7d f8 ff          	cmpb   $0xff,-0x8(%ebp)
    c1a1:	75 07                	jne    c1aa <getValueRequiredBits+0x20>
    c1a3:	b8 01 00 00 00       	mov    $0x1,%eax
    c1a8:	eb 6b                	jmp    c215 <getValueRequiredBits+0x8b>
  /*The scaling of 2-bit and 4-bit values uses multiples of 85 and 17*/
  if(value % 17 == 0) return value % 85 == 0 ? 2 : 4;
    c1aa:	0f b6 4d f8          	movzbl -0x8(%ebp),%ecx
    c1ae:	0f b6 d9             	movzbl %cl,%ebx
    c1b1:	89 da                	mov    %ebx,%edx
    c1b3:	89 d0                	mov    %edx,%eax
    c1b5:	c1 e0 04             	shl    $0x4,%eax
    c1b8:	89 c2                	mov    %eax,%edx
    c1ba:	89 d0                	mov    %edx,%eax
    c1bc:	c1 e0 04             	shl    $0x4,%eax
    c1bf:	29 d0                	sub    %edx,%eax
    c1c1:	01 d8                	add    %ebx,%eax
    c1c3:	66 c1 e8 08          	shr    $0x8,%ax
    c1c7:	c0 e8 04             	shr    $0x4,%al
    c1ca:	89 c2                	mov    %eax,%edx
    c1cc:	c1 e2 04             	shl    $0x4,%edx
    c1cf:	01 c2                	add    %eax,%edx
    c1d1:	89 c8                	mov    %ecx,%eax
    c1d3:	29 d0                	sub    %edx,%eax
    c1d5:	84 c0                	test   %al,%al
    c1d7:	75 37                	jne    c210 <getValueRequiredBits+0x86>
    c1d9:	0f b6 4d f8          	movzbl -0x8(%ebp),%ecx
    c1dd:	0f b6 d1             	movzbl %cl,%edx
    c1e0:	89 d0                	mov    %edx,%eax
    c1e2:	01 c0                	add    %eax,%eax
    c1e4:	01 d0                	add    %edx,%eax
    c1e6:	c1 e0 06             	shl    $0x6,%eax
    c1e9:	01 d0                	add    %edx,%eax
    c1eb:	66 c1 e8 08          	shr    $0x8,%ax
    c1ef:	c0 e8 06             	shr    $0x6,%al
    c1f2:	ba 55 00 00 00       	mov    $0x55,%edx
    c1f7:	0f af c2             	imul   %edx,%eax
    c1fa:	29 c1                	sub    %eax,%ecx
    c1fc:	89 c8                	mov    %ecx,%eax
    c1fe:	84 c0                	test   %al,%al
    c200:	75 07                	jne    c209 <getValueRequiredBits+0x7f>
    c202:	b8 02 00 00 00       	mov    $0x2,%eax
    c207:	eb 0c                	jmp    c215 <getValueRequiredBits+0x8b>
    c209:	b8 04 00 00 00       	mov    $0x4,%eax
    c20e:	eb 05                	jmp    c215 <getValueRequiredBits+0x8b>
  return 8;
    c210:	b8 08 00 00 00       	mov    $0x8,%eax
}
    c215:	83 c4 04             	add    $0x4,%esp
    c218:	5b                   	pop    %ebx
    c219:	5d                   	pop    %ebp
    c21a:	c3                   	ret    

0000c21b <lodepng_compute_color_stats>:

/*stats must already have been inited. */
unsigned lodepng_compute_color_stats(LodePNGColorStats* stats,
                                     const unsigned char* in, unsigned w, unsigned h,
                                     const LodePNGColorMode* mode_in) {
    c21b:	55                   	push   %ebp
    c21c:	89 e5                	mov    %esp,%ebp
    c21e:	56                   	push   %esi
    c21f:	53                   	push   %ebx
    c220:	81 ec a0 00 00 00    	sub    $0xa0,%esp
  size_t i;
  ColorTree tree;
  size_t numpixels = (size_t)w * (size_t)h;
    c226:	8b 55 10             	mov    0x10(%ebp),%edx
    c229:	8b 45 14             	mov    0x14(%ebp),%eax
    c22c:	0f af c2             	imul   %edx,%eax
    c22f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  unsigned error = 0;
    c232:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  /* mark things as done already if it would be impossible to have a more expensive case */
  unsigned colored_done = lodepng_is_greyscale_type(mode_in) ? 1 : 0;
    c239:	ff 75 18             	pushl  0x18(%ebp)
    c23c:	e8 0b cd ff ff       	call   8f4c <lodepng_is_greyscale_type>
    c241:	83 c4 04             	add    $0x4,%esp
    c244:	85 c0                	test   %eax,%eax
    c246:	0f 95 c0             	setne  %al
    c249:	0f b6 c0             	movzbl %al,%eax
    c24c:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned alpha_done = lodepng_can_have_alpha(mode_in) ? 0 : 1;
    c24f:	ff 75 18             	pushl  0x18(%ebp)
    c252:	e8 85 cd ff ff       	call   8fdc <lodepng_can_have_alpha>
    c257:	83 c4 04             	add    $0x4,%esp
    c25a:	85 c0                	test   %eax,%eax
    c25c:	0f 94 c0             	sete   %al
    c25f:	0f b6 c0             	movzbl %al,%eax
    c262:	89 45 e8             	mov    %eax,-0x18(%ebp)
  unsigned numcolors_done = 0;
    c265:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  unsigned bpp = lodepng_get_bpp(mode_in);
    c26c:	ff 75 18             	pushl  0x18(%ebp)
    c26f:	e8 ab cc ff ff       	call   8f1f <lodepng_get_bpp>
    c274:	83 c4 04             	add    $0x4,%esp
    c277:	89 45 d0             	mov    %eax,-0x30(%ebp)
  unsigned bits_done = (stats->bits == 1 && bpp == 1) ? 1 : 0;
    c27a:	8b 45 08             	mov    0x8(%ebp),%eax
    c27d:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c283:	83 f8 01             	cmp    $0x1,%eax
    c286:	75 0d                	jne    c295 <lodepng_compute_color_stats+0x7a>
    c288:	83 7d d0 01          	cmpl   $0x1,-0x30(%ebp)
    c28c:	75 07                	jne    c295 <lodepng_compute_color_stats+0x7a>
    c28e:	b8 01 00 00 00       	mov    $0x1,%eax
    c293:	eb 05                	jmp    c29a <lodepng_compute_color_stats+0x7f>
    c295:	b8 00 00 00 00       	mov    $0x0,%eax
    c29a:	89 45 e0             	mov    %eax,-0x20(%ebp)
  unsigned sixteen = 0; /* whether the input image is 16 bit */
    c29d:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  unsigned maxnumcolors = 257;
    c2a4:	c7 45 d8 01 01 00 00 	movl   $0x101,-0x28(%ebp)
  if(bpp <= 8) maxnumcolors = LODEPNG_MIN(257, stats->numcolors + (1u << bpp));
    c2ab:	83 7d d0 08          	cmpl   $0x8,-0x30(%ebp)
    c2af:	77 26                	ja     c2d7 <lodepng_compute_color_stats+0xbc>
    c2b1:	8b 45 08             	mov    0x8(%ebp),%eax
    c2b4:	8b 50 14             	mov    0x14(%eax),%edx
    c2b7:	8b 45 d0             	mov    -0x30(%ebp),%eax
    c2ba:	bb 01 00 00 00       	mov    $0x1,%ebx
    c2bf:	89 c1                	mov    %eax,%ecx
    c2c1:	d3 e3                	shl    %cl,%ebx
    c2c3:	89 d8                	mov    %ebx,%eax
    c2c5:	01 d0                	add    %edx,%eax
    c2c7:	ba 01 01 00 00       	mov    $0x101,%edx
    c2cc:	3d 01 01 00 00       	cmp    $0x101,%eax
    c2d1:	0f 47 c2             	cmova  %edx,%eax
    c2d4:	89 45 d8             	mov    %eax,-0x28(%ebp)

  stats->numpixels += numpixels;
    c2d7:	8b 45 08             	mov    0x8(%ebp),%eax
    c2da:	8b 90 1c 04 00 00    	mov    0x41c(%eax),%edx
    c2e0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    c2e3:	01 c2                	add    %eax,%edx
    c2e5:	8b 45 08             	mov    0x8(%ebp),%eax
    c2e8:	89 90 1c 04 00 00    	mov    %edx,0x41c(%eax)

  /*if palette not allowed, no need to compute numcolors*/
  if(!stats->allow_palette) numcolors_done = 1;
    c2ee:	8b 45 08             	mov    0x8(%ebp),%eax
    c2f1:	8b 80 20 04 00 00    	mov    0x420(%eax),%eax
    c2f7:	85 c0                	test   %eax,%eax
    c2f9:	75 07                	jne    c302 <lodepng_compute_color_stats+0xe7>
    c2fb:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)

  color_tree_init(&tree);
    c302:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    c308:	50                   	push   %eax
    c309:	e8 81 da ff ff       	call   9d8f <color_tree_init>
    c30e:	83 c4 04             	add    $0x4,%esp

  /*If the stats was already filled in from previous data, fill its palette in tree
  and mark things as done already if we know they are the most expensive case already*/
  if(stats->alpha) alpha_done = 1;
    c311:	8b 45 08             	mov    0x8(%ebp),%eax
    c314:	8b 40 10             	mov    0x10(%eax),%eax
    c317:	85 c0                	test   %eax,%eax
    c319:	74 07                	je     c322 <lodepng_compute_color_stats+0x107>
    c31b:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
  if(stats->colored) colored_done = 1;
    c322:	8b 45 08             	mov    0x8(%ebp),%eax
    c325:	8b 00                	mov    (%eax),%eax
    c327:	85 c0                	test   %eax,%eax
    c329:	74 07                	je     c332 <lodepng_compute_color_stats+0x117>
    c32b:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
  if(stats->bits == 16) numcolors_done = 1;
    c332:	8b 45 08             	mov    0x8(%ebp),%eax
    c335:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c33b:	83 f8 10             	cmp    $0x10,%eax
    c33e:	75 07                	jne    c347 <lodepng_compute_color_stats+0x12c>
    c340:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
  if(stats->bits >= bpp) bits_done = 1;
    c347:	8b 45 08             	mov    0x8(%ebp),%eax
    c34a:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c350:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    c353:	72 07                	jb     c35c <lodepng_compute_color_stats+0x141>
    c355:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
  if(stats->numcolors >= maxnumcolors) numcolors_done = 1;
    c35c:	8b 45 08             	mov    0x8(%ebp),%eax
    c35f:	8b 40 14             	mov    0x14(%eax),%eax
    c362:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    c365:	72 07                	jb     c36e <lodepng_compute_color_stats+0x153>
    c367:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)

  if(!numcolors_done) {
    c36e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    c372:	0f 85 82 00 00 00    	jne    c3fa <lodepng_compute_color_stats+0x1df>
    for(i = 0; i < stats->numcolors; i++) {
    c378:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c37f:	eb 6c                	jmp    c3ed <lodepng_compute_color_stats+0x1d2>
      const unsigned char* color = &stats->palette[i * 4];
    c381:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c384:	c1 e0 02             	shl    $0x2,%eax
    c387:	8d 50 10             	lea    0x10(%eax),%edx
    c38a:	8b 45 08             	mov    0x8(%ebp),%eax
    c38d:	01 d0                	add    %edx,%eax
    c38f:	83 c0 08             	add    $0x8,%eax
    c392:	89 45 cc             	mov    %eax,-0x34(%ebp)
      error = color_tree_add(&tree, color[0], color[1], color[2], color[3], i);
    c395:	8b 75 f4             	mov    -0xc(%ebp),%esi
    c398:	8b 45 cc             	mov    -0x34(%ebp),%eax
    c39b:	83 c0 03             	add    $0x3,%eax
    c39e:	0f b6 00             	movzbl (%eax),%eax
    c3a1:	0f b6 d8             	movzbl %al,%ebx
    c3a4:	8b 45 cc             	mov    -0x34(%ebp),%eax
    c3a7:	83 c0 02             	add    $0x2,%eax
    c3aa:	0f b6 00             	movzbl (%eax),%eax
    c3ad:	0f b6 c8             	movzbl %al,%ecx
    c3b0:	8b 45 cc             	mov    -0x34(%ebp),%eax
    c3b3:	83 c0 01             	add    $0x1,%eax
    c3b6:	0f b6 00             	movzbl (%eax),%eax
    c3b9:	0f b6 d0             	movzbl %al,%edx
    c3bc:	8b 45 cc             	mov    -0x34(%ebp),%eax
    c3bf:	0f b6 00             	movzbl (%eax),%eax
    c3c2:	0f b6 c0             	movzbl %al,%eax
    c3c5:	83 ec 08             	sub    $0x8,%esp
    c3c8:	56                   	push   %esi
    c3c9:	53                   	push   %ebx
    c3ca:	51                   	push   %ecx
    c3cb:	52                   	push   %edx
    c3cc:	50                   	push   %eax
    c3cd:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    c3d3:	50                   	push   %eax
    c3d4:	e8 39 db ff ff       	call   9f12 <color_tree_add>
    c3d9:	83 c4 20             	add    $0x20,%esp
    c3dc:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if(error) goto cleanup;
    c3df:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    c3e3:	0f 85 22 09 00 00    	jne    cd0b <lodepng_compute_color_stats+0xaf0>
  if(stats->bits == 16) numcolors_done = 1;
  if(stats->bits >= bpp) bits_done = 1;
  if(stats->numcolors >= maxnumcolors) numcolors_done = 1;

  if(!numcolors_done) {
    for(i = 0; i < stats->numcolors; i++) {
    c3e9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c3ed:	8b 45 08             	mov    0x8(%ebp),%eax
    c3f0:	8b 50 14             	mov    0x14(%eax),%edx
    c3f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c3f6:	39 c2                	cmp    %eax,%edx
    c3f8:	77 87                	ja     c381 <lodepng_compute_color_stats+0x166>
      if(error) goto cleanup;
    }
  }

  /*Check if the 16-bit input is truly 16-bit*/
  if(mode_in->bitdepth == 16 && !sixteen) {
    c3fa:	8b 45 18             	mov    0x18(%ebp),%eax
    c3fd:	8b 40 04             	mov    0x4(%eax),%eax
    c400:	83 f8 10             	cmp    $0x10,%eax
    c403:	0f 85 1e 01 00 00    	jne    c527 <lodepng_compute_color_stats+0x30c>
    c409:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    c40d:	0f 85 14 01 00 00    	jne    c527 <lodepng_compute_color_stats+0x30c>
    unsigned short r = 0, g = 0, b = 0, a = 0;
    c413:	66 c7 85 72 ff ff ff 	movw   $0x0,-0x8e(%ebp)
    c41a:	00 00 
    c41c:	66 c7 85 70 ff ff ff 	movw   $0x0,-0x90(%ebp)
    c423:	00 00 
    c425:	66 c7 85 6e ff ff ff 	movw   $0x0,-0x92(%ebp)
    c42c:	00 00 
    c42e:	66 c7 85 6c ff ff ff 	movw   $0x0,-0x94(%ebp)
    c435:	00 00 
    for(i = 0; i != numpixels; ++i) {
    c437:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c43e:	e9 d8 00 00 00       	jmp    c51b <lodepng_compute_color_stats+0x300>
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    c443:	83 ec 04             	sub    $0x4,%esp
    c446:	ff 75 18             	pushl  0x18(%ebp)
    c449:	ff 75 f4             	pushl  -0xc(%ebp)
    c44c:	ff 75 0c             	pushl  0xc(%ebp)
    c44f:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
    c455:	50                   	push   %eax
    c456:	8d 85 6e ff ff ff    	lea    -0x92(%ebp),%eax
    c45c:	50                   	push   %eax
    c45d:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
    c463:	50                   	push   %eax
    c464:	8d 85 72 ff ff ff    	lea    -0x8e(%ebp),%eax
    c46a:	50                   	push   %eax
    c46b:	e8 a8 f2 ff ff       	call   b718 <getPixelColorRGBA16>
    c470:	83 c4 20             	add    $0x20,%esp
      if((r & 255) != ((r >> 8) & 255) || (g & 255) != ((g >> 8) & 255) ||
    c473:	0f b7 85 72 ff ff ff 	movzwl -0x8e(%ebp),%eax
    c47a:	66 c1 e8 08          	shr    $0x8,%ax
    c47e:	89 c2                	mov    %eax,%edx
    c480:	0f b7 85 72 ff ff ff 	movzwl -0x8e(%ebp),%eax
    c487:	31 d0                	xor    %edx,%eax
    c489:	0f b7 c0             	movzwl %ax,%eax
    c48c:	0f b6 c0             	movzbl %al,%eax
    c48f:	85 c0                	test   %eax,%eax
    c491:	75 60                	jne    c4f3 <lodepng_compute_color_stats+0x2d8>
    c493:	0f b7 85 70 ff ff ff 	movzwl -0x90(%ebp),%eax
    c49a:	66 c1 e8 08          	shr    $0x8,%ax
    c49e:	89 c2                	mov    %eax,%edx
    c4a0:	0f b7 85 70 ff ff ff 	movzwl -0x90(%ebp),%eax
    c4a7:	31 d0                	xor    %edx,%eax
    c4a9:	0f b7 c0             	movzwl %ax,%eax
    c4ac:	0f b6 c0             	movzbl %al,%eax
    c4af:	85 c0                	test   %eax,%eax
    c4b1:	75 40                	jne    c4f3 <lodepng_compute_color_stats+0x2d8>
         (b & 255) != ((b >> 8) & 255) || (a & 255) != ((a >> 8) & 255)) /*first and second byte differ*/ {
    c4b3:	0f b7 85 6e ff ff ff 	movzwl -0x92(%ebp),%eax
    c4ba:	66 c1 e8 08          	shr    $0x8,%ax
    c4be:	89 c2                	mov    %eax,%edx
    c4c0:	0f b7 85 6e ff ff ff 	movzwl -0x92(%ebp),%eax
    c4c7:	31 d0                	xor    %edx,%eax
    c4c9:	0f b7 c0             	movzwl %ax,%eax
    c4cc:	0f b6 c0             	movzbl %al,%eax
  /*Check if the 16-bit input is truly 16-bit*/
  if(mode_in->bitdepth == 16 && !sixteen) {
    unsigned short r = 0, g = 0, b = 0, a = 0;
    for(i = 0; i != numpixels; ++i) {
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
      if((r & 255) != ((r >> 8) & 255) || (g & 255) != ((g >> 8) & 255) ||
    c4cf:	85 c0                	test   %eax,%eax
    c4d1:	75 20                	jne    c4f3 <lodepng_compute_color_stats+0x2d8>
         (b & 255) != ((b >> 8) & 255) || (a & 255) != ((a >> 8) & 255)) /*first and second byte differ*/ {
    c4d3:	0f b7 85 6c ff ff ff 	movzwl -0x94(%ebp),%eax
    c4da:	66 c1 e8 08          	shr    $0x8,%ax
    c4de:	89 c2                	mov    %eax,%edx
    c4e0:	0f b7 85 6c ff ff ff 	movzwl -0x94(%ebp),%eax
    c4e7:	31 d0                	xor    %edx,%eax
    c4e9:	0f b7 c0             	movzwl %ax,%eax
    c4ec:	0f b6 c0             	movzbl %al,%eax
    c4ef:	85 c0                	test   %eax,%eax
    c4f1:	74 24                	je     c517 <lodepng_compute_color_stats+0x2fc>
        stats->bits = 16;
    c4f3:	8b 45 08             	mov    0x8(%ebp),%eax
    c4f6:	c7 80 18 04 00 00 10 	movl   $0x10,0x418(%eax)
    c4fd:	00 00 00 
        sixteen = 1;
    c500:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
        bits_done = 1;
    c507:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
        numcolors_done = 1; /*counting colors no longer useful, palette doesn't support 16-bit*/
    c50e:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
        break;
    c515:	eb 10                	jmp    c527 <lodepng_compute_color_stats+0x30c>
  }

  /*Check if the 16-bit input is truly 16-bit*/
  if(mode_in->bitdepth == 16 && !sixteen) {
    unsigned short r = 0, g = 0, b = 0, a = 0;
    for(i = 0; i != numpixels; ++i) {
    c517:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c51b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c51e:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    c521:	0f 85 1c ff ff ff    	jne    c443 <lodepng_compute_color_stats+0x228>
        break;
      }
    }
  }

  if(sixteen) {
    c527:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    c52b:	0f 84 bd 02 00 00    	je     c7ee <lodepng_compute_color_stats+0x5d3>
    unsigned short r = 0, g = 0, b = 0, a = 0;
    c531:	66 c7 85 6a ff ff ff 	movw   $0x0,-0x96(%ebp)
    c538:	00 00 
    c53a:	66 c7 85 68 ff ff ff 	movw   $0x0,-0x98(%ebp)
    c541:	00 00 
    c543:	66 c7 85 66 ff ff ff 	movw   $0x0,-0x9a(%ebp)
    c54a:	00 00 
    c54c:	66 c7 85 64 ff ff ff 	movw   $0x0,-0x9c(%ebp)
    c553:	00 00 

    for(i = 0; i != numpixels; ++i) {
    c555:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c55c:	e9 b1 01 00 00       	jmp    c712 <lodepng_compute_color_stats+0x4f7>
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    c561:	83 ec 04             	sub    $0x4,%esp
    c564:	ff 75 18             	pushl  0x18(%ebp)
    c567:	ff 75 f4             	pushl  -0xc(%ebp)
    c56a:	ff 75 0c             	pushl  0xc(%ebp)
    c56d:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
    c573:	50                   	push   %eax
    c574:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
    c57a:	50                   	push   %eax
    c57b:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
    c581:	50                   	push   %eax
    c582:	8d 85 6a ff ff ff    	lea    -0x96(%ebp),%eax
    c588:	50                   	push   %eax
    c589:	e8 8a f1 ff ff       	call   b718 <getPixelColorRGBA16>
    c58e:	83 c4 20             	add    $0x20,%esp

      if(!colored_done && (r != g || r != b)) {
    c591:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    c595:	75 36                	jne    c5cd <lodepng_compute_color_stats+0x3b2>
    c597:	0f b7 95 6a ff ff ff 	movzwl -0x96(%ebp),%edx
    c59e:	0f b7 85 68 ff ff ff 	movzwl -0x98(%ebp),%eax
    c5a5:	66 39 c2             	cmp    %ax,%dx
    c5a8:	75 13                	jne    c5bd <lodepng_compute_color_stats+0x3a2>
    c5aa:	0f b7 95 6a ff ff ff 	movzwl -0x96(%ebp),%edx
    c5b1:	0f b7 85 66 ff ff ff 	movzwl -0x9a(%ebp),%eax
    c5b8:	66 39 c2             	cmp    %ax,%dx
    c5bb:	74 10                	je     c5cd <lodepng_compute_color_stats+0x3b2>
        stats->colored = 1;
    c5bd:	8b 45 08             	mov    0x8(%ebp),%eax
    c5c0:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        colored_done = 1;
    c5c6:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
      }

      if(!alpha_done) {
    c5cd:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    c5d1:	0f 85 1f 01 00 00    	jne    c6f6 <lodepng_compute_color_stats+0x4db>
        unsigned matchkey = (r == stats->key_r && g == stats->key_g && b == stats->key_b);
    c5d7:	8b 45 08             	mov    0x8(%ebp),%eax
    c5da:	0f b7 50 08          	movzwl 0x8(%eax),%edx
    c5de:	0f b7 85 6a ff ff ff 	movzwl -0x96(%ebp),%eax
    c5e5:	66 39 c2             	cmp    %ax,%dx
    c5e8:	75 2d                	jne    c617 <lodepng_compute_color_stats+0x3fc>
    c5ea:	8b 45 08             	mov    0x8(%ebp),%eax
    c5ed:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    c5f1:	0f b7 85 68 ff ff ff 	movzwl -0x98(%ebp),%eax
    c5f8:	66 39 c2             	cmp    %ax,%dx
    c5fb:	75 1a                	jne    c617 <lodepng_compute_color_stats+0x3fc>
    c5fd:	8b 45 08             	mov    0x8(%ebp),%eax
    c600:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    c604:	0f b7 85 66 ff ff ff 	movzwl -0x9a(%ebp),%eax
    c60b:	66 39 c2             	cmp    %ax,%dx
    c60e:	75 07                	jne    c617 <lodepng_compute_color_stats+0x3fc>
    c610:	b8 01 00 00 00       	mov    $0x1,%eax
    c615:	eb 05                	jmp    c61c <lodepng_compute_color_stats+0x401>
    c617:	b8 00 00 00 00       	mov    $0x0,%eax
    c61c:	89 45 c8             	mov    %eax,-0x38(%ebp)
        if(a != 65535 && (a != 0 || (stats->key && !matchkey))) {
    c61f:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    c626:	66 83 f8 ff          	cmp    $0xffff,%ax
    c62a:	74 3c                	je     c668 <lodepng_compute_color_stats+0x44d>
    c62c:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    c633:	66 85 c0             	test   %ax,%ax
    c636:	75 10                	jne    c648 <lodepng_compute_color_stats+0x42d>
    c638:	8b 45 08             	mov    0x8(%ebp),%eax
    c63b:	8b 40 04             	mov    0x4(%eax),%eax
    c63e:	85 c0                	test   %eax,%eax
    c640:	74 26                	je     c668 <lodepng_compute_color_stats+0x44d>
    c642:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
    c646:	75 20                	jne    c668 <lodepng_compute_color_stats+0x44d>
          stats->alpha = 1;
    c648:	8b 45 08             	mov    0x8(%ebp),%eax
    c64b:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    c652:	8b 45 08             	mov    0x8(%ebp),%eax
    c655:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    c65c:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
    c663:	e9 8e 00 00 00       	jmp    c6f6 <lodepng_compute_color_stats+0x4db>
        } else if(a == 0 && !stats->alpha && !stats->key) {
    c668:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    c66f:	66 85 c0             	test   %ax,%ax
    c672:	75 4a                	jne    c6be <lodepng_compute_color_stats+0x4a3>
    c674:	8b 45 08             	mov    0x8(%ebp),%eax
    c677:	8b 40 10             	mov    0x10(%eax),%eax
    c67a:	85 c0                	test   %eax,%eax
    c67c:	75 40                	jne    c6be <lodepng_compute_color_stats+0x4a3>
    c67e:	8b 45 08             	mov    0x8(%ebp),%eax
    c681:	8b 40 04             	mov    0x4(%eax),%eax
    c684:	85 c0                	test   %eax,%eax
    c686:	75 36                	jne    c6be <lodepng_compute_color_stats+0x4a3>
          stats->key = 1;
    c688:	8b 45 08             	mov    0x8(%ebp),%eax
    c68b:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
          stats->key_r = r;
    c692:	0f b7 95 6a ff ff ff 	movzwl -0x96(%ebp),%edx
    c699:	8b 45 08             	mov    0x8(%ebp),%eax
    c69c:	66 89 50 08          	mov    %dx,0x8(%eax)
          stats->key_g = g;
    c6a0:	0f b7 95 68 ff ff ff 	movzwl -0x98(%ebp),%edx
    c6a7:	8b 45 08             	mov    0x8(%ebp),%eax
    c6aa:	66 89 50 0a          	mov    %dx,0xa(%eax)
          stats->key_b = b;
    c6ae:	0f b7 95 66 ff ff ff 	movzwl -0x9a(%ebp),%edx
    c6b5:	8b 45 08             	mov    0x8(%ebp),%eax
    c6b8:	66 89 50 0c          	mov    %dx,0xc(%eax)
    c6bc:	eb 38                	jmp    c6f6 <lodepng_compute_color_stats+0x4db>
        } else if(a == 65535 && stats->key && matchkey) {
    c6be:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    c6c5:	66 83 f8 ff          	cmp    $0xffff,%ax
    c6c9:	75 2b                	jne    c6f6 <lodepng_compute_color_stats+0x4db>
    c6cb:	8b 45 08             	mov    0x8(%ebp),%eax
    c6ce:	8b 40 04             	mov    0x4(%eax),%eax
    c6d1:	85 c0                	test   %eax,%eax
    c6d3:	74 21                	je     c6f6 <lodepng_compute_color_stats+0x4db>
    c6d5:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
    c6d9:	74 1b                	je     c6f6 <lodepng_compute_color_stats+0x4db>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    c6db:	8b 45 08             	mov    0x8(%ebp),%eax
    c6de:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    c6e5:	8b 45 08             	mov    0x8(%ebp),%eax
    c6e8:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    c6ef:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
        }
      }
      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    c6f6:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    c6fa:	74 12                	je     c70e <lodepng_compute_color_stats+0x4f3>
    c6fc:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    c700:	74 0c                	je     c70e <lodepng_compute_color_stats+0x4f3>
    c702:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    c706:	74 06                	je     c70e <lodepng_compute_color_stats+0x4f3>
    c708:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    c70c:	75 12                	jne    c720 <lodepng_compute_color_stats+0x505>
  }

  if(sixteen) {
    unsigned short r = 0, g = 0, b = 0, a = 0;

    for(i = 0; i != numpixels; ++i) {
    c70e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c712:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c715:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    c718:	0f 85 43 fe ff ff    	jne    c561 <lodepng_compute_color_stats+0x346>
    c71e:	eb 01                	jmp    c721 <lodepng_compute_color_stats+0x506>
          stats->alpha = 1;
          stats->key = 0;
          alpha_done = 1;
        }
      }
      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    c720:	90                   	nop
    }

    if(stats->key && !stats->alpha) {
    c721:	8b 45 08             	mov    0x8(%ebp),%eax
    c724:	8b 40 04             	mov    0x4(%eax),%eax
    c727:	85 c0                	test   %eax,%eax
    c729:	0f 84 e0 05 00 00    	je     cd0f <lodepng_compute_color_stats+0xaf4>
    c72f:	8b 45 08             	mov    0x8(%ebp),%eax
    c732:	8b 40 10             	mov    0x10(%eax),%eax
    c735:	85 c0                	test   %eax,%eax
    c737:	0f 85 d2 05 00 00    	jne    cd0f <lodepng_compute_color_stats+0xaf4>
      for(i = 0; i != numpixels; ++i) {
    c73d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c744:	e9 94 00 00 00       	jmp    c7dd <lodepng_compute_color_stats+0x5c2>
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    c749:	83 ec 04             	sub    $0x4,%esp
    c74c:	ff 75 18             	pushl  0x18(%ebp)
    c74f:	ff 75 f4             	pushl  -0xc(%ebp)
    c752:	ff 75 0c             	pushl  0xc(%ebp)
    c755:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
    c75b:	50                   	push   %eax
    c75c:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
    c762:	50                   	push   %eax
    c763:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
    c769:	50                   	push   %eax
    c76a:	8d 85 6a ff ff ff    	lea    -0x96(%ebp),%eax
    c770:	50                   	push   %eax
    c771:	e8 a2 ef ff ff       	call   b718 <getPixelColorRGBA16>
    c776:	83 c4 20             	add    $0x20,%esp
        if(a != 0 && r == stats->key_r && g == stats->key_g && b == stats->key_b) {
    c779:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    c780:	66 85 c0             	test   %ax,%ax
    c783:	74 54                	je     c7d9 <lodepng_compute_color_stats+0x5be>
    c785:	8b 45 08             	mov    0x8(%ebp),%eax
    c788:	0f b7 50 08          	movzwl 0x8(%eax),%edx
    c78c:	0f b7 85 6a ff ff ff 	movzwl -0x96(%ebp),%eax
    c793:	66 39 c2             	cmp    %ax,%dx
    c796:	75 41                	jne    c7d9 <lodepng_compute_color_stats+0x5be>
    c798:	8b 45 08             	mov    0x8(%ebp),%eax
    c79b:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    c79f:	0f b7 85 68 ff ff ff 	movzwl -0x98(%ebp),%eax
    c7a6:	66 39 c2             	cmp    %ax,%dx
    c7a9:	75 2e                	jne    c7d9 <lodepng_compute_color_stats+0x5be>
    c7ab:	8b 45 08             	mov    0x8(%ebp),%eax
    c7ae:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    c7b2:	0f b7 85 66 ff ff ff 	movzwl -0x9a(%ebp),%eax
    c7b9:	66 39 c2             	cmp    %ax,%dx
    c7bc:	75 1b                	jne    c7d9 <lodepng_compute_color_stats+0x5be>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    c7be:	8b 45 08             	mov    0x8(%ebp),%eax
    c7c1:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    c7c8:	8b 45 08             	mov    0x8(%ebp),%eax
    c7cb:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    c7d2:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
      }
      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    }

    if(stats->key && !stats->alpha) {
      for(i = 0; i != numpixels; ++i) {
    c7d9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c7dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c7e0:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    c7e3:	0f 85 60 ff ff ff    	jne    c749 <lodepng_compute_color_stats+0x52e>
    c7e9:	e9 21 05 00 00       	jmp    cd0f <lodepng_compute_color_stats+0xaf4>
          alpha_done = 1;
        }
      }
    }
  } else /* < 16-bit */ {
    unsigned char r = 0, g = 0, b = 0, a = 0;
    c7ee:	c6 85 63 ff ff ff 00 	movb   $0x0,-0x9d(%ebp)
    c7f5:	c6 85 62 ff ff ff 00 	movb   $0x0,-0x9e(%ebp)
    c7fc:	c6 85 61 ff ff ff 00 	movb   $0x0,-0x9f(%ebp)
    c803:	c6 85 60 ff ff ff 00 	movb   $0x0,-0xa0(%ebp)
    for(i = 0; i != numpixels; ++i) {
    c80a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c811:	e9 ab 03 00 00       	jmp    cbc1 <lodepng_compute_color_stats+0x9a6>
      getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
    c816:	83 ec 04             	sub    $0x4,%esp
    c819:	ff 75 18             	pushl  0x18(%ebp)
    c81c:	ff 75 f4             	pushl  -0xc(%ebp)
    c81f:	ff 75 0c             	pushl  0xc(%ebp)
    c822:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    c828:	50                   	push   %eax
    c829:	8d 85 61 ff ff ff    	lea    -0x9f(%ebp),%eax
    c82f:	50                   	push   %eax
    c830:	8d 85 62 ff ff ff    	lea    -0x9e(%ebp),%eax
    c836:	50                   	push   %eax
    c837:	8d 85 63 ff ff ff    	lea    -0x9d(%ebp),%eax
    c83d:	50                   	push   %eax
    c83e:	e8 1e de ff ff       	call   a661 <getPixelColorRGBA8>
    c843:	83 c4 20             	add    $0x20,%esp

      if(!bits_done && stats->bits < 8) {
    c846:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    c84a:	75 41                	jne    c88d <lodepng_compute_color_stats+0x672>
    c84c:	8b 45 08             	mov    0x8(%ebp),%eax
    c84f:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c855:	83 f8 07             	cmp    $0x7,%eax
    c858:	77 33                	ja     c88d <lodepng_compute_color_stats+0x672>
        /*only r is checked, < 8 bits is only relevant for grayscale*/
        unsigned bits = getValueRequiredBits(r);
    c85a:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    c861:	0f b6 c0             	movzbl %al,%eax
    c864:	83 ec 0c             	sub    $0xc,%esp
    c867:	50                   	push   %eax
    c868:	e8 1d f9 ff ff       	call   c18a <getValueRequiredBits>
    c86d:	83 c4 10             	add    $0x10,%esp
    c870:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        if(bits > stats->bits) stats->bits = bits;
    c873:	8b 45 08             	mov    0x8(%ebp),%eax
    c876:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c87c:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
    c87f:	73 0c                	jae    c88d <lodepng_compute_color_stats+0x672>
    c881:	8b 45 08             	mov    0x8(%ebp),%eax
    c884:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    c887:	89 90 18 04 00 00    	mov    %edx,0x418(%eax)
      }
      bits_done = (stats->bits >= bpp);
    c88d:	8b 45 08             	mov    0x8(%ebp),%eax
    c890:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c896:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    c899:	0f 93 c0             	setae  %al
    c89c:	0f b6 c0             	movzbl %al,%eax
    c89f:	89 45 e0             	mov    %eax,-0x20(%ebp)

      if(!colored_done && (r != g || r != b)) {
    c8a2:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    c8a6:	75 4f                	jne    c8f7 <lodepng_compute_color_stats+0x6dc>
    c8a8:	0f b6 95 63 ff ff ff 	movzbl -0x9d(%ebp),%edx
    c8af:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    c8b6:	38 c2                	cmp    %al,%dl
    c8b8:	75 12                	jne    c8cc <lodepng_compute_color_stats+0x6b1>
    c8ba:	0f b6 95 63 ff ff ff 	movzbl -0x9d(%ebp),%edx
    c8c1:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    c8c8:	38 c2                	cmp    %al,%dl
    c8ca:	74 2b                	je     c8f7 <lodepng_compute_color_stats+0x6dc>
        stats->colored = 1;
    c8cc:	8b 45 08             	mov    0x8(%ebp),%eax
    c8cf:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        colored_done = 1;
    c8d5:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
        if(stats->bits < 8) stats->bits = 8; /*PNG has no colored modes with less than 8-bit per channel*/
    c8dc:	8b 45 08             	mov    0x8(%ebp),%eax
    c8df:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c8e5:	83 f8 07             	cmp    $0x7,%eax
    c8e8:	77 0d                	ja     c8f7 <lodepng_compute_color_stats+0x6dc>
    c8ea:	8b 45 08             	mov    0x8(%ebp),%eax
    c8ed:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    c8f4:	00 00 00 
      }

      if(!alpha_done) {
    c8f7:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    c8fb:	0f 85 65 01 00 00    	jne    ca66 <lodepng_compute_color_stats+0x84b>
        unsigned matchkey = (r == stats->key_r && g == stats->key_g && b == stats->key_b);
    c901:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    c908:	0f b6 d0             	movzbl %al,%edx
    c90b:	8b 45 08             	mov    0x8(%ebp),%eax
    c90e:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    c912:	66 39 c2             	cmp    %ax,%dx
    c915:	75 33                	jne    c94a <lodepng_compute_color_stats+0x72f>
    c917:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    c91e:	0f b6 d0             	movzbl %al,%edx
    c921:	8b 45 08             	mov    0x8(%ebp),%eax
    c924:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    c928:	66 39 c2             	cmp    %ax,%dx
    c92b:	75 1d                	jne    c94a <lodepng_compute_color_stats+0x72f>
    c92d:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    c934:	0f b6 d0             	movzbl %al,%edx
    c937:	8b 45 08             	mov    0x8(%ebp),%eax
    c93a:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    c93e:	66 39 c2             	cmp    %ax,%dx
    c941:	75 07                	jne    c94a <lodepng_compute_color_stats+0x72f>
    c943:	b8 01 00 00 00       	mov    $0x1,%eax
    c948:	eb 05                	jmp    c94f <lodepng_compute_color_stats+0x734>
    c94a:	b8 00 00 00 00       	mov    $0x0,%eax
    c94f:	89 45 c0             	mov    %eax,-0x40(%ebp)
        if(a != 255 && (a != 0 || (stats->key && !matchkey))) {
    c952:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    c959:	3c ff                	cmp    $0xff,%al
    c95b:	74 5a                	je     c9b7 <lodepng_compute_color_stats+0x79c>
    c95d:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    c964:	84 c0                	test   %al,%al
    c966:	75 10                	jne    c978 <lodepng_compute_color_stats+0x75d>
    c968:	8b 45 08             	mov    0x8(%ebp),%eax
    c96b:	8b 40 04             	mov    0x4(%eax),%eax
    c96e:	85 c0                	test   %eax,%eax
    c970:	74 45                	je     c9b7 <lodepng_compute_color_stats+0x79c>
    c972:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
    c976:	75 3f                	jne    c9b7 <lodepng_compute_color_stats+0x79c>
          stats->alpha = 1;
    c978:	8b 45 08             	mov    0x8(%ebp),%eax
    c97b:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    c982:	8b 45 08             	mov    0x8(%ebp),%eax
    c985:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    c98c:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    c993:	8b 45 08             	mov    0x8(%ebp),%eax
    c996:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c99c:	83 f8 07             	cmp    $0x7,%eax
    c99f:	0f 87 c1 00 00 00    	ja     ca66 <lodepng_compute_color_stats+0x84b>
    c9a5:	8b 45 08             	mov    0x8(%ebp),%eax
    c9a8:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    c9af:	00 00 00 
    c9b2:	e9 af 00 00 00       	jmp    ca66 <lodepng_compute_color_stats+0x84b>
        } else if(a == 0 && !stats->alpha && !stats->key) {
    c9b7:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    c9be:	84 c0                	test   %al,%al
    c9c0:	75 53                	jne    ca15 <lodepng_compute_color_stats+0x7fa>
    c9c2:	8b 45 08             	mov    0x8(%ebp),%eax
    c9c5:	8b 40 10             	mov    0x10(%eax),%eax
    c9c8:	85 c0                	test   %eax,%eax
    c9ca:	75 49                	jne    ca15 <lodepng_compute_color_stats+0x7fa>
    c9cc:	8b 45 08             	mov    0x8(%ebp),%eax
    c9cf:	8b 40 04             	mov    0x4(%eax),%eax
    c9d2:	85 c0                	test   %eax,%eax
    c9d4:	75 3f                	jne    ca15 <lodepng_compute_color_stats+0x7fa>
          stats->key = 1;
    c9d6:	8b 45 08             	mov    0x8(%ebp),%eax
    c9d9:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
          stats->key_r = r;
    c9e0:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    c9e7:	0f b6 d0             	movzbl %al,%edx
    c9ea:	8b 45 08             	mov    0x8(%ebp),%eax
    c9ed:	66 89 50 08          	mov    %dx,0x8(%eax)
          stats->key_g = g;
    c9f1:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    c9f8:	0f b6 d0             	movzbl %al,%edx
    c9fb:	8b 45 08             	mov    0x8(%ebp),%eax
    c9fe:	66 89 50 0a          	mov    %dx,0xa(%eax)
          stats->key_b = b;
    ca02:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    ca09:	0f b6 d0             	movzbl %al,%edx
    ca0c:	8b 45 08             	mov    0x8(%ebp),%eax
    ca0f:	66 89 50 0c          	mov    %dx,0xc(%eax)
    ca13:	eb 51                	jmp    ca66 <lodepng_compute_color_stats+0x84b>
        } else if(a == 255 && stats->key && matchkey) {
    ca15:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    ca1c:	3c ff                	cmp    $0xff,%al
    ca1e:	75 46                	jne    ca66 <lodepng_compute_color_stats+0x84b>
    ca20:	8b 45 08             	mov    0x8(%ebp),%eax
    ca23:	8b 40 04             	mov    0x4(%eax),%eax
    ca26:	85 c0                	test   %eax,%eax
    ca28:	74 3c                	je     ca66 <lodepng_compute_color_stats+0x84b>
    ca2a:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
    ca2e:	74 36                	je     ca66 <lodepng_compute_color_stats+0x84b>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    ca30:	8b 45 08             	mov    0x8(%ebp),%eax
    ca33:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    ca3a:	8b 45 08             	mov    0x8(%ebp),%eax
    ca3d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    ca44:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    ca4b:	8b 45 08             	mov    0x8(%ebp),%eax
    ca4e:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    ca54:	83 f8 07             	cmp    $0x7,%eax
    ca57:	77 0d                	ja     ca66 <lodepng_compute_color_stats+0x84b>
    ca59:	8b 45 08             	mov    0x8(%ebp),%eax
    ca5c:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    ca63:	00 00 00 
        }
      }

      if(!numcolors_done) {
    ca66:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    ca6a:	0f 85 35 01 00 00    	jne    cba5 <lodepng_compute_color_stats+0x98a>
        if(!color_tree_has(&tree, r, g, b, a)) {
    ca70:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    ca77:	0f b6 d8             	movzbl %al,%ebx
    ca7a:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    ca81:	0f b6 c8             	movzbl %al,%ecx
    ca84:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    ca8b:	0f b6 d0             	movzbl %al,%edx
    ca8e:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    ca95:	0f b6 c0             	movzbl %al,%eax
    ca98:	83 ec 0c             	sub    $0xc,%esp
    ca9b:	53                   	push   %ebx
    ca9c:	51                   	push   %ecx
    ca9d:	52                   	push   %edx
    ca9e:	50                   	push   %eax
    ca9f:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    caa5:	50                   	push   %eax
    caa6:	e8 1c d4 ff ff       	call   9ec7 <color_tree_has>
    caab:	83 c4 20             	add    $0x20,%esp
    caae:	85 c0                	test   %eax,%eax
    cab0:	0f 85 ef 00 00 00    	jne    cba5 <lodepng_compute_color_stats+0x98a>
          error = color_tree_add(&tree, r, g, b, a, stats->numcolors);
    cab6:	8b 45 08             	mov    0x8(%ebp),%eax
    cab9:	8b 70 14             	mov    0x14(%eax),%esi
    cabc:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    cac3:	0f b6 d8             	movzbl %al,%ebx
    cac6:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    cacd:	0f b6 c8             	movzbl %al,%ecx
    cad0:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    cad7:	0f b6 d0             	movzbl %al,%edx
    cada:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    cae1:	0f b6 c0             	movzbl %al,%eax
    cae4:	83 ec 08             	sub    $0x8,%esp
    cae7:	56                   	push   %esi
    cae8:	53                   	push   %ebx
    cae9:	51                   	push   %ecx
    caea:	52                   	push   %edx
    caeb:	50                   	push   %eax
    caec:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    caf2:	50                   	push   %eax
    caf3:	e8 1a d4 ff ff       	call   9f12 <color_tree_add>
    caf8:	83 c4 20             	add    $0x20,%esp
    cafb:	89 45 f0             	mov    %eax,-0x10(%ebp)
          if(error) goto cleanup;
    cafe:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    cb02:	0f 85 06 02 00 00    	jne    cd0e <lodepng_compute_color_stats+0xaf3>
          if(stats->numcolors < 256) {
    cb08:	8b 45 08             	mov    0x8(%ebp),%eax
    cb0b:	8b 40 14             	mov    0x14(%eax),%eax
    cb0e:	3d ff 00 00 00       	cmp    $0xff,%eax
    cb13:	77 6f                	ja     cb84 <lodepng_compute_color_stats+0x969>
            unsigned char* p = stats->palette;
    cb15:	8b 45 08             	mov    0x8(%ebp),%eax
    cb18:	83 c0 18             	add    $0x18,%eax
    cb1b:	89 45 bc             	mov    %eax,-0x44(%ebp)
            unsigned n = stats->numcolors;
    cb1e:	8b 45 08             	mov    0x8(%ebp),%eax
    cb21:	8b 40 14             	mov    0x14(%eax),%eax
    cb24:	89 45 b8             	mov    %eax,-0x48(%ebp)
            p[n * 4 + 0] = r;
    cb27:	8b 45 b8             	mov    -0x48(%ebp),%eax
    cb2a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    cb31:	8b 45 bc             	mov    -0x44(%ebp),%eax
    cb34:	01 c2                	add    %eax,%edx
    cb36:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    cb3d:	88 02                	mov    %al,(%edx)
            p[n * 4 + 1] = g;
    cb3f:	8b 45 b8             	mov    -0x48(%ebp),%eax
    cb42:	c1 e0 02             	shl    $0x2,%eax
    cb45:	8d 50 01             	lea    0x1(%eax),%edx
    cb48:	8b 45 bc             	mov    -0x44(%ebp),%eax
    cb4b:	01 c2                	add    %eax,%edx
    cb4d:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    cb54:	88 02                	mov    %al,(%edx)
            p[n * 4 + 2] = b;
    cb56:	8b 45 b8             	mov    -0x48(%ebp),%eax
    cb59:	c1 e0 02             	shl    $0x2,%eax
    cb5c:	8d 50 02             	lea    0x2(%eax),%edx
    cb5f:	8b 45 bc             	mov    -0x44(%ebp),%eax
    cb62:	01 c2                	add    %eax,%edx
    cb64:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    cb6b:	88 02                	mov    %al,(%edx)
            p[n * 4 + 3] = a;
    cb6d:	8b 45 b8             	mov    -0x48(%ebp),%eax
    cb70:	c1 e0 02             	shl    $0x2,%eax
    cb73:	8d 50 03             	lea    0x3(%eax),%edx
    cb76:	8b 45 bc             	mov    -0x44(%ebp),%eax
    cb79:	01 c2                	add    %eax,%edx
    cb7b:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    cb82:	88 02                	mov    %al,(%edx)
          }
          ++stats->numcolors;
    cb84:	8b 45 08             	mov    0x8(%ebp),%eax
    cb87:	8b 40 14             	mov    0x14(%eax),%eax
    cb8a:	8d 50 01             	lea    0x1(%eax),%edx
    cb8d:	8b 45 08             	mov    0x8(%ebp),%eax
    cb90:	89 50 14             	mov    %edx,0x14(%eax)
          numcolors_done = stats->numcolors >= maxnumcolors;
    cb93:	8b 45 08             	mov    0x8(%ebp),%eax
    cb96:	8b 40 14             	mov    0x14(%eax),%eax
    cb99:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    cb9c:	0f 93 c0             	setae  %al
    cb9f:	0f b6 c0             	movzbl %al,%eax
    cba2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        }
      }

      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    cba5:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    cba9:	74 12                	je     cbbd <lodepng_compute_color_stats+0x9a2>
    cbab:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    cbaf:	74 0c                	je     cbbd <lodepng_compute_color_stats+0x9a2>
    cbb1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    cbb5:	74 06                	je     cbbd <lodepng_compute_color_stats+0x9a2>
    cbb7:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    cbbb:	75 12                	jne    cbcf <lodepng_compute_color_stats+0x9b4>
        }
      }
    }
  } else /* < 16-bit */ {
    unsigned char r = 0, g = 0, b = 0, a = 0;
    for(i = 0; i != numpixels; ++i) {
    cbbd:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    cbc1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    cbc4:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    cbc7:	0f 85 49 fc ff ff    	jne    c816 <lodepng_compute_color_stats+0x5fb>
    cbcd:	eb 01                	jmp    cbd0 <lodepng_compute_color_stats+0x9b5>
          ++stats->numcolors;
          numcolors_done = stats->numcolors >= maxnumcolors;
        }
      }

      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    cbcf:	90                   	nop
    }

    if(stats->key && !stats->alpha) {
    cbd0:	8b 45 08             	mov    0x8(%ebp),%eax
    cbd3:	8b 40 04             	mov    0x4(%eax),%eax
    cbd6:	85 c0                	test   %eax,%eax
    cbd8:	0f 84 dd 00 00 00    	je     ccbb <lodepng_compute_color_stats+0xaa0>
    cbde:	8b 45 08             	mov    0x8(%ebp),%eax
    cbe1:	8b 40 10             	mov    0x10(%eax),%eax
    cbe4:	85 c0                	test   %eax,%eax
    cbe6:	0f 85 cf 00 00 00    	jne    ccbb <lodepng_compute_color_stats+0xaa0>
      for(i = 0; i != numpixels; ++i) {
    cbec:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    cbf3:	e9 b7 00 00 00       	jmp    ccaf <lodepng_compute_color_stats+0xa94>
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
    cbf8:	83 ec 04             	sub    $0x4,%esp
    cbfb:	ff 75 18             	pushl  0x18(%ebp)
    cbfe:	ff 75 f4             	pushl  -0xc(%ebp)
    cc01:	ff 75 0c             	pushl  0xc(%ebp)
    cc04:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    cc0a:	50                   	push   %eax
    cc0b:	8d 85 61 ff ff ff    	lea    -0x9f(%ebp),%eax
    cc11:	50                   	push   %eax
    cc12:	8d 85 62 ff ff ff    	lea    -0x9e(%ebp),%eax
    cc18:	50                   	push   %eax
    cc19:	8d 85 63 ff ff ff    	lea    -0x9d(%ebp),%eax
    cc1f:	50                   	push   %eax
    cc20:	e8 3c da ff ff       	call   a661 <getPixelColorRGBA8>
    cc25:	83 c4 20             	add    $0x20,%esp
        if(a != 0 && r == stats->key_r && g == stats->key_g && b == stats->key_b) {
    cc28:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    cc2f:	84 c0                	test   %al,%al
    cc31:	74 78                	je     ccab <lodepng_compute_color_stats+0xa90>
    cc33:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    cc3a:	0f b6 d0             	movzbl %al,%edx
    cc3d:	8b 45 08             	mov    0x8(%ebp),%eax
    cc40:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    cc44:	66 39 c2             	cmp    %ax,%dx
    cc47:	75 62                	jne    ccab <lodepng_compute_color_stats+0xa90>
    cc49:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    cc50:	0f b6 d0             	movzbl %al,%edx
    cc53:	8b 45 08             	mov    0x8(%ebp),%eax
    cc56:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    cc5a:	66 39 c2             	cmp    %ax,%dx
    cc5d:	75 4c                	jne    ccab <lodepng_compute_color_stats+0xa90>
    cc5f:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    cc66:	0f b6 d0             	movzbl %al,%edx
    cc69:	8b 45 08             	mov    0x8(%ebp),%eax
    cc6c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    cc70:	66 39 c2             	cmp    %ax,%dx
    cc73:	75 36                	jne    ccab <lodepng_compute_color_stats+0xa90>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    cc75:	8b 45 08             	mov    0x8(%ebp),%eax
    cc78:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    cc7f:	8b 45 08             	mov    0x8(%ebp),%eax
    cc82:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    cc89:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    cc90:	8b 45 08             	mov    0x8(%ebp),%eax
    cc93:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    cc99:	83 f8 07             	cmp    $0x7,%eax
    cc9c:	77 0d                	ja     ccab <lodepng_compute_color_stats+0xa90>
    cc9e:	8b 45 08             	mov    0x8(%ebp),%eax
    cca1:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    cca8:	00 00 00 

      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    }

    if(stats->key && !stats->alpha) {
      for(i = 0; i != numpixels; ++i) {
    ccab:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    ccaf:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ccb2:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    ccb5:	0f 85 3d ff ff ff    	jne    cbf8 <lodepng_compute_color_stats+0x9dd>
        }
      }
    }

    /*make the stats's key always 16-bit for consistency - repeat each byte twice*/
    stats->key_r += (stats->key_r << 8);
    ccbb:	8b 45 08             	mov    0x8(%ebp),%eax
    ccbe:	0f b7 50 08          	movzwl 0x8(%eax),%edx
    ccc2:	8b 45 08             	mov    0x8(%ebp),%eax
    ccc5:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    ccc9:	c1 e0 08             	shl    $0x8,%eax
    cccc:	01 c2                	add    %eax,%edx
    ccce:	8b 45 08             	mov    0x8(%ebp),%eax
    ccd1:	66 89 50 08          	mov    %dx,0x8(%eax)
    stats->key_g += (stats->key_g << 8);
    ccd5:	8b 45 08             	mov    0x8(%ebp),%eax
    ccd8:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    ccdc:	8b 45 08             	mov    0x8(%ebp),%eax
    ccdf:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    cce3:	c1 e0 08             	shl    $0x8,%eax
    cce6:	01 c2                	add    %eax,%edx
    cce8:	8b 45 08             	mov    0x8(%ebp),%eax
    cceb:	66 89 50 0a          	mov    %dx,0xa(%eax)
    stats->key_b += (stats->key_b << 8);
    ccef:	8b 45 08             	mov    0x8(%ebp),%eax
    ccf2:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    ccf6:	8b 45 08             	mov    0x8(%ebp),%eax
    ccf9:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    ccfd:	c1 e0 08             	shl    $0x8,%eax
    cd00:	01 c2                	add    %eax,%edx
    cd02:	8b 45 08             	mov    0x8(%ebp),%eax
    cd05:	66 89 50 0c          	mov    %dx,0xc(%eax)
    cd09:	eb 04                	jmp    cd0f <lodepng_compute_color_stats+0xaf4>

  if(!numcolors_done) {
    for(i = 0; i < stats->numcolors; i++) {
      const unsigned char* color = &stats->palette[i * 4];
      error = color_tree_add(&tree, color[0], color[1], color[2], color[3], i);
      if(error) goto cleanup;
    cd0b:	90                   	nop
    cd0c:	eb 01                	jmp    cd0f <lodepng_compute_color_stats+0xaf4>
      }

      if(!numcolors_done) {
        if(!color_tree_has(&tree, r, g, b, a)) {
          error = color_tree_add(&tree, r, g, b, a, stats->numcolors);
          if(error) goto cleanup;
    cd0e:	90                   	nop
    stats->key_g += (stats->key_g << 8);
    stats->key_b += (stats->key_b << 8);
  }

cleanup:
  color_tree_cleanup(&tree);
    cd0f:	83 ec 0c             	sub    $0xc,%esp
    cd12:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    cd18:	50                   	push   %eax
    cd19:	e8 91 d0 ff ff       	call   9daf <color_tree_cleanup>
    cd1e:	83 c4 10             	add    $0x10,%esp
  return error;
    cd21:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    cd24:	8d 65 f8             	lea    -0x8(%ebp),%esp
    cd27:	5b                   	pop    %ebx
    cd28:	5e                   	pop    %esi
    cd29:	5d                   	pop    %ebp
    cd2a:	c3                   	ret    

0000cd2b <lodepng_color_stats_add>:
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
/*Adds a single color to the color stats. The stats must already have been inited. The color must be given as 16-bit
(with 2 bytes repeating for 8-bit and 65535 for opaque alpha channel). This function is expensive, do not call it for
all pixels of an image but only for a few additional values. */
static unsigned lodepng_color_stats_add(LodePNGColorStats* stats,
                                        unsigned r, unsigned g, unsigned b, unsigned a) {
    cd2b:	55                   	push   %ebp
    cd2c:	89 e5                	mov    %esp,%ebp
    cd2e:	83 ec 38             	sub    $0x38,%esp
  unsigned error = 0;
    cd31:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char image[8];
  LodePNGColorMode mode;
  lodepng_color_mode_init(&mode);
    cd38:	8d 45 cc             	lea    -0x34(%ebp),%eax
    cd3b:	50                   	push   %eax
    cd3c:	e8 d1 bd ff ff       	call   8b12 <lodepng_color_mode_init>
    cd41:	83 c4 04             	add    $0x4,%esp
  image[0] = r >> 8; image[1] = r; image[2] = g >> 8; image[3] = g;
    cd44:	8b 45 0c             	mov    0xc(%ebp),%eax
    cd47:	c1 e8 08             	shr    $0x8,%eax
    cd4a:	88 45 ec             	mov    %al,-0x14(%ebp)
    cd4d:	8b 45 0c             	mov    0xc(%ebp),%eax
    cd50:	88 45 ed             	mov    %al,-0x13(%ebp)
    cd53:	8b 45 10             	mov    0x10(%ebp),%eax
    cd56:	c1 e8 08             	shr    $0x8,%eax
    cd59:	88 45 ee             	mov    %al,-0x12(%ebp)
    cd5c:	8b 45 10             	mov    0x10(%ebp),%eax
    cd5f:	88 45 ef             	mov    %al,-0x11(%ebp)
  image[4] = b >> 8; image[5] = b; image[6] = a >> 8; image[7] = a;
    cd62:	8b 45 14             	mov    0x14(%ebp),%eax
    cd65:	c1 e8 08             	shr    $0x8,%eax
    cd68:	88 45 f0             	mov    %al,-0x10(%ebp)
    cd6b:	8b 45 14             	mov    0x14(%ebp),%eax
    cd6e:	88 45 f1             	mov    %al,-0xf(%ebp)
    cd71:	8b 45 18             	mov    0x18(%ebp),%eax
    cd74:	c1 e8 08             	shr    $0x8,%eax
    cd77:	88 45 f2             	mov    %al,-0xe(%ebp)
    cd7a:	8b 45 18             	mov    0x18(%ebp),%eax
    cd7d:	88 45 f3             	mov    %al,-0xd(%ebp)
  mode.bitdepth = 16;
    cd80:	c7 45 d0 10 00 00 00 	movl   $0x10,-0x30(%ebp)
  mode.colortype = LCT_RGBA;
    cd87:	c7 45 cc 06 00 00 00 	movl   $0x6,-0x34(%ebp)
  error = lodepng_compute_color_stats(stats, image, 1, 1, &mode);
    cd8e:	83 ec 0c             	sub    $0xc,%esp
    cd91:	8d 45 cc             	lea    -0x34(%ebp),%eax
    cd94:	50                   	push   %eax
    cd95:	6a 01                	push   $0x1
    cd97:	6a 01                	push   $0x1
    cd99:	8d 45 ec             	lea    -0x14(%ebp),%eax
    cd9c:	50                   	push   %eax
    cd9d:	ff 75 08             	pushl  0x8(%ebp)
    cda0:	e8 76 f4 ff ff       	call   c21b <lodepng_compute_color_stats>
    cda5:	83 c4 20             	add    $0x20,%esp
    cda8:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_color_mode_cleanup(&mode);
    cdab:	83 ec 0c             	sub    $0xc,%esp
    cdae:	8d 45 cc             	lea    -0x34(%ebp),%eax
    cdb1:	50                   	push   %eax
    cdb2:	e8 4e be ff ff       	call   8c05 <lodepng_color_mode_cleanup>
    cdb7:	83 c4 10             	add    $0x10,%esp
  return error;
    cdba:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    cdbd:	c9                   	leave  
    cdbe:	c3                   	ret    

0000cdbf <auto_choose_color>:
e.g. gray if only grayscale pixels, palette if less than 256 colors, color key if only single transparent color, ...
This is used if auto_convert is enabled (it is by default).
*/
static unsigned auto_choose_color(LodePNGColorMode* mode_out,
                                  const LodePNGColorMode* mode_in,
                                  const LodePNGColorStats* stats) {
    cdbf:	55                   	push   %ebp
    cdc0:	89 e5                	mov    %esp,%ebp
    cdc2:	56                   	push   %esi
    cdc3:	53                   	push   %ebx
    cdc4:	83 ec 30             	sub    $0x30,%esp
  unsigned error = 0;
    cdc7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned palettebits;
  size_t i, n;
  size_t numpixels = stats->numpixels;
    cdce:	8b 45 10             	mov    0x10(%ebp),%eax
    cdd1:	8b 80 1c 04 00 00    	mov    0x41c(%eax),%eax
    cdd7:	89 45 d8             	mov    %eax,-0x28(%ebp)
  unsigned palette_ok, gray_ok;

  unsigned alpha = stats->alpha;
    cdda:	8b 45 10             	mov    0x10(%ebp),%eax
    cddd:	8b 40 10             	mov    0x10(%eax),%eax
    cde0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  unsigned key = stats->key;
    cde3:	8b 45 10             	mov    0x10(%ebp),%eax
    cde6:	8b 40 04             	mov    0x4(%eax),%eax
    cde9:	89 45 e0             	mov    %eax,-0x20(%ebp)
  unsigned bits = stats->bits;
    cdec:	8b 45 10             	mov    0x10(%ebp),%eax
    cdef:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    cdf5:	89 45 dc             	mov    %eax,-0x24(%ebp)

  mode_out->key_defined = 0;
    cdf8:	8b 45 08             	mov    0x8(%ebp),%eax
    cdfb:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)

  if(key && numpixels <= 16) {
    ce02:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    ce06:	74 21                	je     ce29 <auto_choose_color+0x6a>
    ce08:	83 7d d8 10          	cmpl   $0x10,-0x28(%ebp)
    ce0c:	7f 1b                	jg     ce29 <auto_choose_color+0x6a>
    alpha = 1; /*too few pixels to justify tRNS chunk overhead*/
    ce0e:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
    key = 0;
    ce15:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    if(bits < 8) bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    ce1c:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
    ce20:	77 07                	ja     ce29 <auto_choose_color+0x6a>
    ce22:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)
  }

  gray_ok = !stats->colored;
    ce29:	8b 45 10             	mov    0x10(%ebp),%eax
    ce2c:	8b 00                	mov    (%eax),%eax
    ce2e:	85 c0                	test   %eax,%eax
    ce30:	0f 94 c0             	sete   %al
    ce33:	0f b6 c0             	movzbl %al,%eax
    ce36:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(!stats->allow_greyscale) gray_ok = 0;
    ce39:	8b 45 10             	mov    0x10(%ebp),%eax
    ce3c:	8b 80 24 04 00 00    	mov    0x424(%eax),%eax
    ce42:	85 c0                	test   %eax,%eax
    ce44:	75 07                	jne    ce4d <auto_choose_color+0x8e>
    ce46:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  if(!gray_ok && bits < 8) bits = 8;
    ce4d:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    ce51:	75 0d                	jne    ce60 <auto_choose_color+0xa1>
    ce53:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
    ce57:	77 07                	ja     ce60 <auto_choose_color+0xa1>
    ce59:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)

  n = stats->numcolors;
    ce60:	8b 45 10             	mov    0x10(%ebp),%eax
    ce63:	8b 40 14             	mov    0x14(%eax),%eax
    ce66:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  palettebits = n <= 2 ? 1 : (n <= 4 ? 2 : (n <= 16 ? 4 : 8));
    ce69:	83 7d d4 02          	cmpl   $0x2,-0x2c(%ebp)
    ce6d:	7e 21                	jle    ce90 <auto_choose_color+0xd1>
    ce6f:	83 7d d4 04          	cmpl   $0x4,-0x2c(%ebp)
    ce73:	7e 14                	jle    ce89 <auto_choose_color+0xca>
    ce75:	83 7d d4 10          	cmpl   $0x10,-0x2c(%ebp)
    ce79:	7f 07                	jg     ce82 <auto_choose_color+0xc3>
    ce7b:	b8 04 00 00 00       	mov    $0x4,%eax
    ce80:	eb 13                	jmp    ce95 <auto_choose_color+0xd6>
    ce82:	b8 08 00 00 00       	mov    $0x8,%eax
    ce87:	eb 0c                	jmp    ce95 <auto_choose_color+0xd6>
    ce89:	b8 02 00 00 00       	mov    $0x2,%eax
    ce8e:	eb 05                	jmp    ce95 <auto_choose_color+0xd6>
    ce90:	b8 01 00 00 00       	mov    $0x1,%eax
    ce95:	89 45 d0             	mov    %eax,-0x30(%ebp)
  palette_ok = n <= 256 && bits <= 8 && n != 0; /*n==0 means likely numcolors wasn't computed*/
    ce98:	81 7d d4 00 01 00 00 	cmpl   $0x100,-0x2c(%ebp)
    ce9f:	7f 13                	jg     ceb4 <auto_choose_color+0xf5>
    cea1:	83 7d dc 08          	cmpl   $0x8,-0x24(%ebp)
    cea5:	77 0d                	ja     ceb4 <auto_choose_color+0xf5>
    cea7:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
    ceab:	74 07                	je     ceb4 <auto_choose_color+0xf5>
    cead:	b8 01 00 00 00       	mov    $0x1,%eax
    ceb2:	eb 05                	jmp    ceb9 <auto_choose_color+0xfa>
    ceb4:	b8 00 00 00 00       	mov    $0x0,%eax
    ceb9:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(numpixels < n * 2) palette_ok = 0; /*don't add palette overhead if image has only a few pixels*/
    cebc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    cebf:	01 c0                	add    %eax,%eax
    cec1:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    cec4:	7e 07                	jle    cecd <auto_choose_color+0x10e>
    cec6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  if(gray_ok && !alpha && bits <= palettebits) palette_ok = 0; /*gray is less overhead*/
    cecd:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    ced1:	74 15                	je     cee8 <auto_choose_color+0x129>
    ced3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    ced7:	75 0f                	jne    cee8 <auto_choose_color+0x129>
    ced9:	8b 45 dc             	mov    -0x24(%ebp),%eax
    cedc:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    cedf:	77 07                	ja     cee8 <auto_choose_color+0x129>
    cee1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  if(!stats->allow_palette) palette_ok = 0;
    cee8:	8b 45 10             	mov    0x10(%ebp),%eax
    ceeb:	8b 80 20 04 00 00    	mov    0x420(%eax),%eax
    cef1:	85 c0                	test   %eax,%eax
    cef3:	75 07                	jne    cefc <auto_choose_color+0x13d>
    cef5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  if(palette_ok) {
    cefc:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    cf00:	0f 84 0a 01 00 00    	je     d010 <auto_choose_color+0x251>
    const unsigned char* p = stats->palette;
    cf06:	8b 45 10             	mov    0x10(%ebp),%eax
    cf09:	83 c0 18             	add    $0x18,%eax
    cf0c:	89 45 cc             	mov    %eax,-0x34(%ebp)
    lodepng_palette_clear(mode_out); /*remove potential earlier palette*/
    cf0f:	83 ec 0c             	sub    $0xc,%esp
    cf12:	ff 75 08             	pushl  0x8(%ebp)
    cf15:	e8 ef be ff ff       	call   8e09 <lodepng_palette_clear>
    cf1a:	83 c4 10             	add    $0x10,%esp
    for(i = 0; i != stats->numcolors; ++i) {
    cf1d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    cf24:	eb 6e                	jmp    cf94 <auto_choose_color+0x1d5>
      error = lodepng_palette_add(mode_out, p[i * 4 + 0], p[i * 4 + 1], p[i * 4 + 2], p[i * 4 + 3]);
    cf26:	8b 45 f0             	mov    -0x10(%ebp),%eax
    cf29:	c1 e0 02             	shl    $0x2,%eax
    cf2c:	8d 50 03             	lea    0x3(%eax),%edx
    cf2f:	8b 45 cc             	mov    -0x34(%ebp),%eax
    cf32:	01 d0                	add    %edx,%eax
    cf34:	0f b6 00             	movzbl (%eax),%eax
    cf37:	0f b6 d8             	movzbl %al,%ebx
    cf3a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    cf3d:	c1 e0 02             	shl    $0x2,%eax
    cf40:	8d 50 02             	lea    0x2(%eax),%edx
    cf43:	8b 45 cc             	mov    -0x34(%ebp),%eax
    cf46:	01 d0                	add    %edx,%eax
    cf48:	0f b6 00             	movzbl (%eax),%eax
    cf4b:	0f b6 c8             	movzbl %al,%ecx
    cf4e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    cf51:	c1 e0 02             	shl    $0x2,%eax
    cf54:	8d 50 01             	lea    0x1(%eax),%edx
    cf57:	8b 45 cc             	mov    -0x34(%ebp),%eax
    cf5a:	01 d0                	add    %edx,%eax
    cf5c:	0f b6 00             	movzbl (%eax),%eax
    cf5f:	0f b6 d0             	movzbl %al,%edx
    cf62:	8b 45 f0             	mov    -0x10(%ebp),%eax
    cf65:	c1 e0 02             	shl    $0x2,%eax
    cf68:	89 c6                	mov    %eax,%esi
    cf6a:	8b 45 cc             	mov    -0x34(%ebp),%eax
    cf6d:	01 f0                	add    %esi,%eax
    cf6f:	0f b6 00             	movzbl (%eax),%eax
    cf72:	0f b6 c0             	movzbl %al,%eax
    cf75:	83 ec 0c             	sub    $0xc,%esp
    cf78:	53                   	push   %ebx
    cf79:	51                   	push   %ecx
    cf7a:	52                   	push   %edx
    cf7b:	50                   	push   %eax
    cf7c:	ff 75 08             	pushl  0x8(%ebp)
    cf7f:	e8 be be ff ff       	call   8e42 <lodepng_palette_add>
    cf84:	83 c4 20             	add    $0x20,%esp
    cf87:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if(error) break;
    cf8a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    cf8e:	75 13                	jne    cfa3 <auto_choose_color+0x1e4>
  if(!stats->allow_palette) palette_ok = 0;

  if(palette_ok) {
    const unsigned char* p = stats->palette;
    lodepng_palette_clear(mode_out); /*remove potential earlier palette*/
    for(i = 0; i != stats->numcolors; ++i) {
    cf90:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    cf94:	8b 45 10             	mov    0x10(%ebp),%eax
    cf97:	8b 50 14             	mov    0x14(%eax),%edx
    cf9a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    cf9d:	39 c2                	cmp    %eax,%edx
    cf9f:	75 85                	jne    cf26 <auto_choose_color+0x167>
    cfa1:	eb 01                	jmp    cfa4 <auto_choose_color+0x1e5>
      error = lodepng_palette_add(mode_out, p[i * 4 + 0], p[i * 4 + 1], p[i * 4 + 2], p[i * 4 + 3]);
      if(error) break;
    cfa3:	90                   	nop
    }

    mode_out->colortype = LCT_PALETTE;
    cfa4:	8b 45 08             	mov    0x8(%ebp),%eax
    cfa7:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
    mode_out->bitdepth = palettebits;
    cfad:	8b 45 08             	mov    0x8(%ebp),%eax
    cfb0:	8b 55 d0             	mov    -0x30(%ebp),%edx
    cfb3:	89 50 04             	mov    %edx,0x4(%eax)

    if(mode_in->colortype == LCT_PALETTE && mode_in->palettesize >= mode_out->palettesize
    cfb6:	8b 45 0c             	mov    0xc(%ebp),%eax
    cfb9:	8b 00                	mov    (%eax),%eax
    cfbb:	83 f8 03             	cmp    $0x3,%eax
    cfbe:	0f 85 ec 00 00 00    	jne    d0b0 <auto_choose_color+0x2f1>
    cfc4:	8b 45 0c             	mov    0xc(%ebp),%eax
    cfc7:	8b 50 0c             	mov    0xc(%eax),%edx
    cfca:	8b 45 08             	mov    0x8(%ebp),%eax
    cfcd:	8b 40 0c             	mov    0xc(%eax),%eax
    cfd0:	39 c2                	cmp    %eax,%edx
    cfd2:	0f 8c d8 00 00 00    	jl     d0b0 <auto_choose_color+0x2f1>
        && mode_in->bitdepth == mode_out->bitdepth) {
    cfd8:	8b 45 0c             	mov    0xc(%ebp),%eax
    cfdb:	8b 50 04             	mov    0x4(%eax),%edx
    cfde:	8b 45 08             	mov    0x8(%ebp),%eax
    cfe1:	8b 40 04             	mov    0x4(%eax),%eax
    cfe4:	39 c2                	cmp    %eax,%edx
    cfe6:	0f 85 c4 00 00 00    	jne    d0b0 <auto_choose_color+0x2f1>
      /*If input should have same palette colors, keep original to preserve its order and prevent conversion*/
      lodepng_color_mode_cleanup(mode_out);
    cfec:	83 ec 0c             	sub    $0xc,%esp
    cfef:	ff 75 08             	pushl  0x8(%ebp)
    cff2:	e8 0e bc ff ff       	call   8c05 <lodepng_color_mode_cleanup>
    cff7:	83 c4 10             	add    $0x10,%esp
      lodepng_color_mode_copy(mode_out, mode_in);
    cffa:	83 ec 08             	sub    $0x8,%esp
    cffd:	ff 75 0c             	pushl  0xc(%ebp)
    d000:	ff 75 08             	pushl  0x8(%ebp)
    d003:	e8 14 bc ff ff       	call   8c1c <lodepng_color_mode_copy>
    d008:	83 c4 10             	add    $0x10,%esp
    d00b:	e9 a0 00 00 00       	jmp    d0b0 <auto_choose_color+0x2f1>
    }
  } else /*8-bit or 16-bit per channel*/ {
    mode_out->bitdepth = bits;
    d010:	8b 45 08             	mov    0x8(%ebp),%eax
    d013:	8b 55 dc             	mov    -0x24(%ebp),%edx
    d016:	89 50 04             	mov    %edx,0x4(%eax)
    mode_out->colortype = alpha ? (gray_ok ? LCT_GREY_ALPHA : LCT_RGBA)
    d019:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    d01d:	74 14                	je     d033 <auto_choose_color+0x274>
    d01f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    d023:	74 07                	je     d02c <auto_choose_color+0x26d>
    d025:	b8 04 00 00 00       	mov    $0x4,%eax
    d02a:	eb 19                	jmp    d045 <auto_choose_color+0x286>
    d02c:	b8 06 00 00 00       	mov    $0x6,%eax
    d031:	eb 12                	jmp    d045 <auto_choose_color+0x286>
    d033:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    d037:	74 07                	je     d040 <auto_choose_color+0x281>
    d039:	b8 00 00 00 00       	mov    $0x0,%eax
    d03e:	eb 05                	jmp    d045 <auto_choose_color+0x286>
    d040:	b8 02 00 00 00       	mov    $0x2,%eax
    d045:	8b 55 08             	mov    0x8(%ebp),%edx
    d048:	89 02                	mov    %eax,(%edx)
                                : (gray_ok ? LCT_GREY : LCT_RGB);
    if(key) {
    d04a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    d04e:	74 60                	je     d0b0 <auto_choose_color+0x2f1>
      unsigned mask = (1u << mode_out->bitdepth) - 1u; /*stats always uses 16-bit, mask converts it*/
    d050:	8b 45 08             	mov    0x8(%ebp),%eax
    d053:	8b 40 04             	mov    0x4(%eax),%eax
    d056:	ba 01 00 00 00       	mov    $0x1,%edx
    d05b:	89 c1                	mov    %eax,%ecx
    d05d:	d3 e2                	shl    %cl,%edx
    d05f:	89 d0                	mov    %edx,%eax
    d061:	83 e8 01             	sub    $0x1,%eax
    d064:	89 45 c8             	mov    %eax,-0x38(%ebp)
      mode_out->key_r = stats->key_r & mask;
    d067:	8b 45 10             	mov    0x10(%ebp),%eax
    d06a:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    d06e:	0f b7 c0             	movzwl %ax,%eax
    d071:	23 45 c8             	and    -0x38(%ebp),%eax
    d074:	89 c2                	mov    %eax,%edx
    d076:	8b 45 08             	mov    0x8(%ebp),%eax
    d079:	89 50 14             	mov    %edx,0x14(%eax)
      mode_out->key_g = stats->key_g & mask;
    d07c:	8b 45 10             	mov    0x10(%ebp),%eax
    d07f:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    d083:	0f b7 c0             	movzwl %ax,%eax
    d086:	23 45 c8             	and    -0x38(%ebp),%eax
    d089:	89 c2                	mov    %eax,%edx
    d08b:	8b 45 08             	mov    0x8(%ebp),%eax
    d08e:	89 50 18             	mov    %edx,0x18(%eax)
      mode_out->key_b = stats->key_b & mask;
    d091:	8b 45 10             	mov    0x10(%ebp),%eax
    d094:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    d098:	0f b7 c0             	movzwl %ax,%eax
    d09b:	23 45 c8             	and    -0x38(%ebp),%eax
    d09e:	89 c2                	mov    %eax,%edx
    d0a0:	8b 45 08             	mov    0x8(%ebp),%eax
    d0a3:	89 50 1c             	mov    %edx,0x1c(%eax)
      mode_out->key_defined = 1;
    d0a6:	8b 45 08             	mov    0x8(%ebp),%eax
    d0a9:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
    }
  }

  return error;
    d0b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    d0b3:	8d 65 f8             	lea    -0x8(%ebp),%esp
    d0b6:	5b                   	pop    %ebx
    d0b7:	5e                   	pop    %esi
    d0b8:	5d                   	pop    %ebp
    d0b9:	c3                   	ret    

0000d0ba <paethPredictor>:
/*
Paeth predictor, used by PNG filter type 4
The parameters are of type short, but should come from unsigned chars, the shorts
are only needed to make the paeth calculation correct.
*/
static unsigned char paethPredictor(short a, short b, short c) {
    d0ba:	55                   	push   %ebp
    d0bb:	89 e5                	mov    %esp,%ebp
    d0bd:	83 ec 1c             	sub    $0x1c,%esp
    d0c0:	8b 4d 08             	mov    0x8(%ebp),%ecx
    d0c3:	8b 55 0c             	mov    0xc(%ebp),%edx
    d0c6:	8b 45 10             	mov    0x10(%ebp),%eax
    d0c9:	66 89 4d ec          	mov    %cx,-0x14(%ebp)
    d0cd:	66 89 55 e8          	mov    %dx,-0x18(%ebp)
    d0d1:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  short pa = LODEPNG_ABS(b - c);
    d0d5:	0f bf 55 e8          	movswl -0x18(%ebp),%edx
    d0d9:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    d0dd:	29 c2                	sub    %eax,%edx
    d0df:	89 d0                	mov    %edx,%eax
    d0e1:	99                   	cltd   
    d0e2:	31 d0                	xor    %edx,%eax
    d0e4:	29 d0                	sub    %edx,%eax
    d0e6:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
  short pb = LODEPNG_ABS(a - c);
    d0ea:	0f bf 55 ec          	movswl -0x14(%ebp),%edx
    d0ee:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    d0f2:	29 c2                	sub    %eax,%edx
    d0f4:	89 d0                	mov    %edx,%eax
    d0f6:	99                   	cltd   
    d0f7:	31 d0                	xor    %edx,%eax
    d0f9:	29 d0                	sub    %edx,%eax
    d0fb:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
  short pc = LODEPNG_ABS(a + b - c - c);
    d0ff:	0f bf 55 ec          	movswl -0x14(%ebp),%edx
    d103:	0f bf 45 e8          	movswl -0x18(%ebp),%eax
    d107:	01 c2                	add    %eax,%edx
    d109:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    d10d:	29 c2                	sub    %eax,%edx
    d10f:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    d113:	29 c2                	sub    %eax,%edx
    d115:	89 d0                	mov    %edx,%eax
    d117:	99                   	cltd   
    d118:	31 d0                	xor    %edx,%eax
    d11a:	29 d0                	sub    %edx,%eax
    d11c:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
  /* return input value associated with smallest of pa, pb, pc (with certain priority if equal) */
  if(pb < pa) { a = b; pa = pb; }
    d120:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
    d124:	66 3b 45 fe          	cmp    -0x2(%ebp),%ax
    d128:	7d 10                	jge    d13a <paethPredictor+0x80>
    d12a:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
    d12e:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    d132:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
    d136:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
  return (pc < pa) ? c : a;
    d13a:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
    d13e:	66 3b 45 fe          	cmp    -0x2(%ebp),%ax
    d142:	7d 06                	jge    d14a <paethPredictor+0x90>
    d144:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
    d148:	eb 04                	jmp    d14e <paethPredictor+0x94>
    d14a:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
}
    d14e:	c9                   	leave  
    d14f:	c3                   	ret    

0000d150 <Adam7_getpassvalues>:
bpp: bits per pixel
"padded" is only relevant if bpp is less than 8 and a scanline or image does not
 end at a full byte
*/
static void Adam7_getpassvalues(unsigned passw[7], unsigned passh[7], size_t filter_passstart[8],
                                size_t padded_passstart[8], size_t passstart[8], unsigned w, unsigned h, unsigned bpp) {
    d150:	55                   	push   %ebp
    d151:	89 e5                	mov    %esp,%ebp
    d153:	56                   	push   %esi
    d154:	53                   	push   %ebx
    d155:	83 ec 10             	sub    $0x10,%esp
  /*the passstart values have 8 values: the 8th one indicates the byte after the end of the 7th (= last) pass*/
  unsigned i;

  /*calculate width and height in pixels of each pass*/
  for(i = 0; i != 7; ++i) {
    d158:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d15f:	e9 e2 00 00 00       	jmp    d246 <Adam7_getpassvalues+0xf6>
    passw[i] = (w + ADAM7_DX[i] - ADAM7_IX[i] - 1) / ADAM7_DX[i];
    d164:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d167:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d16e:	8b 45 08             	mov    0x8(%ebp),%eax
    d171:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    d174:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d177:	8b 14 85 f4 a0 01 00 	mov    0x1a0f4(,%eax,4),%edx
    d17e:	8b 45 1c             	mov    0x1c(%ebp),%eax
    d181:	01 c2                	add    %eax,%edx
    d183:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d186:	8b 04 85 bc a0 01 00 	mov    0x1a0bc(,%eax,4),%eax
    d18d:	29 c2                	sub    %eax,%edx
    d18f:	89 d0                	mov    %edx,%eax
    d191:	8d 58 ff             	lea    -0x1(%eax),%ebx
    d194:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d197:	8b 34 85 f4 a0 01 00 	mov    0x1a0f4(,%eax,4),%esi
    d19e:	89 d8                	mov    %ebx,%eax
    d1a0:	ba 00 00 00 00       	mov    $0x0,%edx
    d1a5:	f7 f6                	div    %esi
    d1a7:	89 01                	mov    %eax,(%ecx)
    passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
    d1a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d1ac:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d1b3:	8b 45 0c             	mov    0xc(%ebp),%eax
    d1b6:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    d1b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d1bc:	8b 14 85 10 a1 01 00 	mov    0x1a110(,%eax,4),%edx
    d1c3:	8b 45 20             	mov    0x20(%ebp),%eax
    d1c6:	01 c2                	add    %eax,%edx
    d1c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d1cb:	8b 04 85 d8 a0 01 00 	mov    0x1a0d8(,%eax,4),%eax
    d1d2:	29 c2                	sub    %eax,%edx
    d1d4:	89 d0                	mov    %edx,%eax
    d1d6:	8d 58 ff             	lea    -0x1(%eax),%ebx
    d1d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d1dc:	8b 34 85 10 a1 01 00 	mov    0x1a110(,%eax,4),%esi
    d1e3:	89 d8                	mov    %ebx,%eax
    d1e5:	ba 00 00 00 00       	mov    $0x0,%edx
    d1ea:	f7 f6                	div    %esi
    d1ec:	89 01                	mov    %eax,(%ecx)
    if(passw[i] == 0) passh[i] = 0;
    d1ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d1f1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d1f8:	8b 45 08             	mov    0x8(%ebp),%eax
    d1fb:	01 d0                	add    %edx,%eax
    d1fd:	8b 00                	mov    (%eax),%eax
    d1ff:	85 c0                	test   %eax,%eax
    d201:	75 15                	jne    d218 <Adam7_getpassvalues+0xc8>
    d203:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d206:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d20d:	8b 45 0c             	mov    0xc(%ebp),%eax
    d210:	01 d0                	add    %edx,%eax
    d212:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    if(passh[i] == 0) passw[i] = 0;
    d218:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d21b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d222:	8b 45 0c             	mov    0xc(%ebp),%eax
    d225:	01 d0                	add    %edx,%eax
    d227:	8b 00                	mov    (%eax),%eax
    d229:	85 c0                	test   %eax,%eax
    d22b:	75 15                	jne    d242 <Adam7_getpassvalues+0xf2>
    d22d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d230:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d237:	8b 45 08             	mov    0x8(%ebp),%eax
    d23a:	01 d0                	add    %edx,%eax
    d23c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
                                size_t padded_passstart[8], size_t passstart[8], unsigned w, unsigned h, unsigned bpp) {
  /*the passstart values have 8 values: the 8th one indicates the byte after the end of the 7th (= last) pass*/
  unsigned i;

  /*calculate width and height in pixels of each pass*/
  for(i = 0; i != 7; ++i) {
    d242:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d246:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
    d24a:	0f 85 14 ff ff ff    	jne    d164 <Adam7_getpassvalues+0x14>
    passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
    if(passw[i] == 0) passh[i] = 0;
    if(passh[i] == 0) passw[i] = 0;
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
    d250:	8b 45 18             	mov    0x18(%ebp),%eax
    d253:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    d259:	8b 45 18             	mov    0x18(%ebp),%eax
    d25c:	8b 10                	mov    (%eax),%edx
    d25e:	8b 45 14             	mov    0x14(%ebp),%eax
    d261:	89 10                	mov    %edx,(%eax)
    d263:	8b 45 14             	mov    0x14(%ebp),%eax
    d266:	8b 10                	mov    (%eax),%edx
    d268:	8b 45 10             	mov    0x10(%ebp),%eax
    d26b:	89 10                	mov    %edx,(%eax)
  for(i = 0; i != 7; ++i) {
    d26d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d274:	e9 40 01 00 00       	jmp    d3b9 <Adam7_getpassvalues+0x269>
    /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
    filter_passstart[i + 1] = filter_passstart[i]
    d279:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d27c:	83 c0 01             	add    $0x1,%eax
    d27f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d286:	8b 45 10             	mov    0x10(%ebp),%eax
    d289:	01 c2                	add    %eax,%edx
    d28b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d28e:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d295:	8b 45 10             	mov    0x10(%ebp),%eax
    d298:	01 c8                	add    %ecx,%eax
    d29a:	8b 00                	mov    (%eax),%eax
                            + ((passw[i] && passh[i]) ? passh[i] * (1u + (passw[i] * bpp + 7u) / 8u) : 0);
    d29c:	89 c6                	mov    %eax,%esi
    d29e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d2a1:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d2a8:	8b 45 08             	mov    0x8(%ebp),%eax
    d2ab:	01 c8                	add    %ecx,%eax
    d2ad:	8b 00                	mov    (%eax),%eax
    d2af:	85 c0                	test   %eax,%eax
    d2b1:	74 49                	je     d2fc <Adam7_getpassvalues+0x1ac>
    d2b3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d2b6:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d2bd:	8b 45 0c             	mov    0xc(%ebp),%eax
    d2c0:	01 c8                	add    %ecx,%eax
    d2c2:	8b 00                	mov    (%eax),%eax
    d2c4:	85 c0                	test   %eax,%eax
    d2c6:	74 34                	je     d2fc <Adam7_getpassvalues+0x1ac>
    d2c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d2cb:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d2d2:	8b 45 0c             	mov    0xc(%ebp),%eax
    d2d5:	01 c8                	add    %ecx,%eax
    d2d7:	8b 08                	mov    (%eax),%ecx
    d2d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d2dc:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    d2e3:	8b 45 08             	mov    0x8(%ebp),%eax
    d2e6:	01 d8                	add    %ebx,%eax
    d2e8:	8b 00                	mov    (%eax),%eax
    d2ea:	0f af 45 24          	imul   0x24(%ebp),%eax
    d2ee:	83 c0 07             	add    $0x7,%eax
    d2f1:	c1 e8 03             	shr    $0x3,%eax
    d2f4:	83 c0 01             	add    $0x1,%eax
    d2f7:	0f af c1             	imul   %ecx,%eax
    d2fa:	eb 05                	jmp    d301 <Adam7_getpassvalues+0x1b1>
    d2fc:	b8 00 00 00 00       	mov    $0x0,%eax
    d301:	01 f0                	add    %esi,%eax
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
  for(i = 0; i != 7; ++i) {
    /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
    filter_passstart[i + 1] = filter_passstart[i]
    d303:	89 02                	mov    %eax,(%edx)
                            + ((passw[i] && passh[i]) ? passh[i] * (1u + (passw[i] * bpp + 7u) / 8u) : 0);
    /*bits padded if needed to fill full byte at end of each scanline*/
    padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7u) / 8u);
    d305:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d308:	83 c0 01             	add    $0x1,%eax
    d30b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d312:	8b 45 14             	mov    0x14(%ebp),%eax
    d315:	01 c2                	add    %eax,%edx
    d317:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d31a:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d321:	8b 45 14             	mov    0x14(%ebp),%eax
    d324:	01 c8                	add    %ecx,%eax
    d326:	8b 00                	mov    (%eax),%eax
    d328:	89 c6                	mov    %eax,%esi
    d32a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d32d:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d334:	8b 45 0c             	mov    0xc(%ebp),%eax
    d337:	01 c8                	add    %ecx,%eax
    d339:	8b 08                	mov    (%eax),%ecx
    d33b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d33e:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    d345:	8b 45 08             	mov    0x8(%ebp),%eax
    d348:	01 d8                	add    %ebx,%eax
    d34a:	8b 00                	mov    (%eax),%eax
    d34c:	0f af 45 24          	imul   0x24(%ebp),%eax
    d350:	83 c0 07             	add    $0x7,%eax
    d353:	c1 e8 03             	shr    $0x3,%eax
    d356:	0f af c1             	imul   %ecx,%eax
    d359:	01 f0                	add    %esi,%eax
    d35b:	89 02                	mov    %eax,(%edx)
    /*only padded at end of reduced image*/
    passstart[i + 1] = passstart[i] + (passh[i] * passw[i] * bpp + 7u) / 8u;
    d35d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d360:	83 c0 01             	add    $0x1,%eax
    d363:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d36a:	8b 45 18             	mov    0x18(%ebp),%eax
    d36d:	01 c2                	add    %eax,%edx
    d36f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d372:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d379:	8b 45 18             	mov    0x18(%ebp),%eax
    d37c:	01 c8                	add    %ecx,%eax
    d37e:	8b 00                	mov    (%eax),%eax
    d380:	89 c6                	mov    %eax,%esi
    d382:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d385:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d38c:	8b 45 0c             	mov    0xc(%ebp),%eax
    d38f:	01 c8                	add    %ecx,%eax
    d391:	8b 08                	mov    (%eax),%ecx
    d393:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d396:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    d39d:	8b 45 08             	mov    0x8(%ebp),%eax
    d3a0:	01 d8                	add    %ebx,%eax
    d3a2:	8b 00                	mov    (%eax),%eax
    d3a4:	0f af c1             	imul   %ecx,%eax
    d3a7:	0f af 45 24          	imul   0x24(%ebp),%eax
    d3ab:	83 c0 07             	add    $0x7,%eax
    d3ae:	c1 e8 03             	shr    $0x3,%eax
    d3b1:	01 f0                	add    %esi,%eax
    d3b3:	89 02                	mov    %eax,(%edx)
    if(passw[i] == 0) passh[i] = 0;
    if(passh[i] == 0) passw[i] = 0;
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
  for(i = 0; i != 7; ++i) {
    d3b5:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d3b9:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
    d3bd:	0f 85 b6 fe ff ff    	jne    d279 <Adam7_getpassvalues+0x129>
    /*bits padded if needed to fill full byte at end of each scanline*/
    padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7u) / 8u);
    /*only padded at end of reduced image*/
    passstart[i + 1] = passstart[i] + (passh[i] * passw[i] * bpp + 7u) / 8u;
  }
}
    d3c3:	90                   	nop
    d3c4:	83 c4 10             	add    $0x10,%esp
    d3c7:	5b                   	pop    %ebx
    d3c8:	5e                   	pop    %esi
    d3c9:	5d                   	pop    %ebp
    d3ca:	c3                   	ret    

0000d3cb <lodepng_inspect>:
/* / PNG Decoder                                                            / */
/* ////////////////////////////////////////////////////////////////////////// */

/*read the information from the header and store it in the LodePNGInfo. return value is error*/
unsigned lodepng_inspect(unsigned* w, unsigned* h, LodePNGState* state,
                         const unsigned char* in, size_t insize) {
    d3cb:	55                   	push   %ebp
    d3cc:	89 e5                	mov    %esp,%ebp
    d3ce:	83 ec 28             	sub    $0x28,%esp
  unsigned width, height;
  LodePNGInfo* info = &state->info_png;
    d3d1:	8b 45 10             	mov    0x10(%ebp),%eax
    d3d4:	05 98 00 00 00       	add    $0x98,%eax
    d3d9:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(insize == 0 || in == 0) {
    d3dc:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
    d3e0:	74 06                	je     d3e8 <lodepng_inspect+0x1d>
    d3e2:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    d3e6:	75 17                	jne    d3ff <lodepng_inspect+0x34>
    CERROR_RETURN_ERROR(state->error, 48); /*error: the given data is empty*/
    d3e8:	8b 45 10             	mov    0x10(%ebp),%eax
    d3eb:	c7 80 7c 01 00 00 30 	movl   $0x30,0x17c(%eax)
    d3f2:	00 00 00 
    d3f5:	b8 30 00 00 00       	mov    $0x30,%eax
    d3fa:	e9 ce 02 00 00       	jmp    d6cd <lodepng_inspect+0x302>
  }
  if(insize < 33) {
    d3ff:	83 7d 18 20          	cmpl   $0x20,0x18(%ebp)
    d403:	7f 17                	jg     d41c <lodepng_inspect+0x51>
    CERROR_RETURN_ERROR(state->error, 27); /*error: the data length is smaller than the length of a PNG header*/
    d405:	8b 45 10             	mov    0x10(%ebp),%eax
    d408:	c7 80 7c 01 00 00 1b 	movl   $0x1b,0x17c(%eax)
    d40f:	00 00 00 
    d412:	b8 1b 00 00 00       	mov    $0x1b,%eax
    d417:	e9 b1 02 00 00       	jmp    d6cd <lodepng_inspect+0x302>
  }

  /*when decoding a new PNG image, make sure all parameters created after previous decoding are reset*/
  /* TODO: remove this. One should use a new LodePNGState for new sessions */
  lodepng_info_cleanup(info);
    d41c:	83 ec 0c             	sub    $0xc,%esp
    d41f:	ff 75 f4             	pushl  -0xc(%ebp)
    d422:	e8 63 c7 ff ff       	call   9b8a <lodepng_info_cleanup>
    d427:	83 c4 10             	add    $0x10,%esp
  lodepng_info_init(info);
    d42a:	83 ec 0c             	sub    $0xc,%esp
    d42d:	ff 75 f4             	pushl  -0xc(%ebp)
    d430:	e8 74 c6 ff ff       	call   9aa9 <lodepng_info_init>
    d435:	83 c4 10             	add    $0x10,%esp

  if(in[0] != 137 || in[1] != 80 || in[2] != 78 || in[3] != 71
    d438:	8b 45 14             	mov    0x14(%ebp),%eax
    d43b:	0f b6 00             	movzbl (%eax),%eax
    d43e:	3c 89                	cmp    $0x89,%al
    d440:	75 5b                	jne    d49d <lodepng_inspect+0xd2>
    d442:	8b 45 14             	mov    0x14(%ebp),%eax
    d445:	83 c0 01             	add    $0x1,%eax
    d448:	0f b6 00             	movzbl (%eax),%eax
    d44b:	3c 50                	cmp    $0x50,%al
    d44d:	75 4e                	jne    d49d <lodepng_inspect+0xd2>
    d44f:	8b 45 14             	mov    0x14(%ebp),%eax
    d452:	83 c0 02             	add    $0x2,%eax
    d455:	0f b6 00             	movzbl (%eax),%eax
    d458:	3c 4e                	cmp    $0x4e,%al
    d45a:	75 41                	jne    d49d <lodepng_inspect+0xd2>
    d45c:	8b 45 14             	mov    0x14(%ebp),%eax
    d45f:	83 c0 03             	add    $0x3,%eax
    d462:	0f b6 00             	movzbl (%eax),%eax
    d465:	3c 47                	cmp    $0x47,%al
    d467:	75 34                	jne    d49d <lodepng_inspect+0xd2>
     || in[4] != 13 || in[5] != 10 || in[6] != 26 || in[7] != 10) {
    d469:	8b 45 14             	mov    0x14(%ebp),%eax
    d46c:	83 c0 04             	add    $0x4,%eax
    d46f:	0f b6 00             	movzbl (%eax),%eax
    d472:	3c 0d                	cmp    $0xd,%al
    d474:	75 27                	jne    d49d <lodepng_inspect+0xd2>
    d476:	8b 45 14             	mov    0x14(%ebp),%eax
    d479:	83 c0 05             	add    $0x5,%eax
    d47c:	0f b6 00             	movzbl (%eax),%eax
    d47f:	3c 0a                	cmp    $0xa,%al
    d481:	75 1a                	jne    d49d <lodepng_inspect+0xd2>
    d483:	8b 45 14             	mov    0x14(%ebp),%eax
    d486:	83 c0 06             	add    $0x6,%eax
    d489:	0f b6 00             	movzbl (%eax),%eax
    d48c:	3c 1a                	cmp    $0x1a,%al
    d48e:	75 0d                	jne    d49d <lodepng_inspect+0xd2>
    d490:	8b 45 14             	mov    0x14(%ebp),%eax
    d493:	83 c0 07             	add    $0x7,%eax
    d496:	0f b6 00             	movzbl (%eax),%eax
    d499:	3c 0a                	cmp    $0xa,%al
    d49b:	74 17                	je     d4b4 <lodepng_inspect+0xe9>
    CERROR_RETURN_ERROR(state->error, 28); /*error: the first 8 bytes are not the correct PNG signature*/
    d49d:	8b 45 10             	mov    0x10(%ebp),%eax
    d4a0:	c7 80 7c 01 00 00 1c 	movl   $0x1c,0x17c(%eax)
    d4a7:	00 00 00 
    d4aa:	b8 1c 00 00 00       	mov    $0x1c,%eax
    d4af:	e9 19 02 00 00       	jmp    d6cd <lodepng_inspect+0x302>
  }
  if(lodepng_chunk_length(in + 8) != 13) {
    d4b4:	8b 45 14             	mov    0x14(%ebp),%eax
    d4b7:	83 c0 08             	add    $0x8,%eax
    d4ba:	83 ec 0c             	sub    $0xc,%esp
    d4bd:	50                   	push   %eax
    d4be:	e8 c2 ae ff ff       	call   8385 <lodepng_chunk_length>
    d4c3:	83 c4 10             	add    $0x10,%esp
    d4c6:	83 f8 0d             	cmp    $0xd,%eax
    d4c9:	74 17                	je     d4e2 <lodepng_inspect+0x117>
    CERROR_RETURN_ERROR(state->error, 94); /*error: header size must be 13 bytes*/
    d4cb:	8b 45 10             	mov    0x10(%ebp),%eax
    d4ce:	c7 80 7c 01 00 00 5e 	movl   $0x5e,0x17c(%eax)
    d4d5:	00 00 00 
    d4d8:	b8 5e 00 00 00       	mov    $0x5e,%eax
    d4dd:	e9 eb 01 00 00       	jmp    d6cd <lodepng_inspect+0x302>
  }
  if(!lodepng_chunk_type_equals(in + 8, "IHDR")) {
    d4e2:	8b 45 14             	mov    0x14(%ebp),%eax
    d4e5:	83 c0 08             	add    $0x8,%eax
    d4e8:	83 ec 08             	sub    $0x8,%esp
    d4eb:	68 2c a1 01 00       	push   $0x1a12c
    d4f0:	50                   	push   %eax
    d4f1:	e8 dc ae ff ff       	call   83d2 <lodepng_chunk_type_equals>
    d4f6:	83 c4 10             	add    $0x10,%esp
    d4f9:	84 c0                	test   %al,%al
    d4fb:	75 17                	jne    d514 <lodepng_inspect+0x149>
    CERROR_RETURN_ERROR(state->error, 29); /*error: it doesn't start with a IHDR chunk!*/
    d4fd:	8b 45 10             	mov    0x10(%ebp),%eax
    d500:	c7 80 7c 01 00 00 1d 	movl   $0x1d,0x17c(%eax)
    d507:	00 00 00 
    d50a:	b8 1d 00 00 00       	mov    $0x1d,%eax
    d50f:	e9 b9 01 00 00       	jmp    d6cd <lodepng_inspect+0x302>
  }

  /*read the values given in the header*/
  width = lodepng_read32bitInt(&in[16]);
    d514:	8b 45 14             	mov    0x14(%ebp),%eax
    d517:	83 c0 10             	add    $0x10,%eax
    d51a:	83 ec 0c             	sub    $0xc,%esp
    d51d:	50                   	push   %eax
    d51e:	e8 5e 62 ff ff       	call   3781 <lodepng_read32bitInt>
    d523:	83 c4 10             	add    $0x10,%esp
    d526:	89 45 f0             	mov    %eax,-0x10(%ebp)
  height = lodepng_read32bitInt(&in[20]);
    d529:	8b 45 14             	mov    0x14(%ebp),%eax
    d52c:	83 c0 14             	add    $0x14,%eax
    d52f:	83 ec 0c             	sub    $0xc,%esp
    d532:	50                   	push   %eax
    d533:	e8 49 62 ff ff       	call   3781 <lodepng_read32bitInt>
    d538:	83 c4 10             	add    $0x10,%esp
    d53b:	89 45 ec             	mov    %eax,-0x14(%ebp)
  /*TODO: remove the undocumented feature that allows to give null pointers to width or height*/
  if(w) *w = width;
    d53e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    d542:	74 08                	je     d54c <lodepng_inspect+0x181>
    d544:	8b 45 08             	mov    0x8(%ebp),%eax
    d547:	8b 55 f0             	mov    -0x10(%ebp),%edx
    d54a:	89 10                	mov    %edx,(%eax)
  if(h) *h = height;
    d54c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    d550:	74 08                	je     d55a <lodepng_inspect+0x18f>
    d552:	8b 45 0c             	mov    0xc(%ebp),%eax
    d555:	8b 55 ec             	mov    -0x14(%ebp),%edx
    d558:	89 10                	mov    %edx,(%eax)
  info->color.bitdepth = in[24];
    d55a:	8b 45 14             	mov    0x14(%ebp),%eax
    d55d:	83 c0 18             	add    $0x18,%eax
    d560:	0f b6 00             	movzbl (%eax),%eax
    d563:	0f b6 d0             	movzbl %al,%edx
    d566:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d569:	89 50 10             	mov    %edx,0x10(%eax)
  info->color.colortype = (LodePNGColorType)in[25];
    d56c:	8b 45 14             	mov    0x14(%ebp),%eax
    d56f:	83 c0 19             	add    $0x19,%eax
    d572:	0f b6 00             	movzbl (%eax),%eax
    d575:	0f b6 d0             	movzbl %al,%edx
    d578:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d57b:	89 50 0c             	mov    %edx,0xc(%eax)
  info->compression_method = in[26];
    d57e:	8b 45 14             	mov    0x14(%ebp),%eax
    d581:	83 c0 1a             	add    $0x1a,%eax
    d584:	0f b6 00             	movzbl (%eax),%eax
    d587:	0f b6 d0             	movzbl %al,%edx
    d58a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d58d:	89 10                	mov    %edx,(%eax)
  info->filter_method = in[27];
    d58f:	8b 45 14             	mov    0x14(%ebp),%eax
    d592:	83 c0 1b             	add    $0x1b,%eax
    d595:	0f b6 00             	movzbl (%eax),%eax
    d598:	0f b6 d0             	movzbl %al,%edx
    d59b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d59e:	89 50 04             	mov    %edx,0x4(%eax)
  info->interlace_method = in[28];
    d5a1:	8b 45 14             	mov    0x14(%ebp),%eax
    d5a4:	83 c0 1c             	add    $0x1c,%eax
    d5a7:	0f b6 00             	movzbl (%eax),%eax
    d5aa:	0f b6 d0             	movzbl %al,%edx
    d5ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d5b0:	89 50 08             	mov    %edx,0x8(%eax)

  /*errors returned only after the parsing so other values are still output*/

  /*error: invalid image size*/
  if(width == 0 || height == 0) CERROR_RETURN_ERROR(state->error, 93);
    d5b3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    d5b7:	74 06                	je     d5bf <lodepng_inspect+0x1f4>
    d5b9:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    d5bd:	75 17                	jne    d5d6 <lodepng_inspect+0x20b>
    d5bf:	8b 45 10             	mov    0x10(%ebp),%eax
    d5c2:	c7 80 7c 01 00 00 5d 	movl   $0x5d,0x17c(%eax)
    d5c9:	00 00 00 
    d5cc:	b8 5d 00 00 00       	mov    $0x5d,%eax
    d5d1:	e9 f7 00 00 00       	jmp    d6cd <lodepng_inspect+0x302>
  /*error: invalid colortype or bitdepth combination*/
  state->error = checkColorValidity(info->color.colortype, info->color.bitdepth);
    d5d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d5d9:	8b 50 10             	mov    0x10(%eax),%edx
    d5dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d5df:	8b 40 0c             	mov    0xc(%eax),%eax
    d5e2:	83 ec 08             	sub    $0x8,%esp
    d5e5:	52                   	push   %edx
    d5e6:	50                   	push   %eax
    d5e7:	e8 d4 b3 ff ff       	call   89c0 <checkColorValidity>
    d5ec:	83 c4 10             	add    $0x10,%esp
    d5ef:	89 c2                	mov    %eax,%edx
    d5f1:	8b 45 10             	mov    0x10(%ebp),%eax
    d5f4:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) return state->error;
    d5fa:	8b 45 10             	mov    0x10(%ebp),%eax
    d5fd:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    d603:	85 c0                	test   %eax,%eax
    d605:	74 0e                	je     d615 <lodepng_inspect+0x24a>
    d607:	8b 45 10             	mov    0x10(%ebp),%eax
    d60a:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    d610:	e9 b8 00 00 00       	jmp    d6cd <lodepng_inspect+0x302>
  /*error: only compression method 0 is allowed in the specification*/
  if(info->compression_method != 0) CERROR_RETURN_ERROR(state->error, 32);
    d615:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d618:	8b 00                	mov    (%eax),%eax
    d61a:	85 c0                	test   %eax,%eax
    d61c:	74 17                	je     d635 <lodepng_inspect+0x26a>
    d61e:	8b 45 10             	mov    0x10(%ebp),%eax
    d621:	c7 80 7c 01 00 00 20 	movl   $0x20,0x17c(%eax)
    d628:	00 00 00 
    d62b:	b8 20 00 00 00       	mov    $0x20,%eax
    d630:	e9 98 00 00 00       	jmp    d6cd <lodepng_inspect+0x302>
  /*error: only filter method 0 is allowed in the specification*/
  if(info->filter_method != 0) CERROR_RETURN_ERROR(state->error, 33);
    d635:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d638:	8b 40 04             	mov    0x4(%eax),%eax
    d63b:	85 c0                	test   %eax,%eax
    d63d:	74 14                	je     d653 <lodepng_inspect+0x288>
    d63f:	8b 45 10             	mov    0x10(%ebp),%eax
    d642:	c7 80 7c 01 00 00 21 	movl   $0x21,0x17c(%eax)
    d649:	00 00 00 
    d64c:	b8 21 00 00 00       	mov    $0x21,%eax
    d651:	eb 7a                	jmp    d6cd <lodepng_inspect+0x302>
  /*error: only interlace methods 0 and 1 exist in the specification*/
  if(info->interlace_method > 1) CERROR_RETURN_ERROR(state->error, 34);
    d653:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d656:	8b 40 08             	mov    0x8(%eax),%eax
    d659:	83 f8 01             	cmp    $0x1,%eax
    d65c:	76 14                	jbe    d672 <lodepng_inspect+0x2a7>
    d65e:	8b 45 10             	mov    0x10(%ebp),%eax
    d661:	c7 80 7c 01 00 00 22 	movl   $0x22,0x17c(%eax)
    d668:	00 00 00 
    d66b:	b8 22 00 00 00       	mov    $0x22,%eax
    d670:	eb 5b                	jmp    d6cd <lodepng_inspect+0x302>

  if(!state->decoder.ignore_crc) {
    d672:	8b 45 10             	mov    0x10(%ebp),%eax
    d675:	8b 40 18             	mov    0x18(%eax),%eax
    d678:	85 c0                	test   %eax,%eax
    d67a:	75 48                	jne    d6c4 <lodepng_inspect+0x2f9>
    unsigned CRC = lodepng_read32bitInt(&in[29]);
    d67c:	8b 45 14             	mov    0x14(%ebp),%eax
    d67f:	83 c0 1d             	add    $0x1d,%eax
    d682:	83 ec 0c             	sub    $0xc,%esp
    d685:	50                   	push   %eax
    d686:	e8 f6 60 ff ff       	call   3781 <lodepng_read32bitInt>
    d68b:	83 c4 10             	add    $0x10,%esp
    d68e:	89 45 e8             	mov    %eax,-0x18(%ebp)
    unsigned checksum = lodepng_crc32(&in[12], 17);
    d691:	8b 45 14             	mov    0x14(%ebp),%eax
    d694:	83 c0 0c             	add    $0xc,%eax
    d697:	83 ec 08             	sub    $0x8,%esp
    d69a:	6a 11                	push   $0x11
    d69c:	50                   	push   %eax
    d69d:	e8 71 ab ff ff       	call   8213 <lodepng_crc32>
    d6a2:	83 c4 10             	add    $0x10,%esp
    d6a5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(CRC != checksum) {
    d6a8:	8b 45 e8             	mov    -0x18(%ebp),%eax
    d6ab:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    d6ae:	74 14                	je     d6c4 <lodepng_inspect+0x2f9>
      CERROR_RETURN_ERROR(state->error, 57); /*invalid CRC*/
    d6b0:	8b 45 10             	mov    0x10(%ebp),%eax
    d6b3:	c7 80 7c 01 00 00 39 	movl   $0x39,0x17c(%eax)
    d6ba:	00 00 00 
    d6bd:	b8 39 00 00 00       	mov    $0x39,%eax
    d6c2:	eb 09                	jmp    d6cd <lodepng_inspect+0x302>
    }
  }

  return state->error;
    d6c4:	8b 45 10             	mov    0x10(%ebp),%eax
    d6c7:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
}
    d6cd:	c9                   	leave  
    d6ce:	c3                   	ret    

0000d6cf <unfilterScanline>:

static unsigned unfilterScanline(unsigned char* recon, const unsigned char* scanline, const unsigned char* precon,
                                 size_t bytewidth, unsigned char filterType, size_t length) {
    d6cf:	55                   	push   %ebp
    d6d0:	89 e5                	mov    %esp,%ebp
    d6d2:	56                   	push   %esi
    d6d3:	53                   	push   %ebx
    d6d4:	83 ec 44             	sub    $0x44,%esp
    d6d7:	8b 45 18             	mov    0x18(%ebp),%eax
    d6da:	88 45 b4             	mov    %al,-0x4c(%ebp)
  the incoming scanlines do NOT include the filtertype byte, that one is given in the parameter filterType instead
  recon and scanline MAY be the same memory address! precon must be disjoint.
  */

  size_t i;
  switch(filterType) {
    d6dd:	0f b6 45 b4          	movzbl -0x4c(%ebp),%eax
    d6e1:	83 f8 04             	cmp    $0x4,%eax
    d6e4:	0f 87 81 07 00 00    	ja     de6b <unfilterScanline+0x79c>
    d6ea:	8b 04 85 34 a1 01 00 	mov    0x1a134(,%eax,4),%eax
    d6f1:	ff e0                	jmp    *%eax
    case 0:
      for(i = 0; i != length; ++i) recon[i] = scanline[i];
    d6f3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d6fa:	eb 19                	jmp    d715 <unfilterScanline+0x46>
    d6fc:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d6ff:	8b 45 08             	mov    0x8(%ebp),%eax
    d702:	01 c2                	add    %eax,%edx
    d704:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d707:	8b 45 0c             	mov    0xc(%ebp),%eax
    d70a:	01 c8                	add    %ecx,%eax
    d70c:	0f b6 00             	movzbl (%eax),%eax
    d70f:	88 02                	mov    %al,(%edx)
    d711:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d715:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d718:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d71b:	75 df                	jne    d6fc <unfilterScanline+0x2d>
      break;
    d71d:	e9 50 07 00 00       	jmp    de72 <unfilterScanline+0x7a3>
    case 1:
      for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
    d722:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d729:	eb 19                	jmp    d744 <unfilterScanline+0x75>
    d72b:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d72e:	8b 45 08             	mov    0x8(%ebp),%eax
    d731:	01 c2                	add    %eax,%edx
    d733:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d736:	8b 45 0c             	mov    0xc(%ebp),%eax
    d739:	01 c8                	add    %ecx,%eax
    d73b:	0f b6 00             	movzbl (%eax),%eax
    d73e:	88 02                	mov    %al,(%edx)
    d740:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d744:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d747:	3b 45 14             	cmp    0x14(%ebp),%eax
    d74a:	75 df                	jne    d72b <unfilterScanline+0x5c>
      for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + recon[i - bytewidth];
    d74c:	8b 45 14             	mov    0x14(%ebp),%eax
    d74f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    d752:	eb 2b                	jmp    d77f <unfilterScanline+0xb0>
    d754:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d757:	8b 45 08             	mov    0x8(%ebp),%eax
    d75a:	01 c2                	add    %eax,%edx
    d75c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d75f:	8b 45 0c             	mov    0xc(%ebp),%eax
    d762:	01 c8                	add    %ecx,%eax
    d764:	0f b6 08             	movzbl (%eax),%ecx
    d767:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d76a:	2b 45 14             	sub    0x14(%ebp),%eax
    d76d:	89 c3                	mov    %eax,%ebx
    d76f:	8b 45 08             	mov    0x8(%ebp),%eax
    d772:	01 d8                	add    %ebx,%eax
    d774:	0f b6 00             	movzbl (%eax),%eax
    d777:	01 c8                	add    %ecx,%eax
    d779:	88 02                	mov    %al,(%edx)
    d77b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d77f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d782:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d785:	7c cd                	jl     d754 <unfilterScanline+0x85>
      break;
    d787:	e9 e6 06 00 00       	jmp    de72 <unfilterScanline+0x7a3>
    case 2:
      if(precon) {
    d78c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    d790:	74 3c                	je     d7ce <unfilterScanline+0xff>
        for(i = 0; i != length; ++i) recon[i] = scanline[i] + precon[i];
    d792:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d799:	eb 26                	jmp    d7c1 <unfilterScanline+0xf2>
    d79b:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d79e:	8b 45 08             	mov    0x8(%ebp),%eax
    d7a1:	01 d0                	add    %edx,%eax
    d7a3:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d7a6:	8b 55 0c             	mov    0xc(%ebp),%edx
    d7a9:	01 ca                	add    %ecx,%edx
    d7ab:	0f b6 0a             	movzbl (%edx),%ecx
    d7ae:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    d7b1:	8b 55 10             	mov    0x10(%ebp),%edx
    d7b4:	01 da                	add    %ebx,%edx
    d7b6:	0f b6 12             	movzbl (%edx),%edx
    d7b9:	01 ca                	add    %ecx,%edx
    d7bb:	88 10                	mov    %dl,(%eax)
    d7bd:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d7c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d7c4:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d7c7:	75 d2                	jne    d79b <unfilterScanline+0xcc>
      } else {
        for(i = 0; i != length; ++i) recon[i] = scanline[i];
      }
      break;
    d7c9:	e9 a4 06 00 00       	jmp    de72 <unfilterScanline+0x7a3>
      break;
    case 2:
      if(precon) {
        for(i = 0; i != length; ++i) recon[i] = scanline[i] + precon[i];
      } else {
        for(i = 0; i != length; ++i) recon[i] = scanline[i];
    d7ce:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d7d5:	eb 19                	jmp    d7f0 <unfilterScanline+0x121>
    d7d7:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d7da:	8b 45 08             	mov    0x8(%ebp),%eax
    d7dd:	01 c2                	add    %eax,%edx
    d7df:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d7e2:	8b 45 0c             	mov    0xc(%ebp),%eax
    d7e5:	01 c8                	add    %ecx,%eax
    d7e7:	0f b6 00             	movzbl (%eax),%eax
    d7ea:	88 02                	mov    %al,(%edx)
    d7ec:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d7f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d7f3:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d7f6:	75 df                	jne    d7d7 <unfilterScanline+0x108>
      }
      break;
    d7f8:	e9 75 06 00 00       	jmp    de72 <unfilterScanline+0x7a3>
    case 3:
      if(precon) {
    d7fd:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    d801:	0f 84 8e 00 00 00    	je     d895 <unfilterScanline+0x1c6>
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i] + (precon[i] >> 1u);
    d807:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d80e:	eb 28                	jmp    d838 <unfilterScanline+0x169>
    d810:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d813:	8b 45 08             	mov    0x8(%ebp),%eax
    d816:	01 d0                	add    %edx,%eax
    d818:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d81b:	8b 55 0c             	mov    0xc(%ebp),%edx
    d81e:	01 ca                	add    %ecx,%edx
    d820:	0f b6 12             	movzbl (%edx),%edx
    d823:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    d826:	8b 4d 10             	mov    0x10(%ebp),%ecx
    d829:	01 d9                	add    %ebx,%ecx
    d82b:	0f b6 09             	movzbl (%ecx),%ecx
    d82e:	d0 e9                	shr    %cl
    d830:	01 ca                	add    %ecx,%edx
    d832:	88 10                	mov    %dl,(%eax)
    d834:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d838:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d83b:	3b 45 14             	cmp    0x14(%ebp),%eax
    d83e:	75 d0                	jne    d810 <unfilterScanline+0x141>
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + ((recon[i - bytewidth] + precon[i]) >> 1u);
    d840:	8b 45 14             	mov    0x14(%ebp),%eax
    d843:	89 45 f4             	mov    %eax,-0xc(%ebp)
    d846:	eb 40                	jmp    d888 <unfilterScanline+0x1b9>
    d848:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d84b:	8b 45 08             	mov    0x8(%ebp),%eax
    d84e:	01 c2                	add    %eax,%edx
    d850:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d853:	8b 45 0c             	mov    0xc(%ebp),%eax
    d856:	01 c8                	add    %ecx,%eax
    d858:	0f b6 08             	movzbl (%eax),%ecx
    d85b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d85e:	2b 45 14             	sub    0x14(%ebp),%eax
    d861:	89 c3                	mov    %eax,%ebx
    d863:	8b 45 08             	mov    0x8(%ebp),%eax
    d866:	01 d8                	add    %ebx,%eax
    d868:	0f b6 00             	movzbl (%eax),%eax
    d86b:	0f b6 d8             	movzbl %al,%ebx
    d86e:	8b 75 f4             	mov    -0xc(%ebp),%esi
    d871:	8b 45 10             	mov    0x10(%ebp),%eax
    d874:	01 f0                	add    %esi,%eax
    d876:	0f b6 00             	movzbl (%eax),%eax
    d879:	0f b6 c0             	movzbl %al,%eax
    d87c:	01 d8                	add    %ebx,%eax
    d87e:	d1 f8                	sar    %eax
    d880:	01 c8                	add    %ecx,%eax
    d882:	88 02                	mov    %al,(%edx)
    d884:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d888:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d88b:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d88e:	7c b8                	jl     d848 <unfilterScanline+0x179>
      } else {
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + (recon[i - bytewidth] >> 1u);
      }
      break;
    d890:	e9 dd 05 00 00       	jmp    de72 <unfilterScanline+0x7a3>
    case 3:
      if(precon) {
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i] + (precon[i] >> 1u);
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + ((recon[i - bytewidth] + precon[i]) >> 1u);
      } else {
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
    d895:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d89c:	eb 19                	jmp    d8b7 <unfilterScanline+0x1e8>
    d89e:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d8a1:	8b 45 08             	mov    0x8(%ebp),%eax
    d8a4:	01 c2                	add    %eax,%edx
    d8a6:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d8a9:	8b 45 0c             	mov    0xc(%ebp),%eax
    d8ac:	01 c8                	add    %ecx,%eax
    d8ae:	0f b6 00             	movzbl (%eax),%eax
    d8b1:	88 02                	mov    %al,(%edx)
    d8b3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d8b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d8ba:	3b 45 14             	cmp    0x14(%ebp),%eax
    d8bd:	75 df                	jne    d89e <unfilterScanline+0x1cf>
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + (recon[i - bytewidth] >> 1u);
    d8bf:	8b 45 14             	mov    0x14(%ebp),%eax
    d8c2:	89 45 f4             	mov    %eax,-0xc(%ebp)
    d8c5:	eb 2d                	jmp    d8f4 <unfilterScanline+0x225>
    d8c7:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d8ca:	8b 45 08             	mov    0x8(%ebp),%eax
    d8cd:	01 c2                	add    %eax,%edx
    d8cf:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d8d2:	8b 45 0c             	mov    0xc(%ebp),%eax
    d8d5:	01 c8                	add    %ecx,%eax
    d8d7:	0f b6 08             	movzbl (%eax),%ecx
    d8da:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d8dd:	2b 45 14             	sub    0x14(%ebp),%eax
    d8e0:	89 c3                	mov    %eax,%ebx
    d8e2:	8b 45 08             	mov    0x8(%ebp),%eax
    d8e5:	01 d8                	add    %ebx,%eax
    d8e7:	0f b6 00             	movzbl (%eax),%eax
    d8ea:	d0 e8                	shr    %al
    d8ec:	01 c8                	add    %ecx,%eax
    d8ee:	88 02                	mov    %al,(%edx)
    d8f0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d8f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d8f7:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d8fa:	7c cb                	jl     d8c7 <unfilterScanline+0x1f8>
      }
      break;
    d8fc:	e9 71 05 00 00       	jmp    de72 <unfilterScanline+0x7a3>
    case 4:
      if(precon) {
    d901:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    d905:	0f 84 f9 04 00 00    	je     de04 <unfilterScanline+0x735>
        for(i = 0; i != bytewidth; ++i) {
    d90b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d912:	eb 26                	jmp    d93a <unfilterScanline+0x26b>
          recon[i] = (scanline[i] + precon[i]); /*paethPredictor(0, precon[i], 0) is always precon[i]*/
    d914:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d917:	8b 45 08             	mov    0x8(%ebp),%eax
    d91a:	01 d0                	add    %edx,%eax
    d91c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d91f:	8b 55 0c             	mov    0xc(%ebp),%edx
    d922:	01 ca                	add    %ecx,%edx
    d924:	0f b6 0a             	movzbl (%edx),%ecx
    d927:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    d92a:	8b 55 10             	mov    0x10(%ebp),%edx
    d92d:	01 da                	add    %ebx,%edx
    d92f:	0f b6 12             	movzbl (%edx),%edx
    d932:	01 ca                	add    %ecx,%edx
    d934:	88 10                	mov    %dl,(%eax)
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + (recon[i - bytewidth] >> 1u);
      }
      break;
    case 4:
      if(precon) {
        for(i = 0; i != bytewidth; ++i) {
    d936:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d93a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d93d:	3b 45 14             	cmp    0x14(%ebp),%eax
    d940:	75 d2                	jne    d914 <unfilterScanline+0x245>
          recon[i] = (scanline[i] + precon[i]); /*paethPredictor(0, precon[i], 0) is always precon[i]*/
        }

        /* Unroll independent paths of the paeth predictor. A 6x and 8x version would also be possible but that
        adds too much code. Whether this actually speeds anything up at all depends on compiler and settings. */
        if(bytewidth >= 4) {
    d942:	83 7d 14 03          	cmpl   $0x3,0x14(%ebp)
    d946:	0f 8e db 01 00 00    	jle    db27 <unfilterScanline+0x458>
          for(; i + 3 < length; i += 4) {
    d94c:	e9 c2 01 00 00       	jmp    db13 <unfilterScanline+0x444>
            size_t j = i - bytewidth;
    d951:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d954:	2b 45 14             	sub    0x14(%ebp),%eax
    d957:	89 45 f0             	mov    %eax,-0x10(%ebp)
            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1], s2 = scanline[i + 2], s3 = scanline[i + 3];
    d95a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d95d:	8b 45 0c             	mov    0xc(%ebp),%eax
    d960:	01 d0                	add    %edx,%eax
    d962:	0f b6 00             	movzbl (%eax),%eax
    d965:	88 45 ef             	mov    %al,-0x11(%ebp)
    d968:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d96b:	8d 50 01             	lea    0x1(%eax),%edx
    d96e:	8b 45 0c             	mov    0xc(%ebp),%eax
    d971:	01 d0                	add    %edx,%eax
    d973:	0f b6 00             	movzbl (%eax),%eax
    d976:	88 45 ee             	mov    %al,-0x12(%ebp)
    d979:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d97c:	8d 50 02             	lea    0x2(%eax),%edx
    d97f:	8b 45 0c             	mov    0xc(%ebp),%eax
    d982:	01 d0                	add    %edx,%eax
    d984:	0f b6 00             	movzbl (%eax),%eax
    d987:	88 45 ed             	mov    %al,-0x13(%ebp)
    d98a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d98d:	8d 50 03             	lea    0x3(%eax),%edx
    d990:	8b 45 0c             	mov    0xc(%ebp),%eax
    d993:	01 d0                	add    %edx,%eax
    d995:	0f b6 00             	movzbl (%eax),%eax
    d998:	88 45 ec             	mov    %al,-0x14(%ebp)
            unsigned char r0 = recon[j + 0], r1 = recon[j + 1], r2 = recon[j + 2], r3 = recon[j + 3];
    d99b:	8b 55 f0             	mov    -0x10(%ebp),%edx
    d99e:	8b 45 08             	mov    0x8(%ebp),%eax
    d9a1:	01 d0                	add    %edx,%eax
    d9a3:	0f b6 00             	movzbl (%eax),%eax
    d9a6:	88 45 eb             	mov    %al,-0x15(%ebp)
    d9a9:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d9ac:	8d 50 01             	lea    0x1(%eax),%edx
    d9af:	8b 45 08             	mov    0x8(%ebp),%eax
    d9b2:	01 d0                	add    %edx,%eax
    d9b4:	0f b6 00             	movzbl (%eax),%eax
    d9b7:	88 45 ea             	mov    %al,-0x16(%ebp)
    d9ba:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d9bd:	8d 50 02             	lea    0x2(%eax),%edx
    d9c0:	8b 45 08             	mov    0x8(%ebp),%eax
    d9c3:	01 d0                	add    %edx,%eax
    d9c5:	0f b6 00             	movzbl (%eax),%eax
    d9c8:	88 45 e9             	mov    %al,-0x17(%ebp)
    d9cb:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d9ce:	8d 50 03             	lea    0x3(%eax),%edx
    d9d1:	8b 45 08             	mov    0x8(%ebp),%eax
    d9d4:	01 d0                	add    %edx,%eax
    d9d6:	0f b6 00             	movzbl (%eax),%eax
    d9d9:	88 45 e8             	mov    %al,-0x18(%ebp)
            unsigned char p0 = precon[i + 0], p1 = precon[i + 1], p2 = precon[i + 2], p3 = precon[i + 3];
    d9dc:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d9df:	8b 45 10             	mov    0x10(%ebp),%eax
    d9e2:	01 d0                	add    %edx,%eax
    d9e4:	0f b6 00             	movzbl (%eax),%eax
    d9e7:	88 45 e7             	mov    %al,-0x19(%ebp)
    d9ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d9ed:	8d 50 01             	lea    0x1(%eax),%edx
    d9f0:	8b 45 10             	mov    0x10(%ebp),%eax
    d9f3:	01 d0                	add    %edx,%eax
    d9f5:	0f b6 00             	movzbl (%eax),%eax
    d9f8:	88 45 e6             	mov    %al,-0x1a(%ebp)
    d9fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d9fe:	8d 50 02             	lea    0x2(%eax),%edx
    da01:	8b 45 10             	mov    0x10(%ebp),%eax
    da04:	01 d0                	add    %edx,%eax
    da06:	0f b6 00             	movzbl (%eax),%eax
    da09:	88 45 e5             	mov    %al,-0x1b(%ebp)
    da0c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    da0f:	8d 50 03             	lea    0x3(%eax),%edx
    da12:	8b 45 10             	mov    0x10(%ebp),%eax
    da15:	01 d0                	add    %edx,%eax
    da17:	0f b6 00             	movzbl (%eax),%eax
    da1a:	88 45 e4             	mov    %al,-0x1c(%ebp)
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2], q3 = precon[j + 3];
    da1d:	8b 55 f0             	mov    -0x10(%ebp),%edx
    da20:	8b 45 10             	mov    0x10(%ebp),%eax
    da23:	01 d0                	add    %edx,%eax
    da25:	0f b6 00             	movzbl (%eax),%eax
    da28:	88 45 e3             	mov    %al,-0x1d(%ebp)
    da2b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    da2e:	8d 50 01             	lea    0x1(%eax),%edx
    da31:	8b 45 10             	mov    0x10(%ebp),%eax
    da34:	01 d0                	add    %edx,%eax
    da36:	0f b6 00             	movzbl (%eax),%eax
    da39:	88 45 e2             	mov    %al,-0x1e(%ebp)
    da3c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    da3f:	8d 50 02             	lea    0x2(%eax),%edx
    da42:	8b 45 10             	mov    0x10(%ebp),%eax
    da45:	01 d0                	add    %edx,%eax
    da47:	0f b6 00             	movzbl (%eax),%eax
    da4a:	88 45 e1             	mov    %al,-0x1f(%ebp)
    da4d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    da50:	8d 50 03             	lea    0x3(%eax),%edx
    da53:	8b 45 10             	mov    0x10(%ebp),%eax
    da56:	01 d0                	add    %edx,%eax
    da58:	0f b6 00             	movzbl (%eax),%eax
    da5b:	88 45 e0             	mov    %al,-0x20(%ebp)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
    da5e:	8b 55 f4             	mov    -0xc(%ebp),%edx
    da61:	8b 45 08             	mov    0x8(%ebp),%eax
    da64:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    da67:	0f b6 4d e3          	movzbl -0x1d(%ebp),%ecx
    da6b:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
    da6f:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
    da73:	51                   	push   %ecx
    da74:	52                   	push   %edx
    da75:	50                   	push   %eax
    da76:	e8 3f f6 ff ff       	call   d0ba <paethPredictor>
    da7b:	83 c4 0c             	add    $0xc,%esp
    da7e:	89 c2                	mov    %eax,%edx
    da80:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
    da84:	01 d0                	add    %edx,%eax
    da86:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
    da88:	8b 45 f4             	mov    -0xc(%ebp),%eax
    da8b:	8d 50 01             	lea    0x1(%eax),%edx
    da8e:	8b 45 08             	mov    0x8(%ebp),%eax
    da91:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    da94:	0f b6 4d e2          	movzbl -0x1e(%ebp),%ecx
    da98:	0f b6 55 e6          	movzbl -0x1a(%ebp),%edx
    da9c:	0f b6 45 ea          	movzbl -0x16(%ebp),%eax
    daa0:	51                   	push   %ecx
    daa1:	52                   	push   %edx
    daa2:	50                   	push   %eax
    daa3:	e8 12 f6 ff ff       	call   d0ba <paethPredictor>
    daa8:	83 c4 0c             	add    $0xc,%esp
    daab:	89 c2                	mov    %eax,%edx
    daad:	0f b6 45 ee          	movzbl -0x12(%ebp),%eax
    dab1:	01 d0                	add    %edx,%eax
    dab3:	88 03                	mov    %al,(%ebx)
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
    dab5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dab8:	8d 50 02             	lea    0x2(%eax),%edx
    dabb:	8b 45 08             	mov    0x8(%ebp),%eax
    dabe:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    dac1:	0f b6 4d e1          	movzbl -0x1f(%ebp),%ecx
    dac5:	0f b6 55 e5          	movzbl -0x1b(%ebp),%edx
    dac9:	0f b6 45 e9          	movzbl -0x17(%ebp),%eax
    dacd:	51                   	push   %ecx
    dace:	52                   	push   %edx
    dacf:	50                   	push   %eax
    dad0:	e8 e5 f5 ff ff       	call   d0ba <paethPredictor>
    dad5:	83 c4 0c             	add    $0xc,%esp
    dad8:	89 c2                	mov    %eax,%edx
    dada:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
    dade:	01 d0                	add    %edx,%eax
    dae0:	88 03                	mov    %al,(%ebx)
            recon[i + 3] = s3 + paethPredictor(r3, p3, q3);
    dae2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dae5:	8d 50 03             	lea    0x3(%eax),%edx
    dae8:	8b 45 08             	mov    0x8(%ebp),%eax
    daeb:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    daee:	0f b6 4d e0          	movzbl -0x20(%ebp),%ecx
    daf2:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    daf6:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    dafa:	51                   	push   %ecx
    dafb:	52                   	push   %edx
    dafc:	50                   	push   %eax
    dafd:	e8 b8 f5 ff ff       	call   d0ba <paethPredictor>
    db02:	83 c4 0c             	add    $0xc,%esp
    db05:	89 c2                	mov    %eax,%edx
    db07:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
    db0b:	01 d0                	add    %edx,%eax
    db0d:	88 03                	mov    %al,(%ebx)
        }

        /* Unroll independent paths of the paeth predictor. A 6x and 8x version would also be possible but that
        adds too much code. Whether this actually speeds anything up at all depends on compiler and settings. */
        if(bytewidth >= 4) {
          for(; i + 3 < length; i += 4) {
    db0f:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
    db13:	8b 45 f4             	mov    -0xc(%ebp),%eax
    db16:	83 c0 03             	add    $0x3,%eax
    db19:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    db1c:	0f 8c 2f fe ff ff    	jl     d951 <unfilterScanline+0x282>
    db22:	e9 d3 02 00 00       	jmp    ddfa <unfilterScanline+0x72b>
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
            recon[i + 3] = s3 + paethPredictor(r3, p3, q3);
          }
        } else if(bytewidth >= 3) {
    db27:	83 7d 14 02          	cmpl   $0x2,0x14(%ebp)
    db2b:	0f 8e 6a 01 00 00    	jle    dc9b <unfilterScanline+0x5cc>
          for(; i + 2 < length; i += 3) {
    db31:	e9 51 01 00 00       	jmp    dc87 <unfilterScanline+0x5b8>
            size_t j = i - bytewidth;
    db36:	8b 45 f4             	mov    -0xc(%ebp),%eax
    db39:	2b 45 14             	sub    0x14(%ebp),%eax
    db3c:	89 45 dc             	mov    %eax,-0x24(%ebp)
            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1], s2 = scanline[i + 2];
    db3f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    db42:	8b 45 0c             	mov    0xc(%ebp),%eax
    db45:	01 d0                	add    %edx,%eax
    db47:	0f b6 00             	movzbl (%eax),%eax
    db4a:	88 45 db             	mov    %al,-0x25(%ebp)
    db4d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    db50:	8d 50 01             	lea    0x1(%eax),%edx
    db53:	8b 45 0c             	mov    0xc(%ebp),%eax
    db56:	01 d0                	add    %edx,%eax
    db58:	0f b6 00             	movzbl (%eax),%eax
    db5b:	88 45 da             	mov    %al,-0x26(%ebp)
    db5e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    db61:	8d 50 02             	lea    0x2(%eax),%edx
    db64:	8b 45 0c             	mov    0xc(%ebp),%eax
    db67:	01 d0                	add    %edx,%eax
    db69:	0f b6 00             	movzbl (%eax),%eax
    db6c:	88 45 d9             	mov    %al,-0x27(%ebp)
            unsigned char r0 = recon[j + 0], r1 = recon[j + 1], r2 = recon[j + 2];
    db6f:	8b 55 dc             	mov    -0x24(%ebp),%edx
    db72:	8b 45 08             	mov    0x8(%ebp),%eax
    db75:	01 d0                	add    %edx,%eax
    db77:	0f b6 00             	movzbl (%eax),%eax
    db7a:	88 45 d8             	mov    %al,-0x28(%ebp)
    db7d:	8b 45 dc             	mov    -0x24(%ebp),%eax
    db80:	8d 50 01             	lea    0x1(%eax),%edx
    db83:	8b 45 08             	mov    0x8(%ebp),%eax
    db86:	01 d0                	add    %edx,%eax
    db88:	0f b6 00             	movzbl (%eax),%eax
    db8b:	88 45 d7             	mov    %al,-0x29(%ebp)
    db8e:	8b 45 dc             	mov    -0x24(%ebp),%eax
    db91:	8d 50 02             	lea    0x2(%eax),%edx
    db94:	8b 45 08             	mov    0x8(%ebp),%eax
    db97:	01 d0                	add    %edx,%eax
    db99:	0f b6 00             	movzbl (%eax),%eax
    db9c:	88 45 d6             	mov    %al,-0x2a(%ebp)
            unsigned char p0 = precon[i + 0], p1 = precon[i + 1], p2 = precon[i + 2];
    db9f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dba2:	8b 45 10             	mov    0x10(%ebp),%eax
    dba5:	01 d0                	add    %edx,%eax
    dba7:	0f b6 00             	movzbl (%eax),%eax
    dbaa:	88 45 d5             	mov    %al,-0x2b(%ebp)
    dbad:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dbb0:	8d 50 01             	lea    0x1(%eax),%edx
    dbb3:	8b 45 10             	mov    0x10(%ebp),%eax
    dbb6:	01 d0                	add    %edx,%eax
    dbb8:	0f b6 00             	movzbl (%eax),%eax
    dbbb:	88 45 d4             	mov    %al,-0x2c(%ebp)
    dbbe:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dbc1:	8d 50 02             	lea    0x2(%eax),%edx
    dbc4:	8b 45 10             	mov    0x10(%ebp),%eax
    dbc7:	01 d0                	add    %edx,%eax
    dbc9:	0f b6 00             	movzbl (%eax),%eax
    dbcc:	88 45 d3             	mov    %al,-0x2d(%ebp)
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2];
    dbcf:	8b 55 dc             	mov    -0x24(%ebp),%edx
    dbd2:	8b 45 10             	mov    0x10(%ebp),%eax
    dbd5:	01 d0                	add    %edx,%eax
    dbd7:	0f b6 00             	movzbl (%eax),%eax
    dbda:	88 45 d2             	mov    %al,-0x2e(%ebp)
    dbdd:	8b 45 dc             	mov    -0x24(%ebp),%eax
    dbe0:	8d 50 01             	lea    0x1(%eax),%edx
    dbe3:	8b 45 10             	mov    0x10(%ebp),%eax
    dbe6:	01 d0                	add    %edx,%eax
    dbe8:	0f b6 00             	movzbl (%eax),%eax
    dbeb:	88 45 d1             	mov    %al,-0x2f(%ebp)
    dbee:	8b 45 dc             	mov    -0x24(%ebp),%eax
    dbf1:	8d 50 02             	lea    0x2(%eax),%edx
    dbf4:	8b 45 10             	mov    0x10(%ebp),%eax
    dbf7:	01 d0                	add    %edx,%eax
    dbf9:	0f b6 00             	movzbl (%eax),%eax
    dbfc:	88 45 d0             	mov    %al,-0x30(%ebp)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
    dbff:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dc02:	8b 45 08             	mov    0x8(%ebp),%eax
    dc05:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    dc08:	0f b6 4d d2          	movzbl -0x2e(%ebp),%ecx
    dc0c:	0f b6 55 d5          	movzbl -0x2b(%ebp),%edx
    dc10:	0f b6 45 d8          	movzbl -0x28(%ebp),%eax
    dc14:	51                   	push   %ecx
    dc15:	52                   	push   %edx
    dc16:	50                   	push   %eax
    dc17:	e8 9e f4 ff ff       	call   d0ba <paethPredictor>
    dc1c:	83 c4 0c             	add    $0xc,%esp
    dc1f:	89 c2                	mov    %eax,%edx
    dc21:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
    dc25:	01 d0                	add    %edx,%eax
    dc27:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
    dc29:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dc2c:	8d 50 01             	lea    0x1(%eax),%edx
    dc2f:	8b 45 08             	mov    0x8(%ebp),%eax
    dc32:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    dc35:	0f b6 4d d1          	movzbl -0x2f(%ebp),%ecx
    dc39:	0f b6 55 d4          	movzbl -0x2c(%ebp),%edx
    dc3d:	0f b6 45 d7          	movzbl -0x29(%ebp),%eax
    dc41:	51                   	push   %ecx
    dc42:	52                   	push   %edx
    dc43:	50                   	push   %eax
    dc44:	e8 71 f4 ff ff       	call   d0ba <paethPredictor>
    dc49:	83 c4 0c             	add    $0xc,%esp
    dc4c:	89 c2                	mov    %eax,%edx
    dc4e:	0f b6 45 da          	movzbl -0x26(%ebp),%eax
    dc52:	01 d0                	add    %edx,%eax
    dc54:	88 03                	mov    %al,(%ebx)
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
    dc56:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dc59:	8d 50 02             	lea    0x2(%eax),%edx
    dc5c:	8b 45 08             	mov    0x8(%ebp),%eax
    dc5f:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    dc62:	0f b6 4d d0          	movzbl -0x30(%ebp),%ecx
    dc66:	0f b6 55 d3          	movzbl -0x2d(%ebp),%edx
    dc6a:	0f b6 45 d6          	movzbl -0x2a(%ebp),%eax
    dc6e:	51                   	push   %ecx
    dc6f:	52                   	push   %edx
    dc70:	50                   	push   %eax
    dc71:	e8 44 f4 ff ff       	call   d0ba <paethPredictor>
    dc76:	83 c4 0c             	add    $0xc,%esp
    dc79:	89 c2                	mov    %eax,%edx
    dc7b:	0f b6 45 d9          	movzbl -0x27(%ebp),%eax
    dc7f:	01 d0                	add    %edx,%eax
    dc81:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
            recon[i + 3] = s3 + paethPredictor(r3, p3, q3);
          }
        } else if(bytewidth >= 3) {
          for(; i + 2 < length; i += 3) {
    dc83:	83 45 f4 03          	addl   $0x3,-0xc(%ebp)
    dc87:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dc8a:	83 c0 02             	add    $0x2,%eax
    dc8d:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    dc90:	0f 8c a0 fe ff ff    	jl     db36 <unfilterScanline+0x467>
    dc96:	e9 5f 01 00 00       	jmp    ddfa <unfilterScanline+0x72b>
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2];
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
          }
        } else if(bytewidth >= 2) {
    dc9b:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
    dc9f:	0f 8e 55 01 00 00    	jle    ddfa <unfilterScanline+0x72b>
          for(; i + 1 < length; i += 2) {
    dca5:	e9 e0 00 00 00       	jmp    dd8a <unfilterScanline+0x6bb>
            size_t j = i - bytewidth;
    dcaa:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dcad:	2b 45 14             	sub    0x14(%ebp),%eax
    dcb0:	89 45 cc             	mov    %eax,-0x34(%ebp)
            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1];
    dcb3:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dcb6:	8b 45 0c             	mov    0xc(%ebp),%eax
    dcb9:	01 d0                	add    %edx,%eax
    dcbb:	0f b6 00             	movzbl (%eax),%eax
    dcbe:	88 45 cb             	mov    %al,-0x35(%ebp)
    dcc1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dcc4:	8d 50 01             	lea    0x1(%eax),%edx
    dcc7:	8b 45 0c             	mov    0xc(%ebp),%eax
    dcca:	01 d0                	add    %edx,%eax
    dccc:	0f b6 00             	movzbl (%eax),%eax
    dccf:	88 45 ca             	mov    %al,-0x36(%ebp)
            unsigned char r0 = recon[j + 0], r1 = recon[j + 1];
    dcd2:	8b 55 cc             	mov    -0x34(%ebp),%edx
    dcd5:	8b 45 08             	mov    0x8(%ebp),%eax
    dcd8:	01 d0                	add    %edx,%eax
    dcda:	0f b6 00             	movzbl (%eax),%eax
    dcdd:	88 45 c9             	mov    %al,-0x37(%ebp)
    dce0:	8b 45 cc             	mov    -0x34(%ebp),%eax
    dce3:	8d 50 01             	lea    0x1(%eax),%edx
    dce6:	8b 45 08             	mov    0x8(%ebp),%eax
    dce9:	01 d0                	add    %edx,%eax
    dceb:	0f b6 00             	movzbl (%eax),%eax
    dcee:	88 45 c8             	mov    %al,-0x38(%ebp)
            unsigned char p0 = precon[i + 0], p1 = precon[i + 1];
    dcf1:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dcf4:	8b 45 10             	mov    0x10(%ebp),%eax
    dcf7:	01 d0                	add    %edx,%eax
    dcf9:	0f b6 00             	movzbl (%eax),%eax
    dcfc:	88 45 c7             	mov    %al,-0x39(%ebp)
    dcff:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dd02:	8d 50 01             	lea    0x1(%eax),%edx
    dd05:	8b 45 10             	mov    0x10(%ebp),%eax
    dd08:	01 d0                	add    %edx,%eax
    dd0a:	0f b6 00             	movzbl (%eax),%eax
    dd0d:	88 45 c6             	mov    %al,-0x3a(%ebp)
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1];
    dd10:	8b 55 cc             	mov    -0x34(%ebp),%edx
    dd13:	8b 45 10             	mov    0x10(%ebp),%eax
    dd16:	01 d0                	add    %edx,%eax
    dd18:	0f b6 00             	movzbl (%eax),%eax
    dd1b:	88 45 c5             	mov    %al,-0x3b(%ebp)
    dd1e:	8b 45 cc             	mov    -0x34(%ebp),%eax
    dd21:	8d 50 01             	lea    0x1(%eax),%edx
    dd24:	8b 45 10             	mov    0x10(%ebp),%eax
    dd27:	01 d0                	add    %edx,%eax
    dd29:	0f b6 00             	movzbl (%eax),%eax
    dd2c:	88 45 c4             	mov    %al,-0x3c(%ebp)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
    dd2f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dd32:	8b 45 08             	mov    0x8(%ebp),%eax
    dd35:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    dd38:	0f b6 4d c5          	movzbl -0x3b(%ebp),%ecx
    dd3c:	0f b6 55 c7          	movzbl -0x39(%ebp),%edx
    dd40:	0f b6 45 c9          	movzbl -0x37(%ebp),%eax
    dd44:	51                   	push   %ecx
    dd45:	52                   	push   %edx
    dd46:	50                   	push   %eax
    dd47:	e8 6e f3 ff ff       	call   d0ba <paethPredictor>
    dd4c:	83 c4 0c             	add    $0xc,%esp
    dd4f:	89 c2                	mov    %eax,%edx
    dd51:	0f b6 45 cb          	movzbl -0x35(%ebp),%eax
    dd55:	01 d0                	add    %edx,%eax
    dd57:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
    dd59:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dd5c:	8d 50 01             	lea    0x1(%eax),%edx
    dd5f:	8b 45 08             	mov    0x8(%ebp),%eax
    dd62:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    dd65:	0f b6 4d c4          	movzbl -0x3c(%ebp),%ecx
    dd69:	0f b6 55 c6          	movzbl -0x3a(%ebp),%edx
    dd6d:	0f b6 45 c8          	movzbl -0x38(%ebp),%eax
    dd71:	51                   	push   %ecx
    dd72:	52                   	push   %edx
    dd73:	50                   	push   %eax
    dd74:	e8 41 f3 ff ff       	call   d0ba <paethPredictor>
    dd79:	83 c4 0c             	add    $0xc,%esp
    dd7c:	89 c2                	mov    %eax,%edx
    dd7e:	0f b6 45 ca          	movzbl -0x36(%ebp),%eax
    dd82:	01 d0                	add    %edx,%eax
    dd84:	88 03                	mov    %al,(%ebx)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
          }
        } else if(bytewidth >= 2) {
          for(; i + 1 < length; i += 2) {
    dd86:	83 45 f4 02          	addl   $0x2,-0xc(%ebp)
    dd8a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dd8d:	83 c0 01             	add    $0x1,%eax
    dd90:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    dd93:	0f 8c 11 ff ff ff    	jl     dcaa <unfilterScanline+0x5db>
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
          }
        }

        for(; i != length; ++i) {
    dd99:	eb 5f                	jmp    ddfa <unfilterScanline+0x72b>
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
    dd9b:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dd9e:	8b 45 08             	mov    0x8(%ebp),%eax
    dda1:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    dda4:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dda7:	8b 45 0c             	mov    0xc(%ebp),%eax
    ddaa:	01 d0                	add    %edx,%eax
    ddac:	0f b6 00             	movzbl (%eax),%eax
    ddaf:	88 45 b7             	mov    %al,-0x49(%ebp)
    ddb2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ddb5:	2b 45 14             	sub    0x14(%ebp),%eax
    ddb8:	89 c2                	mov    %eax,%edx
    ddba:	8b 45 10             	mov    0x10(%ebp),%eax
    ddbd:	01 d0                	add    %edx,%eax
    ddbf:	0f b6 00             	movzbl (%eax),%eax
    ddc2:	0f b6 c8             	movzbl %al,%ecx
    ddc5:	8b 55 f4             	mov    -0xc(%ebp),%edx
    ddc8:	8b 45 10             	mov    0x10(%ebp),%eax
    ddcb:	01 d0                	add    %edx,%eax
    ddcd:	0f b6 00             	movzbl (%eax),%eax
    ddd0:	0f b6 d0             	movzbl %al,%edx
    ddd3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ddd6:	2b 45 14             	sub    0x14(%ebp),%eax
    ddd9:	89 c6                	mov    %eax,%esi
    dddb:	8b 45 08             	mov    0x8(%ebp),%eax
    ddde:	01 f0                	add    %esi,%eax
    dde0:	0f b6 00             	movzbl (%eax),%eax
    dde3:	0f b6 c0             	movzbl %al,%eax
    dde6:	51                   	push   %ecx
    dde7:	52                   	push   %edx
    dde8:	50                   	push   %eax
    dde9:	e8 cc f2 ff ff       	call   d0ba <paethPredictor>
    ddee:	83 c4 0c             	add    $0xc,%esp
    ddf1:	02 45 b7             	add    -0x49(%ebp),%al
    ddf4:	88 03                	mov    %al,(%ebx)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
          }
        }

        for(; i != length; ++i) {
    ddf6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    ddfa:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ddfd:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    de00:	75 99                	jne    dd9b <unfilterScanline+0x6cc>
        for(i = bytewidth; i < length; ++i) {
          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
          recon[i] = (scanline[i] + recon[i - bytewidth]);
        }
      }
      break;
    de02:	eb 6e                	jmp    de72 <unfilterScanline+0x7a3>

        for(; i != length; ++i) {
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
        }
      } else {
        for(i = 0; i != bytewidth; ++i) {
    de04:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    de0b:	eb 19                	jmp    de26 <unfilterScanline+0x757>
          recon[i] = scanline[i];
    de0d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    de10:	8b 45 08             	mov    0x8(%ebp),%eax
    de13:	01 c2                	add    %eax,%edx
    de15:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    de18:	8b 45 0c             	mov    0xc(%ebp),%eax
    de1b:	01 c8                	add    %ecx,%eax
    de1d:	0f b6 00             	movzbl (%eax),%eax
    de20:	88 02                	mov    %al,(%edx)

        for(; i != length; ++i) {
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
        }
      } else {
        for(i = 0; i != bytewidth; ++i) {
    de22:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    de26:	8b 45 f4             	mov    -0xc(%ebp),%eax
    de29:	3b 45 14             	cmp    0x14(%ebp),%eax
    de2c:	75 df                	jne    de0d <unfilterScanline+0x73e>
          recon[i] = scanline[i];
        }
        for(i = bytewidth; i < length; ++i) {
    de2e:	8b 45 14             	mov    0x14(%ebp),%eax
    de31:	89 45 f4             	mov    %eax,-0xc(%ebp)
    de34:	eb 2b                	jmp    de61 <unfilterScanline+0x792>
          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
          recon[i] = (scanline[i] + recon[i - bytewidth]);
    de36:	8b 55 f4             	mov    -0xc(%ebp),%edx
    de39:	8b 45 08             	mov    0x8(%ebp),%eax
    de3c:	01 c2                	add    %eax,%edx
    de3e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    de41:	8b 45 0c             	mov    0xc(%ebp),%eax
    de44:	01 c8                	add    %ecx,%eax
    de46:	0f b6 08             	movzbl (%eax),%ecx
    de49:	8b 45 f4             	mov    -0xc(%ebp),%eax
    de4c:	2b 45 14             	sub    0x14(%ebp),%eax
    de4f:	89 c3                	mov    %eax,%ebx
    de51:	8b 45 08             	mov    0x8(%ebp),%eax
    de54:	01 d8                	add    %ebx,%eax
    de56:	0f b6 00             	movzbl (%eax),%eax
    de59:	01 c8                	add    %ecx,%eax
    de5b:	88 02                	mov    %al,(%edx)
        }
      } else {
        for(i = 0; i != bytewidth; ++i) {
          recon[i] = scanline[i];
        }
        for(i = bytewidth; i < length; ++i) {
    de5d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    de61:	8b 45 f4             	mov    -0xc(%ebp),%eax
    de64:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    de67:	7c cd                	jl     de36 <unfilterScanline+0x767>
          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
          recon[i] = (scanline[i] + recon[i - bytewidth]);
        }
      }
      break;
    de69:	eb 07                	jmp    de72 <unfilterScanline+0x7a3>
    default: return 36; /*error: invalid filter type given*/
    de6b:	b8 24 00 00 00       	mov    $0x24,%eax
    de70:	eb 05                	jmp    de77 <unfilterScanline+0x7a8>
  }
  return 0;
    de72:	b8 00 00 00 00       	mov    $0x0,%eax
}
    de77:	8d 65 f8             	lea    -0x8(%ebp),%esp
    de7a:	5b                   	pop    %ebx
    de7b:	5e                   	pop    %esi
    de7c:	5d                   	pop    %ebp
    de7d:	c3                   	ret    

0000de7e <unfilter>:

static unsigned unfilter(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {
    de7e:	55                   	push   %ebp
    de7f:	89 e5                	mov    %esp,%ebp
    de81:	53                   	push   %ebx
    de82:	83 ec 20             	sub    $0x20,%esp
  w and h are image dimensions or dimensions of reduced image, bpp is bits per pixel
  in and out are allowed to be the same memory address (but aren't the same size since in has the extra filter bytes)
  */

  unsigned y;
  unsigned char* prevline = 0;
    de85:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7u) / 8u;
    de8c:	8b 45 18             	mov    0x18(%ebp),%eax
    de8f:	83 c0 07             	add    $0x7,%eax
    de92:	c1 e8 03             	shr    $0x3,%eax
    de95:	89 45 f0             	mov    %eax,-0x10(%ebp)
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;
    de98:	ff 75 18             	pushl  0x18(%ebp)
    de9b:	6a 01                	push   $0x1
    de9d:	ff 75 10             	pushl  0x10(%ebp)
    dea0:	e8 d9 b1 ff ff       	call   907e <lodepng_get_raw_size_idat>
    dea5:	83 c4 0c             	add    $0xc,%esp
    dea8:	83 e8 01             	sub    $0x1,%eax
    deab:	89 45 ec             	mov    %eax,-0x14(%ebp)

  for(y = 0; y < h; ++y) {
    deae:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    deb5:	eb 6d                	jmp    df24 <unfilter+0xa6>
    size_t outindex = linebytes * y;
    deb7:	8b 45 ec             	mov    -0x14(%ebp),%eax
    deba:	0f af 45 f8          	imul   -0x8(%ebp),%eax
    debe:	89 45 e8             	mov    %eax,-0x18(%ebp)
    size_t inindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
    dec1:	8b 45 ec             	mov    -0x14(%ebp),%eax
    dec4:	83 c0 01             	add    $0x1,%eax
    dec7:	0f af 45 f8          	imul   -0x8(%ebp),%eax
    decb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    unsigned char filterType = in[inindex];
    dece:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    ded1:	8b 45 0c             	mov    0xc(%ebp),%eax
    ded4:	01 d0                	add    %edx,%eax
    ded6:	0f b6 00             	movzbl (%eax),%eax
    ded9:	88 45 e3             	mov    %al,-0x1d(%ebp)

    CERROR_TRY_RETURN(unfilterScanline(&out[outindex], &in[inindex + 1], prevline, bytewidth, filterType, linebytes));
    dedc:	0f b6 45 e3          	movzbl -0x1d(%ebp),%eax
    dee0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    dee3:	8d 4a 01             	lea    0x1(%edx),%ecx
    dee6:	8b 55 0c             	mov    0xc(%ebp),%edx
    dee9:	01 d1                	add    %edx,%ecx
    deeb:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    deee:	8b 55 08             	mov    0x8(%ebp),%edx
    def1:	01 da                	add    %ebx,%edx
    def3:	ff 75 ec             	pushl  -0x14(%ebp)
    def6:	50                   	push   %eax
    def7:	ff 75 f0             	pushl  -0x10(%ebp)
    defa:	ff 75 f4             	pushl  -0xc(%ebp)
    defd:	51                   	push   %ecx
    defe:	52                   	push   %edx
    deff:	e8 cb f7 ff ff       	call   d6cf <unfilterScanline>
    df04:	83 c4 18             	add    $0x18,%esp
    df07:	89 45 dc             	mov    %eax,-0x24(%ebp)
    df0a:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    df0e:	74 05                	je     df15 <unfilter+0x97>
    df10:	8b 45 dc             	mov    -0x24(%ebp),%eax
    df13:	eb 1c                	jmp    df31 <unfilter+0xb3>

    prevline = &out[outindex];
    df15:	8b 55 e8             	mov    -0x18(%ebp),%edx
    df18:	8b 45 08             	mov    0x8(%ebp),%eax
    df1b:	01 d0                	add    %edx,%eax
    df1d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7u) / 8u;
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;

  for(y = 0; y < h; ++y) {
    df20:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    df24:	8b 45 f8             	mov    -0x8(%ebp),%eax
    df27:	3b 45 14             	cmp    0x14(%ebp),%eax
    df2a:	72 8b                	jb     deb7 <unfilter+0x39>
    CERROR_TRY_RETURN(unfilterScanline(&out[outindex], &in[inindex + 1], prevline, bytewidth, filterType, linebytes));

    prevline = &out[outindex];
  }

  return 0;
    df2c:	b8 00 00 00 00       	mov    $0x0,%eax
}
    df31:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    df34:	c9                   	leave  
    df35:	c3                   	ret    

0000df36 <Adam7_deinterlace>:
in is possibly bigger due to padding bits between reduced images.
out must be big enough AND must be 0 everywhere if bpp < 8 in the current implementation
(because that's likely a little bit faster)
NOTE: comments about padding bits are only relevant if bpp < 8
*/
static void Adam7_deinterlace(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {
    df36:	55                   	push   %ebp
    df37:	89 e5                	mov    %esp,%ebp
    df39:	81 ec e0 00 00 00    	sub    $0xe0,%esp
  unsigned passw[7], passh[7];
  size_t filter_passstart[8], padded_passstart[8], passstart[8];
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
    df3f:	ff 75 18             	pushl  0x18(%ebp)
    df42:	ff 75 14             	pushl  0x14(%ebp)
    df45:	ff 75 10             	pushl  0x10(%ebp)
    df48:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
    df4e:	50                   	push   %eax
    df4f:	8d 85 54 ff ff ff    	lea    -0xac(%ebp),%eax
    df55:	50                   	push   %eax
    df56:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    df5c:	50                   	push   %eax
    df5d:	8d 45 94             	lea    -0x6c(%ebp),%eax
    df60:	50                   	push   %eax
    df61:	8d 45 b0             	lea    -0x50(%ebp),%eax
    df64:	50                   	push   %eax
    df65:	e8 e6 f1 ff ff       	call   d150 <Adam7_getpassvalues>
    df6a:	83 c4 20             	add    $0x20,%esp

  if(bpp >= 8) {
    df6d:	83 7d 18 07          	cmpl   $0x7,0x18(%ebp)
    df71:	0f 86 0a 01 00 00    	jbe    e081 <Adam7_deinterlace+0x14b>
    for(i = 0; i != 7; ++i) {
    df77:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    df7e:	e9 ef 00 00 00       	jmp    e072 <Adam7_deinterlace+0x13c>
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
    df83:	8b 45 18             	mov    0x18(%ebp),%eax
    df86:	c1 e8 03             	shr    $0x3,%eax
    df89:	89 45 e0             	mov    %eax,-0x20(%ebp)
      for(y = 0; y < passh[i]; ++y)
    df8c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    df93:	e9 c6 00 00 00       	jmp    e05e <Adam7_deinterlace+0x128>
      for(x = 0; x < passw[i]; ++x) {
    df98:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    df9f:	e9 a6 00 00 00       	jmp    e04a <Adam7_deinterlace+0x114>
        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
    dfa4:	8b 45 fc             	mov    -0x4(%ebp),%eax
    dfa7:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
    dfae:	89 c1                	mov    %eax,%ecx
    dfb0:	8b 45 fc             	mov    -0x4(%ebp),%eax
    dfb3:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    dfb7:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    dfbb:	89 c2                	mov    %eax,%edx
    dfbd:	8b 45 f8             	mov    -0x8(%ebp),%eax
    dfc0:	01 c2                	add    %eax,%edx
    dfc2:	8b 45 e0             	mov    -0x20(%ebp),%eax
    dfc5:	0f af c2             	imul   %edx,%eax
    dfc8:	01 c8                	add    %ecx,%eax
    dfca:	89 45 dc             	mov    %eax,-0x24(%ebp)
        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w
    dfcd:	8b 45 fc             	mov    -0x4(%ebp),%eax
    dfd0:	8b 14 85 d8 a0 01 00 	mov    0x1a0d8(,%eax,4),%edx
    dfd7:	8b 45 fc             	mov    -0x4(%ebp),%eax
    dfda:	8b 04 85 10 a1 01 00 	mov    0x1a110(,%eax,4),%eax
    dfe1:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    dfe5:	01 d0                	add    %edx,%eax
    dfe7:	0f af 45 10          	imul   0x10(%ebp),%eax
    dfeb:	89 c2                	mov    %eax,%edx
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
    dfed:	8b 45 fc             	mov    -0x4(%ebp),%eax
    dff0:	8b 04 85 f4 a0 01 00 	mov    0x1a0f4(,%eax,4),%eax
    dff7:	0f af 45 f8          	imul   -0x8(%ebp),%eax
    dffb:	01 c2                	add    %eax,%edx
    dffd:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e000:	8b 04 85 bc a0 01 00 	mov    0x1a0bc(,%eax,4),%eax
    e007:	01 c2                	add    %eax,%edx
    e009:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e00c:	0f af c2             	imul   %edx,%eax
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w
    e00f:	89 45 d8             	mov    %eax,-0x28(%ebp)
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
        for(b = 0; b < bytewidth; ++b) {
    e012:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    e019:	eb 23                	jmp    e03e <Adam7_deinterlace+0x108>
          out[pixeloutstart + b] = in[pixelinstart + b];
    e01b:	8b 55 d8             	mov    -0x28(%ebp),%edx
    e01e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e021:	01 c2                	add    %eax,%edx
    e023:	8b 45 08             	mov    0x8(%ebp),%eax
    e026:	01 c2                	add    %eax,%edx
    e028:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    e02b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e02e:	01 c1                	add    %eax,%ecx
    e030:	8b 45 0c             	mov    0xc(%ebp),%eax
    e033:	01 c8                	add    %ecx,%eax
    e035:	0f b6 00             	movzbl (%eax),%eax
    e038:	88 02                	mov    %al,(%edx)
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
        for(b = 0; b < bytewidth; ++b) {
    e03a:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    e03e:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e041:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    e044:	72 d5                	jb     e01b <Adam7_deinterlace+0xe5>
  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
    e046:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    e04a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e04d:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    e051:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    e054:	0f 87 4a ff ff ff    	ja     dfa4 <Adam7_deinterlace+0x6e>

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
    e05a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    e05e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e061:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
    e065:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    e068:	0f 87 2a ff ff ff    	ja     df98 <Adam7_deinterlace+0x62>
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
    e06e:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    e072:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
    e076:	0f 85 07 ff ff ff    	jne    df83 <Adam7_deinterlace+0x4d>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
    e07c:	e9 22 01 00 00       	jmp    e1a3 <Adam7_deinterlace+0x26d>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
    e081:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    e088:	e9 0c 01 00 00       	jmp    e199 <Adam7_deinterlace+0x263>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
    e08d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e090:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    e094:	0f af 45 18          	imul   0x18(%ebp),%eax
    e098:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      unsigned olinebits = bpp * w;
    e09b:	8b 45 18             	mov    0x18(%ebp),%eax
    e09e:	0f af 45 10          	imul   0x10(%ebp),%eax
    e0a2:	89 45 d0             	mov    %eax,-0x30(%ebp)
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
    e0a5:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    e0ac:	e9 d4 00 00 00       	jmp    e185 <Adam7_deinterlace+0x24f>
      for(x = 0; x < passw[i]; ++x) {
    e0b1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    e0b8:	e9 b4 00 00 00       	jmp    e171 <Adam7_deinterlace+0x23b>
        ibp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
    e0bd:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e0c0:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
    e0c7:	c1 e0 03             	shl    $0x3,%eax
    e0ca:	89 c1                	mov    %eax,%ecx
    e0cc:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e0cf:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    e0d3:	89 c2                	mov    %eax,%edx
    e0d5:	8b 45 ec             	mov    -0x14(%ebp),%eax
    e0d8:	0f af 45 18          	imul   0x18(%ebp),%eax
    e0dc:	01 d0                	add    %edx,%eax
    e0de:	01 c8                	add    %ecx,%eax
    e0e0:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
        obp = (ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bpp;
    e0e6:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e0e9:	8b 14 85 d8 a0 01 00 	mov    0x1a0d8(,%eax,4),%edx
    e0f0:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e0f3:	8b 04 85 10 a1 01 00 	mov    0x1a110(,%eax,4),%eax
    e0fa:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    e0fe:	01 d0                	add    %edx,%eax
    e100:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    e104:	89 c2                	mov    %eax,%edx
    e106:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e109:	8b 0c 85 bc a0 01 00 	mov    0x1a0bc(,%eax,4),%ecx
    e110:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e113:	8b 04 85 f4 a0 01 00 	mov    0x1a0f4(,%eax,4),%eax
    e11a:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e11e:	01 c8                	add    %ecx,%eax
    e120:	0f af 45 18          	imul   0x18(%ebp),%eax
    e124:	01 d0                	add    %edx,%eax
    e126:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
        for(b = 0; b < bpp; ++b) {
    e12c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    e133:	eb 30                	jmp    e165 <Adam7_deinterlace+0x22f>
          unsigned char bit = readBitFromReversedStream(&ibp, in);
    e135:	ff 75 0c             	pushl  0xc(%ebp)
    e138:	8d 85 2c ff ff ff    	lea    -0xd4(%ebp),%eax
    e13e:	50                   	push   %eax
    e13f:	e8 1e a1 ff ff       	call   8262 <readBitFromReversedStream>
    e144:	83 c4 08             	add    $0x8,%esp
    e147:	88 45 cf             	mov    %al,-0x31(%ebp)
          setBitOfReversedStream(&obp, out, bit);
    e14a:	0f b6 45 cf          	movzbl -0x31(%ebp),%eax
    e14e:	50                   	push   %eax
    e14f:	ff 75 08             	pushl  0x8(%ebp)
    e152:	8d 85 30 ff ff ff    	lea    -0xd0(%ebp),%eax
    e158:	50                   	push   %eax
    e159:	e8 86 a1 ff ff       	call   82e4 <setBitOfReversedStream>
    e15e:	83 c4 0c             	add    $0xc,%esp
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        ibp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
        obp = (ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bpp;
        for(b = 0; b < bpp; ++b) {
    e161:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
    e165:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    e168:	3b 45 18             	cmp    0x18(%ebp),%eax
    e16b:	72 c8                	jb     e135 <Adam7_deinterlace+0x1ff>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
    e16d:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    e171:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e174:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    e178:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    e17b:	0f 87 3c ff ff ff    	ja     e0bd <Adam7_deinterlace+0x187>
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
    e181:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    e185:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e188:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
    e18c:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    e18f:	0f 87 1c ff ff ff    	ja     e0b1 <Adam7_deinterlace+0x17b>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
    e195:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    e199:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
    e19d:	0f 85 ea fe ff ff    	jne    e08d <Adam7_deinterlace+0x157>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
    e1a3:	90                   	nop
    e1a4:	c9                   	leave  
    e1a5:	c3                   	ret    

0000e1a6 <removePaddingBits>:

static void removePaddingBits(unsigned char* out, const unsigned char* in,
                              size_t olinebits, size_t ilinebits, unsigned h) {
    e1a6:	55                   	push   %ebp
    e1a7:	89 e5                	mov    %esp,%ebp
    e1a9:	83 ec 20             	sub    $0x20,%esp
  have >= ilinebits*h bits, out must have >= olinebits*h bits, olinebits must be <= ilinebits
  also used to move bits after earlier such operations happened, e.g. in a sequence of reduced images from Adam7
  only useful if (ilinebits - olinebits) is a value in the range 1..7
  */
  unsigned y;
  size_t diff = ilinebits - olinebits;
    e1ac:	8b 45 14             	mov    0x14(%ebp),%eax
    e1af:	2b 45 10             	sub    0x10(%ebp),%eax
    e1b2:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
    e1b5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    e1bc:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  for(y = 0; y < h; ++y) {
    e1c3:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    e1ca:	eb 4a                	jmp    e216 <removePaddingBits+0x70>
    size_t x;
    for(x = 0; x < olinebits; ++x) {
    e1cc:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    e1d3:	eb 2a                	jmp    e1ff <removePaddingBits+0x59>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
    e1d5:	ff 75 0c             	pushl  0xc(%ebp)
    e1d8:	8d 45 ec             	lea    -0x14(%ebp),%eax
    e1db:	50                   	push   %eax
    e1dc:	e8 81 a0 ff ff       	call   8262 <readBitFromReversedStream>
    e1e1:	83 c4 08             	add    $0x8,%esp
    e1e4:	88 45 f3             	mov    %al,-0xd(%ebp)
      setBitOfReversedStream(&obp, out, bit);
    e1e7:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
    e1eb:	50                   	push   %eax
    e1ec:	ff 75 08             	pushl  0x8(%ebp)
    e1ef:	8d 45 e8             	lea    -0x18(%ebp),%eax
    e1f2:	50                   	push   %eax
    e1f3:	e8 ec a0 ff ff       	call   82e4 <setBitOfReversedStream>
    e1f8:	83 c4 0c             	add    $0xc,%esp
  unsigned y;
  size_t diff = ilinebits - olinebits;
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
  for(y = 0; y < h; ++y) {
    size_t x;
    for(x = 0; x < olinebits; ++x) {
    e1fb:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    e1ff:	8b 45 f8             	mov    -0x8(%ebp),%eax
    e202:	3b 45 10             	cmp    0x10(%ebp),%eax
    e205:	7c ce                	jl     e1d5 <removePaddingBits+0x2f>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    ibp += diff;
    e207:	8b 55 ec             	mov    -0x14(%ebp),%edx
    e20a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e20d:	01 d0                	add    %edx,%eax
    e20f:	89 45 ec             	mov    %eax,-0x14(%ebp)
  only useful if (ilinebits - olinebits) is a value in the range 1..7
  */
  unsigned y;
  size_t diff = ilinebits - olinebits;
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
  for(y = 0; y < h; ++y) {
    e212:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    e216:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e219:	3b 45 18             	cmp    0x18(%ebp),%eax
    e21c:	72 ae                	jb     e1cc <removePaddingBits+0x26>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    ibp += diff;
  }
}
    e21e:	90                   	nop
    e21f:	c9                   	leave  
    e220:	c3                   	ret    

0000e221 <postProcessScanlines>:

/*out must be buffer big enough to contain full image, and in must contain the full decompressed data from
the IDAT chunks (with filter index bytes and possible padding bits)
return value is error*/
static unsigned postProcessScanlines(unsigned char* out, unsigned char* in,
                                     unsigned w, unsigned h, const LodePNGInfo* info_png) {
    e221:	55                   	push   %ebp
    e222:	89 e5                	mov    %esp,%ebp
    e224:	57                   	push   %edi
    e225:	56                   	push   %esi
    e226:	53                   	push   %ebx
    e227:	81 ec b0 00 00 00    	sub    $0xb0,%esp
  Steps:
  *) if no Adam7: 1) unfilter 2) remove padding bits (= possible extra bits per scanline if bpp < 8)
  *) if adam7: 1) 7x unfilter 2) 7x remove padding bits 3) Adam7_deinterlace
  NOTE: the in buffer will be overwritten with intermediate data!
  */
  unsigned bpp = lodepng_get_bpp(&info_png->color);
    e22d:	8b 45 18             	mov    0x18(%ebp),%eax
    e230:	83 c0 0c             	add    $0xc,%eax
    e233:	50                   	push   %eax
    e234:	e8 e6 ac ff ff       	call   8f1f <lodepng_get_bpp>
    e239:	83 c4 04             	add    $0x4,%esp
    e23c:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(bpp == 0) return 31; /*error: invalid colortype*/
    e23f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    e243:	75 0a                	jne    e24f <postProcessScanlines+0x2e>
    e245:	b8 1f 00 00 00       	mov    $0x1f,%eax
    e24a:	e9 c3 01 00 00       	jmp    e412 <postProcessScanlines+0x1f1>

  if(info_png->interlace_method == 0) {
    e24f:	8b 45 18             	mov    0x18(%ebp),%eax
    e252:	8b 40 08             	mov    0x8(%eax),%eax
    e255:	85 c0                	test   %eax,%eax
    e257:	0f 85 a8 00 00 00    	jne    e305 <postProcessScanlines+0xe4>
    if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {
    e25d:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
    e261:	77 76                	ja     e2d9 <postProcessScanlines+0xb8>
    e263:	8b 45 10             	mov    0x10(%ebp),%eax
    e266:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e26a:	89 c2                	mov    %eax,%edx
    e26c:	8b 45 10             	mov    0x10(%ebp),%eax
    e26f:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e273:	83 c0 07             	add    $0x7,%eax
    e276:	c1 e8 03             	shr    $0x3,%eax
    e279:	c1 e0 03             	shl    $0x3,%eax
    e27c:	39 c2                	cmp    %eax,%edx
    e27e:	74 59                	je     e2d9 <postProcessScanlines+0xb8>
      CERROR_TRY_RETURN(unfilter(in, in, w, h, bpp));
    e280:	ff 75 ec             	pushl  -0x14(%ebp)
    e283:	ff 75 14             	pushl  0x14(%ebp)
    e286:	ff 75 10             	pushl  0x10(%ebp)
    e289:	ff 75 0c             	pushl  0xc(%ebp)
    e28c:	ff 75 0c             	pushl  0xc(%ebp)
    e28f:	e8 ea fb ff ff       	call   de7e <unfilter>
    e294:	83 c4 14             	add    $0x14,%esp
    e297:	89 45 e8             	mov    %eax,-0x18(%ebp)
    e29a:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    e29e:	74 08                	je     e2a8 <postProcessScanlines+0x87>
    e2a0:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e2a3:	e9 6a 01 00 00       	jmp    e412 <postProcessScanlines+0x1f1>
      removePaddingBits(out, in, w * bpp, ((w * bpp + 7u) / 8u) * 8u, h);
    e2a8:	8b 45 10             	mov    0x10(%ebp),%eax
    e2ab:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e2af:	83 c0 07             	add    $0x7,%eax
    e2b2:	c1 e8 03             	shr    $0x3,%eax
    e2b5:	c1 e0 03             	shl    $0x3,%eax
    e2b8:	89 c2                	mov    %eax,%edx
    e2ba:	8b 45 10             	mov    0x10(%ebp),%eax
    e2bd:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e2c1:	ff 75 14             	pushl  0x14(%ebp)
    e2c4:	52                   	push   %edx
    e2c5:	50                   	push   %eax
    e2c6:	ff 75 0c             	pushl  0xc(%ebp)
    e2c9:	ff 75 08             	pushl  0x8(%ebp)
    e2cc:	e8 d5 fe ff ff       	call   e1a6 <removePaddingBits>
    e2d1:	83 c4 14             	add    $0x14,%esp
    e2d4:	e9 34 01 00 00       	jmp    e40d <postProcessScanlines+0x1ec>
    }
    /*we can immediately filter into the out buffer, no other steps needed*/
    else CERROR_TRY_RETURN(unfilter(out, in, w, h, bpp));
    e2d9:	ff 75 ec             	pushl  -0x14(%ebp)
    e2dc:	ff 75 14             	pushl  0x14(%ebp)
    e2df:	ff 75 10             	pushl  0x10(%ebp)
    e2e2:	ff 75 0c             	pushl  0xc(%ebp)
    e2e5:	ff 75 08             	pushl  0x8(%ebp)
    e2e8:	e8 91 fb ff ff       	call   de7e <unfilter>
    e2ed:	83 c4 14             	add    $0x14,%esp
    e2f0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    e2f3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    e2f7:	0f 84 10 01 00 00    	je     e40d <postProcessScanlines+0x1ec>
    e2fd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    e300:	e9 0d 01 00 00       	jmp    e412 <postProcessScanlines+0x1f1>
  } else /*interlace_method is 1 (Adam7)*/ {
    unsigned passw[7], passh[7]; size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned i;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
    e305:	ff 75 ec             	pushl  -0x14(%ebp)
    e308:	ff 75 14             	pushl  0x14(%ebp)
    e30b:	ff 75 10             	pushl  0x10(%ebp)
    e30e:	8d 45 88             	lea    -0x78(%ebp),%eax
    e311:	50                   	push   %eax
    e312:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
    e318:	50                   	push   %eax
    e319:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    e31f:	50                   	push   %eax
    e320:	8d 45 a8             	lea    -0x58(%ebp),%eax
    e323:	50                   	push   %eax
    e324:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    e327:	50                   	push   %eax
    e328:	e8 23 ee ff ff       	call   d150 <Adam7_getpassvalues>
    e32d:	83 c4 20             	add    $0x20,%esp

    for(i = 0; i != 7; ++i) {
    e330:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    e337:	e9 b0 00 00 00       	jmp    e3ec <postProcessScanlines+0x1cb>
      CERROR_TRY_RETURN(unfilter(&in[padded_passstart[i]], &in[filter_passstart[i]], passw[i], passh[i], bpp));
    e33c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e33f:	8b 54 85 a8          	mov    -0x58(%ebp,%eax,4),%edx
    e343:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e346:	8b 44 85 c4          	mov    -0x3c(%ebp,%eax,4),%eax
    e34a:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    e34d:	8b 8c 8d 48 ff ff ff 	mov    -0xb8(%ebp,%ecx,4),%ecx
    e354:	89 cb                	mov    %ecx,%ebx
    e356:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    e359:	01 cb                	add    %ecx,%ebx
    e35b:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    e35e:	8b 8c 8d 68 ff ff ff 	mov    -0x98(%ebp,%ecx,4),%ecx
    e365:	89 ce                	mov    %ecx,%esi
    e367:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    e36a:	01 f1                	add    %esi,%ecx
    e36c:	ff 75 ec             	pushl  -0x14(%ebp)
    e36f:	52                   	push   %edx
    e370:	50                   	push   %eax
    e371:	53                   	push   %ebx
    e372:	51                   	push   %ecx
    e373:	e8 06 fb ff ff       	call   de7e <unfilter>
    e378:	83 c4 14             	add    $0x14,%esp
    e37b:	89 45 e0             	mov    %eax,-0x20(%ebp)
    e37e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    e382:	74 08                	je     e38c <postProcessScanlines+0x16b>
    e384:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e387:	e9 86 00 00 00       	jmp    e412 <postProcessScanlines+0x1f1>
      /*TODO: possible efficiency improvement: if in this reduced image the bits fit nicely in 1 scanline,
      move bytes instead of bits or move not at all*/
      if(bpp < 8) {
    e38c:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
    e390:	77 56                	ja     e3e8 <postProcessScanlines+0x1c7>
        /*remove padding bits in scanlines; after this there still may be padding
        bits between the different reduced images: each reduced image still starts nicely at a byte*/
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
    e392:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e395:	8b 44 85 a8          	mov    -0x58(%ebp,%eax,4),%eax
                          ((passw[i] * bpp + 7u) / 8u) * 8u, passh[i]);
    e399:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e39c:	8b 54 95 c4          	mov    -0x3c(%ebp,%edx,4),%edx
    e3a0:	0f af 55 ec          	imul   -0x14(%ebp),%edx
    e3a4:	83 c2 07             	add    $0x7,%edx
    e3a7:	c1 ea 03             	shr    $0x3,%edx
    e3aa:	c1 e2 03             	shl    $0x3,%edx
      /*TODO: possible efficiency improvement: if in this reduced image the bits fit nicely in 1 scanline,
      move bytes instead of bits or move not at all*/
      if(bpp < 8) {
        /*remove padding bits in scanlines; after this there still may be padding
        bits between the different reduced images: each reduced image still starts nicely at a byte*/
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
    e3ad:	89 d6                	mov    %edx,%esi
    e3af:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e3b2:	8b 54 95 c4          	mov    -0x3c(%ebp,%edx,4),%edx
    e3b6:	0f af 55 ec          	imul   -0x14(%ebp),%edx
    e3ba:	89 d3                	mov    %edx,%ebx
    e3bc:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e3bf:	8b 94 95 68 ff ff ff 	mov    -0x98(%ebp,%edx,4),%edx
    e3c6:	89 d1                	mov    %edx,%ecx
    e3c8:	8b 55 0c             	mov    0xc(%ebp),%edx
    e3cb:	01 d1                	add    %edx,%ecx
    e3cd:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e3d0:	8b 54 95 88          	mov    -0x78(%ebp,%edx,4),%edx
    e3d4:	89 d7                	mov    %edx,%edi
    e3d6:	8b 55 0c             	mov    0xc(%ebp),%edx
    e3d9:	01 fa                	add    %edi,%edx
    e3db:	50                   	push   %eax
    e3dc:	56                   	push   %esi
    e3dd:	53                   	push   %ebx
    e3de:	51                   	push   %ecx
    e3df:	52                   	push   %edx
    e3e0:	e8 c1 fd ff ff       	call   e1a6 <removePaddingBits>
    e3e5:	83 c4 14             	add    $0x14,%esp
    unsigned passw[7], passh[7]; size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned i;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

    for(i = 0; i != 7; ++i) {
    e3e8:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    e3ec:	83 7d f0 07          	cmpl   $0x7,-0x10(%ebp)
    e3f0:	0f 85 46 ff ff ff    	jne    e33c <postProcessScanlines+0x11b>
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
                          ((passw[i] * bpp + 7u) / 8u) * 8u, passh[i]);
      }
    }

    Adam7_deinterlace(out, in, w, h, bpp);
    e3f6:	ff 75 ec             	pushl  -0x14(%ebp)
    e3f9:	ff 75 14             	pushl  0x14(%ebp)
    e3fc:	ff 75 10             	pushl  0x10(%ebp)
    e3ff:	ff 75 0c             	pushl  0xc(%ebp)
    e402:	ff 75 08             	pushl  0x8(%ebp)
    e405:	e8 2c fb ff ff       	call   df36 <Adam7_deinterlace>
    e40a:	83 c4 14             	add    $0x14,%esp
  }

  return 0;
    e40d:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e412:	8d 65 f4             	lea    -0xc(%ebp),%esp
    e415:	5b                   	pop    %ebx
    e416:	5e                   	pop    %esi
    e417:	5f                   	pop    %edi
    e418:	5d                   	pop    %ebp
    e419:	c3                   	ret    

0000e41a <readChunk_PLTE>:

static unsigned readChunk_PLTE(LodePNGColorMode* color, const unsigned char* data, size_t chunkLength) {
    e41a:	55                   	push   %ebp
    e41b:	89 e5                	mov    %esp,%ebp
    e41d:	83 ec 18             	sub    $0x18,%esp
  unsigned pos = 0, i;
    e420:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  color->palettesize = chunkLength / 3u;
    e427:	8b 45 10             	mov    0x10(%ebp),%eax
    e42a:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
    e42f:	f7 e2                	mul    %edx
    e431:	89 d0                	mov    %edx,%eax
    e433:	d1 e8                	shr    %eax
    e435:	89 c2                	mov    %eax,%edx
    e437:	8b 45 08             	mov    0x8(%ebp),%eax
    e43a:	89 50 0c             	mov    %edx,0xc(%eax)
  if(color->palettesize == 0 || color->palettesize > 256) return 38; /*error: palette too small or big*/
    e43d:	8b 45 08             	mov    0x8(%ebp),%eax
    e440:	8b 40 0c             	mov    0xc(%eax),%eax
    e443:	85 c0                	test   %eax,%eax
    e445:	74 0d                	je     e454 <readChunk_PLTE+0x3a>
    e447:	8b 45 08             	mov    0x8(%ebp),%eax
    e44a:	8b 40 0c             	mov    0xc(%eax),%eax
    e44d:	3d 00 01 00 00       	cmp    $0x100,%eax
    e452:	7e 0a                	jle    e45e <readChunk_PLTE+0x44>
    e454:	b8 26 00 00 00       	mov    $0x26,%eax
    e459:	e9 da 00 00 00       	jmp    e538 <readChunk_PLTE+0x11e>
  lodepng_color_mode_alloc_palette(color);
    e45e:	83 ec 0c             	sub    $0xc,%esp
    e461:	ff 75 08             	pushl  0x8(%ebp)
    e464:	e8 02 a7 ff ff       	call   8b6b <lodepng_color_mode_alloc_palette>
    e469:	83 c4 10             	add    $0x10,%esp
  if(!color->palette && color->palettesize) {
    e46c:	8b 45 08             	mov    0x8(%ebp),%eax
    e46f:	8b 40 08             	mov    0x8(%eax),%eax
    e472:	85 c0                	test   %eax,%eax
    e474:	75 1e                	jne    e494 <readChunk_PLTE+0x7a>
    e476:	8b 45 08             	mov    0x8(%ebp),%eax
    e479:	8b 40 0c             	mov    0xc(%eax),%eax
    e47c:	85 c0                	test   %eax,%eax
    e47e:	74 14                	je     e494 <readChunk_PLTE+0x7a>
    color->palettesize = 0;
    e480:	8b 45 08             	mov    0x8(%ebp),%eax
    e483:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    return 83; /*alloc fail*/
    e48a:	b8 53 00 00 00       	mov    $0x53,%eax
    e48f:	e9 a4 00 00 00       	jmp    e538 <readChunk_PLTE+0x11e>
  }

  for(i = 0; i != color->palettesize; ++i) {
    e494:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    e49b:	e9 84 00 00 00       	jmp    e524 <readChunk_PLTE+0x10a>
    color->palette[4 * i + 0] = data[pos++]; /*R*/
    e4a0:	8b 45 08             	mov    0x8(%ebp),%eax
    e4a3:	8b 40 08             	mov    0x8(%eax),%eax
    e4a6:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e4a9:	c1 e2 02             	shl    $0x2,%edx
    e4ac:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
    e4af:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e4b2:	8d 50 01             	lea    0x1(%eax),%edx
    e4b5:	89 55 f4             	mov    %edx,-0xc(%ebp)
    e4b8:	8b 55 0c             	mov    0xc(%ebp),%edx
    e4bb:	01 d0                	add    %edx,%eax
    e4bd:	0f b6 00             	movzbl (%eax),%eax
    e4c0:	88 01                	mov    %al,(%ecx)
    color->palette[4 * i + 1] = data[pos++]; /*G*/
    e4c2:	8b 45 08             	mov    0x8(%ebp),%eax
    e4c5:	8b 40 08             	mov    0x8(%eax),%eax
    e4c8:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e4cb:	c1 e2 02             	shl    $0x2,%edx
    e4ce:	83 c2 01             	add    $0x1,%edx
    e4d1:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
    e4d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e4d7:	8d 50 01             	lea    0x1(%eax),%edx
    e4da:	89 55 f4             	mov    %edx,-0xc(%ebp)
    e4dd:	8b 55 0c             	mov    0xc(%ebp),%edx
    e4e0:	01 d0                	add    %edx,%eax
    e4e2:	0f b6 00             	movzbl (%eax),%eax
    e4e5:	88 01                	mov    %al,(%ecx)
    color->palette[4 * i + 2] = data[pos++]; /*B*/
    e4e7:	8b 45 08             	mov    0x8(%ebp),%eax
    e4ea:	8b 40 08             	mov    0x8(%eax),%eax
    e4ed:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e4f0:	c1 e2 02             	shl    $0x2,%edx
    e4f3:	83 c2 02             	add    $0x2,%edx
    e4f6:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
    e4f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e4fc:	8d 50 01             	lea    0x1(%eax),%edx
    e4ff:	89 55 f4             	mov    %edx,-0xc(%ebp)
    e502:	8b 55 0c             	mov    0xc(%ebp),%edx
    e505:	01 d0                	add    %edx,%eax
    e507:	0f b6 00             	movzbl (%eax),%eax
    e50a:	88 01                	mov    %al,(%ecx)
    color->palette[4 * i + 3] = 255; /*alpha*/
    e50c:	8b 45 08             	mov    0x8(%ebp),%eax
    e50f:	8b 40 08             	mov    0x8(%eax),%eax
    e512:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e515:	c1 e2 02             	shl    $0x2,%edx
    e518:	83 c2 03             	add    $0x3,%edx
    e51b:	01 d0                	add    %edx,%eax
    e51d:	c6 00 ff             	movb   $0xff,(%eax)
  if(!color->palette && color->palettesize) {
    color->palettesize = 0;
    return 83; /*alloc fail*/
  }

  for(i = 0; i != color->palettesize; ++i) {
    e520:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    e524:	8b 45 08             	mov    0x8(%ebp),%eax
    e527:	8b 40 0c             	mov    0xc(%eax),%eax
    e52a:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    e52d:	0f 85 6d ff ff ff    	jne    e4a0 <readChunk_PLTE+0x86>
    color->palette[4 * i + 1] = data[pos++]; /*G*/
    color->palette[4 * i + 2] = data[pos++]; /*B*/
    color->palette[4 * i + 3] = 255; /*alpha*/
  }

  return 0; /* OK */
    e533:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e538:	c9                   	leave  
    e539:	c3                   	ret    

0000e53a <readChunk_tRNS>:

static unsigned readChunk_tRNS(LodePNGColorMode* color, const unsigned char* data, size_t chunkLength) {
    e53a:	55                   	push   %ebp
    e53b:	89 e5                	mov    %esp,%ebp
    e53d:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  if(color->colortype == LCT_PALETTE) {
    e540:	8b 45 08             	mov    0x8(%ebp),%eax
    e543:	8b 00                	mov    (%eax),%eax
    e545:	83 f8 03             	cmp    $0x3,%eax
    e548:	75 4d                	jne    e597 <readChunk_tRNS+0x5d>
    /*error: more alpha values given than there are palette entries*/
    if(chunkLength > color->palettesize) return 39;
    e54a:	8b 45 08             	mov    0x8(%ebp),%eax
    e54d:	8b 40 0c             	mov    0xc(%eax),%eax
    e550:	3b 45 10             	cmp    0x10(%ebp),%eax
    e553:	7d 0a                	jge    e55f <readChunk_tRNS+0x25>
    e555:	b8 27 00 00 00       	mov    $0x27,%eax
    e55a:	e9 3c 01 00 00       	jmp    e69b <readChunk_tRNS+0x161>

    for(i = 0; i != chunkLength; ++i) color->palette[4 * i + 3] = data[i];
    e55f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    e566:	eb 22                	jmp    e58a <readChunk_tRNS+0x50>
    e568:	8b 45 08             	mov    0x8(%ebp),%eax
    e56b:	8b 40 08             	mov    0x8(%eax),%eax
    e56e:	8b 55 fc             	mov    -0x4(%ebp),%edx
    e571:	c1 e2 02             	shl    $0x2,%edx
    e574:	83 c2 03             	add    $0x3,%edx
    e577:	01 c2                	add    %eax,%edx
    e579:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    e57c:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e57f:	01 c8                	add    %ecx,%eax
    e581:	0f b6 00             	movzbl (%eax),%eax
    e584:	88 02                	mov    %al,(%edx)
    e586:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    e58a:	8b 45 10             	mov    0x10(%ebp),%eax
    e58d:	39 45 fc             	cmp    %eax,-0x4(%ebp)
    e590:	75 d6                	jne    e568 <readChunk_tRNS+0x2e>
    e592:	e9 ff 00 00 00       	jmp    e696 <readChunk_tRNS+0x15c>
  } else if(color->colortype == LCT_GREY) {
    e597:	8b 45 08             	mov    0x8(%ebp),%eax
    e59a:	8b 00                	mov    (%eax),%eax
    e59c:	85 c0                	test   %eax,%eax
    e59e:	75 59                	jne    e5f9 <readChunk_tRNS+0xbf>
    /*error: this chunk must be 2 bytes for grayscale image*/
    if(chunkLength != 2) return 30;
    e5a0:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
    e5a4:	74 0a                	je     e5b0 <readChunk_tRNS+0x76>
    e5a6:	b8 1e 00 00 00       	mov    $0x1e,%eax
    e5ab:	e9 eb 00 00 00       	jmp    e69b <readChunk_tRNS+0x161>

    color->key_defined = 1;
    e5b0:	8b 45 08             	mov    0x8(%ebp),%eax
    e5b3:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
    color->key_r = color->key_g = color->key_b = 256u * data[0] + data[1];
    e5ba:	8b 45 0c             	mov    0xc(%ebp),%eax
    e5bd:	0f b6 00             	movzbl (%eax),%eax
    e5c0:	0f b6 c0             	movzbl %al,%eax
    e5c3:	c1 e0 08             	shl    $0x8,%eax
    e5c6:	89 c2                	mov    %eax,%edx
    e5c8:	8b 45 0c             	mov    0xc(%ebp),%eax
    e5cb:	83 c0 01             	add    $0x1,%eax
    e5ce:	0f b6 00             	movzbl (%eax),%eax
    e5d1:	0f b6 c0             	movzbl %al,%eax
    e5d4:	01 c2                	add    %eax,%edx
    e5d6:	8b 45 08             	mov    0x8(%ebp),%eax
    e5d9:	89 50 1c             	mov    %edx,0x1c(%eax)
    e5dc:	8b 45 08             	mov    0x8(%ebp),%eax
    e5df:	8b 50 1c             	mov    0x1c(%eax),%edx
    e5e2:	8b 45 08             	mov    0x8(%ebp),%eax
    e5e5:	89 50 18             	mov    %edx,0x18(%eax)
    e5e8:	8b 45 08             	mov    0x8(%ebp),%eax
    e5eb:	8b 50 18             	mov    0x18(%eax),%edx
    e5ee:	8b 45 08             	mov    0x8(%ebp),%eax
    e5f1:	89 50 14             	mov    %edx,0x14(%eax)
    e5f4:	e9 9d 00 00 00       	jmp    e696 <readChunk_tRNS+0x15c>
  } else if(color->colortype == LCT_RGB) {
    e5f9:	8b 45 08             	mov    0x8(%ebp),%eax
    e5fc:	8b 00                	mov    (%eax),%eax
    e5fe:	83 f8 02             	cmp    $0x2,%eax
    e601:	0f 85 88 00 00 00    	jne    e68f <readChunk_tRNS+0x155>
    /*error: this chunk must be 6 bytes for RGB image*/
    if(chunkLength != 6) return 41;
    e607:	83 7d 10 06          	cmpl   $0x6,0x10(%ebp)
    e60b:	74 0a                	je     e617 <readChunk_tRNS+0xdd>
    e60d:	b8 29 00 00 00       	mov    $0x29,%eax
    e612:	e9 84 00 00 00       	jmp    e69b <readChunk_tRNS+0x161>

    color->key_defined = 1;
    e617:	8b 45 08             	mov    0x8(%ebp),%eax
    e61a:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
    color->key_r = 256u * data[0] + data[1];
    e621:	8b 45 0c             	mov    0xc(%ebp),%eax
    e624:	0f b6 00             	movzbl (%eax),%eax
    e627:	0f b6 c0             	movzbl %al,%eax
    e62a:	c1 e0 08             	shl    $0x8,%eax
    e62d:	89 c2                	mov    %eax,%edx
    e62f:	8b 45 0c             	mov    0xc(%ebp),%eax
    e632:	83 c0 01             	add    $0x1,%eax
    e635:	0f b6 00             	movzbl (%eax),%eax
    e638:	0f b6 c0             	movzbl %al,%eax
    e63b:	01 c2                	add    %eax,%edx
    e63d:	8b 45 08             	mov    0x8(%ebp),%eax
    e640:	89 50 14             	mov    %edx,0x14(%eax)
    color->key_g = 256u * data[2] + data[3];
    e643:	8b 45 0c             	mov    0xc(%ebp),%eax
    e646:	83 c0 02             	add    $0x2,%eax
    e649:	0f b6 00             	movzbl (%eax),%eax
    e64c:	0f b6 c0             	movzbl %al,%eax
    e64f:	c1 e0 08             	shl    $0x8,%eax
    e652:	89 c2                	mov    %eax,%edx
    e654:	8b 45 0c             	mov    0xc(%ebp),%eax
    e657:	83 c0 03             	add    $0x3,%eax
    e65a:	0f b6 00             	movzbl (%eax),%eax
    e65d:	0f b6 c0             	movzbl %al,%eax
    e660:	01 c2                	add    %eax,%edx
    e662:	8b 45 08             	mov    0x8(%ebp),%eax
    e665:	89 50 18             	mov    %edx,0x18(%eax)
    color->key_b = 256u * data[4] + data[5];
    e668:	8b 45 0c             	mov    0xc(%ebp),%eax
    e66b:	83 c0 04             	add    $0x4,%eax
    e66e:	0f b6 00             	movzbl (%eax),%eax
    e671:	0f b6 c0             	movzbl %al,%eax
    e674:	c1 e0 08             	shl    $0x8,%eax
    e677:	89 c2                	mov    %eax,%edx
    e679:	8b 45 0c             	mov    0xc(%ebp),%eax
    e67c:	83 c0 05             	add    $0x5,%eax
    e67f:	0f b6 00             	movzbl (%eax),%eax
    e682:	0f b6 c0             	movzbl %al,%eax
    e685:	01 c2                	add    %eax,%edx
    e687:	8b 45 08             	mov    0x8(%ebp),%eax
    e68a:	89 50 1c             	mov    %edx,0x1c(%eax)
    e68d:	eb 07                	jmp    e696 <readChunk_tRNS+0x15c>
  }
  else return 42; /*error: tRNS chunk not allowed for other color models*/
    e68f:	b8 2a 00 00 00       	mov    $0x2a,%eax
    e694:	eb 05                	jmp    e69b <readChunk_tRNS+0x161>

  return 0; /* OK */
    e696:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e69b:	c9                   	leave  
    e69c:	c3                   	ret    

0000e69d <readChunk_bKGD>:


#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
/*background color chunk (bKGD)*/
static unsigned readChunk_bKGD(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    e69d:	55                   	push   %ebp
    e69e:	89 e5                	mov    %esp,%ebp
  if(info->color.colortype == LCT_PALETTE) {
    e6a0:	8b 45 08             	mov    0x8(%ebp),%eax
    e6a3:	8b 40 0c             	mov    0xc(%eax),%eax
    e6a6:	83 f8 03             	cmp    $0x3,%eax
    e6a9:	75 63                	jne    e70e <readChunk_bKGD+0x71>
    /*error: this chunk must be 1 byte for indexed color image*/
    if(chunkLength != 1) return 43;
    e6ab:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    e6af:	74 0a                	je     e6bb <readChunk_bKGD+0x1e>
    e6b1:	b8 2b 00 00 00       	mov    $0x2b,%eax
    e6b6:	e9 63 01 00 00       	jmp    e81e <readChunk_bKGD+0x181>

    /*error: invalid palette index, or maybe this chunk appeared before PLTE*/
    if(data[0] >= info->color.palettesize) return 103;
    e6bb:	8b 45 0c             	mov    0xc(%ebp),%eax
    e6be:	0f b6 00             	movzbl (%eax),%eax
    e6c1:	0f b6 d0             	movzbl %al,%edx
    e6c4:	8b 45 08             	mov    0x8(%ebp),%eax
    e6c7:	8b 40 18             	mov    0x18(%eax),%eax
    e6ca:	39 c2                	cmp    %eax,%edx
    e6cc:	7c 0a                	jl     e6d8 <readChunk_bKGD+0x3b>
    e6ce:	b8 67 00 00 00       	mov    $0x67,%eax
    e6d3:	e9 46 01 00 00       	jmp    e81e <readChunk_bKGD+0x181>

    info->background_defined = 1;
    e6d8:	8b 45 08             	mov    0x8(%ebp),%eax
    e6db:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
    info->background_r = info->background_g = info->background_b = data[0];
    e6e2:	8b 45 0c             	mov    0xc(%ebp),%eax
    e6e5:	0f b6 00             	movzbl (%eax),%eax
    e6e8:	0f b6 d0             	movzbl %al,%edx
    e6eb:	8b 45 08             	mov    0x8(%ebp),%eax
    e6ee:	89 50 38             	mov    %edx,0x38(%eax)
    e6f1:	8b 45 08             	mov    0x8(%ebp),%eax
    e6f4:	8b 50 38             	mov    0x38(%eax),%edx
    e6f7:	8b 45 08             	mov    0x8(%ebp),%eax
    e6fa:	89 50 34             	mov    %edx,0x34(%eax)
    e6fd:	8b 45 08             	mov    0x8(%ebp),%eax
    e700:	8b 50 34             	mov    0x34(%eax),%edx
    e703:	8b 45 08             	mov    0x8(%ebp),%eax
    e706:	89 50 30             	mov    %edx,0x30(%eax)
    e709:	e9 0b 01 00 00       	jmp    e819 <readChunk_bKGD+0x17c>
  } else if(info->color.colortype == LCT_GREY || info->color.colortype == LCT_GREY_ALPHA) {
    e70e:	8b 45 08             	mov    0x8(%ebp),%eax
    e711:	8b 40 0c             	mov    0xc(%eax),%eax
    e714:	85 c0                	test   %eax,%eax
    e716:	74 0b                	je     e723 <readChunk_bKGD+0x86>
    e718:	8b 45 08             	mov    0x8(%ebp),%eax
    e71b:	8b 40 0c             	mov    0xc(%eax),%eax
    e71e:	83 f8 04             	cmp    $0x4,%eax
    e721:	75 59                	jne    e77c <readChunk_bKGD+0xdf>
    /*error: this chunk must be 2 bytes for grayscale image*/
    if(chunkLength != 2) return 44;
    e723:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
    e727:	74 0a                	je     e733 <readChunk_bKGD+0x96>
    e729:	b8 2c 00 00 00       	mov    $0x2c,%eax
    e72e:	e9 eb 00 00 00       	jmp    e81e <readChunk_bKGD+0x181>

    /*the values are truncated to bitdepth in the PNG file*/
    info->background_defined = 1;
    e733:	8b 45 08             	mov    0x8(%ebp),%eax
    e736:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
    info->background_r = info->background_g = info->background_b = 256u * data[0] + data[1];
    e73d:	8b 45 0c             	mov    0xc(%ebp),%eax
    e740:	0f b6 00             	movzbl (%eax),%eax
    e743:	0f b6 c0             	movzbl %al,%eax
    e746:	c1 e0 08             	shl    $0x8,%eax
    e749:	89 c2                	mov    %eax,%edx
    e74b:	8b 45 0c             	mov    0xc(%ebp),%eax
    e74e:	83 c0 01             	add    $0x1,%eax
    e751:	0f b6 00             	movzbl (%eax),%eax
    e754:	0f b6 c0             	movzbl %al,%eax
    e757:	01 c2                	add    %eax,%edx
    e759:	8b 45 08             	mov    0x8(%ebp),%eax
    e75c:	89 50 38             	mov    %edx,0x38(%eax)
    e75f:	8b 45 08             	mov    0x8(%ebp),%eax
    e762:	8b 50 38             	mov    0x38(%eax),%edx
    e765:	8b 45 08             	mov    0x8(%ebp),%eax
    e768:	89 50 34             	mov    %edx,0x34(%eax)
    e76b:	8b 45 08             	mov    0x8(%ebp),%eax
    e76e:	8b 50 34             	mov    0x34(%eax),%edx
    e771:	8b 45 08             	mov    0x8(%ebp),%eax
    e774:	89 50 30             	mov    %edx,0x30(%eax)
    e777:	e9 9d 00 00 00       	jmp    e819 <readChunk_bKGD+0x17c>
  } else if(info->color.colortype == LCT_RGB || info->color.colortype == LCT_RGBA) {
    e77c:	8b 45 08             	mov    0x8(%ebp),%eax
    e77f:	8b 40 0c             	mov    0xc(%eax),%eax
    e782:	83 f8 02             	cmp    $0x2,%eax
    e785:	74 0f                	je     e796 <readChunk_bKGD+0xf9>
    e787:	8b 45 08             	mov    0x8(%ebp),%eax
    e78a:	8b 40 0c             	mov    0xc(%eax),%eax
    e78d:	83 f8 06             	cmp    $0x6,%eax
    e790:	0f 85 83 00 00 00    	jne    e819 <readChunk_bKGD+0x17c>
    /*error: this chunk must be 6 bytes for grayscale image*/
    if(chunkLength != 6) return 45;
    e796:	83 7d 10 06          	cmpl   $0x6,0x10(%ebp)
    e79a:	74 07                	je     e7a3 <readChunk_bKGD+0x106>
    e79c:	b8 2d 00 00 00       	mov    $0x2d,%eax
    e7a1:	eb 7b                	jmp    e81e <readChunk_bKGD+0x181>

    /*the values are truncated to bitdepth in the PNG file*/
    info->background_defined = 1;
    e7a3:	8b 45 08             	mov    0x8(%ebp),%eax
    e7a6:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
    info->background_r = 256u * data[0] + data[1];
    e7ad:	8b 45 0c             	mov    0xc(%ebp),%eax
    e7b0:	0f b6 00             	movzbl (%eax),%eax
    e7b3:	0f b6 c0             	movzbl %al,%eax
    e7b6:	c1 e0 08             	shl    $0x8,%eax
    e7b9:	89 c2                	mov    %eax,%edx
    e7bb:	8b 45 0c             	mov    0xc(%ebp),%eax
    e7be:	83 c0 01             	add    $0x1,%eax
    e7c1:	0f b6 00             	movzbl (%eax),%eax
    e7c4:	0f b6 c0             	movzbl %al,%eax
    e7c7:	01 c2                	add    %eax,%edx
    e7c9:	8b 45 08             	mov    0x8(%ebp),%eax
    e7cc:	89 50 30             	mov    %edx,0x30(%eax)
    info->background_g = 256u * data[2] + data[3];
    e7cf:	8b 45 0c             	mov    0xc(%ebp),%eax
    e7d2:	83 c0 02             	add    $0x2,%eax
    e7d5:	0f b6 00             	movzbl (%eax),%eax
    e7d8:	0f b6 c0             	movzbl %al,%eax
    e7db:	c1 e0 08             	shl    $0x8,%eax
    e7de:	89 c2                	mov    %eax,%edx
    e7e0:	8b 45 0c             	mov    0xc(%ebp),%eax
    e7e3:	83 c0 03             	add    $0x3,%eax
    e7e6:	0f b6 00             	movzbl (%eax),%eax
    e7e9:	0f b6 c0             	movzbl %al,%eax
    e7ec:	01 c2                	add    %eax,%edx
    e7ee:	8b 45 08             	mov    0x8(%ebp),%eax
    e7f1:	89 50 34             	mov    %edx,0x34(%eax)
    info->background_b = 256u * data[4] + data[5];
    e7f4:	8b 45 0c             	mov    0xc(%ebp),%eax
    e7f7:	83 c0 04             	add    $0x4,%eax
    e7fa:	0f b6 00             	movzbl (%eax),%eax
    e7fd:	0f b6 c0             	movzbl %al,%eax
    e800:	c1 e0 08             	shl    $0x8,%eax
    e803:	89 c2                	mov    %eax,%edx
    e805:	8b 45 0c             	mov    0xc(%ebp),%eax
    e808:	83 c0 05             	add    $0x5,%eax
    e80b:	0f b6 00             	movzbl (%eax),%eax
    e80e:	0f b6 c0             	movzbl %al,%eax
    e811:	01 c2                	add    %eax,%edx
    e813:	8b 45 08             	mov    0x8(%ebp),%eax
    e816:	89 50 38             	mov    %edx,0x38(%eax)
  }

  return 0; /* OK */
    e819:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e81e:	5d                   	pop    %ebp
    e81f:	c3                   	ret    

0000e820 <readChunk_tEXt>:

/*text chunk (tEXt)*/
static unsigned readChunk_tEXt(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    e820:	55                   	push   %ebp
    e821:	89 e5                	mov    %esp,%ebp
    e823:	83 ec 28             	sub    $0x28,%esp
  unsigned error = 0;
    e826:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  char *key = 0, *str = 0;
    e82d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    e834:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  while(!error) /*not really a while loop, only used to break on error*/ {
    e83b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    e83f:	0f 85 06 01 00 00    	jne    e94b <readChunk_tEXt+0x12b>
    unsigned length, string2_begin;

    length = 0;
    e845:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    while(length < chunkLength && data[length] != 0) ++length;
    e84c:	eb 04                	jmp    e852 <readChunk_tEXt+0x32>
    e84e:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    e852:	8b 45 10             	mov    0x10(%ebp),%eax
    e855:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    e858:	73 0f                	jae    e869 <readChunk_tEXt+0x49>
    e85a:	8b 55 0c             	mov    0xc(%ebp),%edx
    e85d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e860:	01 d0                	add    %edx,%eax
    e862:	0f b6 00             	movzbl (%eax),%eax
    e865:	84 c0                	test   %al,%al
    e867:	75 e5                	jne    e84e <readChunk_tEXt+0x2e>
    /*even though it's not allowed by the standard, no error is thrown if
    there's no null termination char, if the text is empty*/
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
    e869:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    e86d:	74 06                	je     e875 <readChunk_tEXt+0x55>
    e86f:	83 7d e8 4f          	cmpl   $0x4f,-0x18(%ebp)
    e873:	76 0c                	jbe    e881 <readChunk_tEXt+0x61>
    e875:	c7 45 f4 59 00 00 00 	movl   $0x59,-0xc(%ebp)
    e87c:	e9 ca 00 00 00       	jmp    e94b <readChunk_tEXt+0x12b>

    key = (char*)lodepng_malloc(length + 1);
    e881:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e884:	83 c0 01             	add    $0x1,%eax
    e887:	83 ec 0c             	sub    $0xc,%esp
    e88a:	50                   	push   %eax
    e88b:	e8 73 4b ff ff       	call   3403 <lodepng_malloc>
    e890:	83 c4 10             	add    $0x10,%esp
    e893:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
    e896:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    e89a:	75 0c                	jne    e8a8 <readChunk_tEXt+0x88>
    e89c:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    e8a3:	e9 a3 00 00 00       	jmp    e94b <readChunk_tEXt+0x12b>

    lodepng_memcpy(key, data, length);
    e8a8:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e8ab:	83 ec 04             	sub    $0x4,%esp
    e8ae:	50                   	push   %eax
    e8af:	ff 75 0c             	pushl  0xc(%ebp)
    e8b2:	ff 75 f0             	pushl  -0x10(%ebp)
    e8b5:	e8 87 4b ff ff       	call   3441 <lodepng_memcpy>
    e8ba:	83 c4 10             	add    $0x10,%esp
    key[length] = 0;
    e8bd:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e8c0:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e8c3:	01 d0                	add    %edx,%eax
    e8c5:	c6 00 00             	movb   $0x0,(%eax)

    string2_begin = length + 1; /*skip keyword null terminator*/
    e8c8:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e8cb:	83 c0 01             	add    $0x1,%eax
    e8ce:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    length = (unsigned)(chunkLength < string2_begin ? 0 : chunkLength - string2_begin);
    e8d1:	8b 45 10             	mov    0x10(%ebp),%eax
    e8d4:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    e8d7:	72 08                	jb     e8e1 <readChunk_tEXt+0xc1>
    e8d9:	8b 45 10             	mov    0x10(%ebp),%eax
    e8dc:	2b 45 e4             	sub    -0x1c(%ebp),%eax
    e8df:	eb 05                	jmp    e8e6 <readChunk_tEXt+0xc6>
    e8e1:	b8 00 00 00 00       	mov    $0x0,%eax
    e8e6:	89 45 e8             	mov    %eax,-0x18(%ebp)
    str = (char*)lodepng_malloc(length + 1);
    e8e9:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e8ec:	83 c0 01             	add    $0x1,%eax
    e8ef:	83 ec 0c             	sub    $0xc,%esp
    e8f2:	50                   	push   %eax
    e8f3:	e8 0b 4b ff ff       	call   3403 <lodepng_malloc>
    e8f8:	83 c4 10             	add    $0x10,%esp
    e8fb:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!str) CERROR_BREAK(error, 83); /*alloc fail*/
    e8fe:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    e902:	75 09                	jne    e90d <readChunk_tEXt+0xed>
    e904:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    e90b:	eb 3e                	jmp    e94b <readChunk_tEXt+0x12b>

    lodepng_memcpy(str, data + string2_begin, length);
    e90d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e910:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    e913:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    e916:	01 ca                	add    %ecx,%edx
    e918:	83 ec 04             	sub    $0x4,%esp
    e91b:	50                   	push   %eax
    e91c:	52                   	push   %edx
    e91d:	ff 75 ec             	pushl  -0x14(%ebp)
    e920:	e8 1c 4b ff ff       	call   3441 <lodepng_memcpy>
    e925:	83 c4 10             	add    $0x10,%esp
    str[length] = 0;
    e928:	8b 55 ec             	mov    -0x14(%ebp),%edx
    e92b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e92e:	01 d0                	add    %edx,%eax
    e930:	c6 00 00             	movb   $0x0,(%eax)

    error = lodepng_add_text(info, key, str);
    e933:	83 ec 04             	sub    $0x4,%esp
    e936:	ff 75 ec             	pushl  -0x14(%ebp)
    e939:	ff 75 f0             	pushl  -0x10(%ebp)
    e93c:	ff 75 08             	pushl  0x8(%ebp)
    e93f:	e8 3f ac ff ff       	call   9583 <lodepng_add_text>
    e944:	83 c4 10             	add    $0x10,%esp
    e947:	89 45 f4             	mov    %eax,-0xc(%ebp)

    break;
    e94a:	90                   	nop
  }

  lodepng_free(key);
    e94b:	83 ec 0c             	sub    $0xc,%esp
    e94e:	ff 75 f0             	pushl  -0x10(%ebp)
    e951:	e8 ce 4a ff ff       	call   3424 <lodepng_free>
    e956:	83 c4 10             	add    $0x10,%esp
  lodepng_free(str);
    e959:	83 ec 0c             	sub    $0xc,%esp
    e95c:	ff 75 ec             	pushl  -0x14(%ebp)
    e95f:	e8 c0 4a ff ff       	call   3424 <lodepng_free>
    e964:	83 c4 10             	add    $0x10,%esp

  return error;
    e967:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    e96a:	c9                   	leave  
    e96b:	c3                   	ret    

0000e96c <readChunk_zTXt>:

/*compressed text chunk (zTXt)*/
static unsigned readChunk_zTXt(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,
                               const unsigned char* data, size_t chunkLength) {
    e96c:	55                   	push   %ebp
    e96d:	89 e5                	mov    %esp,%ebp
    e96f:	83 ec 38             	sub    $0x38,%esp
  unsigned error = 0;
    e972:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  /*copy the object to change parameters in it*/
  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;
    e979:	8b 45 0c             	mov    0xc(%ebp),%eax
    e97c:	8b 10                	mov    (%eax),%edx
    e97e:	89 55 d0             	mov    %edx,-0x30(%ebp)
    e981:	8b 50 04             	mov    0x4(%eax),%edx
    e984:	89 55 d4             	mov    %edx,-0x2c(%ebp)
    e987:	8b 50 08             	mov    0x8(%eax),%edx
    e98a:	89 55 d8             	mov    %edx,-0x28(%ebp)
    e98d:	8b 50 0c             	mov    0xc(%eax),%edx
    e990:	89 55 dc             	mov    %edx,-0x24(%ebp)
    e993:	8b 50 10             	mov    0x10(%eax),%edx
    e996:	89 55 e0             	mov    %edx,-0x20(%ebp)
    e999:	8b 40 14             	mov    0x14(%eax),%eax
    e99c:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  unsigned length, string2_begin;
  char *key = 0;
    e99f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  unsigned char* str = 0;
    e9a6:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
  size_t size = 0;
    e9ad:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)

  while(!error) /*not really a while loop, only used to break on error*/ {
    e9b4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    e9b8:	0f 85 48 01 00 00    	jne    eb06 <readChunk_zTXt+0x19a>
    for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
    e9be:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    e9c5:	eb 04                	jmp    e9cb <readChunk_zTXt+0x5f>
    e9c7:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    e9cb:	8b 45 14             	mov    0x14(%ebp),%eax
    e9ce:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    e9d1:	73 0f                	jae    e9e2 <readChunk_zTXt+0x76>
    e9d3:	8b 55 10             	mov    0x10(%ebp),%edx
    e9d6:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e9d9:	01 d0                	add    %edx,%eax
    e9db:	0f b6 00             	movzbl (%eax),%eax
    e9de:	84 c0                	test   %al,%al
    e9e0:	75 e5                	jne    e9c7 <readChunk_zTXt+0x5b>
    if(length + 2 >= chunkLength) CERROR_BREAK(error, 75); /*no null termination, corrupt?*/
    e9e2:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e9e5:	8d 50 02             	lea    0x2(%eax),%edx
    e9e8:	8b 45 14             	mov    0x14(%ebp),%eax
    e9eb:	39 c2                	cmp    %eax,%edx
    e9ed:	72 0c                	jb     e9fb <readChunk_zTXt+0x8f>
    e9ef:	c7 45 f4 4b 00 00 00 	movl   $0x4b,-0xc(%ebp)
    e9f6:	e9 0b 01 00 00       	jmp    eb06 <readChunk_zTXt+0x19a>
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
    e9fb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    e9ff:	74 06                	je     ea07 <readChunk_zTXt+0x9b>
    ea01:	83 7d f0 4f          	cmpl   $0x4f,-0x10(%ebp)
    ea05:	76 0c                	jbe    ea13 <readChunk_zTXt+0xa7>
    ea07:	c7 45 f4 59 00 00 00 	movl   $0x59,-0xc(%ebp)
    ea0e:	e9 f3 00 00 00       	jmp    eb06 <readChunk_zTXt+0x19a>

    key = (char*)lodepng_malloc(length + 1);
    ea13:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ea16:	83 c0 01             	add    $0x1,%eax
    ea19:	83 ec 0c             	sub    $0xc,%esp
    ea1c:	50                   	push   %eax
    ea1d:	e8 e1 49 ff ff       	call   3403 <lodepng_malloc>
    ea22:	83 c4 10             	add    $0x10,%esp
    ea25:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
    ea28:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    ea2c:	75 0c                	jne    ea3a <readChunk_zTXt+0xce>
    ea2e:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    ea35:	e9 cc 00 00 00       	jmp    eb06 <readChunk_zTXt+0x19a>

    lodepng_memcpy(key, data, length);
    ea3a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ea3d:	83 ec 04             	sub    $0x4,%esp
    ea40:	50                   	push   %eax
    ea41:	ff 75 10             	pushl  0x10(%ebp)
    ea44:	ff 75 ec             	pushl  -0x14(%ebp)
    ea47:	e8 f5 49 ff ff       	call   3441 <lodepng_memcpy>
    ea4c:	83 c4 10             	add    $0x10,%esp
    key[length] = 0;
    ea4f:	8b 55 ec             	mov    -0x14(%ebp),%edx
    ea52:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ea55:	01 d0                	add    %edx,%eax
    ea57:	c6 00 00             	movb   $0x0,(%eax)

    if(data[length + 1] != 0) CERROR_BREAK(error, 72); /*the 0 byte indicating compression must be 0*/
    ea5a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ea5d:	8d 50 01             	lea    0x1(%eax),%edx
    ea60:	8b 45 10             	mov    0x10(%ebp),%eax
    ea63:	01 d0                	add    %edx,%eax
    ea65:	0f b6 00             	movzbl (%eax),%eax
    ea68:	84 c0                	test   %al,%al
    ea6a:	74 0c                	je     ea78 <readChunk_zTXt+0x10c>
    ea6c:	c7 45 f4 48 00 00 00 	movl   $0x48,-0xc(%ebp)
    ea73:	e9 8e 00 00 00       	jmp    eb06 <readChunk_zTXt+0x19a>

    string2_begin = length + 2;
    ea78:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ea7b:	83 c0 02             	add    $0x2,%eax
    ea7e:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(string2_begin > chunkLength) CERROR_BREAK(error, 75); /*no null termination, corrupt?*/
    ea81:	8b 45 14             	mov    0x14(%ebp),%eax
    ea84:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    ea87:	76 09                	jbe    ea92 <readChunk_zTXt+0x126>
    ea89:	c7 45 f4 4b 00 00 00 	movl   $0x4b,-0xc(%ebp)
    ea90:	eb 74                	jmp    eb06 <readChunk_zTXt+0x19a>

    length = (unsigned)chunkLength - string2_begin;
    ea92:	8b 45 14             	mov    0x14(%ebp),%eax
    ea95:	2b 45 e8             	sub    -0x18(%ebp),%eax
    ea98:	89 45 f0             	mov    %eax,-0x10(%ebp)
    zlibsettings.max_output_size = decoder->max_text_size;
    ea9b:	8b 45 0c             	mov    0xc(%ebp),%eax
    ea9e:	8b 40 30             	mov    0x30(%eax),%eax
    eaa1:	89 45 d8             	mov    %eax,-0x28(%ebp)
    /*will fail if zlib error, e.g. if length is too small*/
    error = zlib_decompress(&str, &size, 0, &data[string2_begin],
    eaa4:	8b 45 f0             	mov    -0x10(%ebp),%eax
    eaa7:	8b 4d 10             	mov    0x10(%ebp),%ecx
    eaaa:	8b 55 e8             	mov    -0x18(%ebp),%edx
    eaad:	01 d1                	add    %edx,%ecx
    eaaf:	83 ec 08             	sub    $0x8,%esp
    eab2:	8d 55 d0             	lea    -0x30(%ebp),%edx
    eab5:	52                   	push   %edx
    eab6:	50                   	push   %eax
    eab7:	51                   	push   %ecx
    eab8:	6a 00                	push   $0x0
    eaba:	8d 45 c8             	lea    -0x38(%ebp),%eax
    eabd:	50                   	push   %eax
    eabe:	8d 45 cc             	lea    -0x34(%ebp),%eax
    eac1:	50                   	push   %eax
    eac2:	e8 f7 93 ff ff       	call   7ebe <zlib_decompress>
    eac7:	83 c4 20             	add    $0x20,%esp
    eaca:	89 45 f4             	mov    %eax,-0xc(%ebp)
                            length, &zlibsettings);
    /*error: compressed text larger than  decoder->max_text_size*/
    if(error && size > zlibsettings.max_output_size) error = 112;
    eacd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    ead1:	74 11                	je     eae4 <readChunk_zTXt+0x178>
    ead3:	8b 55 d8             	mov    -0x28(%ebp),%edx
    ead6:	8b 45 c8             	mov    -0x38(%ebp),%eax
    ead9:	39 c2                	cmp    %eax,%edx
    eadb:	7d 07                	jge    eae4 <readChunk_zTXt+0x178>
    eadd:	c7 45 f4 70 00 00 00 	movl   $0x70,-0xc(%ebp)
    if(error) break;
    eae4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    eae8:	75 1b                	jne    eb05 <readChunk_zTXt+0x199>
    error = lodepng_add_text_sized(info, key, (char*)str, size);
    eaea:	8b 55 c8             	mov    -0x38(%ebp),%edx
    eaed:	8b 45 cc             	mov    -0x34(%ebp),%eax
    eaf0:	52                   	push   %edx
    eaf1:	50                   	push   %eax
    eaf2:	ff 75 ec             	pushl  -0x14(%ebp)
    eaf5:	ff 75 08             	pushl  0x8(%ebp)
    eaf8:	e8 60 a9 ff ff       	call   945d <lodepng_add_text_sized>
    eafd:	83 c4 10             	add    $0x10,%esp
    eb00:	89 45 f4             	mov    %eax,-0xc(%ebp)
    break;
    eb03:	eb 01                	jmp    eb06 <readChunk_zTXt+0x19a>
    /*will fail if zlib error, e.g. if length is too small*/
    error = zlib_decompress(&str, &size, 0, &data[string2_begin],
                            length, &zlibsettings);
    /*error: compressed text larger than  decoder->max_text_size*/
    if(error && size > zlibsettings.max_output_size) error = 112;
    if(error) break;
    eb05:	90                   	nop
    error = lodepng_add_text_sized(info, key, (char*)str, size);
    break;
  }

  lodepng_free(key);
    eb06:	83 ec 0c             	sub    $0xc,%esp
    eb09:	ff 75 ec             	pushl  -0x14(%ebp)
    eb0c:	e8 13 49 ff ff       	call   3424 <lodepng_free>
    eb11:	83 c4 10             	add    $0x10,%esp
  lodepng_free(str);
    eb14:	8b 45 cc             	mov    -0x34(%ebp),%eax
    eb17:	83 ec 0c             	sub    $0xc,%esp
    eb1a:	50                   	push   %eax
    eb1b:	e8 04 49 ff ff       	call   3424 <lodepng_free>
    eb20:	83 c4 10             	add    $0x10,%esp

  return error;
    eb23:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    eb26:	c9                   	leave  
    eb27:	c3                   	ret    

0000eb28 <readChunk_iTXt>:

/*international text chunk (iTXt)*/
static unsigned readChunk_iTXt(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,
                               const unsigned char* data, size_t chunkLength) {
    eb28:	55                   	push   %ebp
    eb29:	89 e5                	mov    %esp,%ebp
    eb2b:	83 ec 48             	sub    $0x48,%esp
  unsigned error = 0;
    eb2e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned i;

  /*copy the object to change parameters in it*/
  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;
    eb35:	8b 45 0c             	mov    0xc(%ebp),%eax
    eb38:	8b 10                	mov    (%eax),%edx
    eb3a:	89 55 c0             	mov    %edx,-0x40(%ebp)
    eb3d:	8b 50 04             	mov    0x4(%eax),%edx
    eb40:	89 55 c4             	mov    %edx,-0x3c(%ebp)
    eb43:	8b 50 08             	mov    0x8(%eax),%edx
    eb46:	89 55 c8             	mov    %edx,-0x38(%ebp)
    eb49:	8b 50 0c             	mov    0xc(%eax),%edx
    eb4c:	89 55 cc             	mov    %edx,-0x34(%ebp)
    eb4f:	8b 50 10             	mov    0x10(%eax),%edx
    eb52:	89 55 d0             	mov    %edx,-0x30(%ebp)
    eb55:	8b 40 14             	mov    0x14(%eax),%eax
    eb58:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  unsigned length, begin, compressed;
  char *key = 0, *langtag = 0, *transkey = 0;
    eb5b:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    eb62:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    eb69:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

  while(!error) /*not really a while loop, only used to break on error*/ {
    eb70:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    eb74:	0f 85 d5 02 00 00    	jne    ee4f <readChunk_iTXt+0x327>
    /*Quick check if the chunk length isn't too small. Even without check
    it'd still fail with other error checks below if it's too short. This just gives a different error code.*/
    if(chunkLength < 5) CERROR_BREAK(error, 30); /*iTXt chunk too short*/
    eb7a:	83 7d 14 04          	cmpl   $0x4,0x14(%ebp)
    eb7e:	7f 0c                	jg     eb8c <readChunk_iTXt+0x64>
    eb80:	c7 45 f4 1e 00 00 00 	movl   $0x1e,-0xc(%ebp)
    eb87:	e9 c3 02 00 00       	jmp    ee4f <readChunk_iTXt+0x327>

    /*read the key*/
    for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
    eb8c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    eb93:	eb 04                	jmp    eb99 <readChunk_iTXt+0x71>
    eb95:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    eb99:	8b 45 14             	mov    0x14(%ebp),%eax
    eb9c:	39 45 ec             	cmp    %eax,-0x14(%ebp)
    eb9f:	73 0f                	jae    ebb0 <readChunk_iTXt+0x88>
    eba1:	8b 55 10             	mov    0x10(%ebp),%edx
    eba4:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eba7:	01 d0                	add    %edx,%eax
    eba9:	0f b6 00             	movzbl (%eax),%eax
    ebac:	84 c0                	test   %al,%al
    ebae:	75 e5                	jne    eb95 <readChunk_iTXt+0x6d>
    if(length + 3 >= chunkLength) CERROR_BREAK(error, 75); /*no null termination char, corrupt?*/
    ebb0:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ebb3:	8d 50 03             	lea    0x3(%eax),%edx
    ebb6:	8b 45 14             	mov    0x14(%ebp),%eax
    ebb9:	39 c2                	cmp    %eax,%edx
    ebbb:	72 0c                	jb     ebc9 <readChunk_iTXt+0xa1>
    ebbd:	c7 45 f4 4b 00 00 00 	movl   $0x4b,-0xc(%ebp)
    ebc4:	e9 86 02 00 00       	jmp    ee4f <readChunk_iTXt+0x327>
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
    ebc9:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    ebcd:	74 06                	je     ebd5 <readChunk_iTXt+0xad>
    ebcf:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
    ebd3:	76 0c                	jbe    ebe1 <readChunk_iTXt+0xb9>
    ebd5:	c7 45 f4 59 00 00 00 	movl   $0x59,-0xc(%ebp)
    ebdc:	e9 6e 02 00 00       	jmp    ee4f <readChunk_iTXt+0x327>

    key = (char*)lodepng_malloc(length + 1);
    ebe1:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ebe4:	83 c0 01             	add    $0x1,%eax
    ebe7:	83 ec 0c             	sub    $0xc,%esp
    ebea:	50                   	push   %eax
    ebeb:	e8 13 48 ff ff       	call   3403 <lodepng_malloc>
    ebf0:	83 c4 10             	add    $0x10,%esp
    ebf3:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
    ebf6:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    ebfa:	75 0c                	jne    ec08 <readChunk_iTXt+0xe0>
    ebfc:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    ec03:	e9 47 02 00 00       	jmp    ee4f <readChunk_iTXt+0x327>

    lodepng_memcpy(key, data, length);
    ec08:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ec0b:	83 ec 04             	sub    $0x4,%esp
    ec0e:	50                   	push   %eax
    ec0f:	ff 75 10             	pushl  0x10(%ebp)
    ec12:	ff 75 e8             	pushl  -0x18(%ebp)
    ec15:	e8 27 48 ff ff       	call   3441 <lodepng_memcpy>
    ec1a:	83 c4 10             	add    $0x10,%esp
    key[length] = 0;
    ec1d:	8b 55 e8             	mov    -0x18(%ebp),%edx
    ec20:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ec23:	01 d0                	add    %edx,%eax
    ec25:	c6 00 00             	movb   $0x0,(%eax)

    /*read the compression method*/
    compressed = data[length + 1];
    ec28:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ec2b:	8d 50 01             	lea    0x1(%eax),%edx
    ec2e:	8b 45 10             	mov    0x10(%ebp),%eax
    ec31:	01 d0                	add    %edx,%eax
    ec33:	0f b6 00             	movzbl (%eax),%eax
    ec36:	0f b6 c0             	movzbl %al,%eax
    ec39:	89 45 dc             	mov    %eax,-0x24(%ebp)
    if(data[length + 2] != 0) CERROR_BREAK(error, 72); /*the 0 byte indicating compression must be 0*/
    ec3c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ec3f:	8d 50 02             	lea    0x2(%eax),%edx
    ec42:	8b 45 10             	mov    0x10(%ebp),%eax
    ec45:	01 d0                	add    %edx,%eax
    ec47:	0f b6 00             	movzbl (%eax),%eax
    ec4a:	84 c0                	test   %al,%al
    ec4c:	74 0c                	je     ec5a <readChunk_iTXt+0x132>
    ec4e:	c7 45 f4 48 00 00 00 	movl   $0x48,-0xc(%ebp)
    ec55:	e9 f5 01 00 00       	jmp    ee4f <readChunk_iTXt+0x327>

    /*even though it's not allowed by the standard, no error is thrown if
    there's no null termination char, if the text is empty for the next 3 texts*/

    /*read the langtag*/
    begin = length + 3;
    ec5a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ec5d:	83 c0 03             	add    $0x3,%eax
    ec60:	89 45 d8             	mov    %eax,-0x28(%ebp)
    length = 0;
    ec63:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    for(i = begin; i < chunkLength && data[i] != 0; ++i) ++length;
    ec6a:	8b 45 d8             	mov    -0x28(%ebp),%eax
    ec6d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    ec70:	eb 08                	jmp    ec7a <readChunk_iTXt+0x152>
    ec72:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    ec76:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    ec7a:	8b 45 14             	mov    0x14(%ebp),%eax
    ec7d:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    ec80:	73 0f                	jae    ec91 <readChunk_iTXt+0x169>
    ec82:	8b 55 10             	mov    0x10(%ebp),%edx
    ec85:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ec88:	01 d0                	add    %edx,%eax
    ec8a:	0f b6 00             	movzbl (%eax),%eax
    ec8d:	84 c0                	test   %al,%al
    ec8f:	75 e1                	jne    ec72 <readChunk_iTXt+0x14a>

    langtag = (char*)lodepng_malloc(length + 1);
    ec91:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ec94:	83 c0 01             	add    $0x1,%eax
    ec97:	83 ec 0c             	sub    $0xc,%esp
    ec9a:	50                   	push   %eax
    ec9b:	e8 63 47 ff ff       	call   3403 <lodepng_malloc>
    eca0:	83 c4 10             	add    $0x10,%esp
    eca3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(!langtag) CERROR_BREAK(error, 83); /*alloc fail*/
    eca6:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    ecaa:	75 0c                	jne    ecb8 <readChunk_iTXt+0x190>
    ecac:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    ecb3:	e9 97 01 00 00       	jmp    ee4f <readChunk_iTXt+0x327>

    lodepng_memcpy(langtag, data + begin, length);
    ecb8:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ecbb:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ecbe:	8b 55 d8             	mov    -0x28(%ebp),%edx
    ecc1:	01 ca                	add    %ecx,%edx
    ecc3:	83 ec 04             	sub    $0x4,%esp
    ecc6:	50                   	push   %eax
    ecc7:	52                   	push   %edx
    ecc8:	ff 75 e4             	pushl  -0x1c(%ebp)
    eccb:	e8 71 47 ff ff       	call   3441 <lodepng_memcpy>
    ecd0:	83 c4 10             	add    $0x10,%esp
    langtag[length] = 0;
    ecd3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    ecd6:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ecd9:	01 d0                	add    %edx,%eax
    ecdb:	c6 00 00             	movb   $0x0,(%eax)

    /*read the transkey*/
    begin += length + 1;
    ecde:	8b 55 ec             	mov    -0x14(%ebp),%edx
    ece1:	8b 45 d8             	mov    -0x28(%ebp),%eax
    ece4:	01 d0                	add    %edx,%eax
    ece6:	83 c0 01             	add    $0x1,%eax
    ece9:	89 45 d8             	mov    %eax,-0x28(%ebp)
    length = 0;
    ecec:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    for(i = begin; i < chunkLength && data[i] != 0; ++i) ++length;
    ecf3:	8b 45 d8             	mov    -0x28(%ebp),%eax
    ecf6:	89 45 f0             	mov    %eax,-0x10(%ebp)
    ecf9:	eb 08                	jmp    ed03 <readChunk_iTXt+0x1db>
    ecfb:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    ecff:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    ed03:	8b 45 14             	mov    0x14(%ebp),%eax
    ed06:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    ed09:	73 0f                	jae    ed1a <readChunk_iTXt+0x1f2>
    ed0b:	8b 55 10             	mov    0x10(%ebp),%edx
    ed0e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ed11:	01 d0                	add    %edx,%eax
    ed13:	0f b6 00             	movzbl (%eax),%eax
    ed16:	84 c0                	test   %al,%al
    ed18:	75 e1                	jne    ecfb <readChunk_iTXt+0x1d3>

    transkey = (char*)lodepng_malloc(length + 1);
    ed1a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ed1d:	83 c0 01             	add    $0x1,%eax
    ed20:	83 ec 0c             	sub    $0xc,%esp
    ed23:	50                   	push   %eax
    ed24:	e8 da 46 ff ff       	call   3403 <lodepng_malloc>
    ed29:	83 c4 10             	add    $0x10,%esp
    ed2c:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(!transkey) CERROR_BREAK(error, 83); /*alloc fail*/
    ed2f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    ed33:	75 0c                	jne    ed41 <readChunk_iTXt+0x219>
    ed35:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    ed3c:	e9 0e 01 00 00       	jmp    ee4f <readChunk_iTXt+0x327>

    lodepng_memcpy(transkey, data + begin, length);
    ed41:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ed44:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ed47:	8b 55 d8             	mov    -0x28(%ebp),%edx
    ed4a:	01 ca                	add    %ecx,%edx
    ed4c:	83 ec 04             	sub    $0x4,%esp
    ed4f:	50                   	push   %eax
    ed50:	52                   	push   %edx
    ed51:	ff 75 e0             	pushl  -0x20(%ebp)
    ed54:	e8 e8 46 ff ff       	call   3441 <lodepng_memcpy>
    ed59:	83 c4 10             	add    $0x10,%esp
    transkey[length] = 0;
    ed5c:	8b 55 e0             	mov    -0x20(%ebp),%edx
    ed5f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ed62:	01 d0                	add    %edx,%eax
    ed64:	c6 00 00             	movb   $0x0,(%eax)

    /*read the actual text*/
    begin += length + 1;
    ed67:	8b 55 ec             	mov    -0x14(%ebp),%edx
    ed6a:	8b 45 d8             	mov    -0x28(%ebp),%eax
    ed6d:	01 d0                	add    %edx,%eax
    ed6f:	83 c0 01             	add    $0x1,%eax
    ed72:	89 45 d8             	mov    %eax,-0x28(%ebp)

    length = (unsigned)chunkLength < begin ? 0 : (unsigned)chunkLength - begin;
    ed75:	8b 45 14             	mov    0x14(%ebp),%eax
    ed78:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    ed7b:	72 08                	jb     ed85 <readChunk_iTXt+0x25d>
    ed7d:	8b 45 14             	mov    0x14(%ebp),%eax
    ed80:	2b 45 d8             	sub    -0x28(%ebp),%eax
    ed83:	eb 05                	jmp    ed8a <readChunk_iTXt+0x262>
    ed85:	b8 00 00 00 00       	mov    $0x0,%eax
    ed8a:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(compressed) {
    ed8d:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    ed91:	0f 84 90 00 00 00    	je     ee27 <readChunk_iTXt+0x2ff>
      unsigned char* str = 0;
    ed97:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
      size_t size = 0;
    ed9e:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
      zlibsettings.max_output_size = decoder->max_text_size;
    eda5:	8b 45 0c             	mov    0xc(%ebp),%eax
    eda8:	8b 40 30             	mov    0x30(%eax),%eax
    edab:	89 45 c8             	mov    %eax,-0x38(%ebp)
      /*will fail if zlib error, e.g. if length is too small*/
      error = zlib_decompress(&str, &size, 0, &data[begin],
    edae:	8b 45 ec             	mov    -0x14(%ebp),%eax
    edb1:	8b 4d 10             	mov    0x10(%ebp),%ecx
    edb4:	8b 55 d8             	mov    -0x28(%ebp),%edx
    edb7:	01 d1                	add    %edx,%ecx
    edb9:	83 ec 08             	sub    $0x8,%esp
    edbc:	8d 55 c0             	lea    -0x40(%ebp),%edx
    edbf:	52                   	push   %edx
    edc0:	50                   	push   %eax
    edc1:	51                   	push   %ecx
    edc2:	6a 00                	push   $0x0
    edc4:	8d 45 b8             	lea    -0x48(%ebp),%eax
    edc7:	50                   	push   %eax
    edc8:	8d 45 bc             	lea    -0x44(%ebp),%eax
    edcb:	50                   	push   %eax
    edcc:	e8 ed 90 ff ff       	call   7ebe <zlib_decompress>
    edd1:	83 c4 20             	add    $0x20,%esp
    edd4:	89 45 f4             	mov    %eax,-0xc(%ebp)
                              length, &zlibsettings);
      /*error: compressed text larger than  decoder->max_text_size*/
      if(error && size > zlibsettings.max_output_size) error = 112;
    edd7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    eddb:	74 11                	je     edee <readChunk_iTXt+0x2c6>
    eddd:	8b 55 c8             	mov    -0x38(%ebp),%edx
    ede0:	8b 45 b8             	mov    -0x48(%ebp),%eax
    ede3:	39 c2                	cmp    %eax,%edx
    ede5:	7d 07                	jge    edee <readChunk_iTXt+0x2c6>
    ede7:	c7 45 f4 70 00 00 00 	movl   $0x70,-0xc(%ebp)
      if(!error) error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)str, size);
    edee:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    edf2:	75 22                	jne    ee16 <readChunk_iTXt+0x2ee>
    edf4:	8b 55 b8             	mov    -0x48(%ebp),%edx
    edf7:	8b 45 bc             	mov    -0x44(%ebp),%eax
    edfa:	83 ec 08             	sub    $0x8,%esp
    edfd:	52                   	push   %edx
    edfe:	50                   	push   %eax
    edff:	ff 75 e0             	pushl  -0x20(%ebp)
    ee02:	ff 75 e4             	pushl  -0x1c(%ebp)
    ee05:	ff 75 e8             	pushl  -0x18(%ebp)
    ee08:	ff 75 08             	pushl  0x8(%ebp)
    ee0b:	e8 94 a9 ff ff       	call   97a4 <lodepng_add_itext_sized>
    ee10:	83 c4 20             	add    $0x20,%esp
    ee13:	89 45 f4             	mov    %eax,-0xc(%ebp)
      lodepng_free(str);
    ee16:	8b 45 bc             	mov    -0x44(%ebp),%eax
    ee19:	83 ec 0c             	sub    $0xc,%esp
    ee1c:	50                   	push   %eax
    ee1d:	e8 02 46 ff ff       	call   3424 <lodepng_free>
    ee22:	83 c4 10             	add    $0x10,%esp
    } else {
      error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)(data + begin), length);
    }

    break;
    ee25:	eb 27                	jmp    ee4e <readChunk_iTXt+0x326>
      /*error: compressed text larger than  decoder->max_text_size*/
      if(error && size > zlibsettings.max_output_size) error = 112;
      if(!error) error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)str, size);
      lodepng_free(str);
    } else {
      error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)(data + begin), length);
    ee27:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ee2a:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ee2d:	8b 55 d8             	mov    -0x28(%ebp),%edx
    ee30:	01 ca                	add    %ecx,%edx
    ee32:	83 ec 08             	sub    $0x8,%esp
    ee35:	50                   	push   %eax
    ee36:	52                   	push   %edx
    ee37:	ff 75 e0             	pushl  -0x20(%ebp)
    ee3a:	ff 75 e4             	pushl  -0x1c(%ebp)
    ee3d:	ff 75 e8             	pushl  -0x18(%ebp)
    ee40:	ff 75 08             	pushl  0x8(%ebp)
    ee43:	e8 5c a9 ff ff       	call   97a4 <lodepng_add_itext_sized>
    ee48:	83 c4 20             	add    $0x20,%esp
    ee4b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

    break;
    ee4e:	90                   	nop
  }

  lodepng_free(key);
    ee4f:	83 ec 0c             	sub    $0xc,%esp
    ee52:	ff 75 e8             	pushl  -0x18(%ebp)
    ee55:	e8 ca 45 ff ff       	call   3424 <lodepng_free>
    ee5a:	83 c4 10             	add    $0x10,%esp
  lodepng_free(langtag);
    ee5d:	83 ec 0c             	sub    $0xc,%esp
    ee60:	ff 75 e4             	pushl  -0x1c(%ebp)
    ee63:	e8 bc 45 ff ff       	call   3424 <lodepng_free>
    ee68:	83 c4 10             	add    $0x10,%esp
  lodepng_free(transkey);
    ee6b:	83 ec 0c             	sub    $0xc,%esp
    ee6e:	ff 75 e0             	pushl  -0x20(%ebp)
    ee71:	e8 ae 45 ff ff       	call   3424 <lodepng_free>
    ee76:	83 c4 10             	add    $0x10,%esp

  return error;
    ee79:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    ee7c:	c9                   	leave  
    ee7d:	c3                   	ret    

0000ee7e <readChunk_tIME>:

static unsigned readChunk_tIME(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    ee7e:	55                   	push   %ebp
    ee7f:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 7) return 73; /*invalid tIME chunk size*/
    ee81:	83 7d 10 07          	cmpl   $0x7,0x10(%ebp)
    ee85:	74 0a                	je     ee91 <readChunk_tIME+0x13>
    ee87:	b8 49 00 00 00       	mov    $0x49,%eax
    ee8c:	e9 8b 00 00 00       	jmp    ef1c <readChunk_tIME+0x9e>

  info->time_defined = 1;
    ee91:	8b 45 08             	mov    0x8(%ebp),%eax
    ee94:	c7 40 5c 01 00 00 00 	movl   $0x1,0x5c(%eax)
  info->time.year = 256u * data[0] + data[1];
    ee9b:	8b 45 0c             	mov    0xc(%ebp),%eax
    ee9e:	0f b6 00             	movzbl (%eax),%eax
    eea1:	0f b6 c0             	movzbl %al,%eax
    eea4:	c1 e0 08             	shl    $0x8,%eax
    eea7:	89 c2                	mov    %eax,%edx
    eea9:	8b 45 0c             	mov    0xc(%ebp),%eax
    eeac:	83 c0 01             	add    $0x1,%eax
    eeaf:	0f b6 00             	movzbl (%eax),%eax
    eeb2:	0f b6 c0             	movzbl %al,%eax
    eeb5:	01 c2                	add    %eax,%edx
    eeb7:	8b 45 08             	mov    0x8(%ebp),%eax
    eeba:	89 50 60             	mov    %edx,0x60(%eax)
  info->time.month = data[2];
    eebd:	8b 45 0c             	mov    0xc(%ebp),%eax
    eec0:	83 c0 02             	add    $0x2,%eax
    eec3:	0f b6 00             	movzbl (%eax),%eax
    eec6:	0f b6 d0             	movzbl %al,%edx
    eec9:	8b 45 08             	mov    0x8(%ebp),%eax
    eecc:	89 50 64             	mov    %edx,0x64(%eax)
  info->time.day = data[3];
    eecf:	8b 45 0c             	mov    0xc(%ebp),%eax
    eed2:	83 c0 03             	add    $0x3,%eax
    eed5:	0f b6 00             	movzbl (%eax),%eax
    eed8:	0f b6 d0             	movzbl %al,%edx
    eedb:	8b 45 08             	mov    0x8(%ebp),%eax
    eede:	89 50 68             	mov    %edx,0x68(%eax)
  info->time.hour = data[4];
    eee1:	8b 45 0c             	mov    0xc(%ebp),%eax
    eee4:	83 c0 04             	add    $0x4,%eax
    eee7:	0f b6 00             	movzbl (%eax),%eax
    eeea:	0f b6 d0             	movzbl %al,%edx
    eeed:	8b 45 08             	mov    0x8(%ebp),%eax
    eef0:	89 50 6c             	mov    %edx,0x6c(%eax)
  info->time.minute = data[5];
    eef3:	8b 45 0c             	mov    0xc(%ebp),%eax
    eef6:	83 c0 05             	add    $0x5,%eax
    eef9:	0f b6 00             	movzbl (%eax),%eax
    eefc:	0f b6 d0             	movzbl %al,%edx
    eeff:	8b 45 08             	mov    0x8(%ebp),%eax
    ef02:	89 50 70             	mov    %edx,0x70(%eax)
  info->time.second = data[6];
    ef05:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef08:	83 c0 06             	add    $0x6,%eax
    ef0b:	0f b6 00             	movzbl (%eax),%eax
    ef0e:	0f b6 d0             	movzbl %al,%edx
    ef11:	8b 45 08             	mov    0x8(%ebp),%eax
    ef14:	89 50 74             	mov    %edx,0x74(%eax)

  return 0; /* OK */
    ef17:	b8 00 00 00 00       	mov    $0x0,%eax
}
    ef1c:	5d                   	pop    %ebp
    ef1d:	c3                   	ret    

0000ef1e <readChunk_pHYs>:

static unsigned readChunk_pHYs(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    ef1e:	55                   	push   %ebp
    ef1f:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 9) return 74; /*invalid pHYs chunk size*/
    ef21:	83 7d 10 09          	cmpl   $0x9,0x10(%ebp)
    ef25:	74 0a                	je     ef31 <readChunk_pHYs+0x13>
    ef27:	b8 4a 00 00 00       	mov    $0x4a,%eax
    ef2c:	e9 ba 00 00 00       	jmp    efeb <readChunk_pHYs+0xcd>

  info->phys_defined = 1;
    ef31:	8b 45 08             	mov    0x8(%ebp),%eax
    ef34:	c7 40 78 01 00 00 00 	movl   $0x1,0x78(%eax)
  info->phys_x = 16777216u * data[0] + 65536u * data[1] + 256u * data[2] + data[3];
    ef3b:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef3e:	0f b6 00             	movzbl (%eax),%eax
    ef41:	0f b6 c0             	movzbl %al,%eax
    ef44:	c1 e0 08             	shl    $0x8,%eax
    ef47:	89 c2                	mov    %eax,%edx
    ef49:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef4c:	83 c0 01             	add    $0x1,%eax
    ef4f:	0f b6 00             	movzbl (%eax),%eax
    ef52:	0f b6 c0             	movzbl %al,%eax
    ef55:	01 d0                	add    %edx,%eax
    ef57:	c1 e0 08             	shl    $0x8,%eax
    ef5a:	89 c2                	mov    %eax,%edx
    ef5c:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef5f:	83 c0 02             	add    $0x2,%eax
    ef62:	0f b6 00             	movzbl (%eax),%eax
    ef65:	0f b6 c0             	movzbl %al,%eax
    ef68:	01 d0                	add    %edx,%eax
    ef6a:	c1 e0 08             	shl    $0x8,%eax
    ef6d:	89 c2                	mov    %eax,%edx
    ef6f:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef72:	83 c0 03             	add    $0x3,%eax
    ef75:	0f b6 00             	movzbl (%eax),%eax
    ef78:	0f b6 c0             	movzbl %al,%eax
    ef7b:	01 c2                	add    %eax,%edx
    ef7d:	8b 45 08             	mov    0x8(%ebp),%eax
    ef80:	89 50 7c             	mov    %edx,0x7c(%eax)
  info->phys_y = 16777216u * data[4] + 65536u * data[5] + 256u * data[6] + data[7];
    ef83:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef86:	83 c0 04             	add    $0x4,%eax
    ef89:	0f b6 00             	movzbl (%eax),%eax
    ef8c:	0f b6 c0             	movzbl %al,%eax
    ef8f:	c1 e0 08             	shl    $0x8,%eax
    ef92:	89 c2                	mov    %eax,%edx
    ef94:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef97:	83 c0 05             	add    $0x5,%eax
    ef9a:	0f b6 00             	movzbl (%eax),%eax
    ef9d:	0f b6 c0             	movzbl %al,%eax
    efa0:	01 d0                	add    %edx,%eax
    efa2:	c1 e0 08             	shl    $0x8,%eax
    efa5:	89 c2                	mov    %eax,%edx
    efa7:	8b 45 0c             	mov    0xc(%ebp),%eax
    efaa:	83 c0 06             	add    $0x6,%eax
    efad:	0f b6 00             	movzbl (%eax),%eax
    efb0:	0f b6 c0             	movzbl %al,%eax
    efb3:	01 d0                	add    %edx,%eax
    efb5:	c1 e0 08             	shl    $0x8,%eax
    efb8:	89 c2                	mov    %eax,%edx
    efba:	8b 45 0c             	mov    0xc(%ebp),%eax
    efbd:	83 c0 07             	add    $0x7,%eax
    efc0:	0f b6 00             	movzbl (%eax),%eax
    efc3:	0f b6 c0             	movzbl %al,%eax
    efc6:	01 c2                	add    %eax,%edx
    efc8:	8b 45 08             	mov    0x8(%ebp),%eax
    efcb:	89 90 80 00 00 00    	mov    %edx,0x80(%eax)
  info->phys_unit = data[8];
    efd1:	8b 45 0c             	mov    0xc(%ebp),%eax
    efd4:	83 c0 08             	add    $0x8,%eax
    efd7:	0f b6 00             	movzbl (%eax),%eax
    efda:	0f b6 d0             	movzbl %al,%edx
    efdd:	8b 45 08             	mov    0x8(%ebp),%eax
    efe0:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)

  return 0; /* OK */
    efe6:	b8 00 00 00 00       	mov    $0x0,%eax
}
    efeb:	5d                   	pop    %ebp
    efec:	c3                   	ret    

0000efed <readChunk_gAMA>:

static unsigned readChunk_gAMA(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    efed:	55                   	push   %ebp
    efee:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 4) return 96; /*invalid gAMA chunk size*/
    eff0:	83 7d 10 04          	cmpl   $0x4,0x10(%ebp)
    eff4:	74 07                	je     effd <readChunk_gAMA+0x10>
    eff6:	b8 60 00 00 00       	mov    $0x60,%eax
    effb:	eb 5d                	jmp    f05a <readChunk_gAMA+0x6d>

  info->gama_defined = 1;
    effd:	8b 45 08             	mov    0x8(%ebp),%eax
    f000:	c7 80 88 00 00 00 01 	movl   $0x1,0x88(%eax)
    f007:	00 00 00 
  info->gama_gamma = 16777216u * data[0] + 65536u * data[1] + 256u * data[2] + data[3];
    f00a:	8b 45 0c             	mov    0xc(%ebp),%eax
    f00d:	0f b6 00             	movzbl (%eax),%eax
    f010:	0f b6 c0             	movzbl %al,%eax
    f013:	c1 e0 08             	shl    $0x8,%eax
    f016:	89 c2                	mov    %eax,%edx
    f018:	8b 45 0c             	mov    0xc(%ebp),%eax
    f01b:	83 c0 01             	add    $0x1,%eax
    f01e:	0f b6 00             	movzbl (%eax),%eax
    f021:	0f b6 c0             	movzbl %al,%eax
    f024:	01 d0                	add    %edx,%eax
    f026:	c1 e0 08             	shl    $0x8,%eax
    f029:	89 c2                	mov    %eax,%edx
    f02b:	8b 45 0c             	mov    0xc(%ebp),%eax
    f02e:	83 c0 02             	add    $0x2,%eax
    f031:	0f b6 00             	movzbl (%eax),%eax
    f034:	0f b6 c0             	movzbl %al,%eax
    f037:	01 d0                	add    %edx,%eax
    f039:	c1 e0 08             	shl    $0x8,%eax
    f03c:	89 c2                	mov    %eax,%edx
    f03e:	8b 45 0c             	mov    0xc(%ebp),%eax
    f041:	83 c0 03             	add    $0x3,%eax
    f044:	0f b6 00             	movzbl (%eax),%eax
    f047:	0f b6 c0             	movzbl %al,%eax
    f04a:	01 c2                	add    %eax,%edx
    f04c:	8b 45 08             	mov    0x8(%ebp),%eax
    f04f:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)

  return 0; /* OK */
    f055:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f05a:	5d                   	pop    %ebp
    f05b:	c3                   	ret    

0000f05c <readChunk_cHRM>:

static unsigned readChunk_cHRM(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    f05c:	55                   	push   %ebp
    f05d:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 32) return 97; /*invalid cHRM chunk size*/
    f05f:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
    f063:	74 0a                	je     f06f <readChunk_cHRM+0x13>
    f065:	b8 61 00 00 00       	mov    $0x61,%eax
    f06a:	e9 7f 02 00 00       	jmp    f2ee <readChunk_cHRM+0x292>

  info->chrm_defined = 1;
    f06f:	8b 45 08             	mov    0x8(%ebp),%eax
    f072:	c7 80 90 00 00 00 01 	movl   $0x1,0x90(%eax)
    f079:	00 00 00 
  info->chrm_white_x = 16777216u * data[ 0] + 65536u * data[ 1] + 256u * data[ 2] + data[ 3];
    f07c:	8b 45 0c             	mov    0xc(%ebp),%eax
    f07f:	0f b6 00             	movzbl (%eax),%eax
    f082:	0f b6 c0             	movzbl %al,%eax
    f085:	c1 e0 08             	shl    $0x8,%eax
    f088:	89 c2                	mov    %eax,%edx
    f08a:	8b 45 0c             	mov    0xc(%ebp),%eax
    f08d:	83 c0 01             	add    $0x1,%eax
    f090:	0f b6 00             	movzbl (%eax),%eax
    f093:	0f b6 c0             	movzbl %al,%eax
    f096:	01 d0                	add    %edx,%eax
    f098:	c1 e0 08             	shl    $0x8,%eax
    f09b:	89 c2                	mov    %eax,%edx
    f09d:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0a0:	83 c0 02             	add    $0x2,%eax
    f0a3:	0f b6 00             	movzbl (%eax),%eax
    f0a6:	0f b6 c0             	movzbl %al,%eax
    f0a9:	01 d0                	add    %edx,%eax
    f0ab:	c1 e0 08             	shl    $0x8,%eax
    f0ae:	89 c2                	mov    %eax,%edx
    f0b0:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0b3:	83 c0 03             	add    $0x3,%eax
    f0b6:	0f b6 00             	movzbl (%eax),%eax
    f0b9:	0f b6 c0             	movzbl %al,%eax
    f0bc:	01 c2                	add    %eax,%edx
    f0be:	8b 45 08             	mov    0x8(%ebp),%eax
    f0c1:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
  info->chrm_white_y = 16777216u * data[ 4] + 65536u * data[ 5] + 256u * data[ 6] + data[ 7];
    f0c7:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0ca:	83 c0 04             	add    $0x4,%eax
    f0cd:	0f b6 00             	movzbl (%eax),%eax
    f0d0:	0f b6 c0             	movzbl %al,%eax
    f0d3:	c1 e0 08             	shl    $0x8,%eax
    f0d6:	89 c2                	mov    %eax,%edx
    f0d8:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0db:	83 c0 05             	add    $0x5,%eax
    f0de:	0f b6 00             	movzbl (%eax),%eax
    f0e1:	0f b6 c0             	movzbl %al,%eax
    f0e4:	01 d0                	add    %edx,%eax
    f0e6:	c1 e0 08             	shl    $0x8,%eax
    f0e9:	89 c2                	mov    %eax,%edx
    f0eb:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0ee:	83 c0 06             	add    $0x6,%eax
    f0f1:	0f b6 00             	movzbl (%eax),%eax
    f0f4:	0f b6 c0             	movzbl %al,%eax
    f0f7:	01 d0                	add    %edx,%eax
    f0f9:	c1 e0 08             	shl    $0x8,%eax
    f0fc:	89 c2                	mov    %eax,%edx
    f0fe:	8b 45 0c             	mov    0xc(%ebp),%eax
    f101:	83 c0 07             	add    $0x7,%eax
    f104:	0f b6 00             	movzbl (%eax),%eax
    f107:	0f b6 c0             	movzbl %al,%eax
    f10a:	01 c2                	add    %eax,%edx
    f10c:	8b 45 08             	mov    0x8(%ebp),%eax
    f10f:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  info->chrm_red_x   = 16777216u * data[ 8] + 65536u * data[ 9] + 256u * data[10] + data[11];
    f115:	8b 45 0c             	mov    0xc(%ebp),%eax
    f118:	83 c0 08             	add    $0x8,%eax
    f11b:	0f b6 00             	movzbl (%eax),%eax
    f11e:	0f b6 c0             	movzbl %al,%eax
    f121:	c1 e0 08             	shl    $0x8,%eax
    f124:	89 c2                	mov    %eax,%edx
    f126:	8b 45 0c             	mov    0xc(%ebp),%eax
    f129:	83 c0 09             	add    $0x9,%eax
    f12c:	0f b6 00             	movzbl (%eax),%eax
    f12f:	0f b6 c0             	movzbl %al,%eax
    f132:	01 d0                	add    %edx,%eax
    f134:	c1 e0 08             	shl    $0x8,%eax
    f137:	89 c2                	mov    %eax,%edx
    f139:	8b 45 0c             	mov    0xc(%ebp),%eax
    f13c:	83 c0 0a             	add    $0xa,%eax
    f13f:	0f b6 00             	movzbl (%eax),%eax
    f142:	0f b6 c0             	movzbl %al,%eax
    f145:	01 d0                	add    %edx,%eax
    f147:	c1 e0 08             	shl    $0x8,%eax
    f14a:	89 c2                	mov    %eax,%edx
    f14c:	8b 45 0c             	mov    0xc(%ebp),%eax
    f14f:	83 c0 0b             	add    $0xb,%eax
    f152:	0f b6 00             	movzbl (%eax),%eax
    f155:	0f b6 c0             	movzbl %al,%eax
    f158:	01 c2                	add    %eax,%edx
    f15a:	8b 45 08             	mov    0x8(%ebp),%eax
    f15d:	89 90 9c 00 00 00    	mov    %edx,0x9c(%eax)
  info->chrm_red_y   = 16777216u * data[12] + 65536u * data[13] + 256u * data[14] + data[15];
    f163:	8b 45 0c             	mov    0xc(%ebp),%eax
    f166:	83 c0 0c             	add    $0xc,%eax
    f169:	0f b6 00             	movzbl (%eax),%eax
    f16c:	0f b6 c0             	movzbl %al,%eax
    f16f:	c1 e0 08             	shl    $0x8,%eax
    f172:	89 c2                	mov    %eax,%edx
    f174:	8b 45 0c             	mov    0xc(%ebp),%eax
    f177:	83 c0 0d             	add    $0xd,%eax
    f17a:	0f b6 00             	movzbl (%eax),%eax
    f17d:	0f b6 c0             	movzbl %al,%eax
    f180:	01 d0                	add    %edx,%eax
    f182:	c1 e0 08             	shl    $0x8,%eax
    f185:	89 c2                	mov    %eax,%edx
    f187:	8b 45 0c             	mov    0xc(%ebp),%eax
    f18a:	83 c0 0e             	add    $0xe,%eax
    f18d:	0f b6 00             	movzbl (%eax),%eax
    f190:	0f b6 c0             	movzbl %al,%eax
    f193:	01 d0                	add    %edx,%eax
    f195:	c1 e0 08             	shl    $0x8,%eax
    f198:	89 c2                	mov    %eax,%edx
    f19a:	8b 45 0c             	mov    0xc(%ebp),%eax
    f19d:	83 c0 0f             	add    $0xf,%eax
    f1a0:	0f b6 00             	movzbl (%eax),%eax
    f1a3:	0f b6 c0             	movzbl %al,%eax
    f1a6:	01 c2                	add    %eax,%edx
    f1a8:	8b 45 08             	mov    0x8(%ebp),%eax
    f1ab:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
  info->chrm_green_x = 16777216u * data[16] + 65536u * data[17] + 256u * data[18] + data[19];
    f1b1:	8b 45 0c             	mov    0xc(%ebp),%eax
    f1b4:	83 c0 10             	add    $0x10,%eax
    f1b7:	0f b6 00             	movzbl (%eax),%eax
    f1ba:	0f b6 c0             	movzbl %al,%eax
    f1bd:	c1 e0 08             	shl    $0x8,%eax
    f1c0:	89 c2                	mov    %eax,%edx
    f1c2:	8b 45 0c             	mov    0xc(%ebp),%eax
    f1c5:	83 c0 11             	add    $0x11,%eax
    f1c8:	0f b6 00             	movzbl (%eax),%eax
    f1cb:	0f b6 c0             	movzbl %al,%eax
    f1ce:	01 d0                	add    %edx,%eax
    f1d0:	c1 e0 08             	shl    $0x8,%eax
    f1d3:	89 c2                	mov    %eax,%edx
    f1d5:	8b 45 0c             	mov    0xc(%ebp),%eax
    f1d8:	83 c0 12             	add    $0x12,%eax
    f1db:	0f b6 00             	movzbl (%eax),%eax
    f1de:	0f b6 c0             	movzbl %al,%eax
    f1e1:	01 d0                	add    %edx,%eax
    f1e3:	c1 e0 08             	shl    $0x8,%eax
    f1e6:	89 c2                	mov    %eax,%edx
    f1e8:	8b 45 0c             	mov    0xc(%ebp),%eax
    f1eb:	83 c0 13             	add    $0x13,%eax
    f1ee:	0f b6 00             	movzbl (%eax),%eax
    f1f1:	0f b6 c0             	movzbl %al,%eax
    f1f4:	01 c2                	add    %eax,%edx
    f1f6:	8b 45 08             	mov    0x8(%ebp),%eax
    f1f9:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
  info->chrm_green_y = 16777216u * data[20] + 65536u * data[21] + 256u * data[22] + data[23];
    f1ff:	8b 45 0c             	mov    0xc(%ebp),%eax
    f202:	83 c0 14             	add    $0x14,%eax
    f205:	0f b6 00             	movzbl (%eax),%eax
    f208:	0f b6 c0             	movzbl %al,%eax
    f20b:	c1 e0 08             	shl    $0x8,%eax
    f20e:	89 c2                	mov    %eax,%edx
    f210:	8b 45 0c             	mov    0xc(%ebp),%eax
    f213:	83 c0 15             	add    $0x15,%eax
    f216:	0f b6 00             	movzbl (%eax),%eax
    f219:	0f b6 c0             	movzbl %al,%eax
    f21c:	01 d0                	add    %edx,%eax
    f21e:	c1 e0 08             	shl    $0x8,%eax
    f221:	89 c2                	mov    %eax,%edx
    f223:	8b 45 0c             	mov    0xc(%ebp),%eax
    f226:	83 c0 16             	add    $0x16,%eax
    f229:	0f b6 00             	movzbl (%eax),%eax
    f22c:	0f b6 c0             	movzbl %al,%eax
    f22f:	01 d0                	add    %edx,%eax
    f231:	c1 e0 08             	shl    $0x8,%eax
    f234:	89 c2                	mov    %eax,%edx
    f236:	8b 45 0c             	mov    0xc(%ebp),%eax
    f239:	83 c0 17             	add    $0x17,%eax
    f23c:	0f b6 00             	movzbl (%eax),%eax
    f23f:	0f b6 c0             	movzbl %al,%eax
    f242:	01 c2                	add    %eax,%edx
    f244:	8b 45 08             	mov    0x8(%ebp),%eax
    f247:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
  info->chrm_blue_x  = 16777216u * data[24] + 65536u * data[25] + 256u * data[26] + data[27];
    f24d:	8b 45 0c             	mov    0xc(%ebp),%eax
    f250:	83 c0 18             	add    $0x18,%eax
    f253:	0f b6 00             	movzbl (%eax),%eax
    f256:	0f b6 c0             	movzbl %al,%eax
    f259:	c1 e0 08             	shl    $0x8,%eax
    f25c:	89 c2                	mov    %eax,%edx
    f25e:	8b 45 0c             	mov    0xc(%ebp),%eax
    f261:	83 c0 19             	add    $0x19,%eax
    f264:	0f b6 00             	movzbl (%eax),%eax
    f267:	0f b6 c0             	movzbl %al,%eax
    f26a:	01 d0                	add    %edx,%eax
    f26c:	c1 e0 08             	shl    $0x8,%eax
    f26f:	89 c2                	mov    %eax,%edx
    f271:	8b 45 0c             	mov    0xc(%ebp),%eax
    f274:	83 c0 1a             	add    $0x1a,%eax
    f277:	0f b6 00             	movzbl (%eax),%eax
    f27a:	0f b6 c0             	movzbl %al,%eax
    f27d:	01 d0                	add    %edx,%eax
    f27f:	c1 e0 08             	shl    $0x8,%eax
    f282:	89 c2                	mov    %eax,%edx
    f284:	8b 45 0c             	mov    0xc(%ebp),%eax
    f287:	83 c0 1b             	add    $0x1b,%eax
    f28a:	0f b6 00             	movzbl (%eax),%eax
    f28d:	0f b6 c0             	movzbl %al,%eax
    f290:	01 c2                	add    %eax,%edx
    f292:	8b 45 08             	mov    0x8(%ebp),%eax
    f295:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  info->chrm_blue_y  = 16777216u * data[28] + 65536u * data[29] + 256u * data[30] + data[31];
    f29b:	8b 45 0c             	mov    0xc(%ebp),%eax
    f29e:	83 c0 1c             	add    $0x1c,%eax
    f2a1:	0f b6 00             	movzbl (%eax),%eax
    f2a4:	0f b6 c0             	movzbl %al,%eax
    f2a7:	c1 e0 08             	shl    $0x8,%eax
    f2aa:	89 c2                	mov    %eax,%edx
    f2ac:	8b 45 0c             	mov    0xc(%ebp),%eax
    f2af:	83 c0 1d             	add    $0x1d,%eax
    f2b2:	0f b6 00             	movzbl (%eax),%eax
    f2b5:	0f b6 c0             	movzbl %al,%eax
    f2b8:	01 d0                	add    %edx,%eax
    f2ba:	c1 e0 08             	shl    $0x8,%eax
    f2bd:	89 c2                	mov    %eax,%edx
    f2bf:	8b 45 0c             	mov    0xc(%ebp),%eax
    f2c2:	83 c0 1e             	add    $0x1e,%eax
    f2c5:	0f b6 00             	movzbl (%eax),%eax
    f2c8:	0f b6 c0             	movzbl %al,%eax
    f2cb:	01 d0                	add    %edx,%eax
    f2cd:	c1 e0 08             	shl    $0x8,%eax
    f2d0:	89 c2                	mov    %eax,%edx
    f2d2:	8b 45 0c             	mov    0xc(%ebp),%eax
    f2d5:	83 c0 1f             	add    $0x1f,%eax
    f2d8:	0f b6 00             	movzbl (%eax),%eax
    f2db:	0f b6 c0             	movzbl %al,%eax
    f2de:	01 c2                	add    %eax,%edx
    f2e0:	8b 45 08             	mov    0x8(%ebp),%eax
    f2e3:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)

  return 0; /* OK */
    f2e9:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f2ee:	5d                   	pop    %ebp
    f2ef:	c3                   	ret    

0000f2f0 <readChunk_sRGB>:

static unsigned readChunk_sRGB(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    f2f0:	55                   	push   %ebp
    f2f1:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 1) return 98; /*invalid sRGB chunk size (this one is never ignored)*/
    f2f3:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    f2f7:	74 07                	je     f300 <readChunk_sRGB+0x10>
    f2f9:	b8 62 00 00 00       	mov    $0x62,%eax
    f2fe:	eb 24                	jmp    f324 <readChunk_sRGB+0x34>

  info->srgb_defined = 1;
    f300:	8b 45 08             	mov    0x8(%ebp),%eax
    f303:	c7 80 b4 00 00 00 01 	movl   $0x1,0xb4(%eax)
    f30a:	00 00 00 
  info->srgb_intent = data[0];
    f30d:	8b 45 0c             	mov    0xc(%ebp),%eax
    f310:	0f b6 00             	movzbl (%eax),%eax
    f313:	0f b6 d0             	movzbl %al,%edx
    f316:	8b 45 08             	mov    0x8(%ebp),%eax
    f319:	89 90 b8 00 00 00    	mov    %edx,0xb8(%eax)

  return 0; /* OK */
    f31f:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f324:	5d                   	pop    %ebp
    f325:	c3                   	ret    

0000f326 <readChunk_iCCP>:

static unsigned readChunk_iCCP(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,
                               const unsigned char* data, size_t chunkLength) {
    f326:	55                   	push   %ebp
    f327:	89 e5                	mov    %esp,%ebp
    f329:	53                   	push   %ebx
    f32a:	83 ec 34             	sub    $0x34,%esp
  unsigned error = 0;
    f32d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned i;
  size_t size = 0;
    f334:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  /*copy the object to change parameters in it*/
  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;
    f33b:	8b 45 0c             	mov    0xc(%ebp),%eax
    f33e:	8b 10                	mov    (%eax),%edx
    f340:	89 55 cc             	mov    %edx,-0x34(%ebp)
    f343:	8b 50 04             	mov    0x4(%eax),%edx
    f346:	89 55 d0             	mov    %edx,-0x30(%ebp)
    f349:	8b 50 08             	mov    0x8(%eax),%edx
    f34c:	89 55 d4             	mov    %edx,-0x2c(%ebp)
    f34f:	8b 50 0c             	mov    0xc(%eax),%edx
    f352:	89 55 d8             	mov    %edx,-0x28(%ebp)
    f355:	8b 50 10             	mov    0x10(%eax),%edx
    f358:	89 55 dc             	mov    %edx,-0x24(%ebp)
    f35b:	8b 40 14             	mov    0x14(%eax),%eax
    f35e:	89 45 e0             	mov    %eax,-0x20(%ebp)

  unsigned length, string2_begin;

  info->iccp_defined = 1;
    f361:	8b 45 08             	mov    0x8(%ebp),%eax
    f364:	c7 80 bc 00 00 00 01 	movl   $0x1,0xbc(%eax)
    f36b:	00 00 00 
  if(info->iccp_name) lodepng_clear_icc(info);
    f36e:	8b 45 08             	mov    0x8(%ebp),%eax
    f371:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    f377:	85 c0                	test   %eax,%eax
    f379:	74 0e                	je     f389 <readChunk_iCCP+0x63>
    f37b:	83 ec 0c             	sub    $0xc,%esp
    f37e:	ff 75 08             	pushl  0x8(%ebp)
    f381:	e8 ca a6 ff ff       	call   9a50 <lodepng_clear_icc>
    f386:	83 c4 10             	add    $0x10,%esp

  for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
    f389:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    f390:	eb 04                	jmp    f396 <readChunk_iCCP+0x70>
    f392:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    f396:	8b 45 14             	mov    0x14(%ebp),%eax
    f399:	39 45 ec             	cmp    %eax,-0x14(%ebp)
    f39c:	73 0f                	jae    f3ad <readChunk_iCCP+0x87>
    f39e:	8b 55 10             	mov    0x10(%ebp),%edx
    f3a1:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f3a4:	01 d0                	add    %edx,%eax
    f3a6:	0f b6 00             	movzbl (%eax),%eax
    f3a9:	84 c0                	test   %al,%al
    f3ab:	75 e5                	jne    f392 <readChunk_iCCP+0x6c>
  if(length + 2 >= chunkLength) return 75; /*no null termination, corrupt?*/
    f3ad:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f3b0:	8d 50 02             	lea    0x2(%eax),%edx
    f3b3:	8b 45 14             	mov    0x14(%ebp),%eax
    f3b6:	39 c2                	cmp    %eax,%edx
    f3b8:	72 0a                	jb     f3c4 <readChunk_iCCP+0x9e>
    f3ba:	b8 4b 00 00 00       	mov    $0x4b,%eax
    f3bf:	e9 46 01 00 00       	jmp    f50a <readChunk_iCCP+0x1e4>
  if(length < 1 || length > 79) return 89; /*keyword too short or long*/
    f3c4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    f3c8:	74 06                	je     f3d0 <readChunk_iCCP+0xaa>
    f3ca:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
    f3ce:	76 0a                	jbe    f3da <readChunk_iCCP+0xb4>
    f3d0:	b8 59 00 00 00       	mov    $0x59,%eax
    f3d5:	e9 30 01 00 00       	jmp    f50a <readChunk_iCCP+0x1e4>

  info->iccp_name = (char*)lodepng_malloc(length + 1);
    f3da:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f3dd:	83 c0 01             	add    $0x1,%eax
    f3e0:	83 ec 0c             	sub    $0xc,%esp
    f3e3:	50                   	push   %eax
    f3e4:	e8 1a 40 ff ff       	call   3403 <lodepng_malloc>
    f3e9:	83 c4 10             	add    $0x10,%esp
    f3ec:	89 c2                	mov    %eax,%edx
    f3ee:	8b 45 08             	mov    0x8(%ebp),%eax
    f3f1:	89 90 c0 00 00 00    	mov    %edx,0xc0(%eax)
  if(!info->iccp_name) return 83; /*alloc fail*/
    f3f7:	8b 45 08             	mov    0x8(%ebp),%eax
    f3fa:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    f400:	85 c0                	test   %eax,%eax
    f402:	75 0a                	jne    f40e <readChunk_iCCP+0xe8>
    f404:	b8 53 00 00 00       	mov    $0x53,%eax
    f409:	e9 fc 00 00 00       	jmp    f50a <readChunk_iCCP+0x1e4>

  info->iccp_name[length] = 0;
    f40e:	8b 45 08             	mov    0x8(%ebp),%eax
    f411:	8b 90 c0 00 00 00    	mov    0xc0(%eax),%edx
    f417:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f41a:	01 d0                	add    %edx,%eax
    f41c:	c6 00 00             	movb   $0x0,(%eax)
  for(i = 0; i != length; ++i) info->iccp_name[i] = (char)data[i];
    f41f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    f426:	eb 1f                	jmp    f447 <readChunk_iCCP+0x121>
    f428:	8b 45 08             	mov    0x8(%ebp),%eax
    f42b:	8b 90 c0 00 00 00    	mov    0xc0(%eax),%edx
    f431:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f434:	01 d0                	add    %edx,%eax
    f436:	8b 4d 10             	mov    0x10(%ebp),%ecx
    f439:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f43c:	01 ca                	add    %ecx,%edx
    f43e:	0f b6 12             	movzbl (%edx),%edx
    f441:	88 10                	mov    %dl,(%eax)
    f443:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    f447:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f44a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    f44d:	75 d9                	jne    f428 <readChunk_iCCP+0x102>

  if(data[length + 1] != 0) return 72; /*the 0 byte indicating compression must be 0*/
    f44f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f452:	8d 50 01             	lea    0x1(%eax),%edx
    f455:	8b 45 10             	mov    0x10(%ebp),%eax
    f458:	01 d0                	add    %edx,%eax
    f45a:	0f b6 00             	movzbl (%eax),%eax
    f45d:	84 c0                	test   %al,%al
    f45f:	74 0a                	je     f46b <readChunk_iCCP+0x145>
    f461:	b8 48 00 00 00       	mov    $0x48,%eax
    f466:	e9 9f 00 00 00       	jmp    f50a <readChunk_iCCP+0x1e4>

  string2_begin = length + 2;
    f46b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f46e:	83 c0 02             	add    $0x2,%eax
    f471:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(string2_begin > chunkLength) return 75; /*no null termination, corrupt?*/
    f474:	8b 45 14             	mov    0x14(%ebp),%eax
    f477:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    f47a:	76 0a                	jbe    f486 <readChunk_iCCP+0x160>
    f47c:	b8 4b 00 00 00       	mov    $0x4b,%eax
    f481:	e9 84 00 00 00       	jmp    f50a <readChunk_iCCP+0x1e4>

  length = (unsigned)chunkLength - string2_begin;
    f486:	8b 45 14             	mov    0x14(%ebp),%eax
    f489:	2b 45 e8             	sub    -0x18(%ebp),%eax
    f48c:	89 45 ec             	mov    %eax,-0x14(%ebp)
  zlibsettings.max_output_size = decoder->max_icc_size;
    f48f:	8b 45 0c             	mov    0xc(%ebp),%eax
    f492:	8b 40 34             	mov    0x34(%eax),%eax
    f495:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  error = zlib_decompress(&info->iccp_profile, &size, 0,
    f498:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f49b:	8b 4d 10             	mov    0x10(%ebp),%ecx
    f49e:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f4a1:	8d 1c 11             	lea    (%ecx,%edx,1),%ebx
    f4a4:	8b 55 08             	mov    0x8(%ebp),%edx
    f4a7:	8d 8a c4 00 00 00    	lea    0xc4(%edx),%ecx
    f4ad:	83 ec 08             	sub    $0x8,%esp
    f4b0:	8d 55 cc             	lea    -0x34(%ebp),%edx
    f4b3:	52                   	push   %edx
    f4b4:	50                   	push   %eax
    f4b5:	53                   	push   %ebx
    f4b6:	6a 00                	push   $0x0
    f4b8:	8d 45 e4             	lea    -0x1c(%ebp),%eax
    f4bb:	50                   	push   %eax
    f4bc:	51                   	push   %ecx
    f4bd:	e8 fc 89 ff ff       	call   7ebe <zlib_decompress>
    f4c2:	83 c4 20             	add    $0x20,%esp
    f4c5:	89 45 f4             	mov    %eax,-0xc(%ebp)
                          &data[string2_begin],
                          length, &zlibsettings);
  /*error: ICC profile larger than  decoder->max_icc_size*/
  if(error && size > zlibsettings.max_output_size) error = 113;
    f4c8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    f4cc:	74 11                	je     f4df <readChunk_iCCP+0x1b9>
    f4ce:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    f4d1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    f4d4:	39 c2                	cmp    %eax,%edx
    f4d6:	7d 07                	jge    f4df <readChunk_iCCP+0x1b9>
    f4d8:	c7 45 f4 71 00 00 00 	movl   $0x71,-0xc(%ebp)
  info->iccp_profile_size = size;
    f4df:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    f4e2:	89 c2                	mov    %eax,%edx
    f4e4:	8b 45 08             	mov    0x8(%ebp),%eax
    f4e7:	89 90 c8 00 00 00    	mov    %edx,0xc8(%eax)
  if(!error && !info->iccp_profile_size) error = 100; /*invalid ICC profile size*/
    f4ed:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    f4f1:	75 14                	jne    f507 <readChunk_iCCP+0x1e1>
    f4f3:	8b 45 08             	mov    0x8(%ebp),%eax
    f4f6:	8b 80 c8 00 00 00    	mov    0xc8(%eax),%eax
    f4fc:	85 c0                	test   %eax,%eax
    f4fe:	75 07                	jne    f507 <readChunk_iCCP+0x1e1>
    f500:	c7 45 f4 64 00 00 00 	movl   $0x64,-0xc(%ebp)
  return error;
    f507:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    f50a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    f50d:	c9                   	leave  
    f50e:	c3                   	ret    

0000f50f <lodepng_inspect_chunk>:
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

unsigned lodepng_inspect_chunk(LodePNGState* state, size_t pos,
                               const unsigned char* in, size_t insize) {
    f50f:	55                   	push   %ebp
    f510:	89 e5                	mov    %esp,%ebp
    f512:	83 ec 28             	sub    $0x28,%esp
  const unsigned char* chunk = in + pos;
    f515:	8b 55 0c             	mov    0xc(%ebp),%edx
    f518:	8b 45 10             	mov    0x10(%ebp),%eax
    f51b:	01 d0                	add    %edx,%eax
    f51d:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned chunkLength;
  const unsigned char* data;
  unsigned unhandled = 0;
    f520:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned error = 0;
    f527:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  if(pos + 4 > insize) return 30;
    f52e:	8b 45 0c             	mov    0xc(%ebp),%eax
    f531:	83 c0 04             	add    $0x4,%eax
    f534:	3b 45 14             	cmp    0x14(%ebp),%eax
    f537:	7e 0a                	jle    f543 <lodepng_inspect_chunk+0x34>
    f539:	b8 1e 00 00 00       	mov    $0x1e,%eax
    f53e:	e9 43 03 00 00       	jmp    f886 <lodepng_inspect_chunk+0x377>
  chunkLength = lodepng_chunk_length(chunk);
    f543:	ff 75 ec             	pushl  -0x14(%ebp)
    f546:	e8 3a 8e ff ff       	call   8385 <lodepng_chunk_length>
    f54b:	83 c4 04             	add    $0x4,%esp
    f54e:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(chunkLength > 2147483647) return 63;
    f551:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f554:	85 c0                	test   %eax,%eax
    f556:	79 0a                	jns    f562 <lodepng_inspect_chunk+0x53>
    f558:	b8 3f 00 00 00       	mov    $0x3f,%eax
    f55d:	e9 24 03 00 00       	jmp    f886 <lodepng_inspect_chunk+0x377>
  data = lodepng_chunk_data_const(chunk);
    f562:	ff 75 ec             	pushl  -0x14(%ebp)
    f565:	e8 53 8f ff ff       	call   84bd <lodepng_chunk_data_const>
    f56a:	83 c4 04             	add    $0x4,%esp
    f56d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(data + chunkLength + 4 > in + insize) return 30;
    f570:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f573:	8d 50 04             	lea    0x4(%eax),%edx
    f576:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    f579:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    f57c:	8b 55 14             	mov    0x14(%ebp),%edx
    f57f:	8b 45 10             	mov    0x10(%ebp),%eax
    f582:	01 d0                	add    %edx,%eax
    f584:	39 c1                	cmp    %eax,%ecx
    f586:	76 0a                	jbe    f592 <lodepng_inspect_chunk+0x83>
    f588:	b8 1e 00 00 00       	mov    $0x1e,%eax
    f58d:	e9 f4 02 00 00       	jmp    f886 <lodepng_inspect_chunk+0x377>

  if(lodepng_chunk_type_equals(chunk, "PLTE")) {
    f592:	68 48 a1 01 00       	push   $0x1a148
    f597:	ff 75 ec             	pushl  -0x14(%ebp)
    f59a:	e8 33 8e ff ff       	call   83d2 <lodepng_chunk_type_equals>
    f59f:	83 c4 08             	add    $0x8,%esp
    f5a2:	84 c0                	test   %al,%al
    f5a4:	74 24                	je     f5ca <lodepng_inspect_chunk+0xbb>
    error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
    f5a6:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f5a9:	8b 55 08             	mov    0x8(%ebp),%edx
    f5ac:	81 c2 a4 00 00 00    	add    $0xa4,%edx
    f5b2:	83 ec 04             	sub    $0x4,%esp
    f5b5:	50                   	push   %eax
    f5b6:	ff 75 e4             	pushl  -0x1c(%ebp)
    f5b9:	52                   	push   %edx
    f5ba:	e8 5b ee ff ff       	call   e41a <readChunk_PLTE>
    f5bf:	83 c4 10             	add    $0x10,%esp
    f5c2:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f5c5:	e9 8a 02 00 00       	jmp    f854 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "tRNS")) {
    f5ca:	83 ec 08             	sub    $0x8,%esp
    f5cd:	68 4d a1 01 00       	push   $0x1a14d
    f5d2:	ff 75 ec             	pushl  -0x14(%ebp)
    f5d5:	e8 f8 8d ff ff       	call   83d2 <lodepng_chunk_type_equals>
    f5da:	83 c4 10             	add    $0x10,%esp
    f5dd:	84 c0                	test   %al,%al
    f5df:	74 24                	je     f605 <lodepng_inspect_chunk+0xf6>
    error = readChunk_tRNS(&state->info_png.color, data, chunkLength);
    f5e1:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f5e4:	8b 55 08             	mov    0x8(%ebp),%edx
    f5e7:	81 c2 a4 00 00 00    	add    $0xa4,%edx
    f5ed:	83 ec 04             	sub    $0x4,%esp
    f5f0:	50                   	push   %eax
    f5f1:	ff 75 e4             	pushl  -0x1c(%ebp)
    f5f4:	52                   	push   %edx
    f5f5:	e8 40 ef ff ff       	call   e53a <readChunk_tRNS>
    f5fa:	83 c4 10             	add    $0x10,%esp
    f5fd:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f600:	e9 4f 02 00 00       	jmp    f854 <lodepng_inspect_chunk+0x345>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  } else if(lodepng_chunk_type_equals(chunk, "bKGD")) {
    f605:	83 ec 08             	sub    $0x8,%esp
    f608:	68 52 a1 01 00       	push   $0x1a152
    f60d:	ff 75 ec             	pushl  -0x14(%ebp)
    f610:	e8 bd 8d ff ff       	call   83d2 <lodepng_chunk_type_equals>
    f615:	83 c4 10             	add    $0x10,%esp
    f618:	84 c0                	test   %al,%al
    f61a:	74 24                	je     f640 <lodepng_inspect_chunk+0x131>
    error = readChunk_bKGD(&state->info_png, data, chunkLength);
    f61c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f61f:	8b 55 08             	mov    0x8(%ebp),%edx
    f622:	81 c2 98 00 00 00    	add    $0x98,%edx
    f628:	83 ec 04             	sub    $0x4,%esp
    f62b:	50                   	push   %eax
    f62c:	ff 75 e4             	pushl  -0x1c(%ebp)
    f62f:	52                   	push   %edx
    f630:	e8 68 f0 ff ff       	call   e69d <readChunk_bKGD>
    f635:	83 c4 10             	add    $0x10,%esp
    f638:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f63b:	e9 14 02 00 00       	jmp    f854 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "tEXt")) {
    f640:	83 ec 08             	sub    $0x8,%esp
    f643:	68 57 a1 01 00       	push   $0x1a157
    f648:	ff 75 ec             	pushl  -0x14(%ebp)
    f64b:	e8 82 8d ff ff       	call   83d2 <lodepng_chunk_type_equals>
    f650:	83 c4 10             	add    $0x10,%esp
    f653:	84 c0                	test   %al,%al
    f655:	74 24                	je     f67b <lodepng_inspect_chunk+0x16c>
    error = readChunk_tEXt(&state->info_png, data, chunkLength);
    f657:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f65a:	8b 55 08             	mov    0x8(%ebp),%edx
    f65d:	81 c2 98 00 00 00    	add    $0x98,%edx
    f663:	83 ec 04             	sub    $0x4,%esp
    f666:	50                   	push   %eax
    f667:	ff 75 e4             	pushl  -0x1c(%ebp)
    f66a:	52                   	push   %edx
    f66b:	e8 b0 f1 ff ff       	call   e820 <readChunk_tEXt>
    f670:	83 c4 10             	add    $0x10,%esp
    f673:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f676:	e9 d9 01 00 00       	jmp    f854 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "zTXt")) {
    f67b:	83 ec 08             	sub    $0x8,%esp
    f67e:	68 5c a1 01 00       	push   $0x1a15c
    f683:	ff 75 ec             	pushl  -0x14(%ebp)
    f686:	e8 47 8d ff ff       	call   83d2 <lodepng_chunk_type_equals>
    f68b:	83 c4 10             	add    $0x10,%esp
    f68e:	84 c0                	test   %al,%al
    f690:	74 25                	je     f6b7 <lodepng_inspect_chunk+0x1a8>
    error = readChunk_zTXt(&state->info_png, &state->decoder, data, chunkLength);
    f692:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f695:	8b 45 08             	mov    0x8(%ebp),%eax
    f698:	8b 4d 08             	mov    0x8(%ebp),%ecx
    f69b:	81 c1 98 00 00 00    	add    $0x98,%ecx
    f6a1:	52                   	push   %edx
    f6a2:	ff 75 e4             	pushl  -0x1c(%ebp)
    f6a5:	50                   	push   %eax
    f6a6:	51                   	push   %ecx
    f6a7:	e8 c0 f2 ff ff       	call   e96c <readChunk_zTXt>
    f6ac:	83 c4 10             	add    $0x10,%esp
    f6af:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f6b2:	e9 9d 01 00 00       	jmp    f854 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "iTXt")) {
    f6b7:	83 ec 08             	sub    $0x8,%esp
    f6ba:	68 61 a1 01 00       	push   $0x1a161
    f6bf:	ff 75 ec             	pushl  -0x14(%ebp)
    f6c2:	e8 0b 8d ff ff       	call   83d2 <lodepng_chunk_type_equals>
    f6c7:	83 c4 10             	add    $0x10,%esp
    f6ca:	84 c0                	test   %al,%al
    f6cc:	74 25                	je     f6f3 <lodepng_inspect_chunk+0x1e4>
    error = readChunk_iTXt(&state->info_png, &state->decoder, data, chunkLength);
    f6ce:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f6d1:	8b 45 08             	mov    0x8(%ebp),%eax
    f6d4:	8b 4d 08             	mov    0x8(%ebp),%ecx
    f6d7:	81 c1 98 00 00 00    	add    $0x98,%ecx
    f6dd:	52                   	push   %edx
    f6de:	ff 75 e4             	pushl  -0x1c(%ebp)
    f6e1:	50                   	push   %eax
    f6e2:	51                   	push   %ecx
    f6e3:	e8 40 f4 ff ff       	call   eb28 <readChunk_iTXt>
    f6e8:	83 c4 10             	add    $0x10,%esp
    f6eb:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f6ee:	e9 61 01 00 00       	jmp    f854 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "tIME")) {
    f6f3:	83 ec 08             	sub    $0x8,%esp
    f6f6:	68 66 a1 01 00       	push   $0x1a166
    f6fb:	ff 75 ec             	pushl  -0x14(%ebp)
    f6fe:	e8 cf 8c ff ff       	call   83d2 <lodepng_chunk_type_equals>
    f703:	83 c4 10             	add    $0x10,%esp
    f706:	84 c0                	test   %al,%al
    f708:	74 24                	je     f72e <lodepng_inspect_chunk+0x21f>
    error = readChunk_tIME(&state->info_png, data, chunkLength);
    f70a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f70d:	8b 55 08             	mov    0x8(%ebp),%edx
    f710:	81 c2 98 00 00 00    	add    $0x98,%edx
    f716:	83 ec 04             	sub    $0x4,%esp
    f719:	50                   	push   %eax
    f71a:	ff 75 e4             	pushl  -0x1c(%ebp)
    f71d:	52                   	push   %edx
    f71e:	e8 5b f7 ff ff       	call   ee7e <readChunk_tIME>
    f723:	83 c4 10             	add    $0x10,%esp
    f726:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f729:	e9 26 01 00 00       	jmp    f854 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "pHYs")) {
    f72e:	83 ec 08             	sub    $0x8,%esp
    f731:	68 6b a1 01 00       	push   $0x1a16b
    f736:	ff 75 ec             	pushl  -0x14(%ebp)
    f739:	e8 94 8c ff ff       	call   83d2 <lodepng_chunk_type_equals>
    f73e:	83 c4 10             	add    $0x10,%esp
    f741:	84 c0                	test   %al,%al
    f743:	74 24                	je     f769 <lodepng_inspect_chunk+0x25a>
    error = readChunk_pHYs(&state->info_png, data, chunkLength);
    f745:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f748:	8b 55 08             	mov    0x8(%ebp),%edx
    f74b:	81 c2 98 00 00 00    	add    $0x98,%edx
    f751:	83 ec 04             	sub    $0x4,%esp
    f754:	50                   	push   %eax
    f755:	ff 75 e4             	pushl  -0x1c(%ebp)
    f758:	52                   	push   %edx
    f759:	e8 c0 f7 ff ff       	call   ef1e <readChunk_pHYs>
    f75e:	83 c4 10             	add    $0x10,%esp
    f761:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f764:	e9 eb 00 00 00       	jmp    f854 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "gAMA")) {
    f769:	83 ec 08             	sub    $0x8,%esp
    f76c:	68 70 a1 01 00       	push   $0x1a170
    f771:	ff 75 ec             	pushl  -0x14(%ebp)
    f774:	e8 59 8c ff ff       	call   83d2 <lodepng_chunk_type_equals>
    f779:	83 c4 10             	add    $0x10,%esp
    f77c:	84 c0                	test   %al,%al
    f77e:	74 24                	je     f7a4 <lodepng_inspect_chunk+0x295>
    error = readChunk_gAMA(&state->info_png, data, chunkLength);
    f780:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f783:	8b 55 08             	mov    0x8(%ebp),%edx
    f786:	81 c2 98 00 00 00    	add    $0x98,%edx
    f78c:	83 ec 04             	sub    $0x4,%esp
    f78f:	50                   	push   %eax
    f790:	ff 75 e4             	pushl  -0x1c(%ebp)
    f793:	52                   	push   %edx
    f794:	e8 54 f8 ff ff       	call   efed <readChunk_gAMA>
    f799:	83 c4 10             	add    $0x10,%esp
    f79c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f79f:	e9 b0 00 00 00       	jmp    f854 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "cHRM")) {
    f7a4:	83 ec 08             	sub    $0x8,%esp
    f7a7:	68 75 a1 01 00       	push   $0x1a175
    f7ac:	ff 75 ec             	pushl  -0x14(%ebp)
    f7af:	e8 1e 8c ff ff       	call   83d2 <lodepng_chunk_type_equals>
    f7b4:	83 c4 10             	add    $0x10,%esp
    f7b7:	84 c0                	test   %al,%al
    f7b9:	74 21                	je     f7dc <lodepng_inspect_chunk+0x2cd>
    error = readChunk_cHRM(&state->info_png, data, chunkLength);
    f7bb:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f7be:	8b 55 08             	mov    0x8(%ebp),%edx
    f7c1:	81 c2 98 00 00 00    	add    $0x98,%edx
    f7c7:	83 ec 04             	sub    $0x4,%esp
    f7ca:	50                   	push   %eax
    f7cb:	ff 75 e4             	pushl  -0x1c(%ebp)
    f7ce:	52                   	push   %edx
    f7cf:	e8 88 f8 ff ff       	call   f05c <readChunk_cHRM>
    f7d4:	83 c4 10             	add    $0x10,%esp
    f7d7:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f7da:	eb 78                	jmp    f854 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "sRGB")) {
    f7dc:	83 ec 08             	sub    $0x8,%esp
    f7df:	68 7a a1 01 00       	push   $0x1a17a
    f7e4:	ff 75 ec             	pushl  -0x14(%ebp)
    f7e7:	e8 e6 8b ff ff       	call   83d2 <lodepng_chunk_type_equals>
    f7ec:	83 c4 10             	add    $0x10,%esp
    f7ef:	84 c0                	test   %al,%al
    f7f1:	74 21                	je     f814 <lodepng_inspect_chunk+0x305>
    error = readChunk_sRGB(&state->info_png, data, chunkLength);
    f7f3:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f7f6:	8b 55 08             	mov    0x8(%ebp),%edx
    f7f9:	81 c2 98 00 00 00    	add    $0x98,%edx
    f7ff:	83 ec 04             	sub    $0x4,%esp
    f802:	50                   	push   %eax
    f803:	ff 75 e4             	pushl  -0x1c(%ebp)
    f806:	52                   	push   %edx
    f807:	e8 e4 fa ff ff       	call   f2f0 <readChunk_sRGB>
    f80c:	83 c4 10             	add    $0x10,%esp
    f80f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f812:	eb 40                	jmp    f854 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "iCCP")) {
    f814:	83 ec 08             	sub    $0x8,%esp
    f817:	68 7f a1 01 00       	push   $0x1a17f
    f81c:	ff 75 ec             	pushl  -0x14(%ebp)
    f81f:	e8 ae 8b ff ff       	call   83d2 <lodepng_chunk_type_equals>
    f824:	83 c4 10             	add    $0x10,%esp
    f827:	84 c0                	test   %al,%al
    f829:	74 22                	je     f84d <lodepng_inspect_chunk+0x33e>
    error = readChunk_iCCP(&state->info_png, &state->decoder, data, chunkLength);
    f82b:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f82e:	8b 45 08             	mov    0x8(%ebp),%eax
    f831:	8b 4d 08             	mov    0x8(%ebp),%ecx
    f834:	81 c1 98 00 00 00    	add    $0x98,%ecx
    f83a:	52                   	push   %edx
    f83b:	ff 75 e4             	pushl  -0x1c(%ebp)
    f83e:	50                   	push   %eax
    f83f:	51                   	push   %ecx
    f840:	e8 e1 fa ff ff       	call   f326 <readChunk_iCCP>
    f845:	83 c4 10             	add    $0x10,%esp
    f848:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f84b:	eb 07                	jmp    f854 <lodepng_inspect_chunk+0x345>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  } else {
    /* unhandled chunk is ok (is not an error) */
    unhandled = 1;
    f84d:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
  }

  if(!error && !unhandled && !state->decoder.ignore_crc) {
    f854:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    f858:	75 29                	jne    f883 <lodepng_inspect_chunk+0x374>
    f85a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    f85e:	75 23                	jne    f883 <lodepng_inspect_chunk+0x374>
    f860:	8b 45 08             	mov    0x8(%ebp),%eax
    f863:	8b 40 18             	mov    0x18(%eax),%eax
    f866:	85 c0                	test   %eax,%eax
    f868:	75 19                	jne    f883 <lodepng_inspect_chunk+0x374>
    if(lodepng_chunk_check_crc(chunk)) return 57; /*invalid CRC*/
    f86a:	83 ec 0c             	sub    $0xc,%esp
    f86d:	ff 75 ec             	pushl  -0x14(%ebp)
    f870:	e8 53 8c ff ff       	call   84c8 <lodepng_chunk_check_crc>
    f875:	83 c4 10             	add    $0x10,%esp
    f878:	85 c0                	test   %eax,%eax
    f87a:	74 07                	je     f883 <lodepng_inspect_chunk+0x374>
    f87c:	b8 39 00 00 00       	mov    $0x39,%eax
    f881:	eb 03                	jmp    f886 <lodepng_inspect_chunk+0x377>
  }

  return error;
    f883:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    f886:	c9                   	leave  
    f887:	c3                   	ret    

0000f888 <decodeGeneric>:

/*read a PNG, the result will be in the same color type as the PNG (hence "generic")*/
static void decodeGeneric(unsigned char** out, unsigned* w, unsigned* h,
                          LodePNGState* state,
                          const unsigned char* in, size_t insize) {
    f888:	55                   	push   %ebp
    f889:	89 e5                	mov    %esp,%ebp
    f88b:	56                   	push   %esi
    f88c:	53                   	push   %ebx
    f88d:	83 ec 40             	sub    $0x40,%esp
  unsigned char IEND = 0;
    f890:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
  const unsigned char* chunk;
  unsigned char* idat; /*the data from idat chunks, zlib compressed*/
  size_t idatsize = 0;
    f894:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  unsigned char* scanlines = 0;
    f89b:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  size_t scanlines_size = 0, expected_size = 0;
    f8a2:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
    f8a9:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  size_t outsize = 0;
    f8b0:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

  /*for unknown chunk order*/
  unsigned unknown = 0;
    f8b7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  unsigned critical_pos = 1; /*1 = after IHDR, 2 = after PLTE, 3 = after IDAT*/
    f8be:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/


  /* safe output values in case error happens */
  *out = 0;
    f8c5:	8b 45 08             	mov    0x8(%ebp),%eax
    f8c8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *w = *h = 0;
    f8ce:	8b 45 10             	mov    0x10(%ebp),%eax
    f8d1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    f8d7:	8b 45 10             	mov    0x10(%ebp),%eax
    f8da:	8b 10                	mov    (%eax),%edx
    f8dc:	8b 45 0c             	mov    0xc(%ebp),%eax
    f8df:	89 10                	mov    %edx,(%eax)

  state->error = lodepng_inspect(w, h, state, in, insize); /*reads header and resets other parameters in state->info_png*/
    f8e1:	83 ec 0c             	sub    $0xc,%esp
    f8e4:	ff 75 1c             	pushl  0x1c(%ebp)
    f8e7:	ff 75 18             	pushl  0x18(%ebp)
    f8ea:	ff 75 14             	pushl  0x14(%ebp)
    f8ed:	ff 75 10             	pushl  0x10(%ebp)
    f8f0:	ff 75 0c             	pushl  0xc(%ebp)
    f8f3:	e8 d3 da ff ff       	call   d3cb <lodepng_inspect>
    f8f8:	83 c4 20             	add    $0x20,%esp
    f8fb:	89 c2                	mov    %eax,%edx
    f8fd:	8b 45 14             	mov    0x14(%ebp),%eax
    f900:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) return;
    f906:	8b 45 14             	mov    0x14(%ebp),%eax
    f909:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    f90f:	85 c0                	test   %eax,%eax
    f911:	0f 85 24 0a 00 00    	jne    1033b <decodeGeneric+0xab3>

  if(lodepng_pixel_overflow(*w, *h, &state->info_png.color, &state->info_raw)) {
    f917:	8b 45 14             	mov    0x14(%ebp),%eax
    f91a:	8d 58 78             	lea    0x78(%eax),%ebx
    f91d:	8b 45 14             	mov    0x14(%ebp),%eax
    f920:	8d 88 a4 00 00 00    	lea    0xa4(%eax),%ecx
    f926:	8b 45 10             	mov    0x10(%ebp),%eax
    f929:	8b 10                	mov    (%eax),%edx
    f92b:	8b 45 0c             	mov    0xc(%ebp),%eax
    f92e:	8b 00                	mov    (%eax),%eax
    f930:	53                   	push   %ebx
    f931:	51                   	push   %ecx
    f932:	52                   	push   %edx
    f933:	50                   	push   %eax
    f934:	e8 76 97 ff ff       	call   90af <lodepng_pixel_overflow>
    f939:	83 c4 10             	add    $0x10,%esp
    f93c:	85 c0                	test   %eax,%eax
    f93e:	74 12                	je     f952 <decodeGeneric+0xca>
    CERROR_RETURN(state->error, 92); /*overflow possible due to amount of pixels*/
    f940:	8b 45 14             	mov    0x14(%ebp),%eax
    f943:	c7 80 7c 01 00 00 5c 	movl   $0x5c,0x17c(%eax)
    f94a:	00 00 00 
    f94d:	e9 ea 09 00 00       	jmp    1033c <decodeGeneric+0xab4>
  }

  /*the input filesize is a safe upper bound for the sum of idat chunks size*/
  idat = (unsigned char*)lodepng_malloc(insize);
    f952:	83 ec 0c             	sub    $0xc,%esp
    f955:	ff 75 1c             	pushl  0x1c(%ebp)
    f958:	e8 a6 3a ff ff       	call   3403 <lodepng_malloc>
    f95d:	83 c4 10             	add    $0x10,%esp
    f960:	89 45 d8             	mov    %eax,-0x28(%ebp)
  if(!idat) CERROR_RETURN(state->error, 83); /*alloc fail*/
    f963:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
    f967:	75 12                	jne    f97b <decodeGeneric+0xf3>
    f969:	8b 45 14             	mov    0x14(%ebp),%eax
    f96c:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
    f973:	00 00 00 
    f976:	e9 c1 09 00 00       	jmp    1033c <decodeGeneric+0xab4>

  chunk = &in[33]; /*first byte of the first chunk after the header*/
    f97b:	8b 45 18             	mov    0x18(%ebp),%eax
    f97e:	83 c0 21             	add    $0x21,%eax
    f981:	89 45 f0             	mov    %eax,-0x10(%ebp)

  /*loop through the chunks, ignoring unknown chunks and stopping at IEND chunk.
  IDAT data is put at the start of the in buffer*/
  while(!IEND && !state->error) {
    f984:	e9 81 06 00 00       	jmp    1000a <decodeGeneric+0x782>
    unsigned chunkLength;
    const unsigned char* data; /*the data in the chunk*/

    /*error: size of the in buffer too small to contain next chunk*/
    if((size_t)((chunk - in) + 12) > insize || chunk < in) {
    f989:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f98c:	8b 45 18             	mov    0x18(%ebp),%eax
    f98f:	29 c2                	sub    %eax,%edx
    f991:	89 d0                	mov    %edx,%eax
    f993:	83 c0 0c             	add    $0xc,%eax
    f996:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    f999:	7f 08                	jg     f9a3 <decodeGeneric+0x11b>
    f99b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f99e:	3b 45 18             	cmp    0x18(%ebp),%eax
    f9a1:	73 20                	jae    f9c3 <decodeGeneric+0x13b>
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
    f9a3:	8b 45 14             	mov    0x14(%ebp),%eax
    f9a6:	8b 40 20             	mov    0x20(%eax),%eax
    f9a9:	85 c0                	test   %eax,%eax
    f9ab:	0f 85 72 06 00 00    	jne    10023 <decodeGeneric+0x79b>
      CERROR_BREAK(state->error, 30);
    f9b1:	8b 45 14             	mov    0x14(%ebp),%eax
    f9b4:	c7 80 7c 01 00 00 1e 	movl   $0x1e,0x17c(%eax)
    f9bb:	00 00 00 
    f9be:	e9 6a 06 00 00       	jmp    1002d <decodeGeneric+0x7a5>
    }

    /*length of the data of the chunk, excluding the length bytes, chunk type and CRC bytes*/
    chunkLength = lodepng_chunk_length(chunk);
    f9c3:	83 ec 0c             	sub    $0xc,%esp
    f9c6:	ff 75 f0             	pushl  -0x10(%ebp)
    f9c9:	e8 b7 89 ff ff       	call   8385 <lodepng_chunk_length>
    f9ce:	83 c4 10             	add    $0x10,%esp
    f9d1:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    /*error: chunk length larger than the max PNG chunk size*/
    if(chunkLength > 2147483647) {
    f9d4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    f9d7:	85 c0                	test   %eax,%eax
    f9d9:	79 20                	jns    f9fb <decodeGeneric+0x173>
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
    f9db:	8b 45 14             	mov    0x14(%ebp),%eax
    f9de:	8b 40 20             	mov    0x20(%eax),%eax
    f9e1:	85 c0                	test   %eax,%eax
    f9e3:	0f 85 3d 06 00 00    	jne    10026 <decodeGeneric+0x79e>
      CERROR_BREAK(state->error, 63);
    f9e9:	8b 45 14             	mov    0x14(%ebp),%eax
    f9ec:	c7 80 7c 01 00 00 3f 	movl   $0x3f,0x17c(%eax)
    f9f3:	00 00 00 
    f9f6:	e9 32 06 00 00       	jmp    1002d <decodeGeneric+0x7a5>
    }

    if((size_t)((chunk - in) + chunkLength + 12) > insize || (chunk + chunkLength + 12) < in) {
    f9fb:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f9fe:	8b 45 18             	mov    0x18(%ebp),%eax
    fa01:	29 c2                	sub    %eax,%edx
    fa03:	89 d0                	mov    %edx,%eax
    fa05:	89 c2                	mov    %eax,%edx
    fa07:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fa0a:	01 d0                	add    %edx,%eax
    fa0c:	83 c0 0c             	add    $0xc,%eax
    fa0f:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    fa12:	7f 10                	jg     fa24 <decodeGeneric+0x19c>
    fa14:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fa17:	8d 50 0c             	lea    0xc(%eax),%edx
    fa1a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    fa1d:	01 d0                	add    %edx,%eax
    fa1f:	3b 45 18             	cmp    0x18(%ebp),%eax
    fa22:	73 12                	jae    fa36 <decodeGeneric+0x1ae>
      CERROR_BREAK(state->error, 64); /*error: size of the in buffer too small to contain next chunk*/
    fa24:	8b 45 14             	mov    0x14(%ebp),%eax
    fa27:	c7 80 7c 01 00 00 40 	movl   $0x40,0x17c(%eax)
    fa2e:	00 00 00 
    fa31:	e9 f7 05 00 00       	jmp    1002d <decodeGeneric+0x7a5>
    }

    data = lodepng_chunk_data_const(chunk);
    fa36:	83 ec 0c             	sub    $0xc,%esp
    fa39:	ff 75 f0             	pushl  -0x10(%ebp)
    fa3c:	e8 7c 8a ff ff       	call   84bd <lodepng_chunk_data_const>
    fa41:	83 c4 10             	add    $0x10,%esp
    fa44:	89 45 d0             	mov    %eax,-0x30(%ebp)

    unknown = 0;
    fa47:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

    /*IDAT chunk, containing compressed image data*/
    if(lodepng_chunk_type_equals(chunk, "IDAT")) {
    fa4e:	83 ec 08             	sub    $0x8,%esp
    fa51:	68 84 a1 01 00       	push   $0x1a184
    fa56:	ff 75 f0             	pushl  -0x10(%ebp)
    fa59:	e8 74 89 ff ff       	call   83d2 <lodepng_chunk_type_equals>
    fa5e:	83 c4 10             	add    $0x10,%esp
    fa61:	84 c0                	test   %al,%al
    fa63:	74 79                	je     fade <decodeGeneric+0x256>
      size_t newsize;
      if(lodepng_addofl(idatsize, chunkLength, &newsize)) CERROR_BREAK(state->error, 95);
    fa65:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fa68:	83 ec 04             	sub    $0x4,%esp
    fa6b:	8d 55 bc             	lea    -0x44(%ebp),%edx
    fa6e:	52                   	push   %edx
    fa6f:	50                   	push   %eax
    fa70:	ff 75 ec             	pushl  -0x14(%ebp)
    fa73:	e8 4f 3a ff ff       	call   34c7 <lodepng_addofl>
    fa78:	83 c4 10             	add    $0x10,%esp
    fa7b:	85 c0                	test   %eax,%eax
    fa7d:	74 12                	je     fa91 <decodeGeneric+0x209>
    fa7f:	8b 45 14             	mov    0x14(%ebp),%eax
    fa82:	c7 80 7c 01 00 00 5f 	movl   $0x5f,0x17c(%eax)
    fa89:	00 00 00 
    fa8c:	e9 9c 05 00 00       	jmp    1002d <decodeGeneric+0x7a5>
      if(newsize > insize) CERROR_BREAK(state->error, 95);
    fa91:	8b 45 bc             	mov    -0x44(%ebp),%eax
    fa94:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    fa97:	7e 13                	jle    faac <decodeGeneric+0x224>
    fa99:	8b 45 14             	mov    0x14(%ebp),%eax
    fa9c:	c7 80 7c 01 00 00 5f 	movl   $0x5f,0x17c(%eax)
    faa3:	00 00 00 
    faa6:	90                   	nop
    faa7:	e9 81 05 00 00       	jmp    1002d <decodeGeneric+0x7a5>
      lodepng_memcpy(idat + idatsize, data, chunkLength);
    faac:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    faaf:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    fab2:	8b 55 d8             	mov    -0x28(%ebp),%edx
    fab5:	01 ca                	add    %ecx,%edx
    fab7:	83 ec 04             	sub    $0x4,%esp
    faba:	50                   	push   %eax
    fabb:	ff 75 d0             	pushl  -0x30(%ebp)
    fabe:	52                   	push   %edx
    fabf:	e8 7d 39 ff ff       	call   3441 <lodepng_memcpy>
    fac4:	83 c4 10             	add    $0x10,%esp
      idatsize += chunkLength;
    fac7:	8b 55 ec             	mov    -0x14(%ebp),%edx
    faca:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    facd:	01 d0                	add    %edx,%eax
    facf:	89 45 ec             	mov    %eax,-0x14(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      critical_pos = 3;
    fad2:	c7 45 dc 03 00 00 00 	movl   $0x3,-0x24(%ebp)
    fad9:	e9 db 04 00 00       	jmp    ffb9 <decodeGeneric+0x731>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    } else if(lodepng_chunk_type_equals(chunk, "IEND")) {
    fade:	83 ec 08             	sub    $0x8,%esp
    fae1:	68 89 a1 01 00       	push   $0x1a189
    fae6:	ff 75 f0             	pushl  -0x10(%ebp)
    fae9:	e8 e4 88 ff ff       	call   83d2 <lodepng_chunk_type_equals>
    faee:	83 c4 10             	add    $0x10,%esp
    faf1:	84 c0                	test   %al,%al
    faf3:	74 09                	je     fafe <decodeGeneric+0x276>
      /*IEND chunk*/
      IEND = 1;
    faf5:	c6 45 f7 01          	movb   $0x1,-0x9(%ebp)
    faf9:	e9 bb 04 00 00       	jmp    ffb9 <decodeGeneric+0x731>
    } else if(lodepng_chunk_type_equals(chunk, "PLTE")) {
    fafe:	83 ec 08             	sub    $0x8,%esp
    fb01:	68 48 a1 01 00       	push   $0x1a148
    fb06:	ff 75 f0             	pushl  -0x10(%ebp)
    fb09:	e8 c4 88 ff ff       	call   83d2 <lodepng_chunk_type_equals>
    fb0e:	83 c4 10             	add    $0x10,%esp
    fb11:	84 c0                	test   %al,%al
    fb13:	74 44                	je     fb59 <decodeGeneric+0x2d1>
      /*palette chunk (PLTE)*/
      state->error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
    fb15:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fb18:	8b 55 14             	mov    0x14(%ebp),%edx
    fb1b:	81 c2 a4 00 00 00    	add    $0xa4,%edx
    fb21:	83 ec 04             	sub    $0x4,%esp
    fb24:	50                   	push   %eax
    fb25:	ff 75 d0             	pushl  -0x30(%ebp)
    fb28:	52                   	push   %edx
    fb29:	e8 ec e8 ff ff       	call   e41a <readChunk_PLTE>
    fb2e:	83 c4 10             	add    $0x10,%esp
    fb31:	89 c2                	mov    %eax,%edx
    fb33:	8b 45 14             	mov    0x14(%ebp),%eax
    fb36:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fb3c:	8b 45 14             	mov    0x14(%ebp),%eax
    fb3f:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fb45:	85 c0                	test   %eax,%eax
    fb47:	0f 85 dc 04 00 00    	jne    10029 <decodeGeneric+0x7a1>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      critical_pos = 2;
    fb4d:	c7 45 dc 02 00 00 00 	movl   $0x2,-0x24(%ebp)
    fb54:	e9 60 04 00 00       	jmp    ffb9 <decodeGeneric+0x731>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    } else if(lodepng_chunk_type_equals(chunk, "tRNS")) {
    fb59:	83 ec 08             	sub    $0x8,%esp
    fb5c:	68 4d a1 01 00       	push   $0x1a14d
    fb61:	ff 75 f0             	pushl  -0x10(%ebp)
    fb64:	e8 69 88 ff ff       	call   83d2 <lodepng_chunk_type_equals>
    fb69:	83 c4 10             	add    $0x10,%esp
    fb6c:	84 c0                	test   %al,%al
    fb6e:	74 3d                	je     fbad <decodeGeneric+0x325>
      /*palette transparency chunk (tRNS). Even though this one is an ancillary chunk , it is still compiled
      in without 'LODEPNG_COMPILE_ANCILLARY_CHUNKS' because it contains essential color information that
      affects the alpha channel of pixels. */
      state->error = readChunk_tRNS(&state->info_png.color, data, chunkLength);
    fb70:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fb73:	8b 55 14             	mov    0x14(%ebp),%edx
    fb76:	81 c2 a4 00 00 00    	add    $0xa4,%edx
    fb7c:	83 ec 04             	sub    $0x4,%esp
    fb7f:	50                   	push   %eax
    fb80:	ff 75 d0             	pushl  -0x30(%ebp)
    fb83:	52                   	push   %edx
    fb84:	e8 b1 e9 ff ff       	call   e53a <readChunk_tRNS>
    fb89:	83 c4 10             	add    $0x10,%esp
    fb8c:	89 c2                	mov    %eax,%edx
    fb8e:	8b 45 14             	mov    0x14(%ebp),%eax
    fb91:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fb97:	8b 45 14             	mov    0x14(%ebp),%eax
    fb9a:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fba0:	85 c0                	test   %eax,%eax
    fba2:	0f 84 11 04 00 00    	je     ffb9 <decodeGeneric+0x731>
    fba8:	e9 80 04 00 00       	jmp    1002d <decodeGeneric+0x7a5>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      /*background color chunk (bKGD)*/
    } else if(lodepng_chunk_type_equals(chunk, "bKGD")) {
    fbad:	83 ec 08             	sub    $0x8,%esp
    fbb0:	68 52 a1 01 00       	push   $0x1a152
    fbb5:	ff 75 f0             	pushl  -0x10(%ebp)
    fbb8:	e8 15 88 ff ff       	call   83d2 <lodepng_chunk_type_equals>
    fbbd:	83 c4 10             	add    $0x10,%esp
    fbc0:	84 c0                	test   %al,%al
    fbc2:	74 3d                	je     fc01 <decodeGeneric+0x379>
      state->error = readChunk_bKGD(&state->info_png, data, chunkLength);
    fbc4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fbc7:	8b 55 14             	mov    0x14(%ebp),%edx
    fbca:	81 c2 98 00 00 00    	add    $0x98,%edx
    fbd0:	83 ec 04             	sub    $0x4,%esp
    fbd3:	50                   	push   %eax
    fbd4:	ff 75 d0             	pushl  -0x30(%ebp)
    fbd7:	52                   	push   %edx
    fbd8:	e8 c0 ea ff ff       	call   e69d <readChunk_bKGD>
    fbdd:	83 c4 10             	add    $0x10,%esp
    fbe0:	89 c2                	mov    %eax,%edx
    fbe2:	8b 45 14             	mov    0x14(%ebp),%eax
    fbe5:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fbeb:	8b 45 14             	mov    0x14(%ebp),%eax
    fbee:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fbf4:	85 c0                	test   %eax,%eax
    fbf6:	0f 84 bd 03 00 00    	je     ffb9 <decodeGeneric+0x731>
    fbfc:	e9 2c 04 00 00       	jmp    1002d <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "tEXt")) {
    fc01:	83 ec 08             	sub    $0x8,%esp
    fc04:	68 57 a1 01 00       	push   $0x1a157
    fc09:	ff 75 f0             	pushl  -0x10(%ebp)
    fc0c:	e8 c1 87 ff ff       	call   83d2 <lodepng_chunk_type_equals>
    fc11:	83 c4 10             	add    $0x10,%esp
    fc14:	84 c0                	test   %al,%al
    fc16:	74 4b                	je     fc63 <decodeGeneric+0x3db>
      /*text chunk (tEXt)*/
      if(state->decoder.read_text_chunks) {
    fc18:	8b 45 14             	mov    0x14(%ebp),%eax
    fc1b:	8b 40 28             	mov    0x28(%eax),%eax
    fc1e:	85 c0                	test   %eax,%eax
    fc20:	0f 84 93 03 00 00    	je     ffb9 <decodeGeneric+0x731>
        state->error = readChunk_tEXt(&state->info_png, data, chunkLength);
    fc26:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fc29:	8b 55 14             	mov    0x14(%ebp),%edx
    fc2c:	81 c2 98 00 00 00    	add    $0x98,%edx
    fc32:	83 ec 04             	sub    $0x4,%esp
    fc35:	50                   	push   %eax
    fc36:	ff 75 d0             	pushl  -0x30(%ebp)
    fc39:	52                   	push   %edx
    fc3a:	e8 e1 eb ff ff       	call   e820 <readChunk_tEXt>
    fc3f:	83 c4 10             	add    $0x10,%esp
    fc42:	89 c2                	mov    %eax,%edx
    fc44:	8b 45 14             	mov    0x14(%ebp),%eax
    fc47:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) break;
    fc4d:	8b 45 14             	mov    0x14(%ebp),%eax
    fc50:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fc56:	85 c0                	test   %eax,%eax
    fc58:	0f 84 5b 03 00 00    	je     ffb9 <decodeGeneric+0x731>
    fc5e:	e9 ca 03 00 00       	jmp    1002d <decodeGeneric+0x7a5>
      }
    } else if(lodepng_chunk_type_equals(chunk, "zTXt")) {
    fc63:	83 ec 08             	sub    $0x8,%esp
    fc66:	68 5c a1 01 00       	push   $0x1a15c
    fc6b:	ff 75 f0             	pushl  -0x10(%ebp)
    fc6e:	e8 5f 87 ff ff       	call   83d2 <lodepng_chunk_type_equals>
    fc73:	83 c4 10             	add    $0x10,%esp
    fc76:	84 c0                	test   %al,%al
    fc78:	74 4c                	je     fcc6 <decodeGeneric+0x43e>
      /*compressed text chunk (zTXt)*/
      if(state->decoder.read_text_chunks) {
    fc7a:	8b 45 14             	mov    0x14(%ebp),%eax
    fc7d:	8b 40 28             	mov    0x28(%eax),%eax
    fc80:	85 c0                	test   %eax,%eax
    fc82:	0f 84 31 03 00 00    	je     ffb9 <decodeGeneric+0x731>
        state->error = readChunk_zTXt(&state->info_png, &state->decoder, data, chunkLength);
    fc88:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    fc8b:	8b 45 14             	mov    0x14(%ebp),%eax
    fc8e:	8b 4d 14             	mov    0x14(%ebp),%ecx
    fc91:	81 c1 98 00 00 00    	add    $0x98,%ecx
    fc97:	52                   	push   %edx
    fc98:	ff 75 d0             	pushl  -0x30(%ebp)
    fc9b:	50                   	push   %eax
    fc9c:	51                   	push   %ecx
    fc9d:	e8 ca ec ff ff       	call   e96c <readChunk_zTXt>
    fca2:	83 c4 10             	add    $0x10,%esp
    fca5:	89 c2                	mov    %eax,%edx
    fca7:	8b 45 14             	mov    0x14(%ebp),%eax
    fcaa:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) break;
    fcb0:	8b 45 14             	mov    0x14(%ebp),%eax
    fcb3:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fcb9:	85 c0                	test   %eax,%eax
    fcbb:	0f 84 f8 02 00 00    	je     ffb9 <decodeGeneric+0x731>
    fcc1:	e9 67 03 00 00       	jmp    1002d <decodeGeneric+0x7a5>
      }
    } else if(lodepng_chunk_type_equals(chunk, "iTXt")) {
    fcc6:	83 ec 08             	sub    $0x8,%esp
    fcc9:	68 61 a1 01 00       	push   $0x1a161
    fcce:	ff 75 f0             	pushl  -0x10(%ebp)
    fcd1:	e8 fc 86 ff ff       	call   83d2 <lodepng_chunk_type_equals>
    fcd6:	83 c4 10             	add    $0x10,%esp
    fcd9:	84 c0                	test   %al,%al
    fcdb:	74 4c                	je     fd29 <decodeGeneric+0x4a1>
      /*international text chunk (iTXt)*/
      if(state->decoder.read_text_chunks) {
    fcdd:	8b 45 14             	mov    0x14(%ebp),%eax
    fce0:	8b 40 28             	mov    0x28(%eax),%eax
    fce3:	85 c0                	test   %eax,%eax
    fce5:	0f 84 ce 02 00 00    	je     ffb9 <decodeGeneric+0x731>
        state->error = readChunk_iTXt(&state->info_png, &state->decoder, data, chunkLength);
    fceb:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    fcee:	8b 45 14             	mov    0x14(%ebp),%eax
    fcf1:	8b 4d 14             	mov    0x14(%ebp),%ecx
    fcf4:	81 c1 98 00 00 00    	add    $0x98,%ecx
    fcfa:	52                   	push   %edx
    fcfb:	ff 75 d0             	pushl  -0x30(%ebp)
    fcfe:	50                   	push   %eax
    fcff:	51                   	push   %ecx
    fd00:	e8 23 ee ff ff       	call   eb28 <readChunk_iTXt>
    fd05:	83 c4 10             	add    $0x10,%esp
    fd08:	89 c2                	mov    %eax,%edx
    fd0a:	8b 45 14             	mov    0x14(%ebp),%eax
    fd0d:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) break;
    fd13:	8b 45 14             	mov    0x14(%ebp),%eax
    fd16:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fd1c:	85 c0                	test   %eax,%eax
    fd1e:	0f 84 95 02 00 00    	je     ffb9 <decodeGeneric+0x731>
    fd24:	e9 04 03 00 00       	jmp    1002d <decodeGeneric+0x7a5>
      }
    } else if(lodepng_chunk_type_equals(chunk, "tIME")) {
    fd29:	83 ec 08             	sub    $0x8,%esp
    fd2c:	68 66 a1 01 00       	push   $0x1a166
    fd31:	ff 75 f0             	pushl  -0x10(%ebp)
    fd34:	e8 99 86 ff ff       	call   83d2 <lodepng_chunk_type_equals>
    fd39:	83 c4 10             	add    $0x10,%esp
    fd3c:	84 c0                	test   %al,%al
    fd3e:	74 3d                	je     fd7d <decodeGeneric+0x4f5>
      state->error = readChunk_tIME(&state->info_png, data, chunkLength);
    fd40:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fd43:	8b 55 14             	mov    0x14(%ebp),%edx
    fd46:	81 c2 98 00 00 00    	add    $0x98,%edx
    fd4c:	83 ec 04             	sub    $0x4,%esp
    fd4f:	50                   	push   %eax
    fd50:	ff 75 d0             	pushl  -0x30(%ebp)
    fd53:	52                   	push   %edx
    fd54:	e8 25 f1 ff ff       	call   ee7e <readChunk_tIME>
    fd59:	83 c4 10             	add    $0x10,%esp
    fd5c:	89 c2                	mov    %eax,%edx
    fd5e:	8b 45 14             	mov    0x14(%ebp),%eax
    fd61:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fd67:	8b 45 14             	mov    0x14(%ebp),%eax
    fd6a:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fd70:	85 c0                	test   %eax,%eax
    fd72:	0f 84 41 02 00 00    	je     ffb9 <decodeGeneric+0x731>
    fd78:	e9 b0 02 00 00       	jmp    1002d <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "pHYs")) {
    fd7d:	83 ec 08             	sub    $0x8,%esp
    fd80:	68 6b a1 01 00       	push   $0x1a16b
    fd85:	ff 75 f0             	pushl  -0x10(%ebp)
    fd88:	e8 45 86 ff ff       	call   83d2 <lodepng_chunk_type_equals>
    fd8d:	83 c4 10             	add    $0x10,%esp
    fd90:	84 c0                	test   %al,%al
    fd92:	74 3d                	je     fdd1 <decodeGeneric+0x549>
      state->error = readChunk_pHYs(&state->info_png, data, chunkLength);
    fd94:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fd97:	8b 55 14             	mov    0x14(%ebp),%edx
    fd9a:	81 c2 98 00 00 00    	add    $0x98,%edx
    fda0:	83 ec 04             	sub    $0x4,%esp
    fda3:	50                   	push   %eax
    fda4:	ff 75 d0             	pushl  -0x30(%ebp)
    fda7:	52                   	push   %edx
    fda8:	e8 71 f1 ff ff       	call   ef1e <readChunk_pHYs>
    fdad:	83 c4 10             	add    $0x10,%esp
    fdb0:	89 c2                	mov    %eax,%edx
    fdb2:	8b 45 14             	mov    0x14(%ebp),%eax
    fdb5:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fdbb:	8b 45 14             	mov    0x14(%ebp),%eax
    fdbe:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fdc4:	85 c0                	test   %eax,%eax
    fdc6:	0f 84 ed 01 00 00    	je     ffb9 <decodeGeneric+0x731>
    fdcc:	e9 5c 02 00 00       	jmp    1002d <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "gAMA")) {
    fdd1:	83 ec 08             	sub    $0x8,%esp
    fdd4:	68 70 a1 01 00       	push   $0x1a170
    fdd9:	ff 75 f0             	pushl  -0x10(%ebp)
    fddc:	e8 f1 85 ff ff       	call   83d2 <lodepng_chunk_type_equals>
    fde1:	83 c4 10             	add    $0x10,%esp
    fde4:	84 c0                	test   %al,%al
    fde6:	74 3d                	je     fe25 <decodeGeneric+0x59d>
      state->error = readChunk_gAMA(&state->info_png, data, chunkLength);
    fde8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fdeb:	8b 55 14             	mov    0x14(%ebp),%edx
    fdee:	81 c2 98 00 00 00    	add    $0x98,%edx
    fdf4:	83 ec 04             	sub    $0x4,%esp
    fdf7:	50                   	push   %eax
    fdf8:	ff 75 d0             	pushl  -0x30(%ebp)
    fdfb:	52                   	push   %edx
    fdfc:	e8 ec f1 ff ff       	call   efed <readChunk_gAMA>
    fe01:	83 c4 10             	add    $0x10,%esp
    fe04:	89 c2                	mov    %eax,%edx
    fe06:	8b 45 14             	mov    0x14(%ebp),%eax
    fe09:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fe0f:	8b 45 14             	mov    0x14(%ebp),%eax
    fe12:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fe18:	85 c0                	test   %eax,%eax
    fe1a:	0f 84 99 01 00 00    	je     ffb9 <decodeGeneric+0x731>
    fe20:	e9 08 02 00 00       	jmp    1002d <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "cHRM")) {
    fe25:	83 ec 08             	sub    $0x8,%esp
    fe28:	68 75 a1 01 00       	push   $0x1a175
    fe2d:	ff 75 f0             	pushl  -0x10(%ebp)
    fe30:	e8 9d 85 ff ff       	call   83d2 <lodepng_chunk_type_equals>
    fe35:	83 c4 10             	add    $0x10,%esp
    fe38:	84 c0                	test   %al,%al
    fe3a:	74 3d                	je     fe79 <decodeGeneric+0x5f1>
      state->error = readChunk_cHRM(&state->info_png, data, chunkLength);
    fe3c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fe3f:	8b 55 14             	mov    0x14(%ebp),%edx
    fe42:	81 c2 98 00 00 00    	add    $0x98,%edx
    fe48:	83 ec 04             	sub    $0x4,%esp
    fe4b:	50                   	push   %eax
    fe4c:	ff 75 d0             	pushl  -0x30(%ebp)
    fe4f:	52                   	push   %edx
    fe50:	e8 07 f2 ff ff       	call   f05c <readChunk_cHRM>
    fe55:	83 c4 10             	add    $0x10,%esp
    fe58:	89 c2                	mov    %eax,%edx
    fe5a:	8b 45 14             	mov    0x14(%ebp),%eax
    fe5d:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fe63:	8b 45 14             	mov    0x14(%ebp),%eax
    fe66:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fe6c:	85 c0                	test   %eax,%eax
    fe6e:	0f 84 45 01 00 00    	je     ffb9 <decodeGeneric+0x731>
    fe74:	e9 b4 01 00 00       	jmp    1002d <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "sRGB")) {
    fe79:	83 ec 08             	sub    $0x8,%esp
    fe7c:	68 7a a1 01 00       	push   $0x1a17a
    fe81:	ff 75 f0             	pushl  -0x10(%ebp)
    fe84:	e8 49 85 ff ff       	call   83d2 <lodepng_chunk_type_equals>
    fe89:	83 c4 10             	add    $0x10,%esp
    fe8c:	84 c0                	test   %al,%al
    fe8e:	74 3d                	je     fecd <decodeGeneric+0x645>
      state->error = readChunk_sRGB(&state->info_png, data, chunkLength);
    fe90:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fe93:	8b 55 14             	mov    0x14(%ebp),%edx
    fe96:	81 c2 98 00 00 00    	add    $0x98,%edx
    fe9c:	83 ec 04             	sub    $0x4,%esp
    fe9f:	50                   	push   %eax
    fea0:	ff 75 d0             	pushl  -0x30(%ebp)
    fea3:	52                   	push   %edx
    fea4:	e8 47 f4 ff ff       	call   f2f0 <readChunk_sRGB>
    fea9:	83 c4 10             	add    $0x10,%esp
    feac:	89 c2                	mov    %eax,%edx
    feae:	8b 45 14             	mov    0x14(%ebp),%eax
    feb1:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    feb7:	8b 45 14             	mov    0x14(%ebp),%eax
    feba:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fec0:	85 c0                	test   %eax,%eax
    fec2:	0f 84 f1 00 00 00    	je     ffb9 <decodeGeneric+0x731>
    fec8:	e9 60 01 00 00       	jmp    1002d <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "iCCP")) {
    fecd:	83 ec 08             	sub    $0x8,%esp
    fed0:	68 7f a1 01 00       	push   $0x1a17f
    fed5:	ff 75 f0             	pushl  -0x10(%ebp)
    fed8:	e8 f5 84 ff ff       	call   83d2 <lodepng_chunk_type_equals>
    fedd:	83 c4 10             	add    $0x10,%esp
    fee0:	84 c0                	test   %al,%al
    fee2:	74 3e                	je     ff22 <decodeGeneric+0x69a>
      state->error = readChunk_iCCP(&state->info_png, &state->decoder, data, chunkLength);
    fee4:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    fee7:	8b 45 14             	mov    0x14(%ebp),%eax
    feea:	8b 4d 14             	mov    0x14(%ebp),%ecx
    feed:	81 c1 98 00 00 00    	add    $0x98,%ecx
    fef3:	52                   	push   %edx
    fef4:	ff 75 d0             	pushl  -0x30(%ebp)
    fef7:	50                   	push   %eax
    fef8:	51                   	push   %ecx
    fef9:	e8 28 f4 ff ff       	call   f326 <readChunk_iCCP>
    fefe:	83 c4 10             	add    $0x10,%esp
    ff01:	89 c2                	mov    %eax,%edx
    ff03:	8b 45 14             	mov    0x14(%ebp),%eax
    ff06:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    ff0c:	8b 45 14             	mov    0x14(%ebp),%eax
    ff0f:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    ff15:	85 c0                	test   %eax,%eax
    ff17:	0f 84 9c 00 00 00    	je     ffb9 <decodeGeneric+0x731>
    ff1d:	e9 0b 01 00 00       	jmp    1002d <decodeGeneric+0x7a5>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    } else /*it's not an implemented chunk type, so ignore it: skip over the data*/ {
      /*error: unknown critical chunk (5th bit of first byte of chunk type is 0)*/
      if(!state->decoder.ignore_critical && !lodepng_chunk_ancillary(chunk)) {
    ff22:	8b 45 14             	mov    0x14(%ebp),%eax
    ff25:	8b 40 1c             	mov    0x1c(%eax),%eax
    ff28:	85 c0                	test   %eax,%eax
    ff2a:	75 24                	jne    ff50 <decodeGeneric+0x6c8>
    ff2c:	83 ec 0c             	sub    $0xc,%esp
    ff2f:	ff 75 f0             	pushl  -0x10(%ebp)
    ff32:	e8 30 85 ff ff       	call   8467 <lodepng_chunk_ancillary>
    ff37:	83 c4 10             	add    $0x10,%esp
    ff3a:	84 c0                	test   %al,%al
    ff3c:	75 12                	jne    ff50 <decodeGeneric+0x6c8>
        CERROR_BREAK(state->error, 69);
    ff3e:	8b 45 14             	mov    0x14(%ebp),%eax
    ff41:	c7 80 7c 01 00 00 45 	movl   $0x45,0x17c(%eax)
    ff48:	00 00 00 
    ff4b:	e9 dd 00 00 00       	jmp    1002d <decodeGeneric+0x7a5>
      }

      unknown = 1;
    ff50:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      if(state->decoder.remember_unknown_chunks) {
    ff57:	8b 45 14             	mov    0x14(%ebp),%eax
    ff5a:	8b 40 2c             	mov    0x2c(%eax),%eax
    ff5d:	85 c0                	test   %eax,%eax
    ff5f:	74 58                	je     ffb9 <decodeGeneric+0x731>
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
    ff61:	8b 45 dc             	mov    -0x24(%ebp),%eax
    ff64:	83 e8 01             	sub    $0x1,%eax
      }

      unknown = 1;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      if(state->decoder.remember_unknown_chunks) {
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
    ff67:	83 c0 58             	add    $0x58,%eax
    ff6a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    ff71:	8b 45 14             	mov    0x14(%ebp),%eax
    ff74:	01 d0                	add    %edx,%eax
    ff76:	8d 50 10             	lea    0x10(%eax),%edx
    ff79:	8b 45 dc             	mov    -0x24(%ebp),%eax
    ff7c:	83 e8 01             	sub    $0x1,%eax
    ff7f:	83 c0 54             	add    $0x54,%eax
    ff82:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    ff89:	8b 45 14             	mov    0x14(%ebp),%eax
    ff8c:	01 c8                	add    %ecx,%eax
    ff8e:	83 c0 14             	add    $0x14,%eax
    ff91:	83 ec 04             	sub    $0x4,%esp
    ff94:	ff 75 f0             	pushl  -0x10(%ebp)
    ff97:	52                   	push   %edx
    ff98:	50                   	push   %eax
    ff99:	e8 15 88 ff ff       	call   87b3 <lodepng_chunk_append>
    ff9e:	83 c4 10             	add    $0x10,%esp
    ffa1:	89 c2                	mov    %eax,%edx
    ffa3:	8b 45 14             	mov    0x14(%ebp),%eax
    ffa6:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
        if(state->error) break;
    ffac:	8b 45 14             	mov    0x14(%ebp),%eax
    ffaf:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    ffb5:	85 c0                	test   %eax,%eax
    ffb7:	75 73                	jne    1002c <decodeGeneric+0x7a4>
      }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    }

    if(!state->decoder.ignore_crc && !unknown) /*check CRC if wanted, only on known chunk types*/ {
    ffb9:	8b 45 14             	mov    0x14(%ebp),%eax
    ffbc:	8b 40 18             	mov    0x18(%eax),%eax
    ffbf:	85 c0                	test   %eax,%eax
    ffc1:	75 27                	jne    ffea <decodeGeneric+0x762>
    ffc3:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    ffc7:	75 21                	jne    ffea <decodeGeneric+0x762>
      if(lodepng_chunk_check_crc(chunk)) CERROR_BREAK(state->error, 57); /*invalid CRC*/
    ffc9:	83 ec 0c             	sub    $0xc,%esp
    ffcc:	ff 75 f0             	pushl  -0x10(%ebp)
    ffcf:	e8 f4 84 ff ff       	call   84c8 <lodepng_chunk_check_crc>
    ffd4:	83 c4 10             	add    $0x10,%esp
    ffd7:	85 c0                	test   %eax,%eax
    ffd9:	74 0f                	je     ffea <decodeGeneric+0x762>
    ffdb:	8b 45 14             	mov    0x14(%ebp),%eax
    ffde:	c7 80 7c 01 00 00 39 	movl   $0x39,0x17c(%eax)
    ffe5:	00 00 00 
    ffe8:	eb 43                	jmp    1002d <decodeGeneric+0x7a5>
    }

    if(!IEND) chunk = lodepng_chunk_next_const(chunk, in + insize);
    ffea:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
    ffee:	75 1a                	jne    1000a <decodeGeneric+0x782>
    fff0:	8b 55 1c             	mov    0x1c(%ebp),%edx
    fff3:	8b 45 18             	mov    0x18(%ebp),%eax
    fff6:	01 d0                	add    %edx,%eax
    fff8:	83 ec 08             	sub    $0x8,%esp
    fffb:	50                   	push   %eax
    fffc:	ff 75 f0             	pushl  -0x10(%ebp)
    ffff:	e8 3f 86 ff ff       	call   8643 <lodepng_chunk_next_const>
   10004:	83 c4 10             	add    $0x10,%esp
   10007:	89 45 f0             	mov    %eax,-0x10(%ebp)

  chunk = &in[33]; /*first byte of the first chunk after the header*/

  /*loop through the chunks, ignoring unknown chunks and stopping at IEND chunk.
  IDAT data is put at the start of the in buffer*/
  while(!IEND && !state->error) {
   1000a:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
   1000e:	75 1d                	jne    1002d <decodeGeneric+0x7a5>
   10010:	8b 45 14             	mov    0x14(%ebp),%eax
   10013:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10019:	85 c0                	test   %eax,%eax
   1001b:	0f 84 68 f9 ff ff    	je     f989 <decodeGeneric+0x101>
   10021:	eb 0a                	jmp    1002d <decodeGeneric+0x7a5>
    unsigned chunkLength;
    const unsigned char* data; /*the data in the chunk*/

    /*error: size of the in buffer too small to contain next chunk*/
    if((size_t)((chunk - in) + 12) > insize || chunk < in) {
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
   10023:	90                   	nop
   10024:	eb 07                	jmp    1002d <decodeGeneric+0x7a5>

    /*length of the data of the chunk, excluding the length bytes, chunk type and CRC bytes*/
    chunkLength = lodepng_chunk_length(chunk);
    /*error: chunk length larger than the max PNG chunk size*/
    if(chunkLength > 2147483647) {
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
   10026:	90                   	nop
   10027:	eb 04                	jmp    1002d <decodeGeneric+0x7a5>
      /*IEND chunk*/
      IEND = 1;
    } else if(lodepng_chunk_type_equals(chunk, "PLTE")) {
      /*palette chunk (PLTE)*/
      state->error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
      if(state->error) break;
   10029:	90                   	nop
   1002a:	eb 01                	jmp    1002d <decodeGeneric+0x7a5>
      unknown = 1;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      if(state->decoder.remember_unknown_chunks) {
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
        if(state->error) break;
   1002c:	90                   	nop
    }

    if(!IEND) chunk = lodepng_chunk_next_const(chunk, in + insize);
  }

  if(!state->error && state->info_png.color.colortype == LCT_PALETTE && !state->info_png.color.palette) {
   1002d:	8b 45 14             	mov    0x14(%ebp),%eax
   10030:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10036:	85 c0                	test   %eax,%eax
   10038:	75 28                	jne    10062 <decodeGeneric+0x7da>
   1003a:	8b 45 14             	mov    0x14(%ebp),%eax
   1003d:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
   10043:	83 f8 03             	cmp    $0x3,%eax
   10046:	75 1a                	jne    10062 <decodeGeneric+0x7da>
   10048:	8b 45 14             	mov    0x14(%ebp),%eax
   1004b:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   10051:	85 c0                	test   %eax,%eax
   10053:	75 0d                	jne    10062 <decodeGeneric+0x7da>
    state->error = 106; /* error: PNG file must have PLTE chunk if color type is palette */
   10055:	8b 45 14             	mov    0x14(%ebp),%eax
   10058:	c7 80 7c 01 00 00 6a 	movl   $0x6a,0x17c(%eax)
   1005f:	00 00 00 
  }

  if(!state->error) {
   10062:	8b 45 14             	mov    0x14(%ebp),%eax
   10065:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1006b:	85 c0                	test   %eax,%eax
   1006d:	0f 85 d2 01 00 00    	jne    10245 <decodeGeneric+0x9bd>
    /*predict output size, to allocate exact size for output buffer to avoid more dynamic allocation.
    If the decompressed size does not match the prediction, the image must be corrupt.*/
    if(state->info_png.interlace_method == 0) {
   10073:	8b 45 14             	mov    0x14(%ebp),%eax
   10076:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   1007c:	85 c0                	test   %eax,%eax
   1007e:	75 3a                	jne    100ba <decodeGeneric+0x832>
      size_t bpp = lodepng_get_bpp(&state->info_png.color);
   10080:	8b 45 14             	mov    0x14(%ebp),%eax
   10083:	05 a4 00 00 00       	add    $0xa4,%eax
   10088:	83 ec 0c             	sub    $0xc,%esp
   1008b:	50                   	push   %eax
   1008c:	e8 8e 8e ff ff       	call   8f1f <lodepng_get_bpp>
   10091:	83 c4 10             	add    $0x10,%esp
   10094:	89 45 cc             	mov    %eax,-0x34(%ebp)
      expected_size = lodepng_get_raw_size_idat(*w, *h, bpp);
   10097:	8b 4d cc             	mov    -0x34(%ebp),%ecx
   1009a:	8b 45 10             	mov    0x10(%ebp),%eax
   1009d:	8b 10                	mov    (%eax),%edx
   1009f:	8b 45 0c             	mov    0xc(%ebp),%eax
   100a2:	8b 00                	mov    (%eax),%eax
   100a4:	83 ec 04             	sub    $0x4,%esp
   100a7:	51                   	push   %ecx
   100a8:	52                   	push   %edx
   100a9:	50                   	push   %eax
   100aa:	e8 cf 8f ff ff       	call   907e <lodepng_get_raw_size_idat>
   100af:	83 c4 10             	add    $0x10,%esp
   100b2:	89 45 e8             	mov    %eax,-0x18(%ebp)
   100b5:	e9 60 01 00 00       	jmp    1021a <decodeGeneric+0x992>
    } else {
      size_t bpp = lodepng_get_bpp(&state->info_png.color);
   100ba:	8b 45 14             	mov    0x14(%ebp),%eax
   100bd:	05 a4 00 00 00       	add    $0xa4,%eax
   100c2:	83 ec 0c             	sub    $0xc,%esp
   100c5:	50                   	push   %eax
   100c6:	e8 54 8e ff ff       	call   8f1f <lodepng_get_bpp>
   100cb:	83 c4 10             	add    $0x10,%esp
   100ce:	89 45 c8             	mov    %eax,-0x38(%ebp)
      /*Adam-7 interlaced: expected size is the sum of the 7 sub-images sizes*/
      expected_size = 0;
   100d1:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 7) >> 3, (*h + 7) >> 3, bpp);
   100d8:	8b 45 c8             	mov    -0x38(%ebp),%eax
   100db:	8b 55 10             	mov    0x10(%ebp),%edx
   100de:	8b 12                	mov    (%edx),%edx
   100e0:	83 c2 07             	add    $0x7,%edx
   100e3:	89 d1                	mov    %edx,%ecx
   100e5:	c1 e9 03             	shr    $0x3,%ecx
   100e8:	8b 55 0c             	mov    0xc(%ebp),%edx
   100eb:	8b 12                	mov    (%edx),%edx
   100ed:	83 c2 07             	add    $0x7,%edx
   100f0:	c1 ea 03             	shr    $0x3,%edx
   100f3:	83 ec 04             	sub    $0x4,%esp
   100f6:	50                   	push   %eax
   100f7:	51                   	push   %ecx
   100f8:	52                   	push   %edx
   100f9:	e8 80 8f ff ff       	call   907e <lodepng_get_raw_size_idat>
   100fe:	83 c4 10             	add    $0x10,%esp
   10101:	01 45 e8             	add    %eax,-0x18(%ebp)
      if(*w > 4) expected_size += lodepng_get_raw_size_idat((*w + 3) >> 3, (*h + 7) >> 3, bpp);
   10104:	8b 45 0c             	mov    0xc(%ebp),%eax
   10107:	8b 00                	mov    (%eax),%eax
   10109:	83 f8 04             	cmp    $0x4,%eax
   1010c:	76 2c                	jbe    1013a <decodeGeneric+0x8b2>
   1010e:	8b 45 c8             	mov    -0x38(%ebp),%eax
   10111:	8b 55 10             	mov    0x10(%ebp),%edx
   10114:	8b 12                	mov    (%edx),%edx
   10116:	83 c2 07             	add    $0x7,%edx
   10119:	89 d1                	mov    %edx,%ecx
   1011b:	c1 e9 03             	shr    $0x3,%ecx
   1011e:	8b 55 0c             	mov    0xc(%ebp),%edx
   10121:	8b 12                	mov    (%edx),%edx
   10123:	83 c2 03             	add    $0x3,%edx
   10126:	c1 ea 03             	shr    $0x3,%edx
   10129:	83 ec 04             	sub    $0x4,%esp
   1012c:	50                   	push   %eax
   1012d:	51                   	push   %ecx
   1012e:	52                   	push   %edx
   1012f:	e8 4a 8f ff ff       	call   907e <lodepng_get_raw_size_idat>
   10134:	83 c4 10             	add    $0x10,%esp
   10137:	01 45 e8             	add    %eax,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 3) >> 2, (*h + 3) >> 3, bpp);
   1013a:	8b 45 c8             	mov    -0x38(%ebp),%eax
   1013d:	8b 55 10             	mov    0x10(%ebp),%edx
   10140:	8b 12                	mov    (%edx),%edx
   10142:	83 c2 03             	add    $0x3,%edx
   10145:	89 d1                	mov    %edx,%ecx
   10147:	c1 e9 03             	shr    $0x3,%ecx
   1014a:	8b 55 0c             	mov    0xc(%ebp),%edx
   1014d:	8b 12                	mov    (%edx),%edx
   1014f:	83 c2 03             	add    $0x3,%edx
   10152:	c1 ea 02             	shr    $0x2,%edx
   10155:	83 ec 04             	sub    $0x4,%esp
   10158:	50                   	push   %eax
   10159:	51                   	push   %ecx
   1015a:	52                   	push   %edx
   1015b:	e8 1e 8f ff ff       	call   907e <lodepng_get_raw_size_idat>
   10160:	83 c4 10             	add    $0x10,%esp
   10163:	01 45 e8             	add    %eax,-0x18(%ebp)
      if(*w > 2) expected_size += lodepng_get_raw_size_idat((*w + 1) >> 2, (*h + 3) >> 2, bpp);
   10166:	8b 45 0c             	mov    0xc(%ebp),%eax
   10169:	8b 00                	mov    (%eax),%eax
   1016b:	83 f8 02             	cmp    $0x2,%eax
   1016e:	76 2c                	jbe    1019c <decodeGeneric+0x914>
   10170:	8b 45 c8             	mov    -0x38(%ebp),%eax
   10173:	8b 55 10             	mov    0x10(%ebp),%edx
   10176:	8b 12                	mov    (%edx),%edx
   10178:	83 c2 03             	add    $0x3,%edx
   1017b:	89 d1                	mov    %edx,%ecx
   1017d:	c1 e9 02             	shr    $0x2,%ecx
   10180:	8b 55 0c             	mov    0xc(%ebp),%edx
   10183:	8b 12                	mov    (%edx),%edx
   10185:	83 c2 01             	add    $0x1,%edx
   10188:	c1 ea 02             	shr    $0x2,%edx
   1018b:	83 ec 04             	sub    $0x4,%esp
   1018e:	50                   	push   %eax
   1018f:	51                   	push   %ecx
   10190:	52                   	push   %edx
   10191:	e8 e8 8e ff ff       	call   907e <lodepng_get_raw_size_idat>
   10196:	83 c4 10             	add    $0x10,%esp
   10199:	01 45 e8             	add    %eax,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 1) >> 1, (*h + 1) >> 2, bpp);
   1019c:	8b 45 c8             	mov    -0x38(%ebp),%eax
   1019f:	8b 55 10             	mov    0x10(%ebp),%edx
   101a2:	8b 12                	mov    (%edx),%edx
   101a4:	83 c2 01             	add    $0x1,%edx
   101a7:	89 d1                	mov    %edx,%ecx
   101a9:	c1 e9 02             	shr    $0x2,%ecx
   101ac:	8b 55 0c             	mov    0xc(%ebp),%edx
   101af:	8b 12                	mov    (%edx),%edx
   101b1:	83 c2 01             	add    $0x1,%edx
   101b4:	d1 ea                	shr    %edx
   101b6:	83 ec 04             	sub    $0x4,%esp
   101b9:	50                   	push   %eax
   101ba:	51                   	push   %ecx
   101bb:	52                   	push   %edx
   101bc:	e8 bd 8e ff ff       	call   907e <lodepng_get_raw_size_idat>
   101c1:	83 c4 10             	add    $0x10,%esp
   101c4:	01 45 e8             	add    %eax,-0x18(%ebp)
      if(*w > 1) expected_size += lodepng_get_raw_size_idat((*w + 0) >> 1, (*h + 1) >> 1, bpp);
   101c7:	8b 45 0c             	mov    0xc(%ebp),%eax
   101ca:	8b 00                	mov    (%eax),%eax
   101cc:	83 f8 01             	cmp    $0x1,%eax
   101cf:	76 27                	jbe    101f8 <decodeGeneric+0x970>
   101d1:	8b 45 c8             	mov    -0x38(%ebp),%eax
   101d4:	8b 55 10             	mov    0x10(%ebp),%edx
   101d7:	8b 12                	mov    (%edx),%edx
   101d9:	83 c2 01             	add    $0x1,%edx
   101dc:	89 d1                	mov    %edx,%ecx
   101de:	d1 e9                	shr    %ecx
   101e0:	8b 55 0c             	mov    0xc(%ebp),%edx
   101e3:	8b 12                	mov    (%edx),%edx
   101e5:	d1 ea                	shr    %edx
   101e7:	83 ec 04             	sub    $0x4,%esp
   101ea:	50                   	push   %eax
   101eb:	51                   	push   %ecx
   101ec:	52                   	push   %edx
   101ed:	e8 8c 8e ff ff       	call   907e <lodepng_get_raw_size_idat>
   101f2:	83 c4 10             	add    $0x10,%esp
   101f5:	01 45 e8             	add    %eax,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 0), (*h + 0) >> 1, bpp);
   101f8:	8b 55 c8             	mov    -0x38(%ebp),%edx
   101fb:	8b 45 10             	mov    0x10(%ebp),%eax
   101fe:	8b 00                	mov    (%eax),%eax
   10200:	d1 e8                	shr    %eax
   10202:	89 c1                	mov    %eax,%ecx
   10204:	8b 45 0c             	mov    0xc(%ebp),%eax
   10207:	8b 00                	mov    (%eax),%eax
   10209:	83 ec 04             	sub    $0x4,%esp
   1020c:	52                   	push   %edx
   1020d:	51                   	push   %ecx
   1020e:	50                   	push   %eax
   1020f:	e8 6a 8e ff ff       	call   907e <lodepng_get_raw_size_idat>
   10214:	83 c4 10             	add    $0x10,%esp
   10217:	01 45 e8             	add    %eax,-0x18(%ebp)
    }

    state->error = zlib_decompress(&scanlines, &scanlines_size, expected_size, idat, idatsize, &state->decoder.zlibsettings);
   1021a:	8b 45 14             	mov    0x14(%ebp),%eax
   1021d:	83 ec 08             	sub    $0x8,%esp
   10220:	50                   	push   %eax
   10221:	ff 75 ec             	pushl  -0x14(%ebp)
   10224:	ff 75 d8             	pushl  -0x28(%ebp)
   10227:	ff 75 e8             	pushl  -0x18(%ebp)
   1022a:	8d 45 c0             	lea    -0x40(%ebp),%eax
   1022d:	50                   	push   %eax
   1022e:	8d 45 c4             	lea    -0x3c(%ebp),%eax
   10231:	50                   	push   %eax
   10232:	e8 87 7c ff ff       	call   7ebe <zlib_decompress>
   10237:	83 c4 20             	add    $0x20,%esp
   1023a:	89 c2                	mov    %eax,%edx
   1023c:	8b 45 14             	mov    0x14(%ebp),%eax
   1023f:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  }
  if(!state->error && scanlines_size != expected_size) state->error = 91; /*decompressed size doesn't match prediction*/
   10245:	8b 45 14             	mov    0x14(%ebp),%eax
   10248:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1024e:	85 c0                	test   %eax,%eax
   10250:	75 15                	jne    10267 <decodeGeneric+0x9df>
   10252:	8b 45 c0             	mov    -0x40(%ebp),%eax
   10255:	3b 45 e8             	cmp    -0x18(%ebp),%eax
   10258:	74 0d                	je     10267 <decodeGeneric+0x9df>
   1025a:	8b 45 14             	mov    0x14(%ebp),%eax
   1025d:	c7 80 7c 01 00 00 5b 	movl   $0x5b,0x17c(%eax)
   10264:	00 00 00 
  lodepng_free(idat);
   10267:	83 ec 0c             	sub    $0xc,%esp
   1026a:	ff 75 d8             	pushl  -0x28(%ebp)
   1026d:	e8 b2 31 ff ff       	call   3424 <lodepng_free>
   10272:	83 c4 10             	add    $0x10,%esp

  if(!state->error) {
   10275:	8b 45 14             	mov    0x14(%ebp),%eax
   10278:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1027e:	85 c0                	test   %eax,%eax
   10280:	75 4f                	jne    102d1 <decodeGeneric+0xa49>
    outsize = lodepng_get_raw_size(*w, *h, &state->info_png.color);
   10282:	8b 45 14             	mov    0x14(%ebp),%eax
   10285:	8d 88 a4 00 00 00    	lea    0xa4(%eax),%ecx
   1028b:	8b 45 10             	mov    0x10(%ebp),%eax
   1028e:	8b 10                	mov    (%eax),%edx
   10290:	8b 45 0c             	mov    0xc(%ebp),%eax
   10293:	8b 00                	mov    (%eax),%eax
   10295:	83 ec 04             	sub    $0x4,%esp
   10298:	51                   	push   %ecx
   10299:	52                   	push   %edx
   1029a:	50                   	push   %eax
   1029b:	e8 be 8d ff ff       	call   905e <lodepng_get_raw_size>
   102a0:	83 c4 10             	add    $0x10,%esp
   102a3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    *out = (unsigned char*)lodepng_malloc(outsize);
   102a6:	83 ec 0c             	sub    $0xc,%esp
   102a9:	ff 75 e4             	pushl  -0x1c(%ebp)
   102ac:	e8 52 31 ff ff       	call   3403 <lodepng_malloc>
   102b1:	83 c4 10             	add    $0x10,%esp
   102b4:	89 c2                	mov    %eax,%edx
   102b6:	8b 45 08             	mov    0x8(%ebp),%eax
   102b9:	89 10                	mov    %edx,(%eax)
    if(!*out) state->error = 83; /*alloc fail*/
   102bb:	8b 45 08             	mov    0x8(%ebp),%eax
   102be:	8b 00                	mov    (%eax),%eax
   102c0:	85 c0                	test   %eax,%eax
   102c2:	75 0d                	jne    102d1 <decodeGeneric+0xa49>
   102c4:	8b 45 14             	mov    0x14(%ebp),%eax
   102c7:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   102ce:	00 00 00 
  }
  if(!state->error) {
   102d1:	8b 45 14             	mov    0x14(%ebp),%eax
   102d4:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   102da:	85 c0                	test   %eax,%eax
   102dc:	75 4c                	jne    1032a <decodeGeneric+0xaa2>
    lodepng_memset(*out, 0, outsize);
   102de:	8b 45 08             	mov    0x8(%ebp),%eax
   102e1:	8b 00                	mov    (%eax),%eax
   102e3:	83 ec 04             	sub    $0x4,%esp
   102e6:	ff 75 e4             	pushl  -0x1c(%ebp)
   102e9:	6a 00                	push   $0x0
   102eb:	50                   	push   %eax
   102ec:	e8 83 31 ff ff       	call   3474 <lodepng_memset>
   102f1:	83 c4 10             	add    $0x10,%esp
    state->error = postProcessScanlines(*out, scanlines, *w, *h, &state->info_png);
   102f4:	8b 45 14             	mov    0x14(%ebp),%eax
   102f7:	8d b0 98 00 00 00    	lea    0x98(%eax),%esi
   102fd:	8b 45 10             	mov    0x10(%ebp),%eax
   10300:	8b 18                	mov    (%eax),%ebx
   10302:	8b 45 0c             	mov    0xc(%ebp),%eax
   10305:	8b 08                	mov    (%eax),%ecx
   10307:	8b 55 c4             	mov    -0x3c(%ebp),%edx
   1030a:	8b 45 08             	mov    0x8(%ebp),%eax
   1030d:	8b 00                	mov    (%eax),%eax
   1030f:	83 ec 0c             	sub    $0xc,%esp
   10312:	56                   	push   %esi
   10313:	53                   	push   %ebx
   10314:	51                   	push   %ecx
   10315:	52                   	push   %edx
   10316:	50                   	push   %eax
   10317:	e8 05 df ff ff       	call   e221 <postProcessScanlines>
   1031c:	83 c4 20             	add    $0x20,%esp
   1031f:	89 c2                	mov    %eax,%edx
   10321:	8b 45 14             	mov    0x14(%ebp),%eax
   10324:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  }
  lodepng_free(scanlines);
   1032a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   1032d:	83 ec 0c             	sub    $0xc,%esp
   10330:	50                   	push   %eax
   10331:	e8 ee 30 ff ff       	call   3424 <lodepng_free>
   10336:	83 c4 10             	add    $0x10,%esp
   10339:	eb 01                	jmp    1033c <decodeGeneric+0xab4>
  /* safe output values in case error happens */
  *out = 0;
  *w = *h = 0;

  state->error = lodepng_inspect(w, h, state, in, insize); /*reads header and resets other parameters in state->info_png*/
  if(state->error) return;
   1033b:	90                   	nop
  if(!state->error) {
    lodepng_memset(*out, 0, outsize);
    state->error = postProcessScanlines(*out, scanlines, *w, *h, &state->info_png);
  }
  lodepng_free(scanlines);
}
   1033c:	8d 65 f8             	lea    -0x8(%ebp),%esp
   1033f:	5b                   	pop    %ebx
   10340:	5e                   	pop    %esi
   10341:	5d                   	pop    %ebp
   10342:	c3                   	ret    

00010343 <lodepng_decode>:

unsigned lodepng_decode(unsigned char** out, unsigned* w, unsigned* h,
                        LodePNGState* state,
                        const unsigned char* in, size_t insize) {
   10343:	55                   	push   %ebp
   10344:	89 e5                	mov    %esp,%ebp
   10346:	56                   	push   %esi
   10347:	53                   	push   %ebx
   10348:	83 ec 10             	sub    $0x10,%esp
  *out = 0;
   1034b:	8b 45 08             	mov    0x8(%ebp),%eax
   1034e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  decodeGeneric(out, w, h, state, in, insize);
   10354:	83 ec 08             	sub    $0x8,%esp
   10357:	ff 75 1c             	pushl  0x1c(%ebp)
   1035a:	ff 75 18             	pushl  0x18(%ebp)
   1035d:	ff 75 14             	pushl  0x14(%ebp)
   10360:	ff 75 10             	pushl  0x10(%ebp)
   10363:	ff 75 0c             	pushl  0xc(%ebp)
   10366:	ff 75 08             	pushl  0x8(%ebp)
   10369:	e8 1a f5 ff ff       	call   f888 <decodeGeneric>
   1036e:	83 c4 20             	add    $0x20,%esp
  if(state->error) return state->error;
   10371:	8b 45 14             	mov    0x14(%ebp),%eax
   10374:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1037a:	85 c0                	test   %eax,%eax
   1037c:	74 0e                	je     1038c <lodepng_decode+0x49>
   1037e:	8b 45 14             	mov    0x14(%ebp),%eax
   10381:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10387:	e9 55 01 00 00       	jmp    104e1 <lodepng_decode+0x19e>
  if(!state->decoder.color_convert || lodepng_color_mode_equal(&state->info_raw, &state->info_png.color)) {
   1038c:	8b 45 14             	mov    0x14(%ebp),%eax
   1038f:	8b 40 24             	mov    0x24(%eax),%eax
   10392:	85 c0                	test   %eax,%eax
   10394:	74 20                	je     103b6 <lodepng_decode+0x73>
   10396:	8b 45 14             	mov    0x14(%ebp),%eax
   10399:	8d 90 a4 00 00 00    	lea    0xa4(%eax),%edx
   1039f:	8b 45 14             	mov    0x14(%ebp),%eax
   103a2:	83 c0 78             	add    $0x78,%eax
   103a5:	83 ec 08             	sub    $0x8,%esp
   103a8:	52                   	push   %edx
   103a9:	50                   	push   %eax
   103aa:	e8 56 89 ff ff       	call   8d05 <lodepng_color_mode_equal>
   103af:	83 c4 10             	add    $0x10,%esp
   103b2:	85 c0                	test   %eax,%eax
   103b4:	74 54                	je     1040a <lodepng_decode+0xc7>
    /*same color type, no copying or converting of data needed*/
    /*store the info_png color settings on the info_raw so that the info_raw still reflects what colortype
    the raw image has to the end user*/
    if(!state->decoder.color_convert) {
   103b6:	8b 45 14             	mov    0x14(%ebp),%eax
   103b9:	8b 40 24             	mov    0x24(%eax),%eax
   103bc:	85 c0                	test   %eax,%eax
   103be:	0f 85 13 01 00 00    	jne    104d7 <lodepng_decode+0x194>
      state->error = lodepng_color_mode_copy(&state->info_raw, &state->info_png.color);
   103c4:	8b 45 14             	mov    0x14(%ebp),%eax
   103c7:	8d 90 a4 00 00 00    	lea    0xa4(%eax),%edx
   103cd:	8b 45 14             	mov    0x14(%ebp),%eax
   103d0:	83 c0 78             	add    $0x78,%eax
   103d3:	83 ec 08             	sub    $0x8,%esp
   103d6:	52                   	push   %edx
   103d7:	50                   	push   %eax
   103d8:	e8 3f 88 ff ff       	call   8c1c <lodepng_color_mode_copy>
   103dd:	83 c4 10             	add    $0x10,%esp
   103e0:	89 c2                	mov    %eax,%edx
   103e2:	8b 45 14             	mov    0x14(%ebp),%eax
   103e5:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) return state->error;
   103eb:	8b 45 14             	mov    0x14(%ebp),%eax
   103ee:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   103f4:	85 c0                	test   %eax,%eax
   103f6:	0f 84 db 00 00 00    	je     104d7 <lodepng_decode+0x194>
   103fc:	8b 45 14             	mov    0x14(%ebp),%eax
   103ff:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10405:	e9 d7 00 00 00       	jmp    104e1 <lodepng_decode+0x19e>
    }
  } else { /*color conversion needed*/
    unsigned char* data = *out;
   1040a:	8b 45 08             	mov    0x8(%ebp),%eax
   1040d:	8b 00                	mov    (%eax),%eax
   1040f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    size_t outsize;

    /*TODO: check if this works according to the statement in the documentation: "The converter can convert
    from grayscale input color type, to 8-bit grayscale or grayscale with alpha"*/
    if(!(state->info_raw.colortype == LCT_RGB || state->info_raw.colortype == LCT_RGBA)
   10412:	8b 45 14             	mov    0x14(%ebp),%eax
   10415:	8b 40 78             	mov    0x78(%eax),%eax
   10418:	83 f8 02             	cmp    $0x2,%eax
   1041b:	74 20                	je     1043d <lodepng_decode+0xfa>
   1041d:	8b 45 14             	mov    0x14(%ebp),%eax
   10420:	8b 40 78             	mov    0x78(%eax),%eax
   10423:	83 f8 06             	cmp    $0x6,%eax
   10426:	74 15                	je     1043d <lodepng_decode+0xfa>
       && !(state->info_raw.bitdepth == 8)) {
   10428:	8b 45 14             	mov    0x14(%ebp),%eax
   1042b:	8b 40 7c             	mov    0x7c(%eax),%eax
   1042e:	83 f8 08             	cmp    $0x8,%eax
   10431:	74 0a                	je     1043d <lodepng_decode+0xfa>
      return 56; /*unsupported color mode conversion*/
   10433:	b8 38 00 00 00       	mov    $0x38,%eax
   10438:	e9 a4 00 00 00       	jmp    104e1 <lodepng_decode+0x19e>
    }

    outsize = lodepng_get_raw_size(*w, *h, &state->info_raw);
   1043d:	8b 45 14             	mov    0x14(%ebp),%eax
   10440:	8d 48 78             	lea    0x78(%eax),%ecx
   10443:	8b 45 10             	mov    0x10(%ebp),%eax
   10446:	8b 10                	mov    (%eax),%edx
   10448:	8b 45 0c             	mov    0xc(%ebp),%eax
   1044b:	8b 00                	mov    (%eax),%eax
   1044d:	83 ec 04             	sub    $0x4,%esp
   10450:	51                   	push   %ecx
   10451:	52                   	push   %edx
   10452:	50                   	push   %eax
   10453:	e8 06 8c ff ff       	call   905e <lodepng_get_raw_size>
   10458:	83 c4 10             	add    $0x10,%esp
   1045b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    *out = (unsigned char*)lodepng_malloc(outsize);
   1045e:	83 ec 0c             	sub    $0xc,%esp
   10461:	ff 75 f0             	pushl  -0x10(%ebp)
   10464:	e8 9a 2f ff ff       	call   3403 <lodepng_malloc>
   10469:	83 c4 10             	add    $0x10,%esp
   1046c:	89 c2                	mov    %eax,%edx
   1046e:	8b 45 08             	mov    0x8(%ebp),%eax
   10471:	89 10                	mov    %edx,(%eax)
    if(!(*out)) {
   10473:	8b 45 08             	mov    0x8(%ebp),%eax
   10476:	8b 00                	mov    (%eax),%eax
   10478:	85 c0                	test   %eax,%eax
   1047a:	75 0f                	jne    1048b <lodepng_decode+0x148>
      state->error = 83; /*alloc fail*/
   1047c:	8b 45 14             	mov    0x14(%ebp),%eax
   1047f:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   10486:	00 00 00 
   10489:	eb 3c                	jmp    104c7 <lodepng_decode+0x184>
    }
    else state->error = lodepng_convert(*out, data, &state->info_raw,
   1048b:	8b 45 10             	mov    0x10(%ebp),%eax
   1048e:	8b 08                	mov    (%eax),%ecx
   10490:	8b 45 0c             	mov    0xc(%ebp),%eax
   10493:	8b 10                	mov    (%eax),%edx
                                        &state->info_png.color, *w, *h);
   10495:	8b 45 14             	mov    0x14(%ebp),%eax
   10498:	8d b0 a4 00 00 00    	lea    0xa4(%eax),%esi
    outsize = lodepng_get_raw_size(*w, *h, &state->info_raw);
    *out = (unsigned char*)lodepng_malloc(outsize);
    if(!(*out)) {
      state->error = 83; /*alloc fail*/
    }
    else state->error = lodepng_convert(*out, data, &state->info_raw,
   1049e:	8b 45 14             	mov    0x14(%ebp),%eax
   104a1:	8d 58 78             	lea    0x78(%eax),%ebx
   104a4:	8b 45 08             	mov    0x8(%ebp),%eax
   104a7:	8b 00                	mov    (%eax),%eax
   104a9:	83 ec 08             	sub    $0x8,%esp
   104ac:	51                   	push   %ecx
   104ad:	52                   	push   %edx
   104ae:	56                   	push   %esi
   104af:	53                   	push   %ebx
   104b0:	ff 75 f4             	pushl  -0xc(%ebp)
   104b3:	50                   	push   %eax
   104b4:	e8 51 b6 ff ff       	call   bb0a <lodepng_convert>
   104b9:	83 c4 20             	add    $0x20,%esp
   104bc:	89 c2                	mov    %eax,%edx
   104be:	8b 45 14             	mov    0x14(%ebp),%eax
   104c1:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
                                        &state->info_png.color, *w, *h);
    lodepng_free(data);
   104c7:	83 ec 0c             	sub    $0xc,%esp
   104ca:	ff 75 f4             	pushl  -0xc(%ebp)
   104cd:	e8 52 2f ff ff       	call   3424 <lodepng_free>
   104d2:	83 c4 10             	add    $0x10,%esp
   104d5:	eb 01                	jmp    104d8 <lodepng_decode+0x195>
  if(state->error) return state->error;
  if(!state->decoder.color_convert || lodepng_color_mode_equal(&state->info_raw, &state->info_png.color)) {
    /*same color type, no copying or converting of data needed*/
    /*store the info_png color settings on the info_raw so that the info_raw still reflects what colortype
    the raw image has to the end user*/
    if(!state->decoder.color_convert) {
   104d7:	90                   	nop
    }
    else state->error = lodepng_convert(*out, data, &state->info_raw,
                                        &state->info_png.color, *w, *h);
    lodepng_free(data);
  }
  return state->error;
   104d8:	8b 45 14             	mov    0x14(%ebp),%eax
   104db:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
}
   104e1:	8d 65 f8             	lea    -0x8(%ebp),%esp
   104e4:	5b                   	pop    %ebx
   104e5:	5e                   	pop    %esi
   104e6:	5d                   	pop    %ebp
   104e7:	c3                   	ret    

000104e8 <lodepng_decode_memory>:

unsigned lodepng_decode_memory(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in,
                               size_t insize, LodePNGColorType colortype, unsigned bitdepth) {
   104e8:	55                   	push   %ebp
   104e9:	89 e5                	mov    %esp,%ebp
   104eb:	81 ec 98 01 00 00    	sub    $0x198,%esp
  unsigned error;
  LodePNGState state;
  lodepng_state_init(&state);
   104f1:	83 ec 0c             	sub    $0xc,%esp
   104f4:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   104fa:	50                   	push   %eax
   104fb:	e8 d9 01 00 00       	call   106d9 <lodepng_state_init>
   10500:	83 c4 10             	add    $0x10,%esp
  state.info_raw.colortype = colortype;
   10503:	8b 45 1c             	mov    0x1c(%ebp),%eax
   10506:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
  state.info_raw.bitdepth = bitdepth;
   1050c:	8b 45 20             	mov    0x20(%ebp),%eax
   1050f:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  /*disable reading things that this function doesn't output*/
  state.decoder.read_text_chunks = 0;
   10515:	c7 85 9c fe ff ff 00 	movl   $0x0,-0x164(%ebp)
   1051c:	00 00 00 
  state.decoder.remember_unknown_chunks = 0;
   1051f:	c7 85 a0 fe ff ff 00 	movl   $0x0,-0x160(%ebp)
   10526:	00 00 00 
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  error = lodepng_decode(out, w, h, &state, in, insize);
   10529:	83 ec 08             	sub    $0x8,%esp
   1052c:	ff 75 18             	pushl  0x18(%ebp)
   1052f:	ff 75 14             	pushl  0x14(%ebp)
   10532:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   10538:	50                   	push   %eax
   10539:	ff 75 10             	pushl  0x10(%ebp)
   1053c:	ff 75 0c             	pushl  0xc(%ebp)
   1053f:	ff 75 08             	pushl  0x8(%ebp)
   10542:	e8 fc fd ff ff       	call   10343 <lodepng_decode>
   10547:	83 c4 20             	add    $0x20,%esp
   1054a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_state_cleanup(&state);
   1054d:	83 ec 0c             	sub    $0xc,%esp
   10550:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   10556:	50                   	push   %eax
   10557:	e8 d7 01 00 00       	call   10733 <lodepng_state_cleanup>
   1055c:	83 c4 10             	add    $0x10,%esp
  return error;
   1055f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10562:	c9                   	leave  
   10563:	c3                   	ret    

00010564 <lodepng_decode32>:

unsigned lodepng_decode32(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize) {
   10564:	55                   	push   %ebp
   10565:	89 e5                	mov    %esp,%ebp
   10567:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGBA, 8);
   1056a:	83 ec 04             	sub    $0x4,%esp
   1056d:	6a 08                	push   $0x8
   1056f:	6a 06                	push   $0x6
   10571:	ff 75 18             	pushl  0x18(%ebp)
   10574:	ff 75 14             	pushl  0x14(%ebp)
   10577:	ff 75 10             	pushl  0x10(%ebp)
   1057a:	ff 75 0c             	pushl  0xc(%ebp)
   1057d:	ff 75 08             	pushl  0x8(%ebp)
   10580:	e8 63 ff ff ff       	call   104e8 <lodepng_decode_memory>
   10585:	83 c4 20             	add    $0x20,%esp
}
   10588:	c9                   	leave  
   10589:	c3                   	ret    

0001058a <lodepng_decode24>:

unsigned lodepng_decode24(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize) {
   1058a:	55                   	push   %ebp
   1058b:	89 e5                	mov    %esp,%ebp
   1058d:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGB, 8);
   10590:	83 ec 04             	sub    $0x4,%esp
   10593:	6a 08                	push   $0x8
   10595:	6a 02                	push   $0x2
   10597:	ff 75 18             	pushl  0x18(%ebp)
   1059a:	ff 75 14             	pushl  0x14(%ebp)
   1059d:	ff 75 10             	pushl  0x10(%ebp)
   105a0:	ff 75 0c             	pushl  0xc(%ebp)
   105a3:	ff 75 08             	pushl  0x8(%ebp)
   105a6:	e8 3d ff ff ff       	call   104e8 <lodepng_decode_memory>
   105ab:	83 c4 20             	add    $0x20,%esp
}
   105ae:	c9                   	leave  
   105af:	c3                   	ret    

000105b0 <lodepng_decode_file>:

#ifdef LODEPNG_COMPILE_DISK
unsigned lodepng_decode_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename,
                             LodePNGColorType colortype, unsigned bitdepth) {
   105b0:	55                   	push   %ebp
   105b1:	89 e5                	mov    %esp,%ebp
   105b3:	83 ec 18             	sub    $0x18,%esp
  unsigned char* buffer = 0;
   105b6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  size_t buffersize;
  unsigned error;
  /* safe output values in case error happens */
  *out = 0;
   105bd:	8b 45 08             	mov    0x8(%ebp),%eax
   105c0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *w = *h = 0;
   105c6:	8b 45 10             	mov    0x10(%ebp),%eax
   105c9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   105cf:	8b 45 10             	mov    0x10(%ebp),%eax
   105d2:	8b 10                	mov    (%eax),%edx
   105d4:	8b 45 0c             	mov    0xc(%ebp),%eax
   105d7:	89 10                	mov    %edx,(%eax)
  error = lodepng_load_file(&buffer, &buffersize, filename);
   105d9:	83 ec 04             	sub    $0x4,%esp
   105dc:	ff 75 14             	pushl  0x14(%ebp)
   105df:	8d 45 ec             	lea    -0x14(%ebp),%eax
   105e2:	50                   	push   %eax
   105e3:	8d 45 f0             	lea    -0x10(%ebp),%eax
   105e6:	50                   	push   %eax
   105e7:	e8 70 32 ff ff       	call   385c <lodepng_load_file>
   105ec:	83 c4 10             	add    $0x10,%esp
   105ef:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = lodepng_decode_memory(out, w, h, buffer, buffersize, colortype, bitdepth);
   105f2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   105f6:	75 25                	jne    1061d <lodepng_decode_file+0x6d>
   105f8:	8b 55 ec             	mov    -0x14(%ebp),%edx
   105fb:	8b 45 f0             	mov    -0x10(%ebp),%eax
   105fe:	83 ec 04             	sub    $0x4,%esp
   10601:	ff 75 1c             	pushl  0x1c(%ebp)
   10604:	ff 75 18             	pushl  0x18(%ebp)
   10607:	52                   	push   %edx
   10608:	50                   	push   %eax
   10609:	ff 75 10             	pushl  0x10(%ebp)
   1060c:	ff 75 0c             	pushl  0xc(%ebp)
   1060f:	ff 75 08             	pushl  0x8(%ebp)
   10612:	e8 d1 fe ff ff       	call   104e8 <lodepng_decode_memory>
   10617:	83 c4 20             	add    $0x20,%esp
   1061a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_free(buffer);
   1061d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10620:	83 ec 0c             	sub    $0xc,%esp
   10623:	50                   	push   %eax
   10624:	e8 fb 2d ff ff       	call   3424 <lodepng_free>
   10629:	83 c4 10             	add    $0x10,%esp
  return error;
   1062c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   1062f:	c9                   	leave  
   10630:	c3                   	ret    

00010631 <lodepng_decode32_file>:

unsigned lodepng_decode32_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename) {
   10631:	55                   	push   %ebp
   10632:	89 e5                	mov    %esp,%ebp
   10634:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_file(out, w, h, filename, LCT_RGBA, 8);
   10637:	83 ec 08             	sub    $0x8,%esp
   1063a:	6a 08                	push   $0x8
   1063c:	6a 06                	push   $0x6
   1063e:	ff 75 14             	pushl  0x14(%ebp)
   10641:	ff 75 10             	pushl  0x10(%ebp)
   10644:	ff 75 0c             	pushl  0xc(%ebp)
   10647:	ff 75 08             	pushl  0x8(%ebp)
   1064a:	e8 61 ff ff ff       	call   105b0 <lodepng_decode_file>
   1064f:	83 c4 20             	add    $0x20,%esp
}
   10652:	c9                   	leave  
   10653:	c3                   	ret    

00010654 <lodepng_decode24_file>:

unsigned lodepng_decode24_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename) {
   10654:	55                   	push   %ebp
   10655:	89 e5                	mov    %esp,%ebp
   10657:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_file(out, w, h, filename, LCT_RGB, 8);
   1065a:	83 ec 08             	sub    $0x8,%esp
   1065d:	6a 08                	push   $0x8
   1065f:	6a 02                	push   $0x2
   10661:	ff 75 14             	pushl  0x14(%ebp)
   10664:	ff 75 10             	pushl  0x10(%ebp)
   10667:	ff 75 0c             	pushl  0xc(%ebp)
   1066a:	ff 75 08             	pushl  0x8(%ebp)
   1066d:	e8 3e ff ff ff       	call   105b0 <lodepng_decode_file>
   10672:	83 c4 20             	add    $0x20,%esp
}
   10675:	c9                   	leave  
   10676:	c3                   	ret    

00010677 <lodepng_decoder_settings_init>:
#endif /*LODEPNG_COMPILE_DISK*/

void lodepng_decoder_settings_init(LodePNGDecoderSettings* settings) {
   10677:	55                   	push   %ebp
   10678:	89 e5                	mov    %esp,%ebp
  settings->color_convert = 1;
   1067a:	8b 45 08             	mov    0x8(%ebp),%eax
   1067d:	c7 40 24 01 00 00 00 	movl   $0x1,0x24(%eax)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  settings->read_text_chunks = 1;
   10684:	8b 45 08             	mov    0x8(%ebp),%eax
   10687:	c7 40 28 01 00 00 00 	movl   $0x1,0x28(%eax)
  settings->remember_unknown_chunks = 0;
   1068e:	8b 45 08             	mov    0x8(%ebp),%eax
   10691:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
  settings->max_text_size = 16777216;
   10698:	8b 45 08             	mov    0x8(%ebp),%eax
   1069b:	c7 40 30 00 00 00 01 	movl   $0x1000000,0x30(%eax)
  settings->max_icc_size = 16777216; /* 16MB is much more than enough for any reasonable ICC profile */
   106a2:	8b 45 08             	mov    0x8(%ebp),%eax
   106a5:	c7 40 34 00 00 00 01 	movl   $0x1000000,0x34(%eax)
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  settings->ignore_crc = 0;
   106ac:	8b 45 08             	mov    0x8(%ebp),%eax
   106af:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  settings->ignore_critical = 0;
   106b6:	8b 45 08             	mov    0x8(%ebp),%eax
   106b9:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
  settings->ignore_end = 0;
   106c0:	8b 45 08             	mov    0x8(%ebp),%eax
   106c3:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
  lodepng_decompress_settings_init(&settings->zlibsettings);
   106ca:	8b 45 08             	mov    0x8(%ebp),%eax
   106cd:	50                   	push   %eax
   106ce:	e8 ff 7a ff ff       	call   81d2 <lodepng_decompress_settings_init>
   106d3:	83 c4 04             	add    $0x4,%esp
}
   106d6:	90                   	nop
   106d7:	c9                   	leave  
   106d8:	c3                   	ret    

000106d9 <lodepng_state_init>:

#endif /*LODEPNG_COMPILE_DECODER*/

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_ENCODER)

void lodepng_state_init(LodePNGState* state) {
   106d9:	55                   	push   %ebp
   106da:	89 e5                	mov    %esp,%ebp
   106dc:	83 ec 08             	sub    $0x8,%esp
#ifdef LODEPNG_COMPILE_DECODER
  lodepng_decoder_settings_init(&state->decoder);
   106df:	8b 45 08             	mov    0x8(%ebp),%eax
   106e2:	50                   	push   %eax
   106e3:	e8 8f ff ff ff       	call   10677 <lodepng_decoder_settings_init>
   106e8:	83 c4 04             	add    $0x4,%esp
#endif /*LODEPNG_COMPILE_DECODER*/
#ifdef LODEPNG_COMPILE_ENCODER
  lodepng_encoder_settings_init(&state->encoder);
   106eb:	8b 45 08             	mov    0x8(%ebp),%eax
   106ee:	83 c0 38             	add    $0x38,%eax
   106f1:	83 ec 0c             	sub    $0xc,%esp
   106f4:	50                   	push   %eax
   106f5:	e8 fc 30 00 00       	call   137f6 <lodepng_encoder_settings_init>
   106fa:	83 c4 10             	add    $0x10,%esp
#endif /*LODEPNG_COMPILE_ENCODER*/
  lodepng_color_mode_init(&state->info_raw);
   106fd:	8b 45 08             	mov    0x8(%ebp),%eax
   10700:	83 c0 78             	add    $0x78,%eax
   10703:	83 ec 0c             	sub    $0xc,%esp
   10706:	50                   	push   %eax
   10707:	e8 06 84 ff ff       	call   8b12 <lodepng_color_mode_init>
   1070c:	83 c4 10             	add    $0x10,%esp
  lodepng_info_init(&state->info_png);
   1070f:	8b 45 08             	mov    0x8(%ebp),%eax
   10712:	05 98 00 00 00       	add    $0x98,%eax
   10717:	83 ec 0c             	sub    $0xc,%esp
   1071a:	50                   	push   %eax
   1071b:	e8 89 93 ff ff       	call   9aa9 <lodepng_info_init>
   10720:	83 c4 10             	add    $0x10,%esp
  state->error = 1;
   10723:	8b 45 08             	mov    0x8(%ebp),%eax
   10726:	c7 80 7c 01 00 00 01 	movl   $0x1,0x17c(%eax)
   1072d:	00 00 00 
}
   10730:	90                   	nop
   10731:	c9                   	leave  
   10732:	c3                   	ret    

00010733 <lodepng_state_cleanup>:

void lodepng_state_cleanup(LodePNGState* state) {
   10733:	55                   	push   %ebp
   10734:	89 e5                	mov    %esp,%ebp
   10736:	83 ec 08             	sub    $0x8,%esp
  lodepng_color_mode_cleanup(&state->info_raw);
   10739:	8b 45 08             	mov    0x8(%ebp),%eax
   1073c:	83 c0 78             	add    $0x78,%eax
   1073f:	83 ec 0c             	sub    $0xc,%esp
   10742:	50                   	push   %eax
   10743:	e8 bd 84 ff ff       	call   8c05 <lodepng_color_mode_cleanup>
   10748:	83 c4 10             	add    $0x10,%esp
  lodepng_info_cleanup(&state->info_png);
   1074b:	8b 45 08             	mov    0x8(%ebp),%eax
   1074e:	05 98 00 00 00       	add    $0x98,%eax
   10753:	83 ec 0c             	sub    $0xc,%esp
   10756:	50                   	push   %eax
   10757:	e8 2e 94 ff ff       	call   9b8a <lodepng_info_cleanup>
   1075c:	83 c4 10             	add    $0x10,%esp
}
   1075f:	90                   	nop
   10760:	c9                   	leave  
   10761:	c3                   	ret    

00010762 <lodepng_state_copy>:

void lodepng_state_copy(LodePNGState* dest, const LodePNGState* source) {
   10762:	55                   	push   %ebp
   10763:	89 e5                	mov    %esp,%ebp
   10765:	57                   	push   %edi
   10766:	56                   	push   %esi
   10767:	53                   	push   %ebx
   10768:	83 ec 0c             	sub    $0xc,%esp
  lodepng_state_cleanup(dest);
   1076b:	83 ec 0c             	sub    $0xc,%esp
   1076e:	ff 75 08             	pushl  0x8(%ebp)
   10771:	e8 bd ff ff ff       	call   10733 <lodepng_state_cleanup>
   10776:	83 c4 10             	add    $0x10,%esp
  *dest = *source;
   10779:	8b 55 08             	mov    0x8(%ebp),%edx
   1077c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1077f:	89 c3                	mov    %eax,%ebx
   10781:	b8 60 00 00 00       	mov    $0x60,%eax
   10786:	89 d7                	mov    %edx,%edi
   10788:	89 de                	mov    %ebx,%esi
   1078a:	89 c1                	mov    %eax,%ecx
   1078c:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  lodepng_color_mode_init(&dest->info_raw);
   1078e:	8b 45 08             	mov    0x8(%ebp),%eax
   10791:	83 c0 78             	add    $0x78,%eax
   10794:	83 ec 0c             	sub    $0xc,%esp
   10797:	50                   	push   %eax
   10798:	e8 75 83 ff ff       	call   8b12 <lodepng_color_mode_init>
   1079d:	83 c4 10             	add    $0x10,%esp
  lodepng_info_init(&dest->info_png);
   107a0:	8b 45 08             	mov    0x8(%ebp),%eax
   107a3:	05 98 00 00 00       	add    $0x98,%eax
   107a8:	83 ec 0c             	sub    $0xc,%esp
   107ab:	50                   	push   %eax
   107ac:	e8 f8 92 ff ff       	call   9aa9 <lodepng_info_init>
   107b1:	83 c4 10             	add    $0x10,%esp
  dest->error = lodepng_color_mode_copy(&dest->info_raw, &source->info_raw); if(dest->error) return;
   107b4:	8b 45 0c             	mov    0xc(%ebp),%eax
   107b7:	8d 50 78             	lea    0x78(%eax),%edx
   107ba:	8b 45 08             	mov    0x8(%ebp),%eax
   107bd:	83 c0 78             	add    $0x78,%eax
   107c0:	83 ec 08             	sub    $0x8,%esp
   107c3:	52                   	push   %edx
   107c4:	50                   	push   %eax
   107c5:	e8 52 84 ff ff       	call   8c1c <lodepng_color_mode_copy>
   107ca:	83 c4 10             	add    $0x10,%esp
   107cd:	89 c2                	mov    %eax,%edx
   107cf:	8b 45 08             	mov    0x8(%ebp),%eax
   107d2:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
   107d8:	8b 45 08             	mov    0x8(%ebp),%eax
   107db:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   107e1:	85 c0                	test   %eax,%eax
   107e3:	75 36                	jne    1081b <lodepng_state_copy+0xb9>
  dest->error = lodepng_info_copy(&dest->info_png, &source->info_png); if(dest->error) return;
   107e5:	8b 45 0c             	mov    0xc(%ebp),%eax
   107e8:	8d 90 98 00 00 00    	lea    0x98(%eax),%edx
   107ee:	8b 45 08             	mov    0x8(%ebp),%eax
   107f1:	05 98 00 00 00       	add    $0x98,%eax
   107f6:	83 ec 08             	sub    $0x8,%esp
   107f9:	52                   	push   %edx
   107fa:	50                   	push   %eax
   107fb:	e8 dd 93 ff ff       	call   9bdd <lodepng_info_copy>
   10800:	83 c4 10             	add    $0x10,%esp
   10803:	89 c2                	mov    %eax,%edx
   10805:	8b 45 08             	mov    0x8(%ebp),%eax
   10808:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
   1080e:	8b 45 08             	mov    0x8(%ebp),%eax
   10811:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10817:	85 c0                	test   %eax,%eax
   10819:	eb 01                	jmp    1081c <lodepng_state_copy+0xba>
void lodepng_state_copy(LodePNGState* dest, const LodePNGState* source) {
  lodepng_state_cleanup(dest);
  *dest = *source;
  lodepng_color_mode_init(&dest->info_raw);
  lodepng_info_init(&dest->info_png);
  dest->error = lodepng_color_mode_copy(&dest->info_raw, &source->info_raw); if(dest->error) return;
   1081b:	90                   	nop
  dest->error = lodepng_info_copy(&dest->info_png, &source->info_png); if(dest->error) return;
}
   1081c:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1081f:	5b                   	pop    %ebx
   10820:	5e                   	pop    %esi
   10821:	5f                   	pop    %edi
   10822:	5d                   	pop    %ebp
   10823:	c3                   	ret    

00010824 <writeSignature>:
/* ////////////////////////////////////////////////////////////////////////// */
/* / PNG Encoder                                                            / */
/* ////////////////////////////////////////////////////////////////////////// */


static unsigned writeSignature(ucvector* out) {
   10824:	55                   	push   %ebp
   10825:	89 e5                	mov    %esp,%ebp
   10827:	83 ec 10             	sub    $0x10,%esp
  size_t pos = out->size;
   1082a:	8b 45 08             	mov    0x8(%ebp),%eax
   1082d:	8b 40 04             	mov    0x4(%eax),%eax
   10830:	89 45 fc             	mov    %eax,-0x4(%ebp)
  const unsigned char signature[] = {137, 80, 78, 71, 13, 10, 26, 10};
   10833:	c6 45 f4 89          	movb   $0x89,-0xc(%ebp)
   10837:	c6 45 f5 50          	movb   $0x50,-0xb(%ebp)
   1083b:	c6 45 f6 4e          	movb   $0x4e,-0xa(%ebp)
   1083f:	c6 45 f7 47          	movb   $0x47,-0x9(%ebp)
   10843:	c6 45 f8 0d          	movb   $0xd,-0x8(%ebp)
   10847:	c6 45 f9 0a          	movb   $0xa,-0x7(%ebp)
   1084b:	c6 45 fa 1a          	movb   $0x1a,-0x6(%ebp)
   1084f:	c6 45 fb 0a          	movb   $0xa,-0x5(%ebp)
  /*8 bytes PNG signature, aka the magic bytes*/
  if(!ucvector_resize(out, out->size + 8)) return 83; /*alloc fail*/
   10853:	8b 45 08             	mov    0x8(%ebp),%eax
   10856:	8b 40 04             	mov    0x4(%eax),%eax
   10859:	83 c0 08             	add    $0x8,%eax
   1085c:	50                   	push   %eax
   1085d:	ff 75 08             	pushl  0x8(%ebp)
   10860:	e8 f8 2d ff ff       	call   365d <ucvector_resize>
   10865:	83 c4 08             	add    $0x8,%esp
   10868:	85 c0                	test   %eax,%eax
   1086a:	75 07                	jne    10873 <writeSignature+0x4f>
   1086c:	b8 53 00 00 00       	mov    $0x53,%eax
   10871:	eb 1e                	jmp    10891 <writeSignature+0x6d>
  lodepng_memcpy(out->data + pos, signature, 8);
   10873:	8b 45 08             	mov    0x8(%ebp),%eax
   10876:	8b 10                	mov    (%eax),%edx
   10878:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1087b:	01 c2                	add    %eax,%edx
   1087d:	6a 08                	push   $0x8
   1087f:	8d 45 f4             	lea    -0xc(%ebp),%eax
   10882:	50                   	push   %eax
   10883:	52                   	push   %edx
   10884:	e8 b8 2b ff ff       	call   3441 <lodepng_memcpy>
   10889:	83 c4 0c             	add    $0xc,%esp
  return 0;
   1088c:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10891:	c9                   	leave  
   10892:	c3                   	ret    

00010893 <addChunk_IHDR>:

static unsigned addChunk_IHDR(ucvector* out, unsigned w, unsigned h,
                              LodePNGColorType colortype, unsigned bitdepth, unsigned interlace_method) {
   10893:	55                   	push   %ebp
   10894:	89 e5                	mov    %esp,%ebp
   10896:	83 ec 10             	sub    $0x10,%esp
  unsigned char *chunk, *data;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 13, "IHDR"));
   10899:	68 2c a1 01 00       	push   $0x1a12c
   1089e:	6a 0d                	push   $0xd
   108a0:	ff 75 08             	pushl  0x8(%ebp)
   108a3:	8d 45 f4             	lea    -0xc(%ebp),%eax
   108a6:	50                   	push   %eax
   108a7:	e8 cf 7f ff ff       	call   887b <lodepng_chunk_init>
   108ac:	83 c4 10             	add    $0x10,%esp
   108af:	89 45 fc             	mov    %eax,-0x4(%ebp)
   108b2:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   108b6:	74 05                	je     108bd <addChunk_IHDR+0x2a>
   108b8:	8b 45 fc             	mov    -0x4(%ebp),%eax
   108bb:	eb 6d                	jmp    1092a <addChunk_IHDR+0x97>
  data = chunk + 8;
   108bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
   108c0:	83 c0 08             	add    $0x8,%eax
   108c3:	89 45 f8             	mov    %eax,-0x8(%ebp)

  lodepng_set32bitInt(data + 0, w); /*width*/
   108c6:	ff 75 0c             	pushl  0xc(%ebp)
   108c9:	ff 75 f8             	pushl  -0x8(%ebp)
   108cc:	e8 f3 2e ff ff       	call   37c4 <lodepng_set32bitInt>
   108d1:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(data + 4, h); /*height*/
   108d4:	8b 45 f8             	mov    -0x8(%ebp),%eax
   108d7:	83 c0 04             	add    $0x4,%eax
   108da:	ff 75 10             	pushl  0x10(%ebp)
   108dd:	50                   	push   %eax
   108de:	e8 e1 2e ff ff       	call   37c4 <lodepng_set32bitInt>
   108e3:	83 c4 08             	add    $0x8,%esp
  data[8] = (unsigned char)bitdepth; /*bit depth*/
   108e6:	8b 45 f8             	mov    -0x8(%ebp),%eax
   108e9:	83 c0 08             	add    $0x8,%eax
   108ec:	8b 55 18             	mov    0x18(%ebp),%edx
   108ef:	88 10                	mov    %dl,(%eax)
  data[9] = (unsigned char)colortype; /*color type*/
   108f1:	8b 45 f8             	mov    -0x8(%ebp),%eax
   108f4:	83 c0 09             	add    $0x9,%eax
   108f7:	8b 55 14             	mov    0x14(%ebp),%edx
   108fa:	88 10                	mov    %dl,(%eax)
  data[10] = 0; /*compression method*/
   108fc:	8b 45 f8             	mov    -0x8(%ebp),%eax
   108ff:	83 c0 0a             	add    $0xa,%eax
   10902:	c6 00 00             	movb   $0x0,(%eax)
  data[11] = 0; /*filter method*/
   10905:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10908:	83 c0 0b             	add    $0xb,%eax
   1090b:	c6 00 00             	movb   $0x0,(%eax)
  data[12] = interlace_method; /*interlace method*/
   1090e:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10911:	83 c0 0c             	add    $0xc,%eax
   10914:	8b 55 1c             	mov    0x1c(%ebp),%edx
   10917:	88 10                	mov    %dl,(%eax)

  lodepng_chunk_generate_crc(chunk);
   10919:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1091c:	50                   	push   %eax
   1091d:	e8 02 7c ff ff       	call   8524 <lodepng_chunk_generate_crc>
   10922:	83 c4 04             	add    $0x4,%esp
  return 0;
   10925:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1092a:	c9                   	leave  
   1092b:	c3                   	ret    

0001092c <addChunk_PLTE>:

/* only adds the chunk if needed (there is a key or palette with alpha) */
static unsigned addChunk_PLTE(ucvector* out, const LodePNGColorMode* info) {
   1092c:	55                   	push   %ebp
   1092d:	89 e5                	mov    %esp,%ebp
   1092f:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  size_t i, j = 8;
   10932:	c7 45 f8 08 00 00 00 	movl   $0x8,-0x8(%ebp)

  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, info->palettesize * 3, "PLTE"));
   10939:	8b 45 0c             	mov    0xc(%ebp),%eax
   1093c:	8b 50 0c             	mov    0xc(%eax),%edx
   1093f:	89 d0                	mov    %edx,%eax
   10941:	01 c0                	add    %eax,%eax
   10943:	01 d0                	add    %edx,%eax
   10945:	68 48 a1 01 00       	push   $0x1a148
   1094a:	50                   	push   %eax
   1094b:	ff 75 08             	pushl  0x8(%ebp)
   1094e:	8d 45 f0             	lea    -0x10(%ebp),%eax
   10951:	50                   	push   %eax
   10952:	e8 24 7f ff ff       	call   887b <lodepng_chunk_init>
   10957:	83 c4 10             	add    $0x10,%esp
   1095a:	89 45 f4             	mov    %eax,-0xc(%ebp)
   1095d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10961:	74 08                	je     1096b <addChunk_PLTE+0x3f>
   10963:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10966:	e9 95 00 00 00       	jmp    10a00 <addChunk_PLTE+0xd4>

  for(i = 0; i != info->palettesize; ++i) {
   1096b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   10972:	eb 70                	jmp    109e4 <addChunk_PLTE+0xb8>
    /*add all channels except alpha channel*/
    chunk[j++] = info->palette[i * 4 + 0];
   10974:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   10977:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1097a:	8d 50 01             	lea    0x1(%eax),%edx
   1097d:	89 55 f8             	mov    %edx,-0x8(%ebp)
   10980:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   10983:	8b 45 0c             	mov    0xc(%ebp),%eax
   10986:	8b 40 08             	mov    0x8(%eax),%eax
   10989:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   1098c:	c1 e1 02             	shl    $0x2,%ecx
   1098f:	01 c8                	add    %ecx,%eax
   10991:	0f b6 00             	movzbl (%eax),%eax
   10994:	88 02                	mov    %al,(%edx)
    chunk[j++] = info->palette[i * 4 + 1];
   10996:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   10999:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1099c:	8d 50 01             	lea    0x1(%eax),%edx
   1099f:	89 55 f8             	mov    %edx,-0x8(%ebp)
   109a2:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   109a5:	8b 45 0c             	mov    0xc(%ebp),%eax
   109a8:	8b 40 08             	mov    0x8(%eax),%eax
   109ab:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   109ae:	c1 e1 02             	shl    $0x2,%ecx
   109b1:	83 c1 01             	add    $0x1,%ecx
   109b4:	01 c8                	add    %ecx,%eax
   109b6:	0f b6 00             	movzbl (%eax),%eax
   109b9:	88 02                	mov    %al,(%edx)
    chunk[j++] = info->palette[i * 4 + 2];
   109bb:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   109be:	8b 45 f8             	mov    -0x8(%ebp),%eax
   109c1:	8d 50 01             	lea    0x1(%eax),%edx
   109c4:	89 55 f8             	mov    %edx,-0x8(%ebp)
   109c7:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   109ca:	8b 45 0c             	mov    0xc(%ebp),%eax
   109cd:	8b 40 08             	mov    0x8(%eax),%eax
   109d0:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   109d3:	c1 e1 02             	shl    $0x2,%ecx
   109d6:	83 c1 02             	add    $0x2,%ecx
   109d9:	01 c8                	add    %ecx,%eax
   109db:	0f b6 00             	movzbl (%eax),%eax
   109de:	88 02                	mov    %al,(%edx)
  unsigned char* chunk;
  size_t i, j = 8;

  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, info->palettesize * 3, "PLTE"));

  for(i = 0; i != info->palettesize; ++i) {
   109e0:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   109e4:	8b 45 0c             	mov    0xc(%ebp),%eax
   109e7:	8b 40 0c             	mov    0xc(%eax),%eax
   109ea:	3b 45 fc             	cmp    -0x4(%ebp),%eax
   109ed:	75 85                	jne    10974 <addChunk_PLTE+0x48>
    chunk[j++] = info->palette[i * 4 + 0];
    chunk[j++] = info->palette[i * 4 + 1];
    chunk[j++] = info->palette[i * 4 + 2];
  }

  lodepng_chunk_generate_crc(chunk);
   109ef:	8b 45 f0             	mov    -0x10(%ebp),%eax
   109f2:	50                   	push   %eax
   109f3:	e8 2c 7b ff ff       	call   8524 <lodepng_chunk_generate_crc>
   109f8:	83 c4 04             	add    $0x4,%esp
  return 0;
   109fb:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10a00:	c9                   	leave  
   10a01:	c3                   	ret    

00010a02 <addChunk_tRNS>:

static unsigned addChunk_tRNS(ucvector* out, const LodePNGColorMode* info) {
   10a02:	55                   	push   %ebp
   10a03:	89 e5                	mov    %esp,%ebp
   10a05:	83 ec 20             	sub    $0x20,%esp
  unsigned char* chunk = 0;
   10a08:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

  if(info->colortype == LCT_PALETTE) {
   10a0f:	8b 45 0c             	mov    0xc(%ebp),%eax
   10a12:	8b 00                	mov    (%eax),%eax
   10a14:	83 f8 03             	cmp    $0x3,%eax
   10a17:	0f 85 ae 00 00 00    	jne    10acb <addChunk_tRNS+0xc9>
    size_t i, amount = info->palettesize;
   10a1d:	8b 45 0c             	mov    0xc(%ebp),%eax
   10a20:	8b 40 0c             	mov    0xc(%eax),%eax
   10a23:	89 45 f8             	mov    %eax,-0x8(%ebp)
    /*the tail of palette values that all have 255 as alpha, does not have to be encoded*/
    for(i = info->palettesize; i != 0; --i) {
   10a26:	8b 45 0c             	mov    0xc(%ebp),%eax
   10a29:	8b 40 0c             	mov    0xc(%eax),%eax
   10a2c:	89 45 fc             	mov    %eax,-0x4(%ebp)
   10a2f:	eb 23                	jmp    10a54 <addChunk_tRNS+0x52>
      if(info->palette[4 * (i - 1) + 3] != 255) break;
   10a31:	8b 45 0c             	mov    0xc(%ebp),%eax
   10a34:	8b 40 08             	mov    0x8(%eax),%eax
   10a37:	8b 55 fc             	mov    -0x4(%ebp),%edx
   10a3a:	83 ea 01             	sub    $0x1,%edx
   10a3d:	c1 e2 02             	shl    $0x2,%edx
   10a40:	83 c2 03             	add    $0x3,%edx
   10a43:	01 d0                	add    %edx,%eax
   10a45:	0f b6 00             	movzbl (%eax),%eax
   10a48:	3c ff                	cmp    $0xff,%al
   10a4a:	75 10                	jne    10a5c <addChunk_tRNS+0x5a>
      --amount;
   10a4c:	83 6d f8 01          	subl   $0x1,-0x8(%ebp)
  unsigned char* chunk = 0;

  if(info->colortype == LCT_PALETTE) {
    size_t i, amount = info->palettesize;
    /*the tail of palette values that all have 255 as alpha, does not have to be encoded*/
    for(i = info->palettesize; i != 0; --i) {
   10a50:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
   10a54:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   10a58:	75 d7                	jne    10a31 <addChunk_tRNS+0x2f>
   10a5a:	eb 01                	jmp    10a5d <addChunk_tRNS+0x5b>
      if(info->palette[4 * (i - 1) + 3] != 255) break;
   10a5c:	90                   	nop
      --amount;
    }
    if(amount) {
   10a5d:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
   10a61:	0f 84 63 01 00 00    	je     10bca <addChunk_tRNS+0x1c8>
      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, amount, "tRNS"));
   10a67:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10a6a:	68 4d a1 01 00       	push   $0x1a14d
   10a6f:	50                   	push   %eax
   10a70:	ff 75 08             	pushl  0x8(%ebp)
   10a73:	8d 45 e8             	lea    -0x18(%ebp),%eax
   10a76:	50                   	push   %eax
   10a77:	e8 ff 7d ff ff       	call   887b <lodepng_chunk_init>
   10a7c:	83 c4 10             	add    $0x10,%esp
   10a7f:	89 45 f4             	mov    %eax,-0xc(%ebp)
   10a82:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10a86:	74 08                	je     10a90 <addChunk_tRNS+0x8e>
   10a88:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10a8b:	e9 52 01 00 00       	jmp    10be2 <addChunk_tRNS+0x1e0>
      /*add the alpha channel values from the palette*/
      for(i = 0; i != amount; ++i) chunk[8 + i] = info->palette[4 * i + 3];
   10a90:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   10a97:	eb 25                	jmp    10abe <addChunk_tRNS+0xbc>
   10a99:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10a9c:	8b 55 fc             	mov    -0x4(%ebp),%edx
   10a9f:	83 c2 08             	add    $0x8,%edx
   10aa2:	01 c2                	add    %eax,%edx
   10aa4:	8b 45 0c             	mov    0xc(%ebp),%eax
   10aa7:	8b 40 08             	mov    0x8(%eax),%eax
   10aaa:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   10aad:	c1 e1 02             	shl    $0x2,%ecx
   10ab0:	83 c1 03             	add    $0x3,%ecx
   10ab3:	01 c8                	add    %ecx,%eax
   10ab5:	0f b6 00             	movzbl (%eax),%eax
   10ab8:	88 02                	mov    %al,(%edx)
   10aba:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   10abe:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10ac1:	3b 45 f8             	cmp    -0x8(%ebp),%eax
   10ac4:	75 d3                	jne    10a99 <addChunk_tRNS+0x97>
   10ac6:	e9 ff 00 00 00       	jmp    10bca <addChunk_tRNS+0x1c8>
    }
  } else if(info->colortype == LCT_GREY) {
   10acb:	8b 45 0c             	mov    0xc(%ebp),%eax
   10ace:	8b 00                	mov    (%eax),%eax
   10ad0:	85 c0                	test   %eax,%eax
   10ad2:	75 59                	jne    10b2d <addChunk_tRNS+0x12b>
    if(info->key_defined) {
   10ad4:	8b 45 0c             	mov    0xc(%ebp),%eax
   10ad7:	8b 40 10             	mov    0x10(%eax),%eax
   10ada:	85 c0                	test   %eax,%eax
   10adc:	0f 84 e8 00 00 00    	je     10bca <addChunk_tRNS+0x1c8>
      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 2, "tRNS"));
   10ae2:	68 4d a1 01 00       	push   $0x1a14d
   10ae7:	6a 02                	push   $0x2
   10ae9:	ff 75 08             	pushl  0x8(%ebp)
   10aec:	8d 45 e8             	lea    -0x18(%ebp),%eax
   10aef:	50                   	push   %eax
   10af0:	e8 86 7d ff ff       	call   887b <lodepng_chunk_init>
   10af5:	83 c4 10             	add    $0x10,%esp
   10af8:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10afb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   10aff:	74 08                	je     10b09 <addChunk_tRNS+0x107>
   10b01:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10b04:	e9 d9 00 00 00       	jmp    10be2 <addChunk_tRNS+0x1e0>
      chunk[8] = (unsigned char)(info->key_r >> 8);
   10b09:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10b0c:	8d 50 08             	lea    0x8(%eax),%edx
   10b0f:	8b 45 0c             	mov    0xc(%ebp),%eax
   10b12:	8b 40 14             	mov    0x14(%eax),%eax
   10b15:	c1 e8 08             	shr    $0x8,%eax
   10b18:	88 02                	mov    %al,(%edx)
      chunk[9] = (unsigned char)(info->key_r & 255);
   10b1a:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10b1d:	8d 50 09             	lea    0x9(%eax),%edx
   10b20:	8b 45 0c             	mov    0xc(%ebp),%eax
   10b23:	8b 40 14             	mov    0x14(%eax),%eax
   10b26:	88 02                	mov    %al,(%edx)
   10b28:	e9 9d 00 00 00       	jmp    10bca <addChunk_tRNS+0x1c8>
    }
  } else if(info->colortype == LCT_RGB) {
   10b2d:	8b 45 0c             	mov    0xc(%ebp),%eax
   10b30:	8b 00                	mov    (%eax),%eax
   10b32:	83 f8 02             	cmp    $0x2,%eax
   10b35:	0f 85 8f 00 00 00    	jne    10bca <addChunk_tRNS+0x1c8>
    if(info->key_defined) {
   10b3b:	8b 45 0c             	mov    0xc(%ebp),%eax
   10b3e:	8b 40 10             	mov    0x10(%eax),%eax
   10b41:	85 c0                	test   %eax,%eax
   10b43:	0f 84 81 00 00 00    	je     10bca <addChunk_tRNS+0x1c8>
      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 6, "tRNS"));
   10b49:	68 4d a1 01 00       	push   $0x1a14d
   10b4e:	6a 06                	push   $0x6
   10b50:	ff 75 08             	pushl  0x8(%ebp)
   10b53:	8d 45 e8             	lea    -0x18(%ebp),%eax
   10b56:	50                   	push   %eax
   10b57:	e8 1f 7d ff ff       	call   887b <lodepng_chunk_init>
   10b5c:	83 c4 10             	add    $0x10,%esp
   10b5f:	89 45 ec             	mov    %eax,-0x14(%ebp)
   10b62:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   10b66:	74 05                	je     10b6d <addChunk_tRNS+0x16b>
   10b68:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10b6b:	eb 75                	jmp    10be2 <addChunk_tRNS+0x1e0>
      chunk[8] = (unsigned char)(info->key_r >> 8);
   10b6d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10b70:	8d 50 08             	lea    0x8(%eax),%edx
   10b73:	8b 45 0c             	mov    0xc(%ebp),%eax
   10b76:	8b 40 14             	mov    0x14(%eax),%eax
   10b79:	c1 e8 08             	shr    $0x8,%eax
   10b7c:	88 02                	mov    %al,(%edx)
      chunk[9] = (unsigned char)(info->key_r & 255);
   10b7e:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10b81:	8d 50 09             	lea    0x9(%eax),%edx
   10b84:	8b 45 0c             	mov    0xc(%ebp),%eax
   10b87:	8b 40 14             	mov    0x14(%eax),%eax
   10b8a:	88 02                	mov    %al,(%edx)
      chunk[10] = (unsigned char)(info->key_g >> 8);
   10b8c:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10b8f:	8d 50 0a             	lea    0xa(%eax),%edx
   10b92:	8b 45 0c             	mov    0xc(%ebp),%eax
   10b95:	8b 40 18             	mov    0x18(%eax),%eax
   10b98:	c1 e8 08             	shr    $0x8,%eax
   10b9b:	88 02                	mov    %al,(%edx)
      chunk[11] = (unsigned char)(info->key_g & 255);
   10b9d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10ba0:	8d 50 0b             	lea    0xb(%eax),%edx
   10ba3:	8b 45 0c             	mov    0xc(%ebp),%eax
   10ba6:	8b 40 18             	mov    0x18(%eax),%eax
   10ba9:	88 02                	mov    %al,(%edx)
      chunk[12] = (unsigned char)(info->key_b >> 8);
   10bab:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10bae:	8d 50 0c             	lea    0xc(%eax),%edx
   10bb1:	8b 45 0c             	mov    0xc(%ebp),%eax
   10bb4:	8b 40 1c             	mov    0x1c(%eax),%eax
   10bb7:	c1 e8 08             	shr    $0x8,%eax
   10bba:	88 02                	mov    %al,(%edx)
      chunk[13] = (unsigned char)(info->key_b & 255);
   10bbc:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10bbf:	8d 50 0d             	lea    0xd(%eax),%edx
   10bc2:	8b 45 0c             	mov    0xc(%ebp),%eax
   10bc5:	8b 40 1c             	mov    0x1c(%eax),%eax
   10bc8:	88 02                	mov    %al,(%edx)
    }
  }

  if(chunk) lodepng_chunk_generate_crc(chunk);
   10bca:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10bcd:	85 c0                	test   %eax,%eax
   10bcf:	74 0c                	je     10bdd <addChunk_tRNS+0x1db>
   10bd1:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10bd4:	50                   	push   %eax
   10bd5:	e8 4a 79 ff ff       	call   8524 <lodepng_chunk_generate_crc>
   10bda:	83 c4 04             	add    $0x4,%esp
  return 0;
   10bdd:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10be2:	c9                   	leave  
   10be3:	c3                   	ret    

00010be4 <addChunk_IDAT>:

static unsigned addChunk_IDAT(ucvector* out, const unsigned char* data, size_t datasize,
                              LodePNGCompressSettings* zlibsettings) {
   10be4:	55                   	push   %ebp
   10be5:	89 e5                	mov    %esp,%ebp
   10be7:	83 ec 18             	sub    $0x18,%esp
  unsigned error = 0;
   10bea:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* zlib = 0;
   10bf1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  size_t zlibsize = 0;
   10bf8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  error = zlib_compress(&zlib, &zlibsize, data, datasize, zlibsettings);
   10bff:	83 ec 0c             	sub    $0xc,%esp
   10c02:	ff 75 14             	pushl  0x14(%ebp)
   10c05:	ff 75 10             	pushl  0x10(%ebp)
   10c08:	ff 75 0c             	pushl  0xc(%ebp)
   10c0b:	8d 45 ec             	lea    -0x14(%ebp),%eax
   10c0e:	50                   	push   %eax
   10c0f:	8d 45 f0             	lea    -0x10(%ebp),%eax
   10c12:	50                   	push   %eax
   10c13:	e8 fb 74 ff ff       	call   8113 <zlib_compress>
   10c18:	83 c4 20             	add    $0x20,%esp
   10c1b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) {
   10c1e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10c22:	75 1b                	jne    10c3f <addChunk_IDAT+0x5b>
    error = lodepng_chunk_createv(out, zlibsize, "IDAT", zlib);
   10c24:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10c27:	8b 55 ec             	mov    -0x14(%ebp),%edx
   10c2a:	50                   	push   %eax
   10c2b:	68 84 a1 01 00       	push   $0x1a184
   10c30:	52                   	push   %edx
   10c31:	ff 75 08             	pushl  0x8(%ebp)
   10c34:	e8 ea 7c ff ff       	call   8923 <lodepng_chunk_createv>
   10c39:	83 c4 10             	add    $0x10,%esp
   10c3c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  lodepng_free(zlib);
   10c3f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10c42:	83 ec 0c             	sub    $0xc,%esp
   10c45:	50                   	push   %eax
   10c46:	e8 d9 27 ff ff       	call   3424 <lodepng_free>
   10c4b:	83 c4 10             	add    $0x10,%esp
  return error;
   10c4e:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10c51:	c9                   	leave  
   10c52:	c3                   	ret    

00010c53 <addChunk_IEND>:

static unsigned addChunk_IEND(ucvector* out) {
   10c53:	55                   	push   %ebp
   10c54:	89 e5                	mov    %esp,%ebp
  return lodepng_chunk_createv(out, 0, "IEND", 0);
   10c56:	6a 00                	push   $0x0
   10c58:	68 89 a1 01 00       	push   $0x1a189
   10c5d:	6a 00                	push   $0x0
   10c5f:	ff 75 08             	pushl  0x8(%ebp)
   10c62:	e8 bc 7c ff ff       	call   8923 <lodepng_chunk_createv>
   10c67:	83 c4 10             	add    $0x10,%esp
}
   10c6a:	c9                   	leave  
   10c6b:	c3                   	ret    

00010c6c <addChunk_tEXt>:

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

static unsigned addChunk_tEXt(ucvector* out, const char* keyword, const char* textstring) {
   10c6c:	55                   	push   %ebp
   10c6d:	89 e5                	mov    %esp,%ebp
   10c6f:	83 ec 20             	sub    $0x20,%esp
  unsigned char* chunk = 0;
   10c72:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  size_t keysize = lodepng_strlen(keyword), textsize = lodepng_strlen(textstring);
   10c79:	ff 75 0c             	pushl  0xc(%ebp)
   10c7c:	e8 1e 28 ff ff       	call   349f <lodepng_strlen>
   10c81:	83 c4 04             	add    $0x4,%esp
   10c84:	89 45 fc             	mov    %eax,-0x4(%ebp)
   10c87:	ff 75 10             	pushl  0x10(%ebp)
   10c8a:	e8 10 28 ff ff       	call   349f <lodepng_strlen>
   10c8f:	83 c4 04             	add    $0x4,%esp
   10c92:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t size = keysize + 1 + textsize;
   10c95:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10c98:	8d 50 01             	lea    0x1(%eax),%edx
   10c9b:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10c9e:	01 d0                	add    %edx,%eax
   10ca0:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   10ca3:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   10ca7:	7e 06                	jle    10caf <addChunk_tEXt+0x43>
   10ca9:	83 7d fc 4f          	cmpl   $0x4f,-0x4(%ebp)
   10cad:	7e 07                	jle    10cb6 <addChunk_tEXt+0x4a>
   10caf:	b8 59 00 00 00       	mov    $0x59,%eax
   10cb4:	eb 74                	jmp    10d2a <addChunk_tEXt+0xbe>
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, size, "tEXt"));
   10cb6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10cb9:	68 57 a1 01 00       	push   $0x1a157
   10cbe:	50                   	push   %eax
   10cbf:	ff 75 08             	pushl  0x8(%ebp)
   10cc2:	8d 45 ec             	lea    -0x14(%ebp),%eax
   10cc5:	50                   	push   %eax
   10cc6:	e8 b0 7b ff ff       	call   887b <lodepng_chunk_init>
   10ccb:	83 c4 10             	add    $0x10,%esp
   10cce:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10cd1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   10cd5:	74 05                	je     10cdc <addChunk_tEXt+0x70>
   10cd7:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10cda:	eb 4e                	jmp    10d2a <addChunk_tEXt+0xbe>
  lodepng_memcpy(chunk + 8, keyword, keysize);
   10cdc:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10cdf:	83 c0 08             	add    $0x8,%eax
   10ce2:	ff 75 fc             	pushl  -0x4(%ebp)
   10ce5:	ff 75 0c             	pushl  0xc(%ebp)
   10ce8:	50                   	push   %eax
   10ce9:	e8 53 27 ff ff       	call   3441 <lodepng_memcpy>
   10cee:	83 c4 0c             	add    $0xc,%esp
  chunk[8 + keysize] = 0; /*null termination char*/
   10cf1:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10cf4:	8b 55 fc             	mov    -0x4(%ebp),%edx
   10cf7:	83 c2 08             	add    $0x8,%edx
   10cfa:	01 d0                	add    %edx,%eax
   10cfc:	c6 00 00             	movb   $0x0,(%eax)
  lodepng_memcpy(chunk + 9 + keysize, textstring, textsize);
   10cff:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10d02:	8b 55 fc             	mov    -0x4(%ebp),%edx
   10d05:	83 c2 09             	add    $0x9,%edx
   10d08:	01 d0                	add    %edx,%eax
   10d0a:	ff 75 f8             	pushl  -0x8(%ebp)
   10d0d:	ff 75 10             	pushl  0x10(%ebp)
   10d10:	50                   	push   %eax
   10d11:	e8 2b 27 ff ff       	call   3441 <lodepng_memcpy>
   10d16:	83 c4 0c             	add    $0xc,%esp
  lodepng_chunk_generate_crc(chunk);
   10d19:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10d1c:	50                   	push   %eax
   10d1d:	e8 02 78 ff ff       	call   8524 <lodepng_chunk_generate_crc>
   10d22:	83 c4 04             	add    $0x4,%esp
  return 0;
   10d25:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10d2a:	c9                   	leave  
   10d2b:	c3                   	ret    

00010d2c <addChunk_zTXt>:

static unsigned addChunk_zTXt(ucvector* out, const char* keyword, const char* textstring,
                              LodePNGCompressSettings* zlibsettings) {
   10d2c:	55                   	push   %ebp
   10d2d:	89 e5                	mov    %esp,%ebp
   10d2f:	53                   	push   %ebx
   10d30:	83 ec 24             	sub    $0x24,%esp
  unsigned error = 0;
   10d33:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* chunk = 0;
   10d3a:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  unsigned char* compressed = 0;
   10d41:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  size_t compressedsize = 0;
   10d48:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  size_t textsize = lodepng_strlen(textstring);
   10d4f:	ff 75 10             	pushl  0x10(%ebp)
   10d52:	e8 48 27 ff ff       	call   349f <lodepng_strlen>
   10d57:	83 c4 04             	add    $0x4,%esp
   10d5a:	89 45 f0             	mov    %eax,-0x10(%ebp)
  size_t keysize = lodepng_strlen(keyword);
   10d5d:	ff 75 0c             	pushl  0xc(%ebp)
   10d60:	e8 3a 27 ff ff       	call   349f <lodepng_strlen>
   10d65:	83 c4 04             	add    $0x4,%esp
   10d68:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   10d6b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   10d6f:	7e 06                	jle    10d77 <addChunk_zTXt+0x4b>
   10d71:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
   10d75:	7e 0a                	jle    10d81 <addChunk_zTXt+0x55>
   10d77:	b8 59 00 00 00       	mov    $0x59,%eax
   10d7c:	e9 c8 00 00 00       	jmp    10e49 <addChunk_zTXt+0x11d>

  error = zlib_compress(&compressed, &compressedsize,
   10d81:	83 ec 0c             	sub    $0xc,%esp
   10d84:	ff 75 14             	pushl  0x14(%ebp)
   10d87:	ff 75 f0             	pushl  -0x10(%ebp)
   10d8a:	ff 75 10             	pushl  0x10(%ebp)
   10d8d:	8d 45 dc             	lea    -0x24(%ebp),%eax
   10d90:	50                   	push   %eax
   10d91:	8d 45 e0             	lea    -0x20(%ebp),%eax
   10d94:	50                   	push   %eax
   10d95:	e8 79 73 ff ff       	call   8113 <zlib_compress>
   10d9a:	83 c4 20             	add    $0x20,%esp
   10d9d:	89 45 f4             	mov    %eax,-0xc(%ebp)
                        (const unsigned char*)textstring, textsize, zlibsettings);
  if(!error) {
   10da0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10da4:	75 29                	jne    10dcf <addChunk_zTXt+0xa3>
    size_t size = keysize + 2 + compressedsize;
   10da6:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10da9:	8d 50 02             	lea    0x2(%eax),%edx
   10dac:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10daf:	01 d0                	add    %edx,%eax
   10db1:	89 45 e8             	mov    %eax,-0x18(%ebp)
    error = lodepng_chunk_init(&chunk, out, size, "zTXt");
   10db4:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10db7:	68 5c a1 01 00       	push   $0x1a15c
   10dbc:	50                   	push   %eax
   10dbd:	ff 75 08             	pushl  0x8(%ebp)
   10dc0:	8d 45 e4             	lea    -0x1c(%ebp),%eax
   10dc3:	50                   	push   %eax
   10dc4:	e8 b2 7a ff ff       	call   887b <lodepng_chunk_init>
   10dc9:	83 c4 10             	add    $0x10,%esp
   10dcc:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  if(!error) {
   10dcf:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10dd3:	75 62                	jne    10e37 <addChunk_zTXt+0x10b>
    lodepng_memcpy(chunk + 8, keyword, keysize);
   10dd5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10dd8:	83 c0 08             	add    $0x8,%eax
   10ddb:	83 ec 04             	sub    $0x4,%esp
   10dde:	ff 75 ec             	pushl  -0x14(%ebp)
   10de1:	ff 75 0c             	pushl  0xc(%ebp)
   10de4:	50                   	push   %eax
   10de5:	e8 57 26 ff ff       	call   3441 <lodepng_memcpy>
   10dea:	83 c4 10             	add    $0x10,%esp
    chunk[8 + keysize] = 0; /*null termination char*/
   10ded:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10df0:	8b 55 ec             	mov    -0x14(%ebp),%edx
   10df3:	83 c2 08             	add    $0x8,%edx
   10df6:	01 d0                	add    %edx,%eax
   10df8:	c6 00 00             	movb   $0x0,(%eax)
    chunk[9 + keysize] = 0; /*compression method: 0*/
   10dfb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10dfe:	8b 55 ec             	mov    -0x14(%ebp),%edx
   10e01:	83 c2 09             	add    $0x9,%edx
   10e04:	01 d0                	add    %edx,%eax
   10e06:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + 10 + keysize, compressed, compressedsize);
   10e09:	8b 55 dc             	mov    -0x24(%ebp),%edx
   10e0c:	8b 45 e0             	mov    -0x20(%ebp),%eax
   10e0f:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
   10e12:	8b 5d ec             	mov    -0x14(%ebp),%ebx
   10e15:	83 c3 0a             	add    $0xa,%ebx
   10e18:	01 d9                	add    %ebx,%ecx
   10e1a:	83 ec 04             	sub    $0x4,%esp
   10e1d:	52                   	push   %edx
   10e1e:	50                   	push   %eax
   10e1f:	51                   	push   %ecx
   10e20:	e8 1c 26 ff ff       	call   3441 <lodepng_memcpy>
   10e25:	83 c4 10             	add    $0x10,%esp
    lodepng_chunk_generate_crc(chunk);
   10e28:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10e2b:	83 ec 0c             	sub    $0xc,%esp
   10e2e:	50                   	push   %eax
   10e2f:	e8 f0 76 ff ff       	call   8524 <lodepng_chunk_generate_crc>
   10e34:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(compressed);
   10e37:	8b 45 e0             	mov    -0x20(%ebp),%eax
   10e3a:	83 ec 0c             	sub    $0xc,%esp
   10e3d:	50                   	push   %eax
   10e3e:	e8 e1 25 ff ff       	call   3424 <lodepng_free>
   10e43:	83 c4 10             	add    $0x10,%esp
  return error;
   10e46:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10e49:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   10e4c:	c9                   	leave  
   10e4d:	c3                   	ret    

00010e4e <addChunk_iTXt>:

static unsigned addChunk_iTXt(ucvector* out, unsigned compress, const char* keyword, const char* langtag,
                              const char* transkey, const char* textstring, LodePNGCompressSettings* zlibsettings) {
   10e4e:	55                   	push   %ebp
   10e4f:	89 e5                	mov    %esp,%ebp
   10e51:	53                   	push   %ebx
   10e52:	83 ec 34             	sub    $0x34,%esp
  unsigned error = 0;
   10e55:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* chunk = 0;
   10e5c:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  unsigned char* compressed = 0;
   10e63:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  size_t compressedsize = 0;
   10e6a:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  size_t textsize = lodepng_strlen(textstring);
   10e71:	ff 75 1c             	pushl  0x1c(%ebp)
   10e74:	e8 26 26 ff ff       	call   349f <lodepng_strlen>
   10e79:	83 c4 04             	add    $0x4,%esp
   10e7c:	89 45 f0             	mov    %eax,-0x10(%ebp)
  size_t keysize = lodepng_strlen(keyword), langsize = lodepng_strlen(langtag), transsize = lodepng_strlen(transkey);
   10e7f:	ff 75 10             	pushl  0x10(%ebp)
   10e82:	e8 18 26 ff ff       	call   349f <lodepng_strlen>
   10e87:	83 c4 04             	add    $0x4,%esp
   10e8a:	89 45 ec             	mov    %eax,-0x14(%ebp)
   10e8d:	ff 75 14             	pushl  0x14(%ebp)
   10e90:	e8 0a 26 ff ff       	call   349f <lodepng_strlen>
   10e95:	83 c4 04             	add    $0x4,%esp
   10e98:	89 45 e8             	mov    %eax,-0x18(%ebp)
   10e9b:	ff 75 18             	pushl  0x18(%ebp)
   10e9e:	e8 fc 25 ff ff       	call   349f <lodepng_strlen>
   10ea3:	83 c4 04             	add    $0x4,%esp
   10ea6:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   10ea9:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   10ead:	7e 06                	jle    10eb5 <addChunk_iTXt+0x67>
   10eaf:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
   10eb3:	7e 0a                	jle    10ebf <addChunk_iTXt+0x71>
   10eb5:	b8 59 00 00 00       	mov    $0x59,%eax
   10eba:	e9 9a 01 00 00       	jmp    11059 <addChunk_iTXt+0x20b>

  if(compress) {
   10ebf:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   10ec3:	74 1f                	je     10ee4 <addChunk_iTXt+0x96>
    error = zlib_compress(&compressed, &compressedsize,
   10ec5:	83 ec 0c             	sub    $0xc,%esp
   10ec8:	ff 75 20             	pushl  0x20(%ebp)
   10ecb:	ff 75 f0             	pushl  -0x10(%ebp)
   10ece:	ff 75 1c             	pushl  0x1c(%ebp)
   10ed1:	8d 45 d0             	lea    -0x30(%ebp),%eax
   10ed4:	50                   	push   %eax
   10ed5:	8d 45 d4             	lea    -0x2c(%ebp),%eax
   10ed8:	50                   	push   %eax
   10ed9:	e8 35 72 ff ff       	call   8113 <zlib_compress>
   10ede:	83 c4 20             	add    $0x20,%esp
   10ee1:	89 45 f4             	mov    %eax,-0xc(%ebp)
                          (const unsigned char*)textstring, textsize, zlibsettings);
  }
  if(!error) {
   10ee4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10ee8:	75 44                	jne    10f2e <addChunk_iTXt+0xe0>
    size_t size = keysize + 3 + langsize + 1 + transsize + 1 + (compress ? compressedsize : textsize);
   10eea:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10eed:	8d 50 03             	lea    0x3(%eax),%edx
   10ef0:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10ef3:	01 d0                	add    %edx,%eax
   10ef5:	8d 50 01             	lea    0x1(%eax),%edx
   10ef8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10efb:	01 d0                	add    %edx,%eax
   10efd:	8d 50 01             	lea    0x1(%eax),%edx
   10f00:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   10f04:	74 05                	je     10f0b <addChunk_iTXt+0xbd>
   10f06:	8b 45 d0             	mov    -0x30(%ebp),%eax
   10f09:	eb 03                	jmp    10f0e <addChunk_iTXt+0xc0>
   10f0b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10f0e:	01 d0                	add    %edx,%eax
   10f10:	89 45 e0             	mov    %eax,-0x20(%ebp)
    error = lodepng_chunk_init(&chunk, out, size, "iTXt");
   10f13:	8b 45 e0             	mov    -0x20(%ebp),%eax
   10f16:	68 61 a1 01 00       	push   $0x1a161
   10f1b:	50                   	push   %eax
   10f1c:	ff 75 08             	pushl  0x8(%ebp)
   10f1f:	8d 45 d8             	lea    -0x28(%ebp),%eax
   10f22:	50                   	push   %eax
   10f23:	e8 53 79 ff ff       	call   887b <lodepng_chunk_init>
   10f28:	83 c4 10             	add    $0x10,%esp
   10f2b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  if(!error) {
   10f2e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10f32:	0f 85 0f 01 00 00    	jne    11047 <addChunk_iTXt+0x1f9>
    size_t pos = 8;
   10f38:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)
    lodepng_memcpy(chunk + pos, keyword, keysize);
   10f3f:	8b 55 d8             	mov    -0x28(%ebp),%edx
   10f42:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10f45:	01 d0                	add    %edx,%eax
   10f47:	83 ec 04             	sub    $0x4,%esp
   10f4a:	ff 75 ec             	pushl  -0x14(%ebp)
   10f4d:	ff 75 10             	pushl  0x10(%ebp)
   10f50:	50                   	push   %eax
   10f51:	e8 eb 24 ff ff       	call   3441 <lodepng_memcpy>
   10f56:	83 c4 10             	add    $0x10,%esp
    pos += keysize;
   10f59:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10f5c:	01 45 dc             	add    %eax,-0x24(%ebp)
    chunk[pos++] = 0; /*null termination char*/
   10f5f:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   10f62:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10f65:	8d 50 01             	lea    0x1(%eax),%edx
   10f68:	89 55 dc             	mov    %edx,-0x24(%ebp)
   10f6b:	01 c8                	add    %ecx,%eax
   10f6d:	c6 00 00             	movb   $0x0,(%eax)
    chunk[pos++] = (compress ? 1 : 0); /*compression flag*/
   10f70:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   10f73:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10f76:	8d 50 01             	lea    0x1(%eax),%edx
   10f79:	89 55 dc             	mov    %edx,-0x24(%ebp)
   10f7c:	01 c8                	add    %ecx,%eax
   10f7e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   10f82:	0f 95 c2             	setne  %dl
   10f85:	88 10                	mov    %dl,(%eax)
    chunk[pos++] = 0; /*compression method: 0*/
   10f87:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   10f8a:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10f8d:	8d 50 01             	lea    0x1(%eax),%edx
   10f90:	89 55 dc             	mov    %edx,-0x24(%ebp)
   10f93:	01 c8                	add    %ecx,%eax
   10f95:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + pos, langtag, langsize);
   10f98:	8b 55 d8             	mov    -0x28(%ebp),%edx
   10f9b:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10f9e:	01 d0                	add    %edx,%eax
   10fa0:	83 ec 04             	sub    $0x4,%esp
   10fa3:	ff 75 e8             	pushl  -0x18(%ebp)
   10fa6:	ff 75 14             	pushl  0x14(%ebp)
   10fa9:	50                   	push   %eax
   10faa:	e8 92 24 ff ff       	call   3441 <lodepng_memcpy>
   10faf:	83 c4 10             	add    $0x10,%esp
    pos += langsize;
   10fb2:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10fb5:	01 45 dc             	add    %eax,-0x24(%ebp)
    chunk[pos++] = 0; /*null termination char*/
   10fb8:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   10fbb:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10fbe:	8d 50 01             	lea    0x1(%eax),%edx
   10fc1:	89 55 dc             	mov    %edx,-0x24(%ebp)
   10fc4:	01 c8                	add    %ecx,%eax
   10fc6:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + pos, transkey, transsize);
   10fc9:	8b 55 d8             	mov    -0x28(%ebp),%edx
   10fcc:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10fcf:	01 d0                	add    %edx,%eax
   10fd1:	83 ec 04             	sub    $0x4,%esp
   10fd4:	ff 75 e4             	pushl  -0x1c(%ebp)
   10fd7:	ff 75 18             	pushl  0x18(%ebp)
   10fda:	50                   	push   %eax
   10fdb:	e8 61 24 ff ff       	call   3441 <lodepng_memcpy>
   10fe0:	83 c4 10             	add    $0x10,%esp
    pos += transsize;
   10fe3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10fe6:	01 45 dc             	add    %eax,-0x24(%ebp)
    chunk[pos++] = 0; /*null termination char*/
   10fe9:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   10fec:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10fef:	8d 50 01             	lea    0x1(%eax),%edx
   10ff2:	89 55 dc             	mov    %edx,-0x24(%ebp)
   10ff5:	01 c8                	add    %ecx,%eax
   10ff7:	c6 00 00             	movb   $0x0,(%eax)
    if(compress) {
   10ffa:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   10ffe:	74 1e                	je     1101e <addChunk_iTXt+0x1d0>
      lodepng_memcpy(chunk + pos, compressed, compressedsize);
   11000:	8b 55 d0             	mov    -0x30(%ebp),%edx
   11003:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   11006:	8b 5d d8             	mov    -0x28(%ebp),%ebx
   11009:	8b 4d dc             	mov    -0x24(%ebp),%ecx
   1100c:	01 d9                	add    %ebx,%ecx
   1100e:	83 ec 04             	sub    $0x4,%esp
   11011:	52                   	push   %edx
   11012:	50                   	push   %eax
   11013:	51                   	push   %ecx
   11014:	e8 28 24 ff ff       	call   3441 <lodepng_memcpy>
   11019:	83 c4 10             	add    $0x10,%esp
   1101c:	eb 1a                	jmp    11038 <addChunk_iTXt+0x1ea>
    } else {
      lodepng_memcpy(chunk + pos, textstring, textsize);
   1101e:	8b 55 d8             	mov    -0x28(%ebp),%edx
   11021:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11024:	01 d0                	add    %edx,%eax
   11026:	83 ec 04             	sub    $0x4,%esp
   11029:	ff 75 f0             	pushl  -0x10(%ebp)
   1102c:	ff 75 1c             	pushl  0x1c(%ebp)
   1102f:	50                   	push   %eax
   11030:	e8 0c 24 ff ff       	call   3441 <lodepng_memcpy>
   11035:	83 c4 10             	add    $0x10,%esp
    }
    lodepng_chunk_generate_crc(chunk);
   11038:	8b 45 d8             	mov    -0x28(%ebp),%eax
   1103b:	83 ec 0c             	sub    $0xc,%esp
   1103e:	50                   	push   %eax
   1103f:	e8 e0 74 ff ff       	call   8524 <lodepng_chunk_generate_crc>
   11044:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(compressed);
   11047:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   1104a:	83 ec 0c             	sub    $0xc,%esp
   1104d:	50                   	push   %eax
   1104e:	e8 d1 23 ff ff       	call   3424 <lodepng_free>
   11053:	83 c4 10             	add    $0x10,%esp
  return error;
   11056:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   11059:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1105c:	c9                   	leave  
   1105d:	c3                   	ret    

0001105e <addChunk_bKGD>:

static unsigned addChunk_bKGD(ucvector* out, const LodePNGInfo* info) {
   1105e:	55                   	push   %ebp
   1105f:	89 e5                	mov    %esp,%ebp
   11061:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk = 0;
   11064:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  if(info->color.colortype == LCT_GREY || info->color.colortype == LCT_GREY_ALPHA) {
   1106b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1106e:	8b 40 0c             	mov    0xc(%eax),%eax
   11071:	85 c0                	test   %eax,%eax
   11073:	74 0b                	je     11080 <addChunk_bKGD+0x22>
   11075:	8b 45 0c             	mov    0xc(%ebp),%eax
   11078:	8b 40 0c             	mov    0xc(%eax),%eax
   1107b:	83 f8 04             	cmp    $0x4,%eax
   1107e:	75 4b                	jne    110cb <addChunk_bKGD+0x6d>
    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 2, "bKGD"));
   11080:	68 52 a1 01 00       	push   $0x1a152
   11085:	6a 02                	push   $0x2
   11087:	ff 75 08             	pushl  0x8(%ebp)
   1108a:	8d 45 f0             	lea    -0x10(%ebp),%eax
   1108d:	50                   	push   %eax
   1108e:	e8 e8 77 ff ff       	call   887b <lodepng_chunk_init>
   11093:	83 c4 10             	add    $0x10,%esp
   11096:	89 45 f4             	mov    %eax,-0xc(%ebp)
   11099:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1109d:	74 08                	je     110a7 <addChunk_bKGD+0x49>
   1109f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   110a2:	e9 19 01 00 00       	jmp    111c0 <addChunk_bKGD+0x162>
    chunk[8] = (unsigned char)(info->background_r >> 8);
   110a7:	8b 45 f0             	mov    -0x10(%ebp),%eax
   110aa:	8d 50 08             	lea    0x8(%eax),%edx
   110ad:	8b 45 0c             	mov    0xc(%ebp),%eax
   110b0:	8b 40 30             	mov    0x30(%eax),%eax
   110b3:	c1 e8 08             	shr    $0x8,%eax
   110b6:	88 02                	mov    %al,(%edx)
    chunk[9] = (unsigned char)(info->background_r & 255);
   110b8:	8b 45 f0             	mov    -0x10(%ebp),%eax
   110bb:	8d 50 09             	lea    0x9(%eax),%edx
   110be:	8b 45 0c             	mov    0xc(%ebp),%eax
   110c1:	8b 40 30             	mov    0x30(%eax),%eax
   110c4:	88 02                	mov    %al,(%edx)
   110c6:	e9 dd 00 00 00       	jmp    111a8 <addChunk_bKGD+0x14a>
  } else if(info->color.colortype == LCT_RGB || info->color.colortype == LCT_RGBA) {
   110cb:	8b 45 0c             	mov    0xc(%ebp),%eax
   110ce:	8b 40 0c             	mov    0xc(%eax),%eax
   110d1:	83 f8 02             	cmp    $0x2,%eax
   110d4:	74 0f                	je     110e5 <addChunk_bKGD+0x87>
   110d6:	8b 45 0c             	mov    0xc(%ebp),%eax
   110d9:	8b 40 0c             	mov    0xc(%eax),%eax
   110dc:	83 f8 06             	cmp    $0x6,%eax
   110df:	0f 85 86 00 00 00    	jne    1116b <addChunk_bKGD+0x10d>
    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 6, "bKGD"));
   110e5:	68 52 a1 01 00       	push   $0x1a152
   110ea:	6a 06                	push   $0x6
   110ec:	ff 75 08             	pushl  0x8(%ebp)
   110ef:	8d 45 f0             	lea    -0x10(%ebp),%eax
   110f2:	50                   	push   %eax
   110f3:	e8 83 77 ff ff       	call   887b <lodepng_chunk_init>
   110f8:	83 c4 10             	add    $0x10,%esp
   110fb:	89 45 f8             	mov    %eax,-0x8(%ebp)
   110fe:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
   11102:	74 08                	je     1110c <addChunk_bKGD+0xae>
   11104:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11107:	e9 b4 00 00 00       	jmp    111c0 <addChunk_bKGD+0x162>
    chunk[8] = (unsigned char)(info->background_r >> 8);
   1110c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1110f:	8d 50 08             	lea    0x8(%eax),%edx
   11112:	8b 45 0c             	mov    0xc(%ebp),%eax
   11115:	8b 40 30             	mov    0x30(%eax),%eax
   11118:	c1 e8 08             	shr    $0x8,%eax
   1111b:	88 02                	mov    %al,(%edx)
    chunk[9] = (unsigned char)(info->background_r & 255);
   1111d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11120:	8d 50 09             	lea    0x9(%eax),%edx
   11123:	8b 45 0c             	mov    0xc(%ebp),%eax
   11126:	8b 40 30             	mov    0x30(%eax),%eax
   11129:	88 02                	mov    %al,(%edx)
    chunk[10] = (unsigned char)(info->background_g >> 8);
   1112b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1112e:	8d 50 0a             	lea    0xa(%eax),%edx
   11131:	8b 45 0c             	mov    0xc(%ebp),%eax
   11134:	8b 40 34             	mov    0x34(%eax),%eax
   11137:	c1 e8 08             	shr    $0x8,%eax
   1113a:	88 02                	mov    %al,(%edx)
    chunk[11] = (unsigned char)(info->background_g & 255);
   1113c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1113f:	8d 50 0b             	lea    0xb(%eax),%edx
   11142:	8b 45 0c             	mov    0xc(%ebp),%eax
   11145:	8b 40 34             	mov    0x34(%eax),%eax
   11148:	88 02                	mov    %al,(%edx)
    chunk[12] = (unsigned char)(info->background_b >> 8);
   1114a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1114d:	8d 50 0c             	lea    0xc(%eax),%edx
   11150:	8b 45 0c             	mov    0xc(%ebp),%eax
   11153:	8b 40 38             	mov    0x38(%eax),%eax
   11156:	c1 e8 08             	shr    $0x8,%eax
   11159:	88 02                	mov    %al,(%edx)
    chunk[13] = (unsigned char)(info->background_b & 255);
   1115b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1115e:	8d 50 0d             	lea    0xd(%eax),%edx
   11161:	8b 45 0c             	mov    0xc(%ebp),%eax
   11164:	8b 40 38             	mov    0x38(%eax),%eax
   11167:	88 02                	mov    %al,(%edx)
   11169:	eb 3d                	jmp    111a8 <addChunk_bKGD+0x14a>
  } else if(info->color.colortype == LCT_PALETTE) {
   1116b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1116e:	8b 40 0c             	mov    0xc(%eax),%eax
   11171:	83 f8 03             	cmp    $0x3,%eax
   11174:	75 32                	jne    111a8 <addChunk_bKGD+0x14a>
    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 1, "bKGD"));
   11176:	68 52 a1 01 00       	push   $0x1a152
   1117b:	6a 01                	push   $0x1
   1117d:	ff 75 08             	pushl  0x8(%ebp)
   11180:	8d 45 f0             	lea    -0x10(%ebp),%eax
   11183:	50                   	push   %eax
   11184:	e8 f2 76 ff ff       	call   887b <lodepng_chunk_init>
   11189:	83 c4 10             	add    $0x10,%esp
   1118c:	89 45 fc             	mov    %eax,-0x4(%ebp)
   1118f:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   11193:	74 05                	je     1119a <addChunk_bKGD+0x13c>
   11195:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11198:	eb 26                	jmp    111c0 <addChunk_bKGD+0x162>
    chunk[8] = (unsigned char)(info->background_r & 255); /*palette index*/
   1119a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1119d:	8d 50 08             	lea    0x8(%eax),%edx
   111a0:	8b 45 0c             	mov    0xc(%ebp),%eax
   111a3:	8b 40 30             	mov    0x30(%eax),%eax
   111a6:	88 02                	mov    %al,(%edx)
  }
  if(chunk) lodepng_chunk_generate_crc(chunk);
   111a8:	8b 45 f0             	mov    -0x10(%ebp),%eax
   111ab:	85 c0                	test   %eax,%eax
   111ad:	74 0c                	je     111bb <addChunk_bKGD+0x15d>
   111af:	8b 45 f0             	mov    -0x10(%ebp),%eax
   111b2:	50                   	push   %eax
   111b3:	e8 6c 73 ff ff       	call   8524 <lodepng_chunk_generate_crc>
   111b8:	83 c4 04             	add    $0x4,%esp
  return 0;
   111bb:	b8 00 00 00 00       	mov    $0x0,%eax
}
   111c0:	c9                   	leave  
   111c1:	c3                   	ret    

000111c2 <addChunk_tIME>:

static unsigned addChunk_tIME(ucvector* out, const LodePNGTime* time) {
   111c2:	55                   	push   %ebp
   111c3:	89 e5                	mov    %esp,%ebp
   111c5:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 7, "tIME"));
   111c8:	68 66 a1 01 00       	push   $0x1a166
   111cd:	6a 07                	push   $0x7
   111cf:	ff 75 08             	pushl  0x8(%ebp)
   111d2:	8d 45 f8             	lea    -0x8(%ebp),%eax
   111d5:	50                   	push   %eax
   111d6:	e8 a0 76 ff ff       	call   887b <lodepng_chunk_init>
   111db:	83 c4 10             	add    $0x10,%esp
   111de:	89 45 fc             	mov    %eax,-0x4(%ebp)
   111e1:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   111e5:	74 05                	je     111ec <addChunk_tIME+0x2a>
   111e7:	8b 45 fc             	mov    -0x4(%ebp),%eax
   111ea:	eb 74                	jmp    11260 <addChunk_tIME+0x9e>
  chunk[8] = (unsigned char)(time->year >> 8);
   111ec:	8b 45 f8             	mov    -0x8(%ebp),%eax
   111ef:	8d 50 08             	lea    0x8(%eax),%edx
   111f2:	8b 45 0c             	mov    0xc(%ebp),%eax
   111f5:	8b 00                	mov    (%eax),%eax
   111f7:	c1 e8 08             	shr    $0x8,%eax
   111fa:	88 02                	mov    %al,(%edx)
  chunk[9] = (unsigned char)(time->year & 255);
   111fc:	8b 45 f8             	mov    -0x8(%ebp),%eax
   111ff:	8d 50 09             	lea    0x9(%eax),%edx
   11202:	8b 45 0c             	mov    0xc(%ebp),%eax
   11205:	8b 00                	mov    (%eax),%eax
   11207:	88 02                	mov    %al,(%edx)
  chunk[10] = (unsigned char)time->month;
   11209:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1120c:	8d 50 0a             	lea    0xa(%eax),%edx
   1120f:	8b 45 0c             	mov    0xc(%ebp),%eax
   11212:	8b 40 04             	mov    0x4(%eax),%eax
   11215:	88 02                	mov    %al,(%edx)
  chunk[11] = (unsigned char)time->day;
   11217:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1121a:	8d 50 0b             	lea    0xb(%eax),%edx
   1121d:	8b 45 0c             	mov    0xc(%ebp),%eax
   11220:	8b 40 08             	mov    0x8(%eax),%eax
   11223:	88 02                	mov    %al,(%edx)
  chunk[12] = (unsigned char)time->hour;
   11225:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11228:	8d 50 0c             	lea    0xc(%eax),%edx
   1122b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1122e:	8b 40 0c             	mov    0xc(%eax),%eax
   11231:	88 02                	mov    %al,(%edx)
  chunk[13] = (unsigned char)time->minute;
   11233:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11236:	8d 50 0d             	lea    0xd(%eax),%edx
   11239:	8b 45 0c             	mov    0xc(%ebp),%eax
   1123c:	8b 40 10             	mov    0x10(%eax),%eax
   1123f:	88 02                	mov    %al,(%edx)
  chunk[14] = (unsigned char)time->second;
   11241:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11244:	8d 50 0e             	lea    0xe(%eax),%edx
   11247:	8b 45 0c             	mov    0xc(%ebp),%eax
   1124a:	8b 40 14             	mov    0x14(%eax),%eax
   1124d:	88 02                	mov    %al,(%edx)
  lodepng_chunk_generate_crc(chunk);
   1124f:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11252:	50                   	push   %eax
   11253:	e8 cc 72 ff ff       	call   8524 <lodepng_chunk_generate_crc>
   11258:	83 c4 04             	add    $0x4,%esp
  return 0;
   1125b:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11260:	c9                   	leave  
   11261:	c3                   	ret    

00011262 <addChunk_pHYs>:

static unsigned addChunk_pHYs(ucvector* out, const LodePNGInfo* info) {
   11262:	55                   	push   %ebp
   11263:	89 e5                	mov    %esp,%ebp
   11265:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 9, "pHYs"));
   11268:	68 6b a1 01 00       	push   $0x1a16b
   1126d:	6a 09                	push   $0x9
   1126f:	ff 75 08             	pushl  0x8(%ebp)
   11272:	8d 45 f8             	lea    -0x8(%ebp),%eax
   11275:	50                   	push   %eax
   11276:	e8 00 76 ff ff       	call   887b <lodepng_chunk_init>
   1127b:	83 c4 10             	add    $0x10,%esp
   1127e:	89 45 fc             	mov    %eax,-0x4(%ebp)
   11281:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   11285:	74 05                	je     1128c <addChunk_pHYs+0x2a>
   11287:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1128a:	eb 51                	jmp    112dd <addChunk_pHYs+0x7b>
  lodepng_set32bitInt(chunk + 8, info->phys_x);
   1128c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1128f:	8b 40 7c             	mov    0x7c(%eax),%eax
   11292:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11295:	83 c2 08             	add    $0x8,%edx
   11298:	50                   	push   %eax
   11299:	52                   	push   %edx
   1129a:	e8 25 25 ff ff       	call   37c4 <lodepng_set32bitInt>
   1129f:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 12, info->phys_y);
   112a2:	8b 45 0c             	mov    0xc(%ebp),%eax
   112a5:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
   112ab:	8b 55 f8             	mov    -0x8(%ebp),%edx
   112ae:	83 c2 0c             	add    $0xc,%edx
   112b1:	50                   	push   %eax
   112b2:	52                   	push   %edx
   112b3:	e8 0c 25 ff ff       	call   37c4 <lodepng_set32bitInt>
   112b8:	83 c4 08             	add    $0x8,%esp
  chunk[16] = info->phys_unit;
   112bb:	8b 45 f8             	mov    -0x8(%ebp),%eax
   112be:	8d 50 10             	lea    0x10(%eax),%edx
   112c1:	8b 45 0c             	mov    0xc(%ebp),%eax
   112c4:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
   112ca:	88 02                	mov    %al,(%edx)
  lodepng_chunk_generate_crc(chunk);
   112cc:	8b 45 f8             	mov    -0x8(%ebp),%eax
   112cf:	50                   	push   %eax
   112d0:	e8 4f 72 ff ff       	call   8524 <lodepng_chunk_generate_crc>
   112d5:	83 c4 04             	add    $0x4,%esp
  return 0;
   112d8:	b8 00 00 00 00       	mov    $0x0,%eax
}
   112dd:	c9                   	leave  
   112de:	c3                   	ret    

000112df <addChunk_gAMA>:

static unsigned addChunk_gAMA(ucvector* out, const LodePNGInfo* info) {
   112df:	55                   	push   %ebp
   112e0:	89 e5                	mov    %esp,%ebp
   112e2:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 4, "gAMA"));
   112e5:	68 70 a1 01 00       	push   $0x1a170
   112ea:	6a 04                	push   $0x4
   112ec:	ff 75 08             	pushl  0x8(%ebp)
   112ef:	8d 45 f8             	lea    -0x8(%ebp),%eax
   112f2:	50                   	push   %eax
   112f3:	e8 83 75 ff ff       	call   887b <lodepng_chunk_init>
   112f8:	83 c4 10             	add    $0x10,%esp
   112fb:	89 45 fc             	mov    %eax,-0x4(%ebp)
   112fe:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   11302:	74 05                	je     11309 <addChunk_gAMA+0x2a>
   11304:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11307:	eb 2a                	jmp    11333 <addChunk_gAMA+0x54>
  lodepng_set32bitInt(chunk + 8, info->gama_gamma);
   11309:	8b 45 0c             	mov    0xc(%ebp),%eax
   1130c:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
   11312:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11315:	83 c2 08             	add    $0x8,%edx
   11318:	50                   	push   %eax
   11319:	52                   	push   %edx
   1131a:	e8 a5 24 ff ff       	call   37c4 <lodepng_set32bitInt>
   1131f:	83 c4 08             	add    $0x8,%esp
  lodepng_chunk_generate_crc(chunk);
   11322:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11325:	50                   	push   %eax
   11326:	e8 f9 71 ff ff       	call   8524 <lodepng_chunk_generate_crc>
   1132b:	83 c4 04             	add    $0x4,%esp
  return 0;
   1132e:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11333:	c9                   	leave  
   11334:	c3                   	ret    

00011335 <addChunk_cHRM>:

static unsigned addChunk_cHRM(ucvector* out, const LodePNGInfo* info) {
   11335:	55                   	push   %ebp
   11336:	89 e5                	mov    %esp,%ebp
   11338:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 32, "cHRM"));
   1133b:	68 75 a1 01 00       	push   $0x1a175
   11340:	6a 20                	push   $0x20
   11342:	ff 75 08             	pushl  0x8(%ebp)
   11345:	8d 45 f8             	lea    -0x8(%ebp),%eax
   11348:	50                   	push   %eax
   11349:	e8 2d 75 ff ff       	call   887b <lodepng_chunk_init>
   1134e:	83 c4 10             	add    $0x10,%esp
   11351:	89 45 fc             	mov    %eax,-0x4(%ebp)
   11354:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   11358:	74 08                	je     11362 <addChunk_cHRM+0x2d>
   1135a:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1135d:	e9 d9 00 00 00       	jmp    1143b <addChunk_cHRM+0x106>
  lodepng_set32bitInt(chunk + 8, info->chrm_white_x);
   11362:	8b 45 0c             	mov    0xc(%ebp),%eax
   11365:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
   1136b:	8b 55 f8             	mov    -0x8(%ebp),%edx
   1136e:	83 c2 08             	add    $0x8,%edx
   11371:	50                   	push   %eax
   11372:	52                   	push   %edx
   11373:	e8 4c 24 ff ff       	call   37c4 <lodepng_set32bitInt>
   11378:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 12, info->chrm_white_y);
   1137b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1137e:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
   11384:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11387:	83 c2 0c             	add    $0xc,%edx
   1138a:	50                   	push   %eax
   1138b:	52                   	push   %edx
   1138c:	e8 33 24 ff ff       	call   37c4 <lodepng_set32bitInt>
   11391:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 16, info->chrm_red_x);
   11394:	8b 45 0c             	mov    0xc(%ebp),%eax
   11397:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
   1139d:	8b 55 f8             	mov    -0x8(%ebp),%edx
   113a0:	83 c2 10             	add    $0x10,%edx
   113a3:	50                   	push   %eax
   113a4:	52                   	push   %edx
   113a5:	e8 1a 24 ff ff       	call   37c4 <lodepng_set32bitInt>
   113aa:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 20, info->chrm_red_y);
   113ad:	8b 45 0c             	mov    0xc(%ebp),%eax
   113b0:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   113b6:	8b 55 f8             	mov    -0x8(%ebp),%edx
   113b9:	83 c2 14             	add    $0x14,%edx
   113bc:	50                   	push   %eax
   113bd:	52                   	push   %edx
   113be:	e8 01 24 ff ff       	call   37c4 <lodepng_set32bitInt>
   113c3:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 24, info->chrm_green_x);
   113c6:	8b 45 0c             	mov    0xc(%ebp),%eax
   113c9:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
   113cf:	8b 55 f8             	mov    -0x8(%ebp),%edx
   113d2:	83 c2 18             	add    $0x18,%edx
   113d5:	50                   	push   %eax
   113d6:	52                   	push   %edx
   113d7:	e8 e8 23 ff ff       	call   37c4 <lodepng_set32bitInt>
   113dc:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 28, info->chrm_green_y);
   113df:	8b 45 0c             	mov    0xc(%ebp),%eax
   113e2:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
   113e8:	8b 55 f8             	mov    -0x8(%ebp),%edx
   113eb:	83 c2 1c             	add    $0x1c,%edx
   113ee:	50                   	push   %eax
   113ef:	52                   	push   %edx
   113f0:	e8 cf 23 ff ff       	call   37c4 <lodepng_set32bitInt>
   113f5:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 32, info->chrm_blue_x);
   113f8:	8b 45 0c             	mov    0xc(%ebp),%eax
   113fb:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   11401:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11404:	83 c2 20             	add    $0x20,%edx
   11407:	50                   	push   %eax
   11408:	52                   	push   %edx
   11409:	e8 b6 23 ff ff       	call   37c4 <lodepng_set32bitInt>
   1140e:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 36, info->chrm_blue_y);
   11411:	8b 45 0c             	mov    0xc(%ebp),%eax
   11414:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
   1141a:	8b 55 f8             	mov    -0x8(%ebp),%edx
   1141d:	83 c2 24             	add    $0x24,%edx
   11420:	50                   	push   %eax
   11421:	52                   	push   %edx
   11422:	e8 9d 23 ff ff       	call   37c4 <lodepng_set32bitInt>
   11427:	83 c4 08             	add    $0x8,%esp
  lodepng_chunk_generate_crc(chunk);
   1142a:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1142d:	50                   	push   %eax
   1142e:	e8 f1 70 ff ff       	call   8524 <lodepng_chunk_generate_crc>
   11433:	83 c4 04             	add    $0x4,%esp
  return 0;
   11436:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1143b:	c9                   	leave  
   1143c:	c3                   	ret    

0001143d <addChunk_sRGB>:

static unsigned addChunk_sRGB(ucvector* out, const LodePNGInfo* info) {
   1143d:	55                   	push   %ebp
   1143e:	89 e5                	mov    %esp,%ebp
   11440:	83 ec 10             	sub    $0x10,%esp
  unsigned char data = info->srgb_intent;
   11443:	8b 45 0c             	mov    0xc(%ebp),%eax
   11446:	8b 80 b8 00 00 00    	mov    0xb8(%eax),%eax
   1144c:	88 45 ff             	mov    %al,-0x1(%ebp)
  return lodepng_chunk_createv(out, 1, "sRGB", &data);
   1144f:	8d 45 ff             	lea    -0x1(%ebp),%eax
   11452:	50                   	push   %eax
   11453:	68 7a a1 01 00       	push   $0x1a17a
   11458:	6a 01                	push   $0x1
   1145a:	ff 75 08             	pushl  0x8(%ebp)
   1145d:	e8 c1 74 ff ff       	call   8923 <lodepng_chunk_createv>
   11462:	83 c4 10             	add    $0x10,%esp
}
   11465:	c9                   	leave  
   11466:	c3                   	ret    

00011467 <addChunk_iCCP>:

static unsigned addChunk_iCCP(ucvector* out, const LodePNGInfo* info, LodePNGCompressSettings* zlibsettings) {
   11467:	55                   	push   %ebp
   11468:	89 e5                	mov    %esp,%ebp
   1146a:	53                   	push   %ebx
   1146b:	83 ec 24             	sub    $0x24,%esp
  unsigned error = 0;
   1146e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* chunk = 0;
   11475:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  unsigned char* compressed = 0;
   1147c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  size_t compressedsize = 0;
   11483:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  size_t keysize = lodepng_strlen(info->iccp_name);
   1148a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1148d:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   11493:	50                   	push   %eax
   11494:	e8 06 20 ff ff       	call   349f <lodepng_strlen>
   11499:	83 c4 04             	add    $0x4,%esp
   1149c:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   1149f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   114a3:	7e 06                	jle    114ab <addChunk_iCCP+0x44>
   114a5:	83 7d f0 4f          	cmpl   $0x4f,-0x10(%ebp)
   114a9:	7e 0a                	jle    114b5 <addChunk_iCCP+0x4e>
   114ab:	b8 59 00 00 00       	mov    $0x59,%eax
   114b0:	e9 df 00 00 00       	jmp    11594 <addChunk_iCCP+0x12d>
  error = zlib_compress(&compressed, &compressedsize,
                        info->iccp_profile, info->iccp_profile_size, zlibsettings);
   114b5:	8b 45 0c             	mov    0xc(%ebp),%eax
   114b8:	8b 80 c8 00 00 00    	mov    0xc8(%eax),%eax
  unsigned char* compressed = 0;
  size_t compressedsize = 0;
  size_t keysize = lodepng_strlen(info->iccp_name);

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
  error = zlib_compress(&compressed, &compressedsize,
   114be:	89 c2                	mov    %eax,%edx
                        info->iccp_profile, info->iccp_profile_size, zlibsettings);
   114c0:	8b 45 0c             	mov    0xc(%ebp),%eax
   114c3:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
  unsigned char* compressed = 0;
  size_t compressedsize = 0;
  size_t keysize = lodepng_strlen(info->iccp_name);

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
  error = zlib_compress(&compressed, &compressedsize,
   114c9:	83 ec 0c             	sub    $0xc,%esp
   114cc:	ff 75 10             	pushl  0x10(%ebp)
   114cf:	52                   	push   %edx
   114d0:	50                   	push   %eax
   114d1:	8d 45 e0             	lea    -0x20(%ebp),%eax
   114d4:	50                   	push   %eax
   114d5:	8d 45 e4             	lea    -0x1c(%ebp),%eax
   114d8:	50                   	push   %eax
   114d9:	e8 35 6c ff ff       	call   8113 <zlib_compress>
   114de:	83 c4 20             	add    $0x20,%esp
   114e1:	89 45 f4             	mov    %eax,-0xc(%ebp)
                        info->iccp_profile, info->iccp_profile_size, zlibsettings);
  if(!error) {
   114e4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   114e8:	75 29                	jne    11513 <addChunk_iCCP+0xac>
    size_t size = keysize + 2 + compressedsize;
   114ea:	8b 45 f0             	mov    -0x10(%ebp),%eax
   114ed:	8d 50 02             	lea    0x2(%eax),%edx
   114f0:	8b 45 e0             	mov    -0x20(%ebp),%eax
   114f3:	01 d0                	add    %edx,%eax
   114f5:	89 45 ec             	mov    %eax,-0x14(%ebp)
    error = lodepng_chunk_init(&chunk, out, size, "iCCP");
   114f8:	8b 45 ec             	mov    -0x14(%ebp),%eax
   114fb:	68 7f a1 01 00       	push   $0x1a17f
   11500:	50                   	push   %eax
   11501:	ff 75 08             	pushl  0x8(%ebp)
   11504:	8d 45 e8             	lea    -0x18(%ebp),%eax
   11507:	50                   	push   %eax
   11508:	e8 6e 73 ff ff       	call   887b <lodepng_chunk_init>
   1150d:	83 c4 10             	add    $0x10,%esp
   11510:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  if(!error) {
   11513:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   11517:	75 69                	jne    11582 <addChunk_iCCP+0x11b>
    lodepng_memcpy(chunk + 8, info->iccp_name, keysize);
   11519:	8b 45 0c             	mov    0xc(%ebp),%eax
   1151c:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   11522:	8b 55 e8             	mov    -0x18(%ebp),%edx
   11525:	83 c2 08             	add    $0x8,%edx
   11528:	83 ec 04             	sub    $0x4,%esp
   1152b:	ff 75 f0             	pushl  -0x10(%ebp)
   1152e:	50                   	push   %eax
   1152f:	52                   	push   %edx
   11530:	e8 0c 1f ff ff       	call   3441 <lodepng_memcpy>
   11535:	83 c4 10             	add    $0x10,%esp
    chunk[8 + keysize] = 0; /*null termination char*/
   11538:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1153b:	8b 55 f0             	mov    -0x10(%ebp),%edx
   1153e:	83 c2 08             	add    $0x8,%edx
   11541:	01 d0                	add    %edx,%eax
   11543:	c6 00 00             	movb   $0x0,(%eax)
    chunk[9 + keysize] = 0; /*compression method: 0*/
   11546:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11549:	8b 55 f0             	mov    -0x10(%ebp),%edx
   1154c:	83 c2 09             	add    $0x9,%edx
   1154f:	01 d0                	add    %edx,%eax
   11551:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + 10 + keysize, compressed, compressedsize);
   11554:	8b 55 e0             	mov    -0x20(%ebp),%edx
   11557:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1155a:	8b 4d e8             	mov    -0x18(%ebp),%ecx
   1155d:	8b 5d f0             	mov    -0x10(%ebp),%ebx
   11560:	83 c3 0a             	add    $0xa,%ebx
   11563:	01 d9                	add    %ebx,%ecx
   11565:	83 ec 04             	sub    $0x4,%esp
   11568:	52                   	push   %edx
   11569:	50                   	push   %eax
   1156a:	51                   	push   %ecx
   1156b:	e8 d1 1e ff ff       	call   3441 <lodepng_memcpy>
   11570:	83 c4 10             	add    $0x10,%esp
    lodepng_chunk_generate_crc(chunk);
   11573:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11576:	83 ec 0c             	sub    $0xc,%esp
   11579:	50                   	push   %eax
   1157a:	e8 a5 6f ff ff       	call   8524 <lodepng_chunk_generate_crc>
   1157f:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(compressed);
   11582:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11585:	83 ec 0c             	sub    $0xc,%esp
   11588:	50                   	push   %eax
   11589:	e8 96 1e ff ff       	call   3424 <lodepng_free>
   1158e:	83 c4 10             	add    $0x10,%esp
  return error;
   11591:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   11594:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   11597:	c9                   	leave  
   11598:	c3                   	ret    

00011599 <filterScanline>:

#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

static void filterScanline(unsigned char* out, const unsigned char* scanline, const unsigned char* prevline,
                           size_t length, size_t bytewidth, unsigned char filterType) {
   11599:	55                   	push   %ebp
   1159a:	89 e5                	mov    %esp,%ebp
   1159c:	56                   	push   %esi
   1159d:	53                   	push   %ebx
   1159e:	83 ec 14             	sub    $0x14,%esp
   115a1:	8b 45 1c             	mov    0x1c(%ebp),%eax
   115a4:	88 45 e4             	mov    %al,-0x1c(%ebp)
  size_t i;
  switch(filterType) {
   115a7:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
   115ab:	83 f8 04             	cmp    $0x4,%eax
   115ae:	0f 87 41 03 00 00    	ja     118f5 <filterScanline+0x35c>
   115b4:	8b 04 85 90 a1 01 00 	mov    0x1a190(,%eax,4),%eax
   115bb:	ff e0                	jmp    *%eax
    case 0: /*None*/
      for(i = 0; i != length; ++i) out[i] = scanline[i];
   115bd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   115c4:	eb 19                	jmp    115df <filterScanline+0x46>
   115c6:	8b 55 f4             	mov    -0xc(%ebp),%edx
   115c9:	8b 45 08             	mov    0x8(%ebp),%eax
   115cc:	01 c2                	add    %eax,%edx
   115ce:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   115d1:	8b 45 0c             	mov    0xc(%ebp),%eax
   115d4:	01 c8                	add    %ecx,%eax
   115d6:	0f b6 00             	movzbl (%eax),%eax
   115d9:	88 02                	mov    %al,(%edx)
   115db:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   115df:	8b 45 f4             	mov    -0xc(%ebp),%eax
   115e2:	3b 45 14             	cmp    0x14(%ebp),%eax
   115e5:	75 df                	jne    115c6 <filterScanline+0x2d>
      break;
   115e7:	e9 0a 03 00 00       	jmp    118f6 <filterScanline+0x35d>
    case 1: /*Sub*/
      for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
   115ec:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   115f3:	eb 19                	jmp    1160e <filterScanline+0x75>
   115f5:	8b 55 f4             	mov    -0xc(%ebp),%edx
   115f8:	8b 45 08             	mov    0x8(%ebp),%eax
   115fb:	01 c2                	add    %eax,%edx
   115fd:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11600:	8b 45 0c             	mov    0xc(%ebp),%eax
   11603:	01 c8                	add    %ecx,%eax
   11605:	0f b6 00             	movzbl (%eax),%eax
   11608:	88 02                	mov    %al,(%edx)
   1160a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1160e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11611:	3b 45 18             	cmp    0x18(%ebp),%eax
   11614:	75 df                	jne    115f5 <filterScanline+0x5c>
      for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - scanline[i - bytewidth];
   11616:	8b 45 18             	mov    0x18(%ebp),%eax
   11619:	89 45 f4             	mov    %eax,-0xc(%ebp)
   1161c:	eb 2d                	jmp    1164b <filterScanline+0xb2>
   1161e:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11621:	8b 45 08             	mov    0x8(%ebp),%eax
   11624:	01 c2                	add    %eax,%edx
   11626:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11629:	8b 45 0c             	mov    0xc(%ebp),%eax
   1162c:	01 c8                	add    %ecx,%eax
   1162e:	0f b6 08             	movzbl (%eax),%ecx
   11631:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11634:	2b 45 18             	sub    0x18(%ebp),%eax
   11637:	89 c3                	mov    %eax,%ebx
   11639:	8b 45 0c             	mov    0xc(%ebp),%eax
   1163c:	01 d8                	add    %ebx,%eax
   1163e:	0f b6 00             	movzbl (%eax),%eax
   11641:	29 c1                	sub    %eax,%ecx
   11643:	89 c8                	mov    %ecx,%eax
   11645:	88 02                	mov    %al,(%edx)
   11647:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1164b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1164e:	3b 45 14             	cmp    0x14(%ebp),%eax
   11651:	7c cb                	jl     1161e <filterScanline+0x85>
      break;
   11653:	e9 9e 02 00 00       	jmp    118f6 <filterScanline+0x35d>
    case 2: /*Up*/
      if(prevline) {
   11658:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   1165c:	74 3e                	je     1169c <filterScanline+0x103>
        for(i = 0; i != length; ++i) out[i] = scanline[i] - prevline[i];
   1165e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11665:	eb 28                	jmp    1168f <filterScanline+0xf6>
   11667:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1166a:	8b 45 08             	mov    0x8(%ebp),%eax
   1166d:	01 d0                	add    %edx,%eax
   1166f:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11672:	8b 55 0c             	mov    0xc(%ebp),%edx
   11675:	01 ca                	add    %ecx,%edx
   11677:	0f b6 0a             	movzbl (%edx),%ecx
   1167a:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   1167d:	8b 55 10             	mov    0x10(%ebp),%edx
   11680:	01 da                	add    %ebx,%edx
   11682:	0f b6 12             	movzbl (%edx),%edx
   11685:	29 d1                	sub    %edx,%ecx
   11687:	89 ca                	mov    %ecx,%edx
   11689:	88 10                	mov    %dl,(%eax)
   1168b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1168f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11692:	3b 45 14             	cmp    0x14(%ebp),%eax
   11695:	75 d0                	jne    11667 <filterScanline+0xce>
      } else {
        for(i = 0; i != length; ++i) out[i] = scanline[i];
      }
      break;
   11697:	e9 5a 02 00 00       	jmp    118f6 <filterScanline+0x35d>
      break;
    case 2: /*Up*/
      if(prevline) {
        for(i = 0; i != length; ++i) out[i] = scanline[i] - prevline[i];
      } else {
        for(i = 0; i != length; ++i) out[i] = scanline[i];
   1169c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   116a3:	eb 19                	jmp    116be <filterScanline+0x125>
   116a5:	8b 55 f4             	mov    -0xc(%ebp),%edx
   116a8:	8b 45 08             	mov    0x8(%ebp),%eax
   116ab:	01 c2                	add    %eax,%edx
   116ad:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   116b0:	8b 45 0c             	mov    0xc(%ebp),%eax
   116b3:	01 c8                	add    %ecx,%eax
   116b5:	0f b6 00             	movzbl (%eax),%eax
   116b8:	88 02                	mov    %al,(%edx)
   116ba:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   116be:	8b 45 f4             	mov    -0xc(%ebp),%eax
   116c1:	3b 45 14             	cmp    0x14(%ebp),%eax
   116c4:	75 df                	jne    116a5 <filterScanline+0x10c>
      }
      break;
   116c6:	e9 2b 02 00 00       	jmp    118f6 <filterScanline+0x35d>
    case 3: /*Average*/
      if(prevline) {
   116cb:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   116cf:	0f 84 90 00 00 00    	je     11765 <filterScanline+0x1cc>
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i] - (prevline[i] >> 1);
   116d5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   116dc:	eb 28                	jmp    11706 <filterScanline+0x16d>
   116de:	8b 55 f4             	mov    -0xc(%ebp),%edx
   116e1:	8b 45 08             	mov    0x8(%ebp),%eax
   116e4:	01 d0                	add    %edx,%eax
   116e6:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   116e9:	8b 55 0c             	mov    0xc(%ebp),%edx
   116ec:	01 ca                	add    %ecx,%edx
   116ee:	0f b6 12             	movzbl (%edx),%edx
   116f1:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   116f4:	8b 4d 10             	mov    0x10(%ebp),%ecx
   116f7:	01 d9                	add    %ebx,%ecx
   116f9:	0f b6 09             	movzbl (%ecx),%ecx
   116fc:	d0 e9                	shr    %cl
   116fe:	29 ca                	sub    %ecx,%edx
   11700:	88 10                	mov    %dl,(%eax)
   11702:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11706:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11709:	3b 45 18             	cmp    0x18(%ebp),%eax
   1170c:	75 d0                	jne    116de <filterScanline+0x145>
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - ((scanline[i - bytewidth] + prevline[i]) >> 1);
   1170e:	8b 45 18             	mov    0x18(%ebp),%eax
   11711:	89 45 f4             	mov    %eax,-0xc(%ebp)
   11714:	eb 42                	jmp    11758 <filterScanline+0x1bf>
   11716:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11719:	8b 45 08             	mov    0x8(%ebp),%eax
   1171c:	01 c2                	add    %eax,%edx
   1171e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11721:	8b 45 0c             	mov    0xc(%ebp),%eax
   11724:	01 c8                	add    %ecx,%eax
   11726:	0f b6 08             	movzbl (%eax),%ecx
   11729:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1172c:	2b 45 18             	sub    0x18(%ebp),%eax
   1172f:	89 c3                	mov    %eax,%ebx
   11731:	8b 45 0c             	mov    0xc(%ebp),%eax
   11734:	01 d8                	add    %ebx,%eax
   11736:	0f b6 00             	movzbl (%eax),%eax
   11739:	0f b6 d8             	movzbl %al,%ebx
   1173c:	8b 75 f4             	mov    -0xc(%ebp),%esi
   1173f:	8b 45 10             	mov    0x10(%ebp),%eax
   11742:	01 f0                	add    %esi,%eax
   11744:	0f b6 00             	movzbl (%eax),%eax
   11747:	0f b6 c0             	movzbl %al,%eax
   1174a:	01 d8                	add    %ebx,%eax
   1174c:	d1 f8                	sar    %eax
   1174e:	29 c1                	sub    %eax,%ecx
   11750:	89 c8                	mov    %ecx,%eax
   11752:	88 02                	mov    %al,(%edx)
   11754:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11758:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1175b:	3b 45 14             	cmp    0x14(%ebp),%eax
   1175e:	7c b6                	jl     11716 <filterScanline+0x17d>
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - (scanline[i - bytewidth] >> 1);
      }
      break;
   11760:	e9 91 01 00 00       	jmp    118f6 <filterScanline+0x35d>
    case 3: /*Average*/
      if(prevline) {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i] - (prevline[i] >> 1);
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - ((scanline[i - bytewidth] + prevline[i]) >> 1);
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
   11765:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1176c:	eb 19                	jmp    11787 <filterScanline+0x1ee>
   1176e:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11771:	8b 45 08             	mov    0x8(%ebp),%eax
   11774:	01 c2                	add    %eax,%edx
   11776:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11779:	8b 45 0c             	mov    0xc(%ebp),%eax
   1177c:	01 c8                	add    %ecx,%eax
   1177e:	0f b6 00             	movzbl (%eax),%eax
   11781:	88 02                	mov    %al,(%edx)
   11783:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11787:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1178a:	3b 45 18             	cmp    0x18(%ebp),%eax
   1178d:	75 df                	jne    1176e <filterScanline+0x1d5>
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - (scanline[i - bytewidth] >> 1);
   1178f:	8b 45 18             	mov    0x18(%ebp),%eax
   11792:	89 45 f4             	mov    %eax,-0xc(%ebp)
   11795:	eb 2f                	jmp    117c6 <filterScanline+0x22d>
   11797:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1179a:	8b 45 08             	mov    0x8(%ebp),%eax
   1179d:	01 c2                	add    %eax,%edx
   1179f:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   117a2:	8b 45 0c             	mov    0xc(%ebp),%eax
   117a5:	01 c8                	add    %ecx,%eax
   117a7:	0f b6 08             	movzbl (%eax),%ecx
   117aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
   117ad:	2b 45 18             	sub    0x18(%ebp),%eax
   117b0:	89 c3                	mov    %eax,%ebx
   117b2:	8b 45 0c             	mov    0xc(%ebp),%eax
   117b5:	01 d8                	add    %ebx,%eax
   117b7:	0f b6 00             	movzbl (%eax),%eax
   117ba:	d0 e8                	shr    %al
   117bc:	29 c1                	sub    %eax,%ecx
   117be:	89 c8                	mov    %ecx,%eax
   117c0:	88 02                	mov    %al,(%edx)
   117c2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   117c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   117c9:	3b 45 14             	cmp    0x14(%ebp),%eax
   117cc:	7c c9                	jl     11797 <filterScanline+0x1fe>
      }
      break;
   117ce:	e9 23 01 00 00       	jmp    118f6 <filterScanline+0x35d>
    case 4: /*Paeth*/
      if(prevline) {
   117d3:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   117d7:	0f 84 af 00 00 00    	je     1188c <filterScanline+0x2f3>
        /*paethPredictor(0, prevline[i], 0) is always prevline[i]*/
        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
   117dd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   117e4:	eb 28                	jmp    1180e <filterScanline+0x275>
   117e6:	8b 55 f4             	mov    -0xc(%ebp),%edx
   117e9:	8b 45 08             	mov    0x8(%ebp),%eax
   117ec:	01 d0                	add    %edx,%eax
   117ee:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   117f1:	8b 55 0c             	mov    0xc(%ebp),%edx
   117f4:	01 ca                	add    %ecx,%edx
   117f6:	0f b6 0a             	movzbl (%edx),%ecx
   117f9:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   117fc:	8b 55 10             	mov    0x10(%ebp),%edx
   117ff:	01 da                	add    %ebx,%edx
   11801:	0f b6 12             	movzbl (%edx),%edx
   11804:	29 d1                	sub    %edx,%ecx
   11806:	89 ca                	mov    %ecx,%edx
   11808:	88 10                	mov    %dl,(%eax)
   1180a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1180e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11811:	3b 45 18             	cmp    0x18(%ebp),%eax
   11814:	75 d0                	jne    117e6 <filterScanline+0x24d>
        for(i = bytewidth; i < length; ++i) {
   11816:	8b 45 18             	mov    0x18(%ebp),%eax
   11819:	89 45 f4             	mov    %eax,-0xc(%ebp)
   1181c:	eb 64                	jmp    11882 <filterScanline+0x2e9>
          out[i] = (scanline[i] - paethPredictor(scanline[i - bytewidth], prevline[i], prevline[i - bytewidth]));
   1181e:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11821:	8b 45 08             	mov    0x8(%ebp),%eax
   11824:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   11827:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1182a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1182d:	01 d0                	add    %edx,%eax
   1182f:	0f b6 00             	movzbl (%eax),%eax
   11832:	88 45 e7             	mov    %al,-0x19(%ebp)
   11835:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11838:	2b 45 18             	sub    0x18(%ebp),%eax
   1183b:	89 c2                	mov    %eax,%edx
   1183d:	8b 45 10             	mov    0x10(%ebp),%eax
   11840:	01 d0                	add    %edx,%eax
   11842:	0f b6 00             	movzbl (%eax),%eax
   11845:	0f b6 c8             	movzbl %al,%ecx
   11848:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1184b:	8b 45 10             	mov    0x10(%ebp),%eax
   1184e:	01 d0                	add    %edx,%eax
   11850:	0f b6 00             	movzbl (%eax),%eax
   11853:	0f b6 d0             	movzbl %al,%edx
   11856:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11859:	2b 45 18             	sub    0x18(%ebp),%eax
   1185c:	89 c6                	mov    %eax,%esi
   1185e:	8b 45 0c             	mov    0xc(%ebp),%eax
   11861:	01 f0                	add    %esi,%eax
   11863:	0f b6 00             	movzbl (%eax),%eax
   11866:	0f b6 c0             	movzbl %al,%eax
   11869:	51                   	push   %ecx
   1186a:	52                   	push   %edx
   1186b:	50                   	push   %eax
   1186c:	e8 49 b8 ff ff       	call   d0ba <paethPredictor>
   11871:	83 c4 0c             	add    $0xc,%esp
   11874:	0f b6 4d e7          	movzbl -0x19(%ebp),%ecx
   11878:	29 c1                	sub    %eax,%ecx
   1187a:	89 c8                	mov    %ecx,%eax
   1187c:	88 03                	mov    %al,(%ebx)
      break;
    case 4: /*Paeth*/
      if(prevline) {
        /*paethPredictor(0, prevline[i], 0) is always prevline[i]*/
        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
        for(i = bytewidth; i < length; ++i) {
   1187e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11882:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11885:	3b 45 14             	cmp    0x14(%ebp),%eax
   11888:	7c 94                	jl     1181e <filterScanline+0x285>
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
        /*paethPredictor(scanline[i - bytewidth], 0, 0) is always scanline[i - bytewidth]*/
        for(i = bytewidth; i < length; ++i) out[i] = (scanline[i] - scanline[i - bytewidth]);
      }
      break;
   1188a:	eb 6a                	jmp    118f6 <filterScanline+0x35d>
        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
        for(i = bytewidth; i < length; ++i) {
          out[i] = (scanline[i] - paethPredictor(scanline[i - bytewidth], prevline[i], prevline[i - bytewidth]));
        }
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
   1188c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11893:	eb 19                	jmp    118ae <filterScanline+0x315>
   11895:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11898:	8b 45 08             	mov    0x8(%ebp),%eax
   1189b:	01 c2                	add    %eax,%edx
   1189d:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   118a0:	8b 45 0c             	mov    0xc(%ebp),%eax
   118a3:	01 c8                	add    %ecx,%eax
   118a5:	0f b6 00             	movzbl (%eax),%eax
   118a8:	88 02                	mov    %al,(%edx)
   118aa:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   118ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
   118b1:	3b 45 18             	cmp    0x18(%ebp),%eax
   118b4:	75 df                	jne    11895 <filterScanline+0x2fc>
        /*paethPredictor(scanline[i - bytewidth], 0, 0) is always scanline[i - bytewidth]*/
        for(i = bytewidth; i < length; ++i) out[i] = (scanline[i] - scanline[i - bytewidth]);
   118b6:	8b 45 18             	mov    0x18(%ebp),%eax
   118b9:	89 45 f4             	mov    %eax,-0xc(%ebp)
   118bc:	eb 2d                	jmp    118eb <filterScanline+0x352>
   118be:	8b 55 f4             	mov    -0xc(%ebp),%edx
   118c1:	8b 45 08             	mov    0x8(%ebp),%eax
   118c4:	01 c2                	add    %eax,%edx
   118c6:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   118c9:	8b 45 0c             	mov    0xc(%ebp),%eax
   118cc:	01 c8                	add    %ecx,%eax
   118ce:	0f b6 08             	movzbl (%eax),%ecx
   118d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   118d4:	2b 45 18             	sub    0x18(%ebp),%eax
   118d7:	89 c3                	mov    %eax,%ebx
   118d9:	8b 45 0c             	mov    0xc(%ebp),%eax
   118dc:	01 d8                	add    %ebx,%eax
   118de:	0f b6 00             	movzbl (%eax),%eax
   118e1:	29 c1                	sub    %eax,%ecx
   118e3:	89 c8                	mov    %ecx,%eax
   118e5:	88 02                	mov    %al,(%edx)
   118e7:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   118eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
   118ee:	3b 45 14             	cmp    0x14(%ebp),%eax
   118f1:	7c cb                	jl     118be <filterScanline+0x325>
      }
      break;
   118f3:	eb 01                	jmp    118f6 <filterScanline+0x35d>
    default: return; /*invalid filter type given*/
   118f5:	90                   	nop
  }
}
   118f6:	8d 65 f8             	lea    -0x8(%ebp),%esp
   118f9:	5b                   	pop    %ebx
   118fa:	5e                   	pop    %esi
   118fb:	5d                   	pop    %ebp
   118fc:	c3                   	ret    

000118fd <ilog2>:

/* integer binary logarithm, max return value is 31 */
static size_t ilog2(size_t i) {
   118fd:	55                   	push   %ebp
   118fe:	89 e5                	mov    %esp,%ebp
   11900:	83 ec 10             	sub    $0x10,%esp
  size_t result = 0;
   11903:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  if(i >= 65536) { result += 16; i >>= 16; }
   1190a:	81 7d 08 ff ff 00 00 	cmpl   $0xffff,0x8(%ebp)
   11911:	7e 08                	jle    1191b <ilog2+0x1e>
   11913:	83 45 fc 10          	addl   $0x10,-0x4(%ebp)
   11917:	c1 7d 08 10          	sarl   $0x10,0x8(%ebp)
  if(i >= 256) { result += 8; i >>= 8; }
   1191b:	81 7d 08 ff 00 00 00 	cmpl   $0xff,0x8(%ebp)
   11922:	7e 08                	jle    1192c <ilog2+0x2f>
   11924:	83 45 fc 08          	addl   $0x8,-0x4(%ebp)
   11928:	c1 7d 08 08          	sarl   $0x8,0x8(%ebp)
  if(i >= 16) { result += 4; i >>= 4; }
   1192c:	83 7d 08 0f          	cmpl   $0xf,0x8(%ebp)
   11930:	7e 08                	jle    1193a <ilog2+0x3d>
   11932:	83 45 fc 04          	addl   $0x4,-0x4(%ebp)
   11936:	c1 7d 08 04          	sarl   $0x4,0x8(%ebp)
  if(i >= 4) { result += 2; i >>= 2; }
   1193a:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
   1193e:	7e 08                	jle    11948 <ilog2+0x4b>
   11940:	83 45 fc 02          	addl   $0x2,-0x4(%ebp)
   11944:	c1 7d 08 02          	sarl   $0x2,0x8(%ebp)
  if(i >= 2) { result += 1; /*i >>= 1;*/ }
   11948:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
   1194c:	7e 04                	jle    11952 <ilog2+0x55>
   1194e:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  return result;
   11952:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   11955:	c9                   	leave  
   11956:	c3                   	ret    

00011957 <ilog2i>:

/* integer approximation for i * log2(i), helper function for LFS_ENTROPY */
static size_t ilog2i(size_t i) {
   11957:	55                   	push   %ebp
   11958:	89 e5                	mov    %esp,%ebp
   1195a:	56                   	push   %esi
   1195b:	53                   	push   %ebx
   1195c:	83 ec 10             	sub    $0x10,%esp
  size_t l;
  if(i == 0) return 0;
   1195f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   11963:	75 07                	jne    1196c <ilog2i+0x15>
   11965:	b8 00 00 00 00       	mov    $0x0,%eax
   1196a:	eb 30                	jmp    1199c <ilog2i+0x45>
  l = ilog2(i);
   1196c:	ff 75 08             	pushl  0x8(%ebp)
   1196f:	e8 89 ff ff ff       	call   118fd <ilog2>
   11974:	83 c4 04             	add    $0x4,%esp
   11977:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /* approximate i*log2(i): l is integer logarithm, ((i - (1u << l)) << 1u)
  linearly approximates the missing fractional part multiplied by i */
  return i * l + ((i - (1u << l)) << 1u);
   1197a:	8b 45 08             	mov    0x8(%ebp),%eax
   1197d:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   11981:	89 c3                	mov    %eax,%ebx
   11983:	8b 55 08             	mov    0x8(%ebp),%edx
   11986:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11989:	be 01 00 00 00       	mov    $0x1,%esi
   1198e:	89 c1                	mov    %eax,%ecx
   11990:	d3 e6                	shl    %cl,%esi
   11992:	89 f0                	mov    %esi,%eax
   11994:	29 c2                	sub    %eax,%edx
   11996:	89 d0                	mov    %edx,%eax
   11998:	01 c0                	add    %eax,%eax
   1199a:	01 d8                	add    %ebx,%eax
}
   1199c:	8d 65 f8             	lea    -0x8(%ebp),%esp
   1199f:	5b                   	pop    %ebx
   119a0:	5e                   	pop    %esi
   119a1:	5d                   	pop    %ebp
   119a2:	c3                   	ret    

000119a3 <filter>:

static unsigned filter(unsigned char* out, const unsigned char* in, unsigned w, unsigned h,
                       const LodePNGColorMode* color, const LodePNGEncoderSettings* settings) {
   119a3:	55                   	push   %ebp
   119a4:	89 e5                	mov    %esp,%ebp
   119a6:	53                   	push   %ebx
   119a7:	81 ec c4 04 00 00    	sub    $0x4c4,%esp
  For PNG filter method 0
  out must be a buffer with as size: h + (w * h * bpp + 7u) / 8u, because there are
  the scanlines with 1 extra byte per scanline
  */

  unsigned bpp = lodepng_get_bpp(color);
   119ad:	ff 75 18             	pushl  0x18(%ebp)
   119b0:	e8 6a 75 ff ff       	call   8f1f <lodepng_get_bpp>
   119b5:	83 c4 04             	add    $0x4,%esp
   119b8:	89 45 b8             	mov    %eax,-0x48(%ebp)
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;
   119bb:	ff 75 b8             	pushl  -0x48(%ebp)
   119be:	6a 01                	push   $0x1
   119c0:	ff 75 10             	pushl  0x10(%ebp)
   119c3:	e8 b6 76 ff ff       	call   907e <lodepng_get_raw_size_idat>
   119c8:	83 c4 0c             	add    $0xc,%esp
   119cb:	83 e8 01             	sub    $0x1,%eax
   119ce:	89 45 b4             	mov    %eax,-0x4c(%ebp)

  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7u) / 8u;
   119d1:	8b 45 b8             	mov    -0x48(%ebp),%eax
   119d4:	83 c0 07             	add    $0x7,%eax
   119d7:	c1 e8 03             	shr    $0x3,%eax
   119da:	89 45 b0             	mov    %eax,-0x50(%ebp)
  const unsigned char* prevline = 0;
   119dd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned x, y;
  unsigned error = 0;
   119e4:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  LodePNGFilterStrategy strategy = settings->filter_strategy;
   119eb:	8b 45 1c             	mov    0x1c(%ebp),%eax
   119ee:	8b 40 2c             	mov    0x2c(%eax),%eax
   119f1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  This heuristic is used if filter strategy is LFS_MINSUM and filter_palette_zero is true.
  If filter_palette_zero is true and filter_strategy is not LFS_MINSUM, the above heuristic is followed,
  but for "the other case", whatever strategy filter_strategy is set to instead of the minimum sum
  heuristic is used.
  */
  if(settings->filter_palette_zero &&
   119f4:	8b 45 1c             	mov    0x1c(%ebp),%eax
   119f7:	8b 40 28             	mov    0x28(%eax),%eax
   119fa:	85 c0                	test   %eax,%eax
   119fc:	74 1c                	je     11a1a <filter+0x77>
     (color->colortype == LCT_PALETTE || color->bitdepth < 8)) strategy = LFS_ZERO;
   119fe:	8b 45 18             	mov    0x18(%ebp),%eax
   11a01:	8b 00                	mov    (%eax),%eax
  This heuristic is used if filter strategy is LFS_MINSUM and filter_palette_zero is true.
  If filter_palette_zero is true and filter_strategy is not LFS_MINSUM, the above heuristic is followed,
  but for "the other case", whatever strategy filter_strategy is set to instead of the minimum sum
  heuristic is used.
  */
  if(settings->filter_palette_zero &&
   11a03:	83 f8 03             	cmp    $0x3,%eax
   11a06:	74 0b                	je     11a13 <filter+0x70>
     (color->colortype == LCT_PALETTE || color->bitdepth < 8)) strategy = LFS_ZERO;
   11a08:	8b 45 18             	mov    0x18(%ebp),%eax
   11a0b:	8b 40 04             	mov    0x4(%eax),%eax
   11a0e:	83 f8 07             	cmp    $0x7,%eax
   11a11:	77 07                	ja     11a1a <filter+0x77>
   11a13:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

  if(bpp == 0) return 31; /*error: invalid color type*/
   11a1a:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
   11a1e:	75 0a                	jne    11a2a <filter+0x87>
   11a20:	b8 1f 00 00 00       	mov    $0x1f,%eax
   11a25:	e9 5b 07 00 00       	jmp    12185 <filter+0x7e2>

  if(strategy >= LFS_ZERO && strategy <= LFS_FOUR) {
   11a2a:	83 7d e4 04          	cmpl   $0x4,-0x1c(%ebp)
   11a2e:	77 7b                	ja     11aab <filter+0x108>
    unsigned char type = (unsigned char)strategy;
   11a30:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11a33:	88 45 a1             	mov    %al,-0x5f(%ebp)
    for(y = 0; y != h; ++y) {
   11a36:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   11a3d:	eb 5f                	jmp    11a9e <filter+0xfb>
      size_t outindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
   11a3f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11a42:	83 c0 01             	add    $0x1,%eax
   11a45:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11a49:	89 45 9c             	mov    %eax,-0x64(%ebp)
      size_t inindex = linebytes * y;
   11a4c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11a4f:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11a53:	89 45 98             	mov    %eax,-0x68(%ebp)
      out[outindex] = type; /*filter type byte*/
   11a56:	8b 55 9c             	mov    -0x64(%ebp),%edx
   11a59:	8b 45 08             	mov    0x8(%ebp),%eax
   11a5c:	01 c2                	add    %eax,%edx
   11a5e:	0f b6 45 a1          	movzbl -0x5f(%ebp),%eax
   11a62:	88 02                	mov    %al,(%edx)
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
   11a64:	0f b6 45 a1          	movzbl -0x5f(%ebp),%eax
   11a68:	8b 4d 98             	mov    -0x68(%ebp),%ecx
   11a6b:	8b 55 0c             	mov    0xc(%ebp),%edx
   11a6e:	01 d1                	add    %edx,%ecx
   11a70:	8b 55 9c             	mov    -0x64(%ebp),%edx
   11a73:	8d 5a 01             	lea    0x1(%edx),%ebx
   11a76:	8b 55 08             	mov    0x8(%ebp),%edx
   11a79:	01 da                	add    %ebx,%edx
   11a7b:	50                   	push   %eax
   11a7c:	ff 75 b0             	pushl  -0x50(%ebp)
   11a7f:	ff 75 b4             	pushl  -0x4c(%ebp)
   11a82:	ff 75 f4             	pushl  -0xc(%ebp)
   11a85:	51                   	push   %ecx
   11a86:	52                   	push   %edx
   11a87:	e8 0d fb ff ff       	call   11599 <filterScanline>
   11a8c:	83 c4 18             	add    $0x18,%esp
      prevline = &in[inindex];
   11a8f:	8b 55 98             	mov    -0x68(%ebp),%edx
   11a92:	8b 45 0c             	mov    0xc(%ebp),%eax
   11a95:	01 d0                	add    %edx,%eax
   11a97:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(bpp == 0) return 31; /*error: invalid color type*/

  if(strategy >= LFS_ZERO && strategy <= LFS_FOUR) {
    unsigned char type = (unsigned char)strategy;
    for(y = 0; y != h; ++y) {
   11a9a:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   11a9e:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11aa1:	3b 45 14             	cmp    0x14(%ebp),%eax
   11aa4:	75 99                	jne    11a3f <filter+0x9c>
   11aa6:	e9 d7 06 00 00       	jmp    12182 <filter+0x7df>
      size_t inindex = linebytes * y;
      out[outindex] = type; /*filter type byte*/
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
      prevline = &in[inindex];
    }
  } else if(strategy == LFS_MINSUM) {
   11aab:	83 7d e4 05          	cmpl   $0x5,-0x1c(%ebp)
   11aaf:	0f 85 e3 01 00 00    	jne    11c98 <filter+0x2f5>
    /*adaptive filtering*/
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
   11ab5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    unsigned char type, bestType = 0;
   11abc:	c6 45 de 00          	movb   $0x0,-0x22(%ebp)

    for(type = 0; type != 5; ++type) {
   11ac0:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
   11ac4:	eb 2d                	jmp    11af3 <filter+0x150>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
   11ac6:	0f b6 5d df          	movzbl -0x21(%ebp),%ebx
   11aca:	83 ec 0c             	sub    $0xc,%esp
   11acd:	ff 75 b4             	pushl  -0x4c(%ebp)
   11ad0:	e8 2e 19 ff ff       	call   3403 <lodepng_malloc>
   11ad5:	83 c4 10             	add    $0x10,%esp
   11ad8:	89 44 9d 84          	mov    %eax,-0x7c(%ebp,%ebx,4)
      if(!attempt[type]) error = 83; /*alloc fail*/
   11adc:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11ae0:	8b 44 85 84          	mov    -0x7c(%ebp,%eax,4),%eax
   11ae4:	85 c0                	test   %eax,%eax
   11ae6:	75 07                	jne    11aef <filter+0x14c>
   11ae8:	c7 45 e8 53 00 00 00 	movl   $0x53,-0x18(%ebp)
    /*adaptive filtering*/
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
    unsigned char type, bestType = 0;

    for(type = 0; type != 5; ++type) {
   11aef:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
   11af3:	80 7d df 05          	cmpb   $0x5,-0x21(%ebp)
   11af7:	75 cd                	jne    11ac6 <filter+0x123>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
   11af9:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   11afd:	0f 85 6c 01 00 00    	jne    11c6f <filter+0x2cc>
      for(y = 0; y != h; ++y) {
   11b03:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   11b0a:	e9 54 01 00 00       	jmp    11c63 <filter+0x2c0>
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   11b0f:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
   11b13:	e9 d5 00 00 00       	jmp    11bed <filter+0x24a>
          size_t sum = 0;
   11b18:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
   11b1f:	0f b6 55 df          	movzbl -0x21(%ebp),%edx
   11b23:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11b26:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11b2a:	89 c1                	mov    %eax,%ecx
   11b2c:	8b 45 0c             	mov    0xc(%ebp),%eax
   11b2f:	01 c1                	add    %eax,%ecx
   11b31:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11b35:	8b 44 85 84          	mov    -0x7c(%ebp,%eax,4),%eax
   11b39:	83 ec 08             	sub    $0x8,%esp
   11b3c:	52                   	push   %edx
   11b3d:	ff 75 b0             	pushl  -0x50(%ebp)
   11b40:	ff 75 b4             	pushl  -0x4c(%ebp)
   11b43:	ff 75 f4             	pushl  -0xc(%ebp)
   11b46:	51                   	push   %ecx
   11b47:	50                   	push   %eax
   11b48:	e8 4c fa ff ff       	call   11599 <filterScanline>
   11b4d:	83 c4 20             	add    $0x20,%esp

          /*calculate the sum of the result*/
          if(type == 0) {
   11b50:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
   11b54:	75 2d                	jne    11b83 <filter+0x1e0>
            for(x = 0; x != linebytes; ++x) sum += (unsigned char)(attempt[type][x]);
   11b56:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11b5d:	eb 1a                	jmp    11b79 <filter+0x1d6>
   11b5f:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11b63:	8b 54 85 84          	mov    -0x7c(%ebp,%eax,4),%edx
   11b67:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11b6a:	01 d0                	add    %edx,%eax
   11b6c:	0f b6 00             	movzbl (%eax),%eax
   11b6f:	0f b6 c0             	movzbl %al,%eax
   11b72:	01 45 d8             	add    %eax,-0x28(%ebp)
   11b75:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11b79:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11b7c:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11b7f:	75 de                	jne    11b5f <filter+0x1bc>
   11b81:	eb 4b                	jmp    11bce <filter+0x22b>
          } else {
            for(x = 0; x != linebytes; ++x) {
   11b83:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11b8a:	eb 3a                	jmp    11bc6 <filter+0x223>
              /*For differences, each byte should be treated as signed, values above 127 are negative
              (converted to signed char). Filtertype 0 isn't a difference though, so use unsigned there.
              This means filtertype 0 is almost never chosen, but that is justified.*/
              unsigned char s = attempt[type][x];
   11b8c:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11b90:	8b 54 85 84          	mov    -0x7c(%ebp,%eax,4),%edx
   11b94:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11b97:	01 d0                	add    %edx,%eax
   11b99:	0f b6 00             	movzbl (%eax),%eax
   11b9c:	88 45 a2             	mov    %al,-0x5e(%ebp)
              sum += s < 128 ? s : (255U - s);
   11b9f:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
   11ba3:	84 c0                	test   %al,%al
   11ba5:	78 06                	js     11bad <filter+0x20a>
   11ba7:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
   11bab:	eb 0d                	jmp    11bba <filter+0x217>
   11bad:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
   11bb1:	ba ff 00 00 00       	mov    $0xff,%edx
   11bb6:	29 c2                	sub    %eax,%edx
   11bb8:	89 d0                	mov    %edx,%eax
   11bba:	8b 55 d8             	mov    -0x28(%ebp),%edx
   11bbd:	01 d0                	add    %edx,%eax
   11bbf:	89 45 d8             	mov    %eax,-0x28(%ebp)

          /*calculate the sum of the result*/
          if(type == 0) {
            for(x = 0; x != linebytes; ++x) sum += (unsigned char)(attempt[type][x]);
          } else {
            for(x = 0; x != linebytes; ++x) {
   11bc2:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11bc6:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11bc9:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11bcc:	75 be                	jne    11b8c <filter+0x1e9>
              sum += s < 128 ? s : (255U - s);
            }
          }

          /*check if this is smallest sum (or if type == 0 it's the first case so always store the values)*/
          if(type == 0 || sum < smallest) {
   11bce:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
   11bd2:	74 08                	je     11bdc <filter+0x239>
   11bd4:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11bd7:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   11bda:	7d 0d                	jge    11be9 <filter+0x246>
            bestType = type;
   11bdc:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11be0:	88 45 de             	mov    %al,-0x22(%ebp)
            smallest = sum;
   11be3:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11be6:	89 45 e0             	mov    %eax,-0x20(%ebp)
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   11be9:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
   11bed:	80 7d df 05          	cmpb   $0x5,-0x21(%ebp)
   11bf1:	0f 85 21 ff ff ff    	jne    11b18 <filter+0x175>
            bestType = type;
            smallest = sum;
          }
        }

        prevline = &in[y * linebytes];
   11bf7:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11bfa:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11bfe:	89 c2                	mov    %eax,%edx
   11c00:	8b 45 0c             	mov    0xc(%ebp),%eax
   11c03:	01 d0                	add    %edx,%eax
   11c05:	89 45 f4             	mov    %eax,-0xc(%ebp)

        /*now fill the out values*/
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
   11c08:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11c0b:	83 c0 01             	add    $0x1,%eax
   11c0e:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11c12:	89 c2                	mov    %eax,%edx
   11c14:	8b 45 08             	mov    0x8(%ebp),%eax
   11c17:	01 c2                	add    %eax,%edx
   11c19:	0f b6 45 de          	movzbl -0x22(%ebp),%eax
   11c1d:	88 02                	mov    %al,(%edx)
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
   11c1f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11c26:	eb 2f                	jmp    11c57 <filter+0x2b4>
   11c28:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11c2b:	83 c0 01             	add    $0x1,%eax
   11c2e:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11c32:	89 c2                	mov    %eax,%edx
   11c34:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11c37:	01 d0                	add    %edx,%eax
   11c39:	8d 50 01             	lea    0x1(%eax),%edx
   11c3c:	8b 45 08             	mov    0x8(%ebp),%eax
   11c3f:	01 c2                	add    %eax,%edx
   11c41:	0f b6 45 de          	movzbl -0x22(%ebp),%eax
   11c45:	8b 4c 85 84          	mov    -0x7c(%ebp,%eax,4),%ecx
   11c49:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11c4c:	01 c8                	add    %ecx,%eax
   11c4e:	0f b6 00             	movzbl (%eax),%eax
   11c51:	88 02                	mov    %al,(%edx)
   11c53:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11c57:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11c5a:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11c5d:	75 c9                	jne    11c28 <filter+0x285>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
   11c5f:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   11c63:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11c66:	3b 45 14             	cmp    0x14(%ebp),%eax
   11c69:	0f 85 a0 fe ff ff    	jne    11b0f <filter+0x16c>
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
      }
    }

    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
   11c6f:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
   11c73:	eb 18                	jmp    11c8d <filter+0x2ea>
   11c75:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11c79:	8b 44 85 84          	mov    -0x7c(%ebp,%eax,4),%eax
   11c7d:	83 ec 0c             	sub    $0xc,%esp
   11c80:	50                   	push   %eax
   11c81:	e8 9e 17 ff ff       	call   3424 <lodepng_free>
   11c86:	83 c4 10             	add    $0x10,%esp
   11c89:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
   11c8d:	80 7d df 05          	cmpb   $0x5,-0x21(%ebp)
   11c91:	75 e2                	jne    11c75 <filter+0x2d2>
   11c93:	e9 ea 04 00 00       	jmp    12182 <filter+0x7df>
  } else if(strategy == LFS_ENTROPY) {
   11c98:	83 7d e4 06          	cmpl   $0x6,-0x1c(%ebp)
   11c9c:	0f 85 17 02 00 00    	jne    11eb9 <filter+0x516>
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t bestSum = 0;
   11ca2:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
    unsigned type, bestType = 0;
   11ca9:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
    unsigned count[256];

    for(type = 0; type != 5; ++type) {
   11cb0:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
   11cb7:	eb 33                	jmp    11cec <filter+0x349>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
   11cb9:	83 ec 0c             	sub    $0xc,%esp
   11cbc:	ff 75 b4             	pushl  -0x4c(%ebp)
   11cbf:	e8 3f 17 ff ff       	call   3403 <lodepng_malloc>
   11cc4:	83 c4 10             	add    $0x10,%esp
   11cc7:	89 c2                	mov    %eax,%edx
   11cc9:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11ccc:	89 94 85 70 ff ff ff 	mov    %edx,-0x90(%ebp,%eax,4)
      if(!attempt[type]) error = 83; /*alloc fail*/
   11cd3:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11cd6:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
   11cdd:	85 c0                	test   %eax,%eax
   11cdf:	75 07                	jne    11ce8 <filter+0x345>
   11ce1:	c7 45 e8 53 00 00 00 	movl   $0x53,-0x18(%ebp)
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t bestSum = 0;
    unsigned type, bestType = 0;
    unsigned count[256];

    for(type = 0; type != 5; ++type) {
   11ce8:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
   11cec:	83 7d d0 05          	cmpl   $0x5,-0x30(%ebp)
   11cf0:	75 c7                	jne    11cb9 <filter+0x316>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
   11cf2:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   11cf6:	0f 85 8f 01 00 00    	jne    11e8b <filter+0x4e8>
      for(y = 0; y != h; ++y) {
   11cfc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   11d03:	e9 77 01 00 00       	jmp    11e7f <filter+0x4dc>
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   11d08:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
   11d0f:	e9 f4 00 00 00       	jmp    11e08 <filter+0x465>
          size_t sum = 0;
   11d14:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
   11d1b:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11d1e:	0f b6 d0             	movzbl %al,%edx
   11d21:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11d24:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11d28:	89 c1                	mov    %eax,%ecx
   11d2a:	8b 45 0c             	mov    0xc(%ebp),%eax
   11d2d:	01 c1                	add    %eax,%ecx
   11d2f:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11d32:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
   11d39:	83 ec 08             	sub    $0x8,%esp
   11d3c:	52                   	push   %edx
   11d3d:	ff 75 b0             	pushl  -0x50(%ebp)
   11d40:	ff 75 b4             	pushl  -0x4c(%ebp)
   11d43:	ff 75 f4             	pushl  -0xc(%ebp)
   11d46:	51                   	push   %ecx
   11d47:	50                   	push   %eax
   11d48:	e8 4c f8 ff ff       	call   11599 <filterScanline>
   11d4d:	83 c4 20             	add    $0x20,%esp
          lodepng_memset(count, 0, 256 * sizeof(*count));
   11d50:	83 ec 04             	sub    $0x4,%esp
   11d53:	68 00 04 00 00       	push   $0x400
   11d58:	6a 00                	push   $0x0
   11d5a:	8d 85 44 fb ff ff    	lea    -0x4bc(%ebp),%eax
   11d60:	50                   	push   %eax
   11d61:	e8 0e 17 ff ff       	call   3474 <lodepng_memset>
   11d66:	83 c4 10             	add    $0x10,%esp
          for(x = 0; x != linebytes; ++x) ++count[attempt[type][x]];
   11d69:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11d70:	eb 2a                	jmp    11d9c <filter+0x3f9>
   11d72:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11d75:	8b 94 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%edx
   11d7c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11d7f:	01 d0                	add    %edx,%eax
   11d81:	0f b6 00             	movzbl (%eax),%eax
   11d84:	0f b6 c0             	movzbl %al,%eax
   11d87:	8b 94 85 44 fb ff ff 	mov    -0x4bc(%ebp,%eax,4),%edx
   11d8e:	83 c2 01             	add    $0x1,%edx
   11d91:	89 94 85 44 fb ff ff 	mov    %edx,-0x4bc(%ebp,%eax,4)
   11d98:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11d9c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11d9f:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11da2:	75 ce                	jne    11d72 <filter+0x3cf>
          ++count[type]; /*the filter type itself is part of the scanline*/
   11da4:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11da7:	8b 84 85 44 fb ff ff 	mov    -0x4bc(%ebp,%eax,4),%eax
   11dae:	8d 50 01             	lea    0x1(%eax),%edx
   11db1:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11db4:	89 94 85 44 fb ff ff 	mov    %edx,-0x4bc(%ebp,%eax,4)
          for(x = 0; x != 256; ++x) {
   11dbb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11dc2:	eb 1d                	jmp    11de1 <filter+0x43e>
            sum += ilog2i(count[x]);
   11dc4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11dc7:	8b 84 85 44 fb ff ff 	mov    -0x4bc(%ebp,%eax,4),%eax
   11dce:	83 ec 0c             	sub    $0xc,%esp
   11dd1:	50                   	push   %eax
   11dd2:	e8 80 fb ff ff       	call   11957 <ilog2i>
   11dd7:	83 c4 10             	add    $0x10,%esp
   11dda:	01 45 c8             	add    %eax,-0x38(%ebp)
          size_t sum = 0;
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
          lodepng_memset(count, 0, 256 * sizeof(*count));
          for(x = 0; x != linebytes; ++x) ++count[attempt[type][x]];
          ++count[type]; /*the filter type itself is part of the scanline*/
          for(x = 0; x != 256; ++x) {
   11ddd:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11de1:	81 7d f0 00 01 00 00 	cmpl   $0x100,-0x10(%ebp)
   11de8:	75 da                	jne    11dc4 <filter+0x421>
            sum += ilog2i(count[x]);
          }
          /*check if this is smallest sum (or if type == 0 it's the first case so always store the values)*/
          if(type == 0 || sum > bestSum) {
   11dea:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
   11dee:	74 08                	je     11df8 <filter+0x455>
   11df0:	8b 45 c8             	mov    -0x38(%ebp),%eax
   11df3:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
   11df6:	7e 0c                	jle    11e04 <filter+0x461>
            bestType = type;
   11df8:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11dfb:	89 45 cc             	mov    %eax,-0x34(%ebp)
            bestSum = sum;
   11dfe:	8b 45 c8             	mov    -0x38(%ebp),%eax
   11e01:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   11e04:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
   11e08:	83 7d d0 05          	cmpl   $0x5,-0x30(%ebp)
   11e0c:	0f 85 02 ff ff ff    	jne    11d14 <filter+0x371>
            bestType = type;
            bestSum = sum;
          }
        }

        prevline = &in[y * linebytes];
   11e12:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11e15:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11e19:	89 c2                	mov    %eax,%edx
   11e1b:	8b 45 0c             	mov    0xc(%ebp),%eax
   11e1e:	01 d0                	add    %edx,%eax
   11e20:	89 45 f4             	mov    %eax,-0xc(%ebp)

        /*now fill the out values*/
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
   11e23:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11e26:	83 c0 01             	add    $0x1,%eax
   11e29:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11e2d:	89 c2                	mov    %eax,%edx
   11e2f:	8b 45 08             	mov    0x8(%ebp),%eax
   11e32:	01 d0                	add    %edx,%eax
   11e34:	8b 55 cc             	mov    -0x34(%ebp),%edx
   11e37:	88 10                	mov    %dl,(%eax)
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
   11e39:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11e40:	eb 31                	jmp    11e73 <filter+0x4d0>
   11e42:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11e45:	83 c0 01             	add    $0x1,%eax
   11e48:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11e4c:	89 c2                	mov    %eax,%edx
   11e4e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11e51:	01 d0                	add    %edx,%eax
   11e53:	8d 50 01             	lea    0x1(%eax),%edx
   11e56:	8b 45 08             	mov    0x8(%ebp),%eax
   11e59:	01 c2                	add    %eax,%edx
   11e5b:	8b 45 cc             	mov    -0x34(%ebp),%eax
   11e5e:	8b 8c 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%ecx
   11e65:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11e68:	01 c8                	add    %ecx,%eax
   11e6a:	0f b6 00             	movzbl (%eax),%eax
   11e6d:	88 02                	mov    %al,(%edx)
   11e6f:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11e73:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11e76:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11e79:	75 c7                	jne    11e42 <filter+0x49f>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
   11e7b:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   11e7f:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11e82:	3b 45 14             	cmp    0x14(%ebp),%eax
   11e85:	0f 85 7d fe ff ff    	jne    11d08 <filter+0x365>
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
      }
    }

    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
   11e8b:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
   11e92:	eb 1a                	jmp    11eae <filter+0x50b>
   11e94:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11e97:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
   11e9e:	83 ec 0c             	sub    $0xc,%esp
   11ea1:	50                   	push   %eax
   11ea2:	e8 7d 15 ff ff       	call   3424 <lodepng_free>
   11ea7:	83 c4 10             	add    $0x10,%esp
   11eaa:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
   11eae:	83 7d d0 05          	cmpl   $0x5,-0x30(%ebp)
   11eb2:	75 e0                	jne    11e94 <filter+0x4f1>
   11eb4:	e9 c9 02 00 00       	jmp    12182 <filter+0x7df>
  } else if(strategy == LFS_PREDEFINED) {
   11eb9:	83 7d e4 08          	cmpl   $0x8,-0x1c(%ebp)
   11ebd:	0f 85 89 00 00 00    	jne    11f4c <filter+0x5a9>
    for(y = 0; y != h; ++y) {
   11ec3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   11eca:	eb 73                	jmp    11f3f <filter+0x59c>
      size_t outindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
   11ecc:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11ecf:	83 c0 01             	add    $0x1,%eax
   11ed2:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11ed6:	89 45 a8             	mov    %eax,-0x58(%ebp)
      size_t inindex = linebytes * y;
   11ed9:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11edc:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11ee0:	89 45 a4             	mov    %eax,-0x5c(%ebp)
      unsigned char type = settings->predefined_filters[y];
   11ee3:	8b 45 1c             	mov    0x1c(%ebp),%eax
   11ee6:	8b 50 30             	mov    0x30(%eax),%edx
   11ee9:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11eec:	01 d0                	add    %edx,%eax
   11eee:	0f b6 00             	movzbl (%eax),%eax
   11ef1:	88 45 a3             	mov    %al,-0x5d(%ebp)
      out[outindex] = type; /*filter type byte*/
   11ef4:	8b 55 a8             	mov    -0x58(%ebp),%edx
   11ef7:	8b 45 08             	mov    0x8(%ebp),%eax
   11efa:	01 c2                	add    %eax,%edx
   11efc:	0f b6 45 a3          	movzbl -0x5d(%ebp),%eax
   11f00:	88 02                	mov    %al,(%edx)
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
   11f02:	0f b6 45 a3          	movzbl -0x5d(%ebp),%eax
   11f06:	8b 4d a4             	mov    -0x5c(%ebp),%ecx
   11f09:	8b 55 0c             	mov    0xc(%ebp),%edx
   11f0c:	01 d1                	add    %edx,%ecx
   11f0e:	8b 55 a8             	mov    -0x58(%ebp),%edx
   11f11:	8d 5a 01             	lea    0x1(%edx),%ebx
   11f14:	8b 55 08             	mov    0x8(%ebp),%edx
   11f17:	01 da                	add    %ebx,%edx
   11f19:	83 ec 08             	sub    $0x8,%esp
   11f1c:	50                   	push   %eax
   11f1d:	ff 75 b0             	pushl  -0x50(%ebp)
   11f20:	ff 75 b4             	pushl  -0x4c(%ebp)
   11f23:	ff 75 f4             	pushl  -0xc(%ebp)
   11f26:	51                   	push   %ecx
   11f27:	52                   	push   %edx
   11f28:	e8 6c f6 ff ff       	call   11599 <filterScanline>
   11f2d:	83 c4 20             	add    $0x20,%esp
      prevline = &in[inindex];
   11f30:	8b 55 a4             	mov    -0x5c(%ebp),%edx
   11f33:	8b 45 0c             	mov    0xc(%ebp),%eax
   11f36:	01 d0                	add    %edx,%eax
   11f38:	89 45 f4             	mov    %eax,-0xc(%ebp)
      }
    }

    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
  } else if(strategy == LFS_PREDEFINED) {
    for(y = 0; y != h; ++y) {
   11f3b:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   11f3f:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11f42:	3b 45 14             	cmp    0x14(%ebp),%eax
   11f45:	75 85                	jne    11ecc <filter+0x529>
   11f47:	e9 36 02 00 00       	jmp    12182 <filter+0x7df>
      unsigned char type = settings->predefined_filters[y];
      out[outindex] = type; /*filter type byte*/
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
      prevline = &in[inindex];
    }
  } else if(strategy == LFS_BRUTE_FORCE) {
   11f4c:	83 7d e4 07          	cmpl   $0x7,-0x1c(%ebp)
   11f50:	0f 85 25 02 00 00    	jne    1217b <filter+0x7d8>
    /*brute force filter chooser.
    deflate the scanline after every filter attempt to see which one deflates best.
    This is very slow and gives only slightly smaller, sometimes even larger, result*/
    size_t size[5];
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
   11f56:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
    unsigned type = 0, bestType = 0;
   11f5d:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   11f64:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
    unsigned char* dummy;
    LodePNGCompressSettings zlibsettings;
    lodepng_memcpy(&zlibsettings, &settings->zlibsettings, sizeof(LodePNGCompressSettings));
   11f6b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   11f6e:	83 ec 04             	sub    $0x4,%esp
   11f71:	6a 24                	push   $0x24
   11f73:	50                   	push   %eax
   11f74:	8d 85 44 fb ff ff    	lea    -0x4bc(%ebp),%eax
   11f7a:	50                   	push   %eax
   11f7b:	e8 c1 14 ff ff       	call   3441 <lodepng_memcpy>
   11f80:	83 c4 10             	add    $0x10,%esp
    /*use fixed tree on the attempts so that the tree is not adapted to the filtertype on purpose,
    to simulate the true case where the tree is the same for the whole image. Sometimes it gives
    better result with dynamic tree anyway. Using the fixed tree sometimes gives worse, but in rare
    cases better compression. It does make this a bit less slow, so it's worth doing this.*/
    zlibsettings.btype = 1;
   11f83:	c7 85 44 fb ff ff 01 	movl   $0x1,-0x4bc(%ebp)
   11f8a:	00 00 00 
    /*a custom encoder likely doesn't read the btype setting and is optimized for complete PNG
    images only, so disable it*/
    zlibsettings.custom_zlib = 0;
   11f8d:	c7 85 5c fb ff ff 00 	movl   $0x0,-0x4a4(%ebp)
   11f94:	00 00 00 
    zlibsettings.custom_deflate = 0;
   11f97:	c7 85 60 fb ff ff 00 	movl   $0x0,-0x4a0(%ebp)
   11f9e:	00 00 00 
    for(type = 0; type != 5; ++type) {
   11fa1:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   11fa8:	eb 33                	jmp    11fdd <filter+0x63a>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
   11faa:	83 ec 0c             	sub    $0xc,%esp
   11fad:	ff 75 b4             	pushl  -0x4c(%ebp)
   11fb0:	e8 4e 14 ff ff       	call   3403 <lodepng_malloc>
   11fb5:	83 c4 10             	add    $0x10,%esp
   11fb8:	89 c2                	mov    %eax,%edx
   11fba:	8b 45 c0             	mov    -0x40(%ebp),%eax
   11fbd:	89 94 85 48 ff ff ff 	mov    %edx,-0xb8(%ebp,%eax,4)
      if(!attempt[type]) error = 83; /*alloc fail*/
   11fc4:	8b 45 c0             	mov    -0x40(%ebp),%eax
   11fc7:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   11fce:	85 c0                	test   %eax,%eax
   11fd0:	75 07                	jne    11fd9 <filter+0x636>
   11fd2:	c7 45 e8 53 00 00 00 	movl   $0x53,-0x18(%ebp)
    zlibsettings.btype = 1;
    /*a custom encoder likely doesn't read the btype setting and is optimized for complete PNG
    images only, so disable it*/
    zlibsettings.custom_zlib = 0;
    zlibsettings.custom_deflate = 0;
    for(type = 0; type != 5; ++type) {
   11fd9:	83 45 c0 01          	addl   $0x1,-0x40(%ebp)
   11fdd:	83 7d c0 05          	cmpl   $0x5,-0x40(%ebp)
   11fe1:	75 c7                	jne    11faa <filter+0x607>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }
    if(!error) {
   11fe3:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   11fe7:	0f 85 63 01 00 00    	jne    12150 <filter+0x7ad>
      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {
   11fed:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   11ff4:	e9 4b 01 00 00       	jmp    12144 <filter+0x7a1>
        for(type = 0; type != 5; ++type) {
   11ff9:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   12000:	e9 c8 00 00 00       	jmp    120cd <filter+0x72a>
          unsigned testsize = (unsigned)linebytes;
   12005:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12008:	89 45 ac             	mov    %eax,-0x54(%ebp)
          /*if(testsize > 8) testsize /= 8;*/ /*it already works good enough by testing a part of the row*/

          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
   1200b:	8b 45 c0             	mov    -0x40(%ebp),%eax
   1200e:	0f b6 d0             	movzbl %al,%edx
   12011:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12014:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   12018:	89 c1                	mov    %eax,%ecx
   1201a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1201d:	01 c1                	add    %eax,%ecx
   1201f:	8b 45 c0             	mov    -0x40(%ebp),%eax
   12022:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   12029:	83 ec 08             	sub    $0x8,%esp
   1202c:	52                   	push   %edx
   1202d:	ff 75 b0             	pushl  -0x50(%ebp)
   12030:	ff 75 b4             	pushl  -0x4c(%ebp)
   12033:	ff 75 f4             	pushl  -0xc(%ebp)
   12036:	51                   	push   %ecx
   12037:	50                   	push   %eax
   12038:	e8 5c f5 ff ff       	call   11599 <filterScanline>
   1203d:	83 c4 20             	add    $0x20,%esp
          size[type] = 0;
   12040:	8b 45 c0             	mov    -0x40(%ebp),%eax
   12043:	c7 84 85 5c ff ff ff 	movl   $0x0,-0xa4(%ebp,%eax,4)
   1204a:	00 00 00 00 
          dummy = 0;
   1204e:	c7 85 44 ff ff ff 00 	movl   $0x0,-0xbc(%ebp)
   12055:	00 00 00 
          zlib_compress(&dummy, &size[type], attempt[type], testsize, &zlibsettings);
   12058:	8b 55 ac             	mov    -0x54(%ebp),%edx
   1205b:	8b 45 c0             	mov    -0x40(%ebp),%eax
   1205e:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   12065:	8d 8d 5c ff ff ff    	lea    -0xa4(%ebp),%ecx
   1206b:	8b 5d c0             	mov    -0x40(%ebp),%ebx
   1206e:	c1 e3 02             	shl    $0x2,%ebx
   12071:	01 cb                	add    %ecx,%ebx
   12073:	83 ec 0c             	sub    $0xc,%esp
   12076:	8d 8d 44 fb ff ff    	lea    -0x4bc(%ebp),%ecx
   1207c:	51                   	push   %ecx
   1207d:	52                   	push   %edx
   1207e:	50                   	push   %eax
   1207f:	53                   	push   %ebx
   12080:	8d 85 44 ff ff ff    	lea    -0xbc(%ebp),%eax
   12086:	50                   	push   %eax
   12087:	e8 87 60 ff ff       	call   8113 <zlib_compress>
   1208c:	83 c4 20             	add    $0x20,%esp
          lodepng_free(dummy);
   1208f:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
   12095:	83 ec 0c             	sub    $0xc,%esp
   12098:	50                   	push   %eax
   12099:	e8 86 13 ff ff       	call   3424 <lodepng_free>
   1209e:	83 c4 10             	add    $0x10,%esp
          /*check if this is smallest size (or if type == 0 it's the first case so always store the values)*/
          if(type == 0 || size[type] < smallest) {
   120a1:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
   120a5:	74 0f                	je     120b6 <filter+0x713>
   120a7:	8b 45 c0             	mov    -0x40(%ebp),%eax
   120aa:	8b 84 85 5c ff ff ff 	mov    -0xa4(%ebp,%eax,4),%eax
   120b1:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
   120b4:	7d 13                	jge    120c9 <filter+0x726>
            bestType = type;
   120b6:	8b 45 c0             	mov    -0x40(%ebp),%eax
   120b9:	89 45 bc             	mov    %eax,-0x44(%ebp)
            smallest = size[type];
   120bc:	8b 45 c0             	mov    -0x40(%ebp),%eax
   120bf:	8b 84 85 5c ff ff ff 	mov    -0xa4(%ebp,%eax,4),%eax
   120c6:	89 45 c4             	mov    %eax,-0x3c(%ebp)
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }
    if(!error) {
      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {
        for(type = 0; type != 5; ++type) {
   120c9:	83 45 c0 01          	addl   $0x1,-0x40(%ebp)
   120cd:	83 7d c0 05          	cmpl   $0x5,-0x40(%ebp)
   120d1:	0f 85 2e ff ff ff    	jne    12005 <filter+0x662>
          if(type == 0 || size[type] < smallest) {
            bestType = type;
            smallest = size[type];
          }
        }
        prevline = &in[y * linebytes];
   120d7:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   120da:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   120de:	89 c2                	mov    %eax,%edx
   120e0:	8b 45 0c             	mov    0xc(%ebp),%eax
   120e3:	01 d0                	add    %edx,%eax
   120e5:	89 45 f4             	mov    %eax,-0xc(%ebp)
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
   120e8:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   120eb:	83 c0 01             	add    $0x1,%eax
   120ee:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   120f2:	89 c2                	mov    %eax,%edx
   120f4:	8b 45 08             	mov    0x8(%ebp),%eax
   120f7:	01 d0                	add    %edx,%eax
   120f9:	8b 55 bc             	mov    -0x44(%ebp),%edx
   120fc:	88 10                	mov    %dl,(%eax)
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
   120fe:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   12105:	eb 31                	jmp    12138 <filter+0x795>
   12107:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   1210a:	83 c0 01             	add    $0x1,%eax
   1210d:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   12111:	89 c2                	mov    %eax,%edx
   12113:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12116:	01 d0                	add    %edx,%eax
   12118:	8d 50 01             	lea    0x1(%eax),%edx
   1211b:	8b 45 08             	mov    0x8(%ebp),%eax
   1211e:	01 c2                	add    %eax,%edx
   12120:	8b 45 bc             	mov    -0x44(%ebp),%eax
   12123:	8b 8c 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%ecx
   1212a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1212d:	01 c8                	add    %ecx,%eax
   1212f:	0f b6 00             	movzbl (%eax),%eax
   12132:	88 02                	mov    %al,(%edx)
   12134:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   12138:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   1213b:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   1213e:	75 c7                	jne    12107 <filter+0x764>
    for(type = 0; type != 5; ++type) {
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }
    if(!error) {
      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {
   12140:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   12144:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12147:	3b 45 14             	cmp    0x14(%ebp),%eax
   1214a:	0f 85 a9 fe ff ff    	jne    11ff9 <filter+0x656>
        prevline = &in[y * linebytes];
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
      }
    }
    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
   12150:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   12157:	eb 1a                	jmp    12173 <filter+0x7d0>
   12159:	8b 45 c0             	mov    -0x40(%ebp),%eax
   1215c:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   12163:	83 ec 0c             	sub    $0xc,%esp
   12166:	50                   	push   %eax
   12167:	e8 b8 12 ff ff       	call   3424 <lodepng_free>
   1216c:	83 c4 10             	add    $0x10,%esp
   1216f:	83 45 c0 01          	addl   $0x1,-0x40(%ebp)
   12173:	83 7d c0 05          	cmpl   $0x5,-0x40(%ebp)
   12177:	75 e0                	jne    12159 <filter+0x7b6>
   12179:	eb 07                	jmp    12182 <filter+0x7df>
  }
  else return 88; /* unknown filter strategy */
   1217b:	b8 58 00 00 00       	mov    $0x58,%eax
   12180:	eb 03                	jmp    12185 <filter+0x7e2>

  return error;
   12182:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
   12185:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   12188:	c9                   	leave  
   12189:	c3                   	ret    

0001218a <addPaddingBits>:

static void addPaddingBits(unsigned char* out, const unsigned char* in,
                           size_t olinebits, size_t ilinebits, unsigned h) {
   1218a:	55                   	push   %ebp
   1218b:	89 e5                	mov    %esp,%ebp
   1218d:	83 ec 20             	sub    $0x20,%esp
  /*The opposite of the removePaddingBits function
  olinebits must be >= ilinebits*/
  unsigned y;
  size_t diff = olinebits - ilinebits;
   12190:	8b 45 10             	mov    0x10(%ebp),%eax
   12193:	2b 45 14             	sub    0x14(%ebp),%eax
   12196:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t obp = 0, ibp = 0; /*bit pointers*/
   12199:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   121a0:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  for(y = 0; y != h; ++y) {
   121a7:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   121ae:	eb 65                	jmp    12215 <addPaddingBits+0x8b>
    size_t x;
    for(x = 0; x < ilinebits; ++x) {
   121b0:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   121b7:	eb 2a                	jmp    121e3 <addPaddingBits+0x59>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
   121b9:	ff 75 0c             	pushl  0xc(%ebp)
   121bc:	8d 45 e8             	lea    -0x18(%ebp),%eax
   121bf:	50                   	push   %eax
   121c0:	e8 9d 60 ff ff       	call   8262 <readBitFromReversedStream>
   121c5:	83 c4 08             	add    $0x8,%esp
   121c8:	88 45 f3             	mov    %al,-0xd(%ebp)
      setBitOfReversedStream(&obp, out, bit);
   121cb:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
   121cf:	50                   	push   %eax
   121d0:	ff 75 08             	pushl  0x8(%ebp)
   121d3:	8d 45 ec             	lea    -0x14(%ebp),%eax
   121d6:	50                   	push   %eax
   121d7:	e8 08 61 ff ff       	call   82e4 <setBitOfReversedStream>
   121dc:	83 c4 0c             	add    $0xc,%esp
  unsigned y;
  size_t diff = olinebits - ilinebits;
  size_t obp = 0, ibp = 0; /*bit pointers*/
  for(y = 0; y != h; ++y) {
    size_t x;
    for(x = 0; x < ilinebits; ++x) {
   121df:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   121e3:	8b 45 f8             	mov    -0x8(%ebp),%eax
   121e6:	3b 45 14             	cmp    0x14(%ebp),%eax
   121e9:	7c ce                	jl     121b9 <addPaddingBits+0x2f>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    /*obp += diff; --> no, fill in some value in the padding bits too, to avoid
    "Use of uninitialised value of size ###" warning from valgrind*/
    for(x = 0; x != diff; ++x) setBitOfReversedStream(&obp, out, 0);
   121eb:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   121f2:	eb 15                	jmp    12209 <addPaddingBits+0x7f>
   121f4:	6a 00                	push   $0x0
   121f6:	ff 75 08             	pushl  0x8(%ebp)
   121f9:	8d 45 ec             	lea    -0x14(%ebp),%eax
   121fc:	50                   	push   %eax
   121fd:	e8 e2 60 ff ff       	call   82e4 <setBitOfReversedStream>
   12202:	83 c4 0c             	add    $0xc,%esp
   12205:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   12209:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1220c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   1220f:	75 e3                	jne    121f4 <addPaddingBits+0x6a>
  /*The opposite of the removePaddingBits function
  olinebits must be >= ilinebits*/
  unsigned y;
  size_t diff = olinebits - ilinebits;
  size_t obp = 0, ibp = 0; /*bit pointers*/
  for(y = 0; y != h; ++y) {
   12211:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   12215:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12218:	3b 45 18             	cmp    0x18(%ebp),%eax
   1221b:	75 93                	jne    121b0 <addPaddingBits+0x26>
    }
    /*obp += diff; --> no, fill in some value in the padding bits too, to avoid
    "Use of uninitialised value of size ###" warning from valgrind*/
    for(x = 0; x != diff; ++x) setBitOfReversedStream(&obp, out, 0);
  }
}
   1221d:	90                   	nop
   1221e:	c9                   	leave  
   1221f:	c3                   	ret    

00012220 <Adam7_interlace>:
there are no padding bits, not between scanlines, not between reduced images
in has the following size in bits: w * h * bpp.
out is possibly bigger due to padding bits between reduced images
NOTE: comments about padding bits are only relevant if bpp < 8
*/
static void Adam7_interlace(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {
   12220:	55                   	push   %ebp
   12221:	89 e5                	mov    %esp,%ebp
   12223:	81 ec e0 00 00 00    	sub    $0xe0,%esp
  unsigned passw[7], passh[7];
  size_t filter_passstart[8], padded_passstart[8], passstart[8];
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
   12229:	ff 75 18             	pushl  0x18(%ebp)
   1222c:	ff 75 14             	pushl  0x14(%ebp)
   1222f:	ff 75 10             	pushl  0x10(%ebp)
   12232:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
   12238:	50                   	push   %eax
   12239:	8d 85 54 ff ff ff    	lea    -0xac(%ebp),%eax
   1223f:	50                   	push   %eax
   12240:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
   12246:	50                   	push   %eax
   12247:	8d 45 94             	lea    -0x6c(%ebp),%eax
   1224a:	50                   	push   %eax
   1224b:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1224e:	50                   	push   %eax
   1224f:	e8 fc ae ff ff       	call   d150 <Adam7_getpassvalues>
   12254:	83 c4 20             	add    $0x20,%esp

  if(bpp >= 8) {
   12257:	83 7d 18 07          	cmpl   $0x7,0x18(%ebp)
   1225b:	0f 86 0a 01 00 00    	jbe    1236b <Adam7_interlace+0x14b>
    for(i = 0; i != 7; ++i) {
   12261:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   12268:	e9 ef 00 00 00       	jmp    1235c <Adam7_interlace+0x13c>
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
   1226d:	8b 45 18             	mov    0x18(%ebp),%eax
   12270:	c1 e8 03             	shr    $0x3,%eax
   12273:	89 45 e0             	mov    %eax,-0x20(%ebp)
      for(y = 0; y < passh[i]; ++y)
   12276:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1227d:	e9 c6 00 00 00       	jmp    12348 <Adam7_interlace+0x128>
      for(x = 0; x < passw[i]; ++x) {
   12282:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   12289:	e9 a6 00 00 00       	jmp    12334 <Adam7_interlace+0x114>
        size_t pixelinstart = ((ADAM7_IY[i] + y * ADAM7_DY[i]) * w + ADAM7_IX[i] + x * ADAM7_DX[i]) * bytewidth;
   1228e:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12291:	8b 14 85 d8 a0 01 00 	mov    0x1a0d8(,%eax,4),%edx
   12298:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1229b:	8b 04 85 10 a1 01 00 	mov    0x1a110(,%eax,4),%eax
   122a2:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   122a6:	01 d0                	add    %edx,%eax
   122a8:	0f af 45 10          	imul   0x10(%ebp),%eax
   122ac:	89 c2                	mov    %eax,%edx
   122ae:	8b 45 fc             	mov    -0x4(%ebp),%eax
   122b1:	8b 04 85 f4 a0 01 00 	mov    0x1a0f4(,%eax,4),%eax
   122b8:	0f af 45 f8          	imul   -0x8(%ebp),%eax
   122bc:	01 c2                	add    %eax,%edx
   122be:	8b 45 fc             	mov    -0x4(%ebp),%eax
   122c1:	8b 04 85 bc a0 01 00 	mov    0x1a0bc(,%eax,4),%eax
   122c8:	01 c2                	add    %eax,%edx
   122ca:	8b 45 e0             	mov    -0x20(%ebp),%eax
   122cd:	0f af c2             	imul   %edx,%eax
   122d0:	89 45 dc             	mov    %eax,-0x24(%ebp)
        size_t pixeloutstart = passstart[i] + (y * passw[i] + x) * bytewidth;
   122d3:	8b 45 fc             	mov    -0x4(%ebp),%eax
   122d6:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
   122dd:	89 c1                	mov    %eax,%ecx
   122df:	8b 45 fc             	mov    -0x4(%ebp),%eax
   122e2:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   122e6:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   122ea:	89 c2                	mov    %eax,%edx
   122ec:	8b 45 f8             	mov    -0x8(%ebp),%eax
   122ef:	01 c2                	add    %eax,%edx
   122f1:	8b 45 e0             	mov    -0x20(%ebp),%eax
   122f4:	0f af c2             	imul   %edx,%eax
   122f7:	01 c8                	add    %ecx,%eax
   122f9:	89 45 d8             	mov    %eax,-0x28(%ebp)
        for(b = 0; b < bytewidth; ++b) {
   122fc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   12303:	eb 23                	jmp    12328 <Adam7_interlace+0x108>
          out[pixeloutstart + b] = in[pixelinstart + b];
   12305:	8b 55 d8             	mov    -0x28(%ebp),%edx
   12308:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1230b:	01 c2                	add    %eax,%edx
   1230d:	8b 45 08             	mov    0x8(%ebp),%eax
   12310:	01 c2                	add    %eax,%edx
   12312:	8b 4d dc             	mov    -0x24(%ebp),%ecx
   12315:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12318:	01 c1                	add    %eax,%ecx
   1231a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1231d:	01 c8                	add    %ecx,%eax
   1231f:	0f b6 00             	movzbl (%eax),%eax
   12322:	88 02                	mov    %al,(%edx)
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        size_t pixelinstart = ((ADAM7_IY[i] + y * ADAM7_DY[i]) * w + ADAM7_IX[i] + x * ADAM7_DX[i]) * bytewidth;
        size_t pixeloutstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        for(b = 0; b < bytewidth; ++b) {
   12324:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   12328:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1232b:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   1232e:	72 d5                	jb     12305 <Adam7_interlace+0xe5>
  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
   12330:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   12334:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12337:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   1233b:	3b 45 f8             	cmp    -0x8(%ebp),%eax
   1233e:	0f 87 4a ff ff ff    	ja     1228e <Adam7_interlace+0x6e>

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
   12344:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   12348:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1234b:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
   1234f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   12352:	0f 87 2a ff ff ff    	ja     12282 <Adam7_interlace+0x62>
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
   12358:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   1235c:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
   12360:	0f 85 07 ff ff ff    	jne    1226d <Adam7_interlace+0x4d>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
   12366:	e9 22 01 00 00       	jmp    1248d <Adam7_interlace+0x26d>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
   1236b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   12372:	e9 0c 01 00 00       	jmp    12483 <Adam7_interlace+0x263>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
   12377:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1237a:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   1237e:	0f af 45 18          	imul   0x18(%ebp),%eax
   12382:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      unsigned olinebits = bpp * w;
   12385:	8b 45 18             	mov    0x18(%ebp),%eax
   12388:	0f af 45 10          	imul   0x10(%ebp),%eax
   1238c:	89 45 d0             	mov    %eax,-0x30(%ebp)
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
   1238f:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   12396:	e9 d4 00 00 00       	jmp    1246f <Adam7_interlace+0x24f>
      for(x = 0; x < passw[i]; ++x) {
   1239b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   123a2:	e9 b4 00 00 00       	jmp    1245b <Adam7_interlace+0x23b>
        ibp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;
   123a7:	8b 45 fc             	mov    -0x4(%ebp),%eax
   123aa:	8b 14 85 d8 a0 01 00 	mov    0x1a0d8(,%eax,4),%edx
   123b1:	8b 45 fc             	mov    -0x4(%ebp),%eax
   123b4:	8b 04 85 10 a1 01 00 	mov    0x1a110(,%eax,4),%eax
   123bb:	0f af 45 e8          	imul   -0x18(%ebp),%eax
   123bf:	01 d0                	add    %edx,%eax
   123c1:	0f af 45 d0          	imul   -0x30(%ebp),%eax
   123c5:	89 c2                	mov    %eax,%edx
   123c7:	8b 45 fc             	mov    -0x4(%ebp),%eax
   123ca:	8b 0c 85 bc a0 01 00 	mov    0x1a0bc(,%eax,4),%ecx
   123d1:	8b 45 fc             	mov    -0x4(%ebp),%eax
   123d4:	8b 04 85 f4 a0 01 00 	mov    0x1a0f4(,%eax,4),%eax
   123db:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   123df:	01 c8                	add    %ecx,%eax
   123e1:	0f af 45 18          	imul   0x18(%ebp),%eax
   123e5:	01 d0                	add    %edx,%eax
   123e7:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
        obp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
   123ed:	8b 45 fc             	mov    -0x4(%ebp),%eax
   123f0:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
   123f7:	c1 e0 03             	shl    $0x3,%eax
   123fa:	89 c1                	mov    %eax,%ecx
   123fc:	8b 45 e8             	mov    -0x18(%ebp),%eax
   123ff:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
   12403:	89 c2                	mov    %eax,%edx
   12405:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12408:	0f af 45 18          	imul   0x18(%ebp),%eax
   1240c:	01 d0                	add    %edx,%eax
   1240e:	01 c8                	add    %ecx,%eax
   12410:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
        for(b = 0; b < bpp; ++b) {
   12416:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   1241d:	eb 30                	jmp    1244f <Adam7_interlace+0x22f>
          unsigned char bit = readBitFromReversedStream(&ibp, in);
   1241f:	ff 75 0c             	pushl  0xc(%ebp)
   12422:	8d 85 2c ff ff ff    	lea    -0xd4(%ebp),%eax
   12428:	50                   	push   %eax
   12429:	e8 34 5e ff ff       	call   8262 <readBitFromReversedStream>
   1242e:	83 c4 08             	add    $0x8,%esp
   12431:	88 45 cf             	mov    %al,-0x31(%ebp)
          setBitOfReversedStream(&obp, out, bit);
   12434:	0f b6 45 cf          	movzbl -0x31(%ebp),%eax
   12438:	50                   	push   %eax
   12439:	ff 75 08             	pushl  0x8(%ebp)
   1243c:	8d 85 30 ff ff ff    	lea    -0xd0(%ebp),%eax
   12442:	50                   	push   %eax
   12443:	e8 9c 5e ff ff       	call   82e4 <setBitOfReversedStream>
   12448:	83 c4 0c             	add    $0xc,%esp
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        ibp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;
        obp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
        for(b = 0; b < bpp; ++b) {
   1244b:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   1244f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   12452:	3b 45 18             	cmp    0x18(%ebp),%eax
   12455:	72 c8                	jb     1241f <Adam7_interlace+0x1ff>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
   12457:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   1245b:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1245e:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   12462:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   12465:	0f 87 3c ff ff ff    	ja     123a7 <Adam7_interlace+0x187>
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
   1246b:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   1246f:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12472:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
   12476:	3b 45 e8             	cmp    -0x18(%ebp),%eax
   12479:	0f 87 1c ff ff ff    	ja     1239b <Adam7_interlace+0x17b>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
   1247f:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   12483:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
   12487:	0f 85 ea fe ff ff    	jne    12377 <Adam7_interlace+0x157>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
   1248d:	90                   	nop
   1248e:	c9                   	leave  
   1248f:	c3                   	ret    

00012490 <preProcessScanlines>:

/*out must be buffer big enough to contain uncompressed IDAT chunk data, and in must contain the full image.
return value is error**/
static unsigned preProcessScanlines(unsigned char** out, size_t* outsize, const unsigned char* in,
                                    unsigned w, unsigned h,
                                    const LodePNGInfo* info_png, const LodePNGEncoderSettings* settings) {
   12490:	55                   	push   %ebp
   12491:	89 e5                	mov    %esp,%ebp
   12493:	57                   	push   %edi
   12494:	56                   	push   %esi
   12495:	53                   	push   %ebx
   12496:	81 ec bc 00 00 00    	sub    $0xbc,%esp
  /*
  This function converts the pure 2D image with the PNG's colortype, into filtered-padded-interlaced data. Steps:
  *) if no Adam7: 1) add padding bits (= possible extra bits per scanline if bpp < 8) 2) filter
  *) if adam7: 1) Adam7_interlace 2) 7x add padding bits 3) 7x filter
  */
  unsigned bpp = lodepng_get_bpp(&info_png->color);
   1249c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1249f:	83 c0 0c             	add    $0xc,%eax
   124a2:	50                   	push   %eax
   124a3:	e8 77 6a ff ff       	call   8f1f <lodepng_get_bpp>
   124a8:	83 c4 04             	add    $0x4,%esp
   124ab:	89 45 dc             	mov    %eax,-0x24(%ebp)
  unsigned error = 0;
   124ae:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

  if(info_png->interlace_method == 0) {
   124b5:	8b 45 1c             	mov    0x1c(%ebp),%eax
   124b8:	8b 40 08             	mov    0x8(%eax),%eax
   124bb:	85 c0                	test   %eax,%eax
   124bd:	0f 85 49 01 00 00    	jne    1260c <preProcessScanlines+0x17c>
    *outsize = h + (h * ((w * bpp + 7u) / 8u)); /*image size plus an extra byte per scanline + possible padding bits*/
   124c3:	8b 45 14             	mov    0x14(%ebp),%eax
   124c6:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   124ca:	83 c0 07             	add    $0x7,%eax
   124cd:	c1 e8 03             	shr    $0x3,%eax
   124d0:	83 c0 01             	add    $0x1,%eax
   124d3:	0f af 45 18          	imul   0x18(%ebp),%eax
   124d7:	89 c2                	mov    %eax,%edx
   124d9:	8b 45 0c             	mov    0xc(%ebp),%eax
   124dc:	89 10                	mov    %edx,(%eax)
    *out = (unsigned char*)lodepng_malloc(*outsize);
   124de:	8b 45 0c             	mov    0xc(%ebp),%eax
   124e1:	8b 00                	mov    (%eax),%eax
   124e3:	83 ec 0c             	sub    $0xc,%esp
   124e6:	50                   	push   %eax
   124e7:	e8 17 0f ff ff       	call   3403 <lodepng_malloc>
   124ec:	83 c4 10             	add    $0x10,%esp
   124ef:	89 c2                	mov    %eax,%edx
   124f1:	8b 45 08             	mov    0x8(%ebp),%eax
   124f4:	89 10                	mov    %edx,(%eax)
    if(!(*out) && (*outsize)) error = 83; /*alloc fail*/
   124f6:	8b 45 08             	mov    0x8(%ebp),%eax
   124f9:	8b 00                	mov    (%eax),%eax
   124fb:	85 c0                	test   %eax,%eax
   124fd:	75 10                	jne    1250f <preProcessScanlines+0x7f>
   124ff:	8b 45 0c             	mov    0xc(%ebp),%eax
   12502:	8b 00                	mov    (%eax),%eax
   12504:	85 c0                	test   %eax,%eax
   12506:	74 07                	je     1250f <preProcessScanlines+0x7f>
   12508:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)

    if(!error) {
   1250f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   12513:	0f 85 fb 02 00 00    	jne    12814 <preProcessScanlines+0x384>
      /*non multiple of 8 bits per scanline, padding bits needed per scanline*/
      if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {
   12519:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
   1251d:	0f 87 bd 00 00 00    	ja     125e0 <preProcessScanlines+0x150>
   12523:	8b 45 14             	mov    0x14(%ebp),%eax
   12526:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   1252a:	89 c2                	mov    %eax,%edx
   1252c:	8b 45 14             	mov    0x14(%ebp),%eax
   1252f:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   12533:	83 c0 07             	add    $0x7,%eax
   12536:	c1 e8 03             	shr    $0x3,%eax
   12539:	c1 e0 03             	shl    $0x3,%eax
   1253c:	39 c2                	cmp    %eax,%edx
   1253e:	0f 84 9c 00 00 00    	je     125e0 <preProcessScanlines+0x150>
        unsigned char* padded = (unsigned char*)lodepng_malloc(h * ((w * bpp + 7u) / 8u));
   12544:	8b 45 14             	mov    0x14(%ebp),%eax
   12547:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   1254b:	83 c0 07             	add    $0x7,%eax
   1254e:	c1 e8 03             	shr    $0x3,%eax
   12551:	0f af 45 18          	imul   0x18(%ebp),%eax
   12555:	83 ec 0c             	sub    $0xc,%esp
   12558:	50                   	push   %eax
   12559:	e8 a5 0e ff ff       	call   3403 <lodepng_malloc>
   1255e:	83 c4 10             	add    $0x10,%esp
   12561:	89 45 d8             	mov    %eax,-0x28(%ebp)
        if(!padded) error = 83; /*alloc fail*/
   12564:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   12568:	75 07                	jne    12571 <preProcessScanlines+0xe1>
   1256a:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)
        if(!error) {
   12571:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   12575:	75 56                	jne    125cd <preProcessScanlines+0x13d>
          addPaddingBits(padded, in, ((w * bpp + 7u) / 8u) * 8u, w * bpp, h);
   12577:	8b 45 14             	mov    0x14(%ebp),%eax
   1257a:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   1257e:	89 c2                	mov    %eax,%edx
   12580:	8b 45 14             	mov    0x14(%ebp),%eax
   12583:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   12587:	83 c0 07             	add    $0x7,%eax
   1258a:	c1 e8 03             	shr    $0x3,%eax
   1258d:	c1 e0 03             	shl    $0x3,%eax
   12590:	83 ec 0c             	sub    $0xc,%esp
   12593:	ff 75 18             	pushl  0x18(%ebp)
   12596:	52                   	push   %edx
   12597:	50                   	push   %eax
   12598:	ff 75 10             	pushl  0x10(%ebp)
   1259b:	ff 75 d8             	pushl  -0x28(%ebp)
   1259e:	e8 e7 fb ff ff       	call   1218a <addPaddingBits>
   125a3:	83 c4 20             	add    $0x20,%esp
          error = filter(*out, padded, w, h, &info_png->color, settings);
   125a6:	8b 45 1c             	mov    0x1c(%ebp),%eax
   125a9:	8d 50 0c             	lea    0xc(%eax),%edx
   125ac:	8b 45 08             	mov    0x8(%ebp),%eax
   125af:	8b 00                	mov    (%eax),%eax
   125b1:	83 ec 08             	sub    $0x8,%esp
   125b4:	ff 75 20             	pushl  0x20(%ebp)
   125b7:	52                   	push   %edx
   125b8:	ff 75 18             	pushl  0x18(%ebp)
   125bb:	ff 75 14             	pushl  0x14(%ebp)
   125be:	ff 75 d8             	pushl  -0x28(%ebp)
   125c1:	50                   	push   %eax
   125c2:	e8 dc f3 ff ff       	call   119a3 <filter>
   125c7:	83 c4 20             	add    $0x20,%esp
   125ca:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        }
        lodepng_free(padded);
   125cd:	83 ec 0c             	sub    $0xc,%esp
   125d0:	ff 75 d8             	pushl  -0x28(%ebp)
   125d3:	e8 4c 0e ff ff       	call   3424 <lodepng_free>
   125d8:	83 c4 10             	add    $0x10,%esp
    *out = (unsigned char*)lodepng_malloc(*outsize);
    if(!(*out) && (*outsize)) error = 83; /*alloc fail*/

    if(!error) {
      /*non multiple of 8 bits per scanline, padding bits needed per scanline*/
      if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {
   125db:	e9 34 02 00 00       	jmp    12814 <preProcessScanlines+0x384>
          error = filter(*out, padded, w, h, &info_png->color, settings);
        }
        lodepng_free(padded);
      } else {
        /*we can immediately filter into the out buffer, no other steps needed*/
        error = filter(*out, in, w, h, &info_png->color, settings);
   125e0:	8b 45 1c             	mov    0x1c(%ebp),%eax
   125e3:	8d 50 0c             	lea    0xc(%eax),%edx
   125e6:	8b 45 08             	mov    0x8(%ebp),%eax
   125e9:	8b 00                	mov    (%eax),%eax
   125eb:	83 ec 08             	sub    $0x8,%esp
   125ee:	ff 75 20             	pushl  0x20(%ebp)
   125f1:	52                   	push   %edx
   125f2:	ff 75 18             	pushl  0x18(%ebp)
   125f5:	ff 75 14             	pushl  0x14(%ebp)
   125f8:	ff 75 10             	pushl  0x10(%ebp)
   125fb:	50                   	push   %eax
   125fc:	e8 a2 f3 ff ff       	call   119a3 <filter>
   12601:	83 c4 20             	add    $0x20,%esp
   12604:	89 45 e4             	mov    %eax,-0x1c(%ebp)
   12607:	e9 08 02 00 00       	jmp    12814 <preProcessScanlines+0x384>
  } else /*interlace_method is 1 (Adam7)*/ {
    unsigned passw[7], passh[7];
    size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned char* adam7;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
   1260c:	ff 75 dc             	pushl  -0x24(%ebp)
   1260f:	ff 75 18             	pushl  0x18(%ebp)
   12612:	ff 75 14             	pushl  0x14(%ebp)
   12615:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
   1261b:	50                   	push   %eax
   1261c:	8d 85 58 ff ff ff    	lea    -0xa8(%ebp),%eax
   12622:	50                   	push   %eax
   12623:	8d 85 38 ff ff ff    	lea    -0xc8(%ebp),%eax
   12629:	50                   	push   %eax
   1262a:	8d 45 98             	lea    -0x68(%ebp),%eax
   1262d:	50                   	push   %eax
   1262e:	8d 45 b4             	lea    -0x4c(%ebp),%eax
   12631:	50                   	push   %eax
   12632:	e8 19 ab ff ff       	call   d150 <Adam7_getpassvalues>
   12637:	83 c4 20             	add    $0x20,%esp

    *outsize = filter_passstart[7]; /*image size plus an extra byte per scanline + possible padding bits*/
   1263a:	8b 95 54 ff ff ff    	mov    -0xac(%ebp),%edx
   12640:	8b 45 0c             	mov    0xc(%ebp),%eax
   12643:	89 10                	mov    %edx,(%eax)
    *out = (unsigned char*)lodepng_malloc(*outsize);
   12645:	8b 45 0c             	mov    0xc(%ebp),%eax
   12648:	8b 00                	mov    (%eax),%eax
   1264a:	83 ec 0c             	sub    $0xc,%esp
   1264d:	50                   	push   %eax
   1264e:	e8 b0 0d ff ff       	call   3403 <lodepng_malloc>
   12653:	83 c4 10             	add    $0x10,%esp
   12656:	89 c2                	mov    %eax,%edx
   12658:	8b 45 08             	mov    0x8(%ebp),%eax
   1265b:	89 10                	mov    %edx,(%eax)
    if(!(*out)) error = 83; /*alloc fail*/
   1265d:	8b 45 08             	mov    0x8(%ebp),%eax
   12660:	8b 00                	mov    (%eax),%eax
   12662:	85 c0                	test   %eax,%eax
   12664:	75 07                	jne    1266d <preProcessScanlines+0x1dd>
   12666:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)

    adam7 = (unsigned char*)lodepng_malloc(passstart[7]);
   1266d:	8b 45 94             	mov    -0x6c(%ebp),%eax
   12670:	83 ec 0c             	sub    $0xc,%esp
   12673:	50                   	push   %eax
   12674:	e8 8a 0d ff ff       	call   3403 <lodepng_malloc>
   12679:	83 c4 10             	add    $0x10,%esp
   1267c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    if(!adam7 && passstart[7]) error = 83; /*alloc fail*/
   1267f:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
   12683:	75 0e                	jne    12693 <preProcessScanlines+0x203>
   12685:	8b 45 94             	mov    -0x6c(%ebp),%eax
   12688:	85 c0                	test   %eax,%eax
   1268a:	74 07                	je     12693 <preProcessScanlines+0x203>
   1268c:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)

    if(!error) {
   12693:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   12697:	0f 85 69 01 00 00    	jne    12806 <preProcessScanlines+0x376>
      unsigned i;

      Adam7_interlace(adam7, in, w, h, bpp);
   1269d:	83 ec 0c             	sub    $0xc,%esp
   126a0:	ff 75 dc             	pushl  -0x24(%ebp)
   126a3:	ff 75 18             	pushl  0x18(%ebp)
   126a6:	ff 75 14             	pushl  0x14(%ebp)
   126a9:	ff 75 10             	pushl  0x10(%ebp)
   126ac:	ff 75 d4             	pushl  -0x2c(%ebp)
   126af:	e8 6c fb ff ff       	call   12220 <Adam7_interlace>
   126b4:	83 c4 20             	add    $0x20,%esp
      for(i = 0; i != 7; ++i) {
   126b7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
   126be:	e9 36 01 00 00       	jmp    127f9 <preProcessScanlines+0x369>
        if(bpp < 8) {
   126c3:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
   126c7:	0f 87 d6 00 00 00    	ja     127a3 <preProcessScanlines+0x313>
          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
   126cd:	8b 45 e0             	mov    -0x20(%ebp),%eax
   126d0:	83 c0 01             	add    $0x1,%eax
   126d3:	8b 94 85 58 ff ff ff 	mov    -0xa8(%ebp,%eax,4),%edx
   126da:	8b 45 e0             	mov    -0x20(%ebp),%eax
   126dd:	8b 84 85 58 ff ff ff 	mov    -0xa8(%ebp,%eax,4),%eax
   126e4:	29 c2                	sub    %eax,%edx
   126e6:	89 d0                	mov    %edx,%eax
   126e8:	83 ec 0c             	sub    $0xc,%esp
   126eb:	50                   	push   %eax
   126ec:	e8 12 0d ff ff       	call   3403 <lodepng_malloc>
   126f1:	83 c4 10             	add    $0x10,%esp
   126f4:	89 45 d0             	mov    %eax,-0x30(%ebp)
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
   126f7:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
   126fb:	75 0c                	jne    12709 <preProcessScanlines+0x279>
   126fd:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)
   12704:	e9 fd 00 00 00       	jmp    12806 <preProcessScanlines+0x376>
          addPaddingBits(padded, &adam7[passstart[i]],
   12709:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1270c:	8b 44 85 98          	mov    -0x68(%ebp,%eax,4),%eax
                         ((passw[i] * bpp + 7u) / 8u) * 8u, passw[i] * bpp, passh[i]);
   12710:	8b 55 e0             	mov    -0x20(%ebp),%edx
   12713:	8b 54 95 b4          	mov    -0x4c(%ebp,%edx,4),%edx
   12717:	0f af 55 dc          	imul   -0x24(%ebp),%edx
      Adam7_interlace(adam7, in, w, h, bpp);
      for(i = 0; i != 7; ++i) {
        if(bpp < 8) {
          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
          addPaddingBits(padded, &adam7[passstart[i]],
   1271b:	89 d3                	mov    %edx,%ebx
                         ((passw[i] * bpp + 7u) / 8u) * 8u, passw[i] * bpp, passh[i]);
   1271d:	8b 55 e0             	mov    -0x20(%ebp),%edx
   12720:	8b 54 95 b4          	mov    -0x4c(%ebp,%edx,4),%edx
   12724:	0f af 55 dc          	imul   -0x24(%ebp),%edx
   12728:	83 c2 07             	add    $0x7,%edx
   1272b:	c1 ea 03             	shr    $0x3,%edx
   1272e:	c1 e2 03             	shl    $0x3,%edx
      Adam7_interlace(adam7, in, w, h, bpp);
      for(i = 0; i != 7; ++i) {
        if(bpp < 8) {
          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
          addPaddingBits(padded, &adam7[passstart[i]],
   12731:	89 d1                	mov    %edx,%ecx
   12733:	8b 55 e0             	mov    -0x20(%ebp),%edx
   12736:	8b 94 95 78 ff ff ff 	mov    -0x88(%ebp,%edx,4),%edx
   1273d:	89 d6                	mov    %edx,%esi
   1273f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   12742:	01 f2                	add    %esi,%edx
   12744:	83 ec 0c             	sub    $0xc,%esp
   12747:	50                   	push   %eax
   12748:	53                   	push   %ebx
   12749:	51                   	push   %ecx
   1274a:	52                   	push   %edx
   1274b:	ff 75 d0             	pushl  -0x30(%ebp)
   1274e:	e8 37 fa ff ff       	call   1218a <addPaddingBits>
   12753:	83 c4 20             	add    $0x20,%esp
                         ((passw[i] * bpp + 7u) / 8u) * 8u, passw[i] * bpp, passh[i]);
          error = filter(&(*out)[filter_passstart[i]], padded,
   12756:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12759:	8d 58 0c             	lea    0xc(%eax),%ebx
   1275c:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1275f:	8b 54 85 98          	mov    -0x68(%ebp,%eax,4),%edx
   12763:	8b 45 e0             	mov    -0x20(%ebp),%eax
   12766:	8b 44 85 b4          	mov    -0x4c(%ebp,%eax,4),%eax
   1276a:	8b 4d 08             	mov    0x8(%ebp),%ecx
   1276d:	8b 31                	mov    (%ecx),%esi
   1276f:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   12772:	8b 8c 8d 38 ff ff ff 	mov    -0xc8(%ebp,%ecx,4),%ecx
   12779:	01 f1                	add    %esi,%ecx
   1277b:	83 ec 08             	sub    $0x8,%esp
   1277e:	ff 75 20             	pushl  0x20(%ebp)
   12781:	53                   	push   %ebx
   12782:	52                   	push   %edx
   12783:	50                   	push   %eax
   12784:	ff 75 d0             	pushl  -0x30(%ebp)
   12787:	51                   	push   %ecx
   12788:	e8 16 f2 ff ff       	call   119a3 <filter>
   1278d:	83 c4 20             	add    $0x20,%esp
   12790:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                         passw[i], passh[i], &info_png->color, settings);
          lodepng_free(padded);
   12793:	83 ec 0c             	sub    $0xc,%esp
   12796:	ff 75 d0             	pushl  -0x30(%ebp)
   12799:	e8 86 0c ff ff       	call   3424 <lodepng_free>
   1279e:	83 c4 10             	add    $0x10,%esp
   127a1:	eb 4c                	jmp    127ef <preProcessScanlines+0x35f>
        } else {
          error = filter(&(*out)[filter_passstart[i]], &adam7[padded_passstart[i]],
   127a3:	8b 45 1c             	mov    0x1c(%ebp),%eax
   127a6:	8d 70 0c             	lea    0xc(%eax),%esi
   127a9:	8b 45 e0             	mov    -0x20(%ebp),%eax
   127ac:	8b 54 85 98          	mov    -0x68(%ebp,%eax,4),%edx
   127b0:	8b 45 e0             	mov    -0x20(%ebp),%eax
   127b3:	8b 44 85 b4          	mov    -0x4c(%ebp,%eax,4),%eax
   127b7:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   127ba:	8b 8c 8d 58 ff ff ff 	mov    -0xa8(%ebp,%ecx,4),%ecx
   127c1:	89 cb                	mov    %ecx,%ebx
   127c3:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
   127c6:	01 cb                	add    %ecx,%ebx
   127c8:	8b 4d 08             	mov    0x8(%ebp),%ecx
   127cb:	8b 39                	mov    (%ecx),%edi
   127cd:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   127d0:	8b 8c 8d 38 ff ff ff 	mov    -0xc8(%ebp,%ecx,4),%ecx
   127d7:	01 f9                	add    %edi,%ecx
   127d9:	83 ec 08             	sub    $0x8,%esp
   127dc:	ff 75 20             	pushl  0x20(%ebp)
   127df:	56                   	push   %esi
   127e0:	52                   	push   %edx
   127e1:	50                   	push   %eax
   127e2:	53                   	push   %ebx
   127e3:	51                   	push   %ecx
   127e4:	e8 ba f1 ff ff       	call   119a3 <filter>
   127e9:	83 c4 20             	add    $0x20,%esp
   127ec:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                         passw[i], passh[i], &info_png->color, settings);
        }

        if(error) break;
   127ef:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   127f3:	75 10                	jne    12805 <preProcessScanlines+0x375>

    if(!error) {
      unsigned i;

      Adam7_interlace(adam7, in, w, h, bpp);
      for(i = 0; i != 7; ++i) {
   127f5:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
   127f9:	83 7d e0 07          	cmpl   $0x7,-0x20(%ebp)
   127fd:	0f 85 c0 fe ff ff    	jne    126c3 <preProcessScanlines+0x233>
   12803:	eb 01                	jmp    12806 <preProcessScanlines+0x376>
        } else {
          error = filter(&(*out)[filter_passstart[i]], &adam7[padded_passstart[i]],
                         passw[i], passh[i], &info_png->color, settings);
        }

        if(error) break;
   12805:	90                   	nop
      }
    }

    lodepng_free(adam7);
   12806:	83 ec 0c             	sub    $0xc,%esp
   12809:	ff 75 d4             	pushl  -0x2c(%ebp)
   1280c:	e8 13 0c ff ff       	call   3424 <lodepng_free>
   12811:	83 c4 10             	add    $0x10,%esp
  }

  return error;
   12814:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
   12817:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1281a:	5b                   	pop    %ebx
   1281b:	5e                   	pop    %esi
   1281c:	5f                   	pop    %edi
   1281d:	5d                   	pop    %ebp
   1281e:	c3                   	ret    

0001281f <addUnknownChunks>:

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
static unsigned addUnknownChunks(ucvector* out, unsigned char* data, size_t datasize) {
   1281f:	55                   	push   %ebp
   12820:	89 e5                	mov    %esp,%ebp
   12822:	83 ec 10             	sub    $0x10,%esp
  unsigned char* inchunk = data;
   12825:	8b 45 0c             	mov    0xc(%ebp),%eax
   12828:	89 45 fc             	mov    %eax,-0x4(%ebp)
  while((size_t)(inchunk - data) < datasize) {
   1282b:	eb 47                	jmp    12874 <addUnknownChunks+0x55>
    CERROR_TRY_RETURN(lodepng_chunk_append(&out->data, &out->size, inchunk));
   1282d:	8b 45 08             	mov    0x8(%ebp),%eax
   12830:	8d 50 04             	lea    0x4(%eax),%edx
   12833:	8b 45 08             	mov    0x8(%ebp),%eax
   12836:	ff 75 fc             	pushl  -0x4(%ebp)
   12839:	52                   	push   %edx
   1283a:	50                   	push   %eax
   1283b:	e8 73 5f ff ff       	call   87b3 <lodepng_chunk_append>
   12840:	83 c4 0c             	add    $0xc,%esp
   12843:	89 45 f8             	mov    %eax,-0x8(%ebp)
   12846:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
   1284a:	74 05                	je     12851 <addUnknownChunks+0x32>
   1284c:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1284f:	eb 37                	jmp    12888 <addUnknownChunks+0x69>
    out->allocsize = out->size; /*fix the allocsize again*/
   12851:	8b 45 08             	mov    0x8(%ebp),%eax
   12854:	8b 50 04             	mov    0x4(%eax),%edx
   12857:	8b 45 08             	mov    0x8(%ebp),%eax
   1285a:	89 50 08             	mov    %edx,0x8(%eax)
    inchunk = lodepng_chunk_next(inchunk, data + datasize);
   1285d:	8b 55 10             	mov    0x10(%ebp),%edx
   12860:	8b 45 0c             	mov    0xc(%ebp),%eax
   12863:	01 d0                	add    %edx,%eax
   12865:	50                   	push   %eax
   12866:	ff 75 fc             	pushl  -0x4(%ebp)
   12869:	e8 ff 5c ff ff       	call   856d <lodepng_chunk_next>
   1286e:	83 c4 08             	add    $0x8,%esp
   12871:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
static unsigned addUnknownChunks(ucvector* out, unsigned char* data, size_t datasize) {
  unsigned char* inchunk = data;
  while((size_t)(inchunk - data) < datasize) {
   12874:	8b 55 fc             	mov    -0x4(%ebp),%edx
   12877:	8b 45 0c             	mov    0xc(%ebp),%eax
   1287a:	29 c2                	sub    %eax,%edx
   1287c:	89 d0                	mov    %edx,%eax
   1287e:	3b 45 10             	cmp    0x10(%ebp),%eax
   12881:	7c aa                	jl     1282d <addUnknownChunks+0xe>
    CERROR_TRY_RETURN(lodepng_chunk_append(&out->data, &out->size, inchunk));
    out->allocsize = out->size; /*fix the allocsize again*/
    inchunk = lodepng_chunk_next(inchunk, data + datasize);
  }
  return 0;
   12883:	b8 00 00 00 00       	mov    $0x0,%eax
}
   12888:	c9                   	leave  
   12889:	c3                   	ret    

0001288a <isGrayICCProfile>:

static unsigned isGrayICCProfile(const unsigned char* profile, unsigned size) {
   1288a:	55                   	push   %ebp
   1288b:	89 e5                	mov    %esp,%ebp
  the profile is not checked. This is needed only because the PNG specification
  requires using a non-gray color model if there is an ICC profile with "RGB "
  (sadly limiting compression opportunities if the input data is grayscale RGB
  data), and requires using a gray color model if it is "GRAY".
  */
  if(size < 20) return 0;
   1288d:	83 7d 0c 13          	cmpl   $0x13,0xc(%ebp)
   12891:	77 07                	ja     1289a <isGrayICCProfile+0x10>
   12893:	b8 00 00 00 00       	mov    $0x0,%eax
   12898:	eb 40                	jmp    128da <isGrayICCProfile+0x50>
  return profile[16] == 'G' &&  profile[17] == 'R' &&  profile[18] == 'A' &&  profile[19] == 'Y';
   1289a:	8b 45 08             	mov    0x8(%ebp),%eax
   1289d:	83 c0 10             	add    $0x10,%eax
   128a0:	0f b6 00             	movzbl (%eax),%eax
   128a3:	3c 47                	cmp    $0x47,%al
   128a5:	75 2e                	jne    128d5 <isGrayICCProfile+0x4b>
   128a7:	8b 45 08             	mov    0x8(%ebp),%eax
   128aa:	83 c0 11             	add    $0x11,%eax
   128ad:	0f b6 00             	movzbl (%eax),%eax
   128b0:	3c 52                	cmp    $0x52,%al
   128b2:	75 21                	jne    128d5 <isGrayICCProfile+0x4b>
   128b4:	8b 45 08             	mov    0x8(%ebp),%eax
   128b7:	83 c0 12             	add    $0x12,%eax
   128ba:	0f b6 00             	movzbl (%eax),%eax
   128bd:	3c 41                	cmp    $0x41,%al
   128bf:	75 14                	jne    128d5 <isGrayICCProfile+0x4b>
   128c1:	8b 45 08             	mov    0x8(%ebp),%eax
   128c4:	83 c0 13             	add    $0x13,%eax
   128c7:	0f b6 00             	movzbl (%eax),%eax
   128ca:	3c 59                	cmp    $0x59,%al
   128cc:	75 07                	jne    128d5 <isGrayICCProfile+0x4b>
   128ce:	b8 01 00 00 00       	mov    $0x1,%eax
   128d3:	eb 05                	jmp    128da <isGrayICCProfile+0x50>
   128d5:	b8 00 00 00 00       	mov    $0x0,%eax
}
   128da:	5d                   	pop    %ebp
   128db:	c3                   	ret    

000128dc <isRGBICCProfile>:

static unsigned isRGBICCProfile(const unsigned char* profile, unsigned size) {
   128dc:	55                   	push   %ebp
   128dd:	89 e5                	mov    %esp,%ebp
  /* See comment in isGrayICCProfile*/
  if(size < 20) return 0;
   128df:	83 7d 0c 13          	cmpl   $0x13,0xc(%ebp)
   128e3:	77 07                	ja     128ec <isRGBICCProfile+0x10>
   128e5:	b8 00 00 00 00       	mov    $0x0,%eax
   128ea:	eb 40                	jmp    1292c <isRGBICCProfile+0x50>
  return profile[16] == 'R' &&  profile[17] == 'G' &&  profile[18] == 'B' &&  profile[19] == ' ';
   128ec:	8b 45 08             	mov    0x8(%ebp),%eax
   128ef:	83 c0 10             	add    $0x10,%eax
   128f2:	0f b6 00             	movzbl (%eax),%eax
   128f5:	3c 52                	cmp    $0x52,%al
   128f7:	75 2e                	jne    12927 <isRGBICCProfile+0x4b>
   128f9:	8b 45 08             	mov    0x8(%ebp),%eax
   128fc:	83 c0 11             	add    $0x11,%eax
   128ff:	0f b6 00             	movzbl (%eax),%eax
   12902:	3c 47                	cmp    $0x47,%al
   12904:	75 21                	jne    12927 <isRGBICCProfile+0x4b>
   12906:	8b 45 08             	mov    0x8(%ebp),%eax
   12909:	83 c0 12             	add    $0x12,%eax
   1290c:	0f b6 00             	movzbl (%eax),%eax
   1290f:	3c 42                	cmp    $0x42,%al
   12911:	75 14                	jne    12927 <isRGBICCProfile+0x4b>
   12913:	8b 45 08             	mov    0x8(%ebp),%eax
   12916:	83 c0 13             	add    $0x13,%eax
   12919:	0f b6 00             	movzbl (%eax),%eax
   1291c:	3c 20                	cmp    $0x20,%al
   1291e:	75 07                	jne    12927 <isRGBICCProfile+0x4b>
   12920:	b8 01 00 00 00       	mov    $0x1,%eax
   12925:	eb 05                	jmp    1292c <isRGBICCProfile+0x50>
   12927:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1292c:	5d                   	pop    %ebp
   1292d:	c3                   	ret    

0001292e <lodepng_encode>:
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

unsigned lodepng_encode(unsigned char** out, size_t* outsize,
                        const unsigned char* image, unsigned w, unsigned h,
                        LodePNGState* state) {
   1292e:	55                   	push   %ebp
   1292f:	89 e5                	mov    %esp,%ebp
   12931:	57                   	push   %edi
   12932:	56                   	push   %esi
   12933:	53                   	push   %ebx
   12934:	81 ec 7c 05 00 00    	sub    $0x57c,%esp
  unsigned char* data = 0; /*uncompressed version of the IDAT chunk data*/
   1293a:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
  size_t datasize = 0;
   12941:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
  ucvector outv = ucvector_init(NULL, 0);
   12948:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1294b:	6a 00                	push   $0x0
   1294d:	6a 00                	push   $0x0
   1294f:	50                   	push   %eax
   12950:	e8 6f 0d ff ff       	call   36c4 <ucvector_init>
   12955:	83 c4 08             	add    $0x8,%esp
  LodePNGInfo info;
  const LodePNGInfo* info_png = &state->info_png;
   12958:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1295b:	05 98 00 00 00       	add    $0x98,%eax
   12960:	89 45 dc             	mov    %eax,-0x24(%ebp)

  lodepng_info_init(&info);
   12963:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12969:	50                   	push   %eax
   1296a:	e8 3a 71 ff ff       	call   9aa9 <lodepng_info_init>
   1296f:	83 c4 04             	add    $0x4,%esp

  /*provide some proper output values if error will happen*/
  *out = 0;
   12972:	8b 45 08             	mov    0x8(%ebp),%eax
   12975:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *outsize = 0;
   1297b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1297e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  state->error = 0;
   12984:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12987:	c7 80 7c 01 00 00 00 	movl   $0x0,0x17c(%eax)
   1298e:	00 00 00 

  /*check input values validity*/
  if((info_png->color.colortype == LCT_PALETTE || state->encoder.force_palette)
   12991:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12994:	8b 40 0c             	mov    0xc(%eax),%eax
   12997:	83 f8 03             	cmp    $0x3,%eax
   1299a:	74 0a                	je     129a6 <lodepng_encode+0x78>
   1299c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1299f:	8b 40 6c             	mov    0x6c(%eax),%eax
   129a2:	85 c0                	test   %eax,%eax
   129a4:	74 29                	je     129cf <lodepng_encode+0xa1>
      && (info_png->color.palettesize == 0 || info_png->color.palettesize > 256)) {
   129a6:	8b 45 dc             	mov    -0x24(%ebp),%eax
   129a9:	8b 40 18             	mov    0x18(%eax),%eax
   129ac:	85 c0                	test   %eax,%eax
   129ae:	74 0d                	je     129bd <lodepng_encode+0x8f>
   129b0:	8b 45 dc             	mov    -0x24(%ebp),%eax
   129b3:	8b 40 18             	mov    0x18(%eax),%eax
   129b6:	3d 00 01 00 00       	cmp    $0x100,%eax
   129bb:	7e 12                	jle    129cf <lodepng_encode+0xa1>
    state->error = 68; /*invalid palette size, it is only allowed to be 1-256*/
   129bd:	8b 45 1c             	mov    0x1c(%ebp),%eax
   129c0:	c7 80 7c 01 00 00 44 	movl   $0x44,0x17c(%eax)
   129c7:	00 00 00 
    goto cleanup;
   129ca:	e9 78 0c 00 00       	jmp    13647 <lodepng_encode+0xd19>
  }
  if(state->encoder.zlibsettings.btype > 2) {
   129cf:	8b 45 1c             	mov    0x1c(%ebp),%eax
   129d2:	8b 40 38             	mov    0x38(%eax),%eax
   129d5:	83 f8 02             	cmp    $0x2,%eax
   129d8:	76 12                	jbe    129ec <lodepng_encode+0xbe>
    state->error = 61; /*error: invalid btype*/
   129da:	8b 45 1c             	mov    0x1c(%ebp),%eax
   129dd:	c7 80 7c 01 00 00 3d 	movl   $0x3d,0x17c(%eax)
   129e4:	00 00 00 
    goto cleanup;
   129e7:	e9 5b 0c 00 00       	jmp    13647 <lodepng_encode+0xd19>
  }
  if(info_png->interlace_method > 1) {
   129ec:	8b 45 dc             	mov    -0x24(%ebp),%eax
   129ef:	8b 40 08             	mov    0x8(%eax),%eax
   129f2:	83 f8 01             	cmp    $0x1,%eax
   129f5:	76 12                	jbe    12a09 <lodepng_encode+0xdb>
    state->error = 71; /*error: invalid interlace mode*/
   129f7:	8b 45 1c             	mov    0x1c(%ebp),%eax
   129fa:	c7 80 7c 01 00 00 47 	movl   $0x47,0x17c(%eax)
   12a01:	00 00 00 
    goto cleanup;
   12a04:	e9 3e 0c 00 00       	jmp    13647 <lodepng_encode+0xd19>
  }
  state->error = checkColorValidity(info_png->color.colortype, info_png->color.bitdepth);
   12a09:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12a0c:	8b 50 10             	mov    0x10(%eax),%edx
   12a0f:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12a12:	8b 40 0c             	mov    0xc(%eax),%eax
   12a15:	52                   	push   %edx
   12a16:	50                   	push   %eax
   12a17:	e8 a4 5f ff ff       	call   89c0 <checkColorValidity>
   12a1c:	83 c4 08             	add    $0x8,%esp
   12a1f:	89 c2                	mov    %eax,%edx
   12a21:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12a24:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) goto cleanup; /*error: invalid color type given*/
   12a2a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12a2d:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12a33:	85 c0                	test   %eax,%eax
   12a35:	0f 85 c6 0b 00 00    	jne    13601 <lodepng_encode+0xcd3>
  state->error = checkColorValidity(state->info_raw.colortype, state->info_raw.bitdepth);
   12a3b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12a3e:	8b 50 7c             	mov    0x7c(%eax),%edx
   12a41:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12a44:	8b 40 78             	mov    0x78(%eax),%eax
   12a47:	52                   	push   %edx
   12a48:	50                   	push   %eax
   12a49:	e8 72 5f ff ff       	call   89c0 <checkColorValidity>
   12a4e:	83 c4 08             	add    $0x8,%esp
   12a51:	89 c2                	mov    %eax,%edx
   12a53:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12a56:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) goto cleanup; /*error: invalid color type given*/
   12a5c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12a5f:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12a65:	85 c0                	test   %eax,%eax
   12a67:	0f 85 97 0b 00 00    	jne    13604 <lodepng_encode+0xcd6>

  /* color convert and compute scanline filter types */
  lodepng_info_copy(&info, &state->info_png);
   12a6d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12a70:	05 98 00 00 00       	add    $0x98,%eax
   12a75:	83 ec 08             	sub    $0x8,%esp
   12a78:	50                   	push   %eax
   12a79:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12a7f:	50                   	push   %eax
   12a80:	e8 58 71 ff ff       	call   9bdd <lodepng_info_copy>
   12a85:	83 c4 10             	add    $0x10,%esp
  if(state->encoder.auto_convert) {
   12a88:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12a8b:	8b 40 5c             	mov    0x5c(%eax),%eax
   12a8e:	85 c0                	test   %eax,%eax
   12a90:	0f 84 3c 02 00 00    	je     12cd2 <lodepng_encode+0x3a4>
    LodePNGColorStats stats;
    lodepng_color_stats_init(&stats);
   12a96:	83 ec 0c             	sub    $0xc,%esp
   12a99:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   12a9f:	50                   	push   %eax
   12aa0:	e8 5f 96 ff ff       	call   c104 <lodepng_color_stats_init>
   12aa5:	83 c4 10             	add    $0x10,%esp
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    if(info_png->iccp_defined &&
   12aa8:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12aab:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   12ab1:	85 c0                	test   %eax,%eax
   12ab3:	74 2d                	je     12ae2 <lodepng_encode+0x1b4>
        isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
   12ab5:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12ab8:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   12abe:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12ac1:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   12ac7:	83 ec 08             	sub    $0x8,%esp
   12aca:	52                   	push   %edx
   12acb:	50                   	push   %eax
   12acc:	e8 b9 fd ff ff       	call   1288a <isGrayICCProfile>
   12ad1:	83 c4 10             	add    $0x10,%esp
  lodepng_info_copy(&info, &state->info_png);
  if(state->encoder.auto_convert) {
    LodePNGColorStats stats;
    lodepng_color_stats_init(&stats);
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    if(info_png->iccp_defined &&
   12ad4:	85 c0                	test   %eax,%eax
   12ad6:	74 0a                	je     12ae2 <lodepng_encode+0x1b4>
        isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
      /*the PNG specification does not allow to use palette with a GRAY ICC profile, even
      if the palette has only gray colors, so disallow it.*/
      stats.allow_palette = 0;
   12ad8:	c7 85 b8 fe ff ff 00 	movl   $0x0,-0x148(%ebp)
   12adf:	00 00 00 
    }
    if(info_png->iccp_defined &&
   12ae2:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12ae5:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   12aeb:	85 c0                	test   %eax,%eax
   12aed:	74 2d                	je     12b1c <lodepng_encode+0x1ee>
        isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
   12aef:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12af2:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   12af8:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12afb:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   12b01:	83 ec 08             	sub    $0x8,%esp
   12b04:	52                   	push   %edx
   12b05:	50                   	push   %eax
   12b06:	e8 d1 fd ff ff       	call   128dc <isRGBICCProfile>
   12b0b:	83 c4 10             	add    $0x10,%esp
        isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
      /*the PNG specification does not allow to use palette with a GRAY ICC profile, even
      if the palette has only gray colors, so disallow it.*/
      stats.allow_palette = 0;
    }
    if(info_png->iccp_defined &&
   12b0e:	85 c0                	test   %eax,%eax
   12b10:	74 0a                	je     12b1c <lodepng_encode+0x1ee>
        isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
      /*the PNG specification does not allow to use grayscale color with RGB ICC profile, so disallow gray.*/
      stats.allow_greyscale = 0;
   12b12:	c7 85 bc fe ff ff 00 	movl   $0x0,-0x144(%ebp)
   12b19:	00 00 00 
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = lodepng_compute_color_stats(&stats, image, w, h, &state->info_raw);
   12b1c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12b1f:	83 c0 78             	add    $0x78,%eax
   12b22:	83 ec 0c             	sub    $0xc,%esp
   12b25:	50                   	push   %eax
   12b26:	ff 75 18             	pushl  0x18(%ebp)
   12b29:	ff 75 14             	pushl  0x14(%ebp)
   12b2c:	ff 75 10             	pushl  0x10(%ebp)
   12b2f:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   12b35:	50                   	push   %eax
   12b36:	e8 e0 96 ff ff       	call   c21b <lodepng_compute_color_stats>
   12b3b:	83 c4 20             	add    $0x20,%esp
   12b3e:	89 c2                	mov    %eax,%edx
   12b40:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12b43:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   12b49:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12b4c:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12b52:	85 c0                	test   %eax,%eax
   12b54:	0f 85 ad 0a 00 00    	jne    13607 <lodepng_encode+0xcd9>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    if(info_png->background_defined) {
   12b5a:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12b5d:	8b 40 2c             	mov    0x2c(%eax),%eax
   12b60:	85 c0                	test   %eax,%eax
   12b62:	0f 84 be 00 00 00    	je     12c26 <lodepng_encode+0x2f8>
      /*the background chunk's color must be taken into account as well*/
      unsigned r = 0, g = 0, b = 0;
   12b68:	c7 85 c8 fe ff ff 00 	movl   $0x0,-0x138(%ebp)
   12b6f:	00 00 00 
   12b72:	c7 85 c4 fe ff ff 00 	movl   $0x0,-0x13c(%ebp)
   12b79:	00 00 00 
   12b7c:	c7 85 c0 fe ff ff 00 	movl   $0x0,-0x140(%ebp)
   12b83:	00 00 00 
      LodePNGColorMode mode16 = lodepng_color_mode_make(LCT_RGB, 16);
   12b86:	8d 85 78 fa ff ff    	lea    -0x588(%ebp),%eax
   12b8c:	83 ec 04             	sub    $0x4,%esp
   12b8f:	6a 10                	push   $0x10
   12b91:	6a 02                	push   $0x2
   12b93:	50                   	push   %eax
   12b94:	e8 15 61 ff ff       	call   8cae <lodepng_color_mode_make>
   12b99:	83 c4 0c             	add    $0xc,%esp
      lodepng_convert_rgb(&r, &g, &b, info_png->background_r, info_png->background_g, info_png->background_b, &mode16, &info_png->color);
   12b9c:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12b9f:	8d 58 0c             	lea    0xc(%eax),%ebx
   12ba2:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12ba5:	8b 48 38             	mov    0x38(%eax),%ecx
   12ba8:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12bab:	8b 50 34             	mov    0x34(%eax),%edx
   12bae:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12bb1:	8b 40 30             	mov    0x30(%eax),%eax
   12bb4:	53                   	push   %ebx
   12bb5:	8d 9d 78 fa ff ff    	lea    -0x588(%ebp),%ebx
   12bbb:	53                   	push   %ebx
   12bbc:	51                   	push   %ecx
   12bbd:	52                   	push   %edx
   12bbe:	50                   	push   %eax
   12bbf:	8d 85 c0 fe ff ff    	lea    -0x140(%ebp),%eax
   12bc5:	50                   	push   %eax
   12bc6:	8d 85 c4 fe ff ff    	lea    -0x13c(%ebp),%eax
   12bcc:	50                   	push   %eax
   12bcd:	8d 85 c8 fe ff ff    	lea    -0x138(%ebp),%eax
   12bd3:	50                   	push   %eax
   12bd4:	e8 8a 92 ff ff       	call   be63 <lodepng_convert_rgb>
   12bd9:	83 c4 20             	add    $0x20,%esp
      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);
   12bdc:	8b 8d c0 fe ff ff    	mov    -0x140(%ebp),%ecx
   12be2:	8b 95 c4 fe ff ff    	mov    -0x13c(%ebp),%edx
   12be8:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
   12bee:	83 ec 0c             	sub    $0xc,%esp
   12bf1:	68 ff ff 00 00       	push   $0xffff
   12bf6:	51                   	push   %ecx
   12bf7:	52                   	push   %edx
   12bf8:	50                   	push   %eax
   12bf9:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   12bff:	50                   	push   %eax
   12c00:	e8 26 a1 ff ff       	call   cd2b <lodepng_color_stats_add>
   12c05:	83 c4 20             	add    $0x20,%esp
   12c08:	89 c2                	mov    %eax,%edx
   12c0a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12c0d:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   12c13:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12c16:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12c1c:	85 c0                	test   %eax,%eax
   12c1e:	74 06                	je     12c26 <lodepng_encode+0x2f8>
   12c20:	90                   	nop
      /*the PNG specification does not allow to use grayscale color with RGB ICC profile, so disallow gray.*/
      stats.allow_greyscale = 0;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = lodepng_compute_color_stats(&stats, image, w, h, &state->info_raw);
    if(state->error) goto cleanup;
   12c21:	e9 e1 09 00 00       	jmp    13607 <lodepng_encode+0xcd9>
      lodepng_convert_rgb(&r, &g, &b, info_png->background_r, info_png->background_g, info_png->background_b, &mode16, &info_png->color);
      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);
      if(state->error) goto cleanup;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = auto_choose_color(&info.color, &state->info_raw, &stats);
   12c26:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12c29:	8d 50 78             	lea    0x78(%eax),%edx
   12c2c:	83 ec 04             	sub    $0x4,%esp
   12c2f:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   12c35:	50                   	push   %eax
   12c36:	52                   	push   %edx
   12c37:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12c3d:	83 c0 0c             	add    $0xc,%eax
   12c40:	50                   	push   %eax
   12c41:	e8 79 a1 ff ff       	call   cdbf <auto_choose_color>
   12c46:	83 c4 10             	add    $0x10,%esp
   12c49:	89 c2                	mov    %eax,%edx
   12c4b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12c4e:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   12c54:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12c57:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12c5d:	85 c0                	test   %eax,%eax
   12c5f:	0f 85 a5 09 00 00    	jne    1360a <lodepng_encode+0xcdc>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*also convert the background chunk*/
    if(info_png->background_defined) {
   12c65:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12c68:	8b 40 2c             	mov    0x2c(%eax),%eax
   12c6b:	85 c0                	test   %eax,%eax
   12c6d:	74 63                	je     12cd2 <lodepng_encode+0x3a4>
      if(lodepng_convert_rgb(&info.background_r, &info.background_g, &info.background_b,
   12c6f:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12c72:	8d 58 0c             	lea    0xc(%eax),%ebx
   12c75:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12c78:	8b 48 38             	mov    0x38(%eax),%ecx
   12c7b:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12c7e:	8b 50 34             	mov    0x34(%eax),%edx
   12c81:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12c84:	8b 40 30             	mov    0x30(%eax),%eax
   12c87:	53                   	push   %ebx
   12c88:	8d 9d cc fe ff ff    	lea    -0x134(%ebp),%ebx
   12c8e:	83 c3 0c             	add    $0xc,%ebx
   12c91:	53                   	push   %ebx
   12c92:	51                   	push   %ecx
   12c93:	52                   	push   %edx
   12c94:	50                   	push   %eax
   12c95:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12c9b:	83 c0 38             	add    $0x38,%eax
   12c9e:	50                   	push   %eax
   12c9f:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12ca5:	83 c0 34             	add    $0x34,%eax
   12ca8:	50                   	push   %eax
   12ca9:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12caf:	83 c0 30             	add    $0x30,%eax
   12cb2:	50                   	push   %eax
   12cb3:	e8 ab 91 ff ff       	call   be63 <lodepng_convert_rgb>
   12cb8:	83 c4 20             	add    $0x20,%esp
   12cbb:	85 c0                	test   %eax,%eax
   12cbd:	74 13                	je     12cd2 <lodepng_encode+0x3a4>
          info_png->background_r, info_png->background_g, info_png->background_b, &info.color, &info_png->color)) {
        state->error = 104;
   12cbf:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12cc2:	c7 80 7c 01 00 00 68 	movl   $0x68,0x17c(%eax)
   12cc9:	00 00 00 
        goto cleanup;
   12ccc:	90                   	nop
   12ccd:	e9 75 09 00 00       	jmp    13647 <lodepng_encode+0xd19>
      }
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
  }
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  if(info_png->iccp_defined) {
   12cd2:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12cd5:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   12cdb:	85 c0                	test   %eax,%eax
   12cdd:	0f 84 b2 00 00 00    	je     12d95 <lodepng_encode+0x467>
    unsigned gray_icc = isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size);
   12ce3:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12ce6:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   12cec:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12cef:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   12cf5:	83 ec 08             	sub    $0x8,%esp
   12cf8:	52                   	push   %edx
   12cf9:	50                   	push   %eax
   12cfa:	e8 8b fb ff ff       	call   1288a <isGrayICCProfile>
   12cff:	83 c4 10             	add    $0x10,%esp
   12d02:	89 45 d8             	mov    %eax,-0x28(%ebp)
    unsigned rgb_icc = isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size);
   12d05:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12d08:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   12d0e:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12d11:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   12d17:	83 ec 08             	sub    $0x8,%esp
   12d1a:	52                   	push   %edx
   12d1b:	50                   	push   %eax
   12d1c:	e8 bb fb ff ff       	call   128dc <isRGBICCProfile>
   12d21:	83 c4 10             	add    $0x10,%esp
   12d24:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    unsigned gray_png = info.color.colortype == LCT_GREY || info.color.colortype == LCT_GREY_ALPHA;
   12d27:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   12d2d:	85 c0                	test   %eax,%eax
   12d2f:	74 0b                	je     12d3c <lodepng_encode+0x40e>
   12d31:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   12d37:	83 f8 04             	cmp    $0x4,%eax
   12d3a:	75 07                	jne    12d43 <lodepng_encode+0x415>
   12d3c:	b8 01 00 00 00       	mov    $0x1,%eax
   12d41:	eb 05                	jmp    12d48 <lodepng_encode+0x41a>
   12d43:	b8 00 00 00 00       	mov    $0x0,%eax
   12d48:	89 45 d0             	mov    %eax,-0x30(%ebp)
    if(!gray_icc && !rgb_icc) {
   12d4b:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   12d4f:	75 18                	jne    12d69 <lodepng_encode+0x43b>
   12d51:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
   12d55:	75 12                	jne    12d69 <lodepng_encode+0x43b>
      state->error = 100; /* Disallowed profile color type for PNG */
   12d57:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12d5a:	c7 80 7c 01 00 00 64 	movl   $0x64,0x17c(%eax)
   12d61:	00 00 00 
      goto cleanup;
   12d64:	e9 de 08 00 00       	jmp    13647 <lodepng_encode+0xd19>
    }
    if(gray_icc != gray_png) {
   12d69:	8b 45 d8             	mov    -0x28(%ebp),%eax
   12d6c:	3b 45 d0             	cmp    -0x30(%ebp),%eax
   12d6f:	74 24                	je     12d95 <lodepng_encode+0x467>
      /*Not allowed to use RGB/RGBA/palette with GRAY ICC profile or vice versa,
      or in case of auto_convert, it wasn't possible to find appropriate model*/
      state->error = state->encoder.auto_convert ? 102 : 101;
   12d71:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12d74:	8b 40 5c             	mov    0x5c(%eax),%eax
   12d77:	85 c0                	test   %eax,%eax
   12d79:	74 07                	je     12d82 <lodepng_encode+0x454>
   12d7b:	ba 66 00 00 00       	mov    $0x66,%edx
   12d80:	eb 05                	jmp    12d87 <lodepng_encode+0x459>
   12d82:	ba 65 00 00 00       	mov    $0x65,%edx
   12d87:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12d8a:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      goto cleanup;
   12d90:	e9 b2 08 00 00       	jmp    13647 <lodepng_encode+0xd19>
    }
  }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  if(!lodepng_color_mode_equal(&state->info_raw, &info.color)) {
   12d95:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12d98:	83 c0 78             	add    $0x78,%eax
   12d9b:	83 ec 08             	sub    $0x8,%esp
   12d9e:	8d 95 cc fe ff ff    	lea    -0x134(%ebp),%edx
   12da4:	83 c2 0c             	add    $0xc,%edx
   12da7:	52                   	push   %edx
   12da8:	50                   	push   %eax
   12da9:	e8 57 5f ff ff       	call   8d05 <lodepng_color_mode_equal>
   12dae:	83 c4 10             	add    $0x10,%esp
   12db1:	85 c0                	test   %eax,%eax
   12db3:	0f 85 f8 00 00 00    	jne    12eb1 <lodepng_encode+0x583>
    unsigned char* converted;
    size_t size = ((size_t)w * (size_t)h * (size_t)lodepng_get_bpp(&info.color) + 7u) / 8u;
   12db9:	8b 55 14             	mov    0x14(%ebp),%edx
   12dbc:	8b 45 18             	mov    0x18(%ebp),%eax
   12dbf:	89 d3                	mov    %edx,%ebx
   12dc1:	0f af d8             	imul   %eax,%ebx
   12dc4:	83 ec 0c             	sub    $0xc,%esp
   12dc7:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12dcd:	83 c0 0c             	add    $0xc,%eax
   12dd0:	50                   	push   %eax
   12dd1:	e8 49 61 ff ff       	call   8f1f <lodepng_get_bpp>
   12dd6:	83 c4 10             	add    $0x10,%esp
   12dd9:	0f af c3             	imul   %ebx,%eax
   12ddc:	83 c0 07             	add    $0x7,%eax
   12ddf:	c1 e8 03             	shr    $0x3,%eax
   12de2:	89 45 cc             	mov    %eax,-0x34(%ebp)

    converted = (unsigned char*)lodepng_malloc(size);
   12de5:	83 ec 0c             	sub    $0xc,%esp
   12de8:	ff 75 cc             	pushl  -0x34(%ebp)
   12deb:	e8 13 06 ff ff       	call   3403 <lodepng_malloc>
   12df0:	83 c4 10             	add    $0x10,%esp
   12df3:	89 45 c8             	mov    %eax,-0x38(%ebp)
    if(!converted && size) state->error = 83; /*alloc fail*/
   12df6:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
   12dfa:	75 13                	jne    12e0f <lodepng_encode+0x4e1>
   12dfc:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
   12e00:	74 0d                	je     12e0f <lodepng_encode+0x4e1>
   12e02:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e05:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   12e0c:	00 00 00 
    if(!state->error) {
   12e0f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e12:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12e18:	85 c0                	test   %eax,%eax
   12e1a:	75 33                	jne    12e4f <lodepng_encode+0x521>
      state->error = lodepng_convert(converted, image, &info.color, &state->info_raw, w, h);
   12e1c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e1f:	83 c0 78             	add    $0x78,%eax
   12e22:	83 ec 08             	sub    $0x8,%esp
   12e25:	ff 75 18             	pushl  0x18(%ebp)
   12e28:	ff 75 14             	pushl  0x14(%ebp)
   12e2b:	50                   	push   %eax
   12e2c:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12e32:	83 c0 0c             	add    $0xc,%eax
   12e35:	50                   	push   %eax
   12e36:	ff 75 10             	pushl  0x10(%ebp)
   12e39:	ff 75 c8             	pushl  -0x38(%ebp)
   12e3c:	e8 c9 8c ff ff       	call   bb0a <lodepng_convert>
   12e41:	83 c4 20             	add    $0x20,%esp
   12e44:	89 c2                	mov    %eax,%edx
   12e46:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e49:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    }
    if(!state->error) {
   12e4f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e52:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12e58:	85 c0                	test   %eax,%eax
   12e5a:	75 35                	jne    12e91 <lodepng_encode+0x563>
      state->error = preProcessScanlines(&data, &datasize, converted, w, h, &info, &state->encoder);
   12e5c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e5f:	83 c0 38             	add    $0x38,%eax
   12e62:	83 ec 04             	sub    $0x4,%esp
   12e65:	50                   	push   %eax
   12e66:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12e6c:	50                   	push   %eax
   12e6d:	ff 75 18             	pushl  0x18(%ebp)
   12e70:	ff 75 14             	pushl  0x14(%ebp)
   12e73:	ff 75 c8             	pushl  -0x38(%ebp)
   12e76:	8d 45 bc             	lea    -0x44(%ebp),%eax
   12e79:	50                   	push   %eax
   12e7a:	8d 45 c0             	lea    -0x40(%ebp),%eax
   12e7d:	50                   	push   %eax
   12e7e:	e8 0d f6 ff ff       	call   12490 <preProcessScanlines>
   12e83:	83 c4 20             	add    $0x20,%esp
   12e86:	89 c2                	mov    %eax,%edx
   12e88:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e8b:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    }
    lodepng_free(converted);
   12e91:	83 ec 0c             	sub    $0xc,%esp
   12e94:	ff 75 c8             	pushl  -0x38(%ebp)
   12e97:	e8 88 05 ff ff       	call   3424 <lodepng_free>
   12e9c:	83 c4 10             	add    $0x10,%esp
    if(state->error) goto cleanup;
   12e9f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12ea2:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12ea8:	85 c0                	test   %eax,%eax
   12eaa:	74 4b                	je     12ef7 <lodepng_encode+0x5c9>
   12eac:	e9 96 07 00 00       	jmp    13647 <lodepng_encode+0xd19>
  } else {
    state->error = preProcessScanlines(&data, &datasize, image, w, h, &info, &state->encoder);
   12eb1:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12eb4:	83 c0 38             	add    $0x38,%eax
   12eb7:	83 ec 04             	sub    $0x4,%esp
   12eba:	50                   	push   %eax
   12ebb:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12ec1:	50                   	push   %eax
   12ec2:	ff 75 18             	pushl  0x18(%ebp)
   12ec5:	ff 75 14             	pushl  0x14(%ebp)
   12ec8:	ff 75 10             	pushl  0x10(%ebp)
   12ecb:	8d 45 bc             	lea    -0x44(%ebp),%eax
   12ece:	50                   	push   %eax
   12ecf:	8d 45 c0             	lea    -0x40(%ebp),%eax
   12ed2:	50                   	push   %eax
   12ed3:	e8 b8 f5 ff ff       	call   12490 <preProcessScanlines>
   12ed8:	83 c4 20             	add    $0x20,%esp
   12edb:	89 c2                	mov    %eax,%edx
   12edd:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12ee0:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   12ee6:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12ee9:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12eef:	85 c0                	test   %eax,%eax
   12ef1:	0f 85 16 07 00 00    	jne    1360d <lodepng_encode+0xcdf>
  /* output all PNG chunks */ {
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    size_t i;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*write signature and chunks*/
    state->error = writeSignature(&outv);
   12ef7:	83 ec 0c             	sub    $0xc,%esp
   12efa:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12efd:	50                   	push   %eax
   12efe:	e8 21 d9 ff ff       	call   10824 <writeSignature>
   12f03:	83 c4 10             	add    $0x10,%esp
   12f06:	89 c2                	mov    %eax,%edx
   12f08:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f0b:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   12f11:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f14:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12f1a:	85 c0                	test   %eax,%eax
   12f1c:	0f 85 ee 06 00 00    	jne    13610 <lodepng_encode+0xce2>
    /*IHDR*/
    state->error = addChunk_IHDR(&outv, w, h, info.color.colortype, info.color.bitdepth, info.interlace_method);
   12f22:	8b 8d d4 fe ff ff    	mov    -0x12c(%ebp),%ecx
   12f28:	8b 95 dc fe ff ff    	mov    -0x124(%ebp),%edx
   12f2e:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   12f34:	83 ec 08             	sub    $0x8,%esp
   12f37:	51                   	push   %ecx
   12f38:	52                   	push   %edx
   12f39:	50                   	push   %eax
   12f3a:	ff 75 18             	pushl  0x18(%ebp)
   12f3d:	ff 75 14             	pushl  0x14(%ebp)
   12f40:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12f43:	50                   	push   %eax
   12f44:	e8 4a d9 ff ff       	call   10893 <addChunk_IHDR>
   12f49:	83 c4 20             	add    $0x20,%esp
   12f4c:	89 c2                	mov    %eax,%edx
   12f4e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f51:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   12f57:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f5a:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12f60:	85 c0                	test   %eax,%eax
   12f62:	0f 85 ab 06 00 00    	jne    13613 <lodepng_encode+0xce5>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*unknown chunks between IHDR and PLTE*/
    if(info.unknown_chunks_data[0]) {
   12f68:	8b 45 98             	mov    -0x68(%ebp),%eax
   12f6b:	85 c0                	test   %eax,%eax
   12f6d:	74 33                	je     12fa2 <lodepng_encode+0x674>
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[0], info.unknown_chunks_size[0]);
   12f6f:	8b 55 a4             	mov    -0x5c(%ebp),%edx
   12f72:	8b 45 98             	mov    -0x68(%ebp),%eax
   12f75:	83 ec 04             	sub    $0x4,%esp
   12f78:	52                   	push   %edx
   12f79:	50                   	push   %eax
   12f7a:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12f7d:	50                   	push   %eax
   12f7e:	e8 9c f8 ff ff       	call   1281f <addUnknownChunks>
   12f83:	83 c4 10             	add    $0x10,%esp
   12f86:	89 c2                	mov    %eax,%edx
   12f88:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f8b:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   12f91:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f94:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12f9a:	85 c0                	test   %eax,%eax
   12f9c:	0f 85 74 06 00 00    	jne    13616 <lodepng_encode+0xce8>
    }
    /*color profile chunks must come before PLTE */
    if(info.iccp_defined) {
   12fa2:	8b 45 88             	mov    -0x78(%ebp),%eax
   12fa5:	85 c0                	test   %eax,%eax
   12fa7:	74 39                	je     12fe2 <lodepng_encode+0x6b4>
      state->error = addChunk_iCCP(&outv, &info, &state->encoder.zlibsettings);
   12fa9:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12fac:	83 c0 38             	add    $0x38,%eax
   12faf:	83 ec 04             	sub    $0x4,%esp
   12fb2:	50                   	push   %eax
   12fb3:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12fb9:	50                   	push   %eax
   12fba:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12fbd:	50                   	push   %eax
   12fbe:	e8 a4 e4 ff ff       	call   11467 <addChunk_iCCP>
   12fc3:	83 c4 10             	add    $0x10,%esp
   12fc6:	89 c2                	mov    %eax,%edx
   12fc8:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12fcb:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   12fd1:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12fd4:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12fda:	85 c0                	test   %eax,%eax
   12fdc:	0f 85 37 06 00 00    	jne    13619 <lodepng_encode+0xceb>
    }
    if(info.srgb_defined) {
   12fe2:	8b 45 80             	mov    -0x80(%ebp),%eax
   12fe5:	85 c0                	test   %eax,%eax
   12fe7:	74 32                	je     1301b <lodepng_encode+0x6ed>
      state->error = addChunk_sRGB(&outv, &info);
   12fe9:	83 ec 08             	sub    $0x8,%esp
   12fec:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12ff2:	50                   	push   %eax
   12ff3:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12ff6:	50                   	push   %eax
   12ff7:	e8 41 e4 ff ff       	call   1143d <addChunk_sRGB>
   12ffc:	83 c4 10             	add    $0x10,%esp
   12fff:	89 c2                	mov    %eax,%edx
   13001:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13004:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   1300a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1300d:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13013:	85 c0                	test   %eax,%eax
   13015:	0f 85 01 06 00 00    	jne    1361c <lodepng_encode+0xcee>
    }
    if(info.gama_defined) {
   1301b:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
   13021:	85 c0                	test   %eax,%eax
   13023:	74 32                	je     13057 <lodepng_encode+0x729>
      state->error = addChunk_gAMA(&outv, &info);
   13025:	83 ec 08             	sub    $0x8,%esp
   13028:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   1302e:	50                   	push   %eax
   1302f:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13032:	50                   	push   %eax
   13033:	e8 a7 e2 ff ff       	call   112df <addChunk_gAMA>
   13038:	83 c4 10             	add    $0x10,%esp
   1303b:	89 c2                	mov    %eax,%edx
   1303d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13040:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13046:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13049:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1304f:	85 c0                	test   %eax,%eax
   13051:	0f 85 c8 05 00 00    	jne    1361f <lodepng_encode+0xcf1>
    }
    if(info.chrm_defined) {
   13057:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
   1305d:	85 c0                	test   %eax,%eax
   1305f:	74 32                	je     13093 <lodepng_encode+0x765>
      state->error = addChunk_cHRM(&outv, &info);
   13061:	83 ec 08             	sub    $0x8,%esp
   13064:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   1306a:	50                   	push   %eax
   1306b:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1306e:	50                   	push   %eax
   1306f:	e8 c1 e2 ff ff       	call   11335 <addChunk_cHRM>
   13074:	83 c4 10             	add    $0x10,%esp
   13077:	89 c2                	mov    %eax,%edx
   13079:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1307c:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13082:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13085:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1308b:	85 c0                	test   %eax,%eax
   1308d:	0f 85 8f 05 00 00    	jne    13622 <lodepng_encode+0xcf4>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*PLTE*/
    if(info.color.colortype == LCT_PALETTE) {
   13093:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   13099:	83 f8 03             	cmp    $0x3,%eax
   1309c:	75 35                	jne    130d3 <lodepng_encode+0x7a5>
      state->error = addChunk_PLTE(&outv, &info.color);
   1309e:	83 ec 08             	sub    $0x8,%esp
   130a1:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   130a7:	83 c0 0c             	add    $0xc,%eax
   130aa:	50                   	push   %eax
   130ab:	8d 45 b0             	lea    -0x50(%ebp),%eax
   130ae:	50                   	push   %eax
   130af:	e8 78 d8 ff ff       	call   1092c <addChunk_PLTE>
   130b4:	83 c4 10             	add    $0x10,%esp
   130b7:	89 c2                	mov    %eax,%edx
   130b9:	8b 45 1c             	mov    0x1c(%ebp),%eax
   130bc:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   130c2:	8b 45 1c             	mov    0x1c(%ebp),%eax
   130c5:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   130cb:	85 c0                	test   %eax,%eax
   130cd:	0f 85 52 05 00 00    	jne    13625 <lodepng_encode+0xcf7>
    }
    if(state->encoder.force_palette && (info.color.colortype == LCT_RGB || info.color.colortype == LCT_RGBA)) {
   130d3:	8b 45 1c             	mov    0x1c(%ebp),%eax
   130d6:	8b 40 6c             	mov    0x6c(%eax),%eax
   130d9:	85 c0                	test   %eax,%eax
   130db:	74 4b                	je     13128 <lodepng_encode+0x7fa>
   130dd:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   130e3:	83 f8 02             	cmp    $0x2,%eax
   130e6:	74 0b                	je     130f3 <lodepng_encode+0x7c5>
   130e8:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   130ee:	83 f8 06             	cmp    $0x6,%eax
   130f1:	75 35                	jne    13128 <lodepng_encode+0x7fa>
      /*force_palette means: write suggested palette for truecolor in PLTE chunk*/
      state->error = addChunk_PLTE(&outv, &info.color);
   130f3:	83 ec 08             	sub    $0x8,%esp
   130f6:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   130fc:	83 c0 0c             	add    $0xc,%eax
   130ff:	50                   	push   %eax
   13100:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13103:	50                   	push   %eax
   13104:	e8 23 d8 ff ff       	call   1092c <addChunk_PLTE>
   13109:	83 c4 10             	add    $0x10,%esp
   1310c:	89 c2                	mov    %eax,%edx
   1310e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13111:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13117:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1311a:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13120:	85 c0                	test   %eax,%eax
   13122:	0f 85 00 05 00 00    	jne    13628 <lodepng_encode+0xcfa>
    }
    /*tRNS (this will only add if when necessary) */
    state->error = addChunk_tRNS(&outv, &info.color);
   13128:	83 ec 08             	sub    $0x8,%esp
   1312b:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13131:	83 c0 0c             	add    $0xc,%eax
   13134:	50                   	push   %eax
   13135:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13138:	50                   	push   %eax
   13139:	e8 c4 d8 ff ff       	call   10a02 <addChunk_tRNS>
   1313e:	83 c4 10             	add    $0x10,%esp
   13141:	89 c2                	mov    %eax,%edx
   13143:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13146:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   1314c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1314f:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13155:	85 c0                	test   %eax,%eax
   13157:	0f 85 ce 04 00 00    	jne    1362b <lodepng_encode+0xcfd>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*bKGD (must come between PLTE and the IDAt chunks*/
    if(info.background_defined) {
   1315d:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
   13163:	85 c0                	test   %eax,%eax
   13165:	74 32                	je     13199 <lodepng_encode+0x86b>
      state->error = addChunk_bKGD(&outv, &info);
   13167:	83 ec 08             	sub    $0x8,%esp
   1316a:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13170:	50                   	push   %eax
   13171:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13174:	50                   	push   %eax
   13175:	e8 e4 de ff ff       	call   1105e <addChunk_bKGD>
   1317a:	83 c4 10             	add    $0x10,%esp
   1317d:	89 c2                	mov    %eax,%edx
   1317f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13182:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13188:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1318b:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13191:	85 c0                	test   %eax,%eax
   13193:	0f 85 95 04 00 00    	jne    1362e <lodepng_encode+0xd00>
    }
    /*pHYs (must come before the IDAT chunks)*/
    if(info.phys_defined) {
   13199:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
   1319f:	85 c0                	test   %eax,%eax
   131a1:	74 32                	je     131d5 <lodepng_encode+0x8a7>
      state->error = addChunk_pHYs(&outv, &info);
   131a3:	83 ec 08             	sub    $0x8,%esp
   131a6:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   131ac:	50                   	push   %eax
   131ad:	8d 45 b0             	lea    -0x50(%ebp),%eax
   131b0:	50                   	push   %eax
   131b1:	e8 ac e0 ff ff       	call   11262 <addChunk_pHYs>
   131b6:	83 c4 10             	add    $0x10,%esp
   131b9:	89 c2                	mov    %eax,%edx
   131bb:	8b 45 1c             	mov    0x1c(%ebp),%eax
   131be:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   131c4:	8b 45 1c             	mov    0x1c(%ebp),%eax
   131c7:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   131cd:	85 c0                	test   %eax,%eax
   131cf:	0f 85 5c 04 00 00    	jne    13631 <lodepng_encode+0xd03>
    }

    /*unknown chunks between PLTE and IDAT*/
    if(info.unknown_chunks_data[1]) {
   131d5:	8b 45 9c             	mov    -0x64(%ebp),%eax
   131d8:	85 c0                	test   %eax,%eax
   131da:	74 33                	je     1320f <lodepng_encode+0x8e1>
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[1], info.unknown_chunks_size[1]);
   131dc:	8b 55 a8             	mov    -0x58(%ebp),%edx
   131df:	8b 45 9c             	mov    -0x64(%ebp),%eax
   131e2:	83 ec 04             	sub    $0x4,%esp
   131e5:	52                   	push   %edx
   131e6:	50                   	push   %eax
   131e7:	8d 45 b0             	lea    -0x50(%ebp),%eax
   131ea:	50                   	push   %eax
   131eb:	e8 2f f6 ff ff       	call   1281f <addUnknownChunks>
   131f0:	83 c4 10             	add    $0x10,%esp
   131f3:	89 c2                	mov    %eax,%edx
   131f5:	8b 45 1c             	mov    0x1c(%ebp),%eax
   131f8:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   131fe:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13201:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13207:	85 c0                	test   %eax,%eax
   13209:	0f 85 25 04 00 00    	jne    13634 <lodepng_encode+0xd06>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*IDAT (multiple IDAT chunks must be consecutive)*/
    state->error = addChunk_IDAT(&outv, data, datasize, &state->encoder.zlibsettings);
   1320f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13212:	8d 48 38             	lea    0x38(%eax),%ecx
   13215:	8b 55 bc             	mov    -0x44(%ebp),%edx
   13218:	8b 45 c0             	mov    -0x40(%ebp),%eax
   1321b:	51                   	push   %ecx
   1321c:	52                   	push   %edx
   1321d:	50                   	push   %eax
   1321e:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13221:	50                   	push   %eax
   13222:	e8 bd d9 ff ff       	call   10be4 <addChunk_IDAT>
   13227:	83 c4 10             	add    $0x10,%esp
   1322a:	89 c2                	mov    %eax,%edx
   1322c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1322f:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   13235:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13238:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1323e:	85 c0                	test   %eax,%eax
   13240:	0f 85 f1 03 00 00    	jne    13637 <lodepng_encode+0xd09>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*tIME*/
    if(info.time_defined) {
   13246:	8b 85 28 ff ff ff    	mov    -0xd8(%ebp),%eax
   1324c:	85 c0                	test   %eax,%eax
   1324e:	74 35                	je     13285 <lodepng_encode+0x957>
      state->error = addChunk_tIME(&outv, &info.time);
   13250:	83 ec 08             	sub    $0x8,%esp
   13253:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13259:	83 c0 60             	add    $0x60,%eax
   1325c:	50                   	push   %eax
   1325d:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13260:	50                   	push   %eax
   13261:	e8 5c df ff ff       	call   111c2 <addChunk_tIME>
   13266:	83 c4 10             	add    $0x10,%esp
   13269:	89 c2                	mov    %eax,%edx
   1326b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1326e:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13274:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13277:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1327d:	85 c0                	test   %eax,%eax
   1327f:	0f 85 b5 03 00 00    	jne    1363a <lodepng_encode+0xd0c>
    }
    /*tEXt and/or zTXt*/
    for(i = 0; i != info.text_num; ++i) {
   13285:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   1328c:	e9 12 01 00 00       	jmp    133a3 <lodepng_encode+0xa75>
      if(lodepng_strlen(info.text_keys[i]) > 79) {
   13291:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   13297:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   1329a:	c1 e2 02             	shl    $0x2,%edx
   1329d:	01 d0                	add    %edx,%eax
   1329f:	8b 00                	mov    (%eax),%eax
   132a1:	83 ec 0c             	sub    $0xc,%esp
   132a4:	50                   	push   %eax
   132a5:	e8 f5 01 ff ff       	call   349f <lodepng_strlen>
   132aa:	83 c4 10             	add    $0x10,%esp
   132ad:	83 f8 4f             	cmp    $0x4f,%eax
   132b0:	7e 12                	jle    132c4 <lodepng_encode+0x996>
        state->error = 66; /*text chunk too large*/
   132b2:	8b 45 1c             	mov    0x1c(%ebp),%eax
   132b5:	c7 80 7c 01 00 00 42 	movl   $0x42,0x17c(%eax)
   132bc:	00 00 00 
        goto cleanup;
   132bf:	e9 83 03 00 00       	jmp    13647 <lodepng_encode+0xd19>
      }
      if(lodepng_strlen(info.text_keys[i]) < 1) {
   132c4:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   132ca:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   132cd:	c1 e2 02             	shl    $0x2,%edx
   132d0:	01 d0                	add    %edx,%eax
   132d2:	8b 00                	mov    (%eax),%eax
   132d4:	83 ec 0c             	sub    $0xc,%esp
   132d7:	50                   	push   %eax
   132d8:	e8 c2 01 ff ff       	call   349f <lodepng_strlen>
   132dd:	83 c4 10             	add    $0x10,%esp
   132e0:	85 c0                	test   %eax,%eax
   132e2:	7f 12                	jg     132f6 <lodepng_encode+0x9c8>
        state->error = 67; /*text chunk too small*/
   132e4:	8b 45 1c             	mov    0x1c(%ebp),%eax
   132e7:	c7 80 7c 01 00 00 43 	movl   $0x43,0x17c(%eax)
   132ee:	00 00 00 
        goto cleanup;
   132f1:	e9 51 03 00 00       	jmp    13647 <lodepng_encode+0xd19>
      }
      if(state->encoder.text_compression) {
   132f6:	8b 45 1c             	mov    0x1c(%ebp),%eax
   132f9:	8b 40 74             	mov    0x74(%eax),%eax
   132fc:	85 c0                	test   %eax,%eax
   132fe:	74 52                	je     13352 <lodepng_encode+0xa24>
        state->error = addChunk_zTXt(&outv, info.text_keys[i], info.text_strings[i], &state->encoder.zlibsettings);
   13300:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13303:	8d 48 38             	lea    0x38(%eax),%ecx
   13306:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
   1330c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   1330f:	c1 e2 02             	shl    $0x2,%edx
   13312:	01 d0                	add    %edx,%eax
   13314:	8b 10                	mov    (%eax),%edx
   13316:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   1331c:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
   1331f:	c1 e3 02             	shl    $0x2,%ebx
   13322:	01 d8                	add    %ebx,%eax
   13324:	8b 00                	mov    (%eax),%eax
   13326:	51                   	push   %ecx
   13327:	52                   	push   %edx
   13328:	50                   	push   %eax
   13329:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1332c:	50                   	push   %eax
   1332d:	e8 fa d9 ff ff       	call   10d2c <addChunk_zTXt>
   13332:	83 c4 10             	add    $0x10,%esp
   13335:	89 c2                	mov    %eax,%edx
   13337:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1333a:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) goto cleanup;
   13340:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13343:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13349:	85 c0                	test   %eax,%eax
   1334b:	74 52                	je     1339f <lodepng_encode+0xa71>
   1334d:	e9 f5 02 00 00       	jmp    13647 <lodepng_encode+0xd19>
      } else {
        state->error = addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
   13352:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
   13358:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   1335b:	c1 e2 02             	shl    $0x2,%edx
   1335e:	01 d0                	add    %edx,%eax
   13360:	8b 10                	mov    (%eax),%edx
   13362:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   13368:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
   1336b:	c1 e1 02             	shl    $0x2,%ecx
   1336e:	01 c8                	add    %ecx,%eax
   13370:	8b 00                	mov    (%eax),%eax
   13372:	83 ec 04             	sub    $0x4,%esp
   13375:	52                   	push   %edx
   13376:	50                   	push   %eax
   13377:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1337a:	50                   	push   %eax
   1337b:	e8 ec d8 ff ff       	call   10c6c <addChunk_tEXt>
   13380:	83 c4 10             	add    $0x10,%esp
   13383:	89 c2                	mov    %eax,%edx
   13385:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13388:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) goto cleanup;
   1338e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13391:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13397:	85 c0                	test   %eax,%eax
   13399:	0f 85 9e 02 00 00    	jne    1363d <lodepng_encode+0xd0f>
    if(info.time_defined) {
      state->error = addChunk_tIME(&outv, &info.time);
      if(state->error) goto cleanup;
    }
    /*tEXt and/or zTXt*/
    for(i = 0; i != info.text_num; ++i) {
   1339f:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   133a3:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
   133a9:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   133ac:	0f 85 df fe ff ff    	jne    13291 <lodepng_encode+0x963>
        state->error = addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
        if(state->error) goto cleanup;
      }
    }
    /*LodePNG version id in text chunk*/
    if(state->encoder.add_id) {
   133b2:	8b 45 1c             	mov    0x1c(%ebp),%eax
   133b5:	8b 40 70             	mov    0x70(%eax),%eax
   133b8:	85 c0                	test   %eax,%eax
   133ba:	0f 84 e3 00 00 00    	je     134a3 <lodepng_encode+0xb75>
      unsigned already_added_id_text = 0;
   133c0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      for(i = 0; i != info.text_num; ++i) {
   133c7:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   133ce:	e9 85 00 00 00       	jmp    13458 <lodepng_encode+0xb2a>
        const char* k = info.text_keys[i];
   133d3:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   133d9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   133dc:	c1 e2 02             	shl    $0x2,%edx
   133df:	01 d0                	add    %edx,%eax
   133e1:	8b 00                	mov    (%eax),%eax
   133e3:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        /* Could use strcmp, but we're not calling or reimplementing this C library function for this use only */
        if(k[0] == 'L' && k[1] == 'o' && k[2] == 'd' && k[3] == 'e' &&
   133e6:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   133e9:	0f b6 00             	movzbl (%eax),%eax
   133ec:	3c 4c                	cmp    $0x4c,%al
   133ee:	75 64                	jne    13454 <lodepng_encode+0xb26>
   133f0:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   133f3:	83 c0 01             	add    $0x1,%eax
   133f6:	0f b6 00             	movzbl (%eax),%eax
   133f9:	3c 6f                	cmp    $0x6f,%al
   133fb:	75 57                	jne    13454 <lodepng_encode+0xb26>
   133fd:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   13400:	83 c0 02             	add    $0x2,%eax
   13403:	0f b6 00             	movzbl (%eax),%eax
   13406:	3c 64                	cmp    $0x64,%al
   13408:	75 4a                	jne    13454 <lodepng_encode+0xb26>
   1340a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   1340d:	83 c0 03             	add    $0x3,%eax
   13410:	0f b6 00             	movzbl (%eax),%eax
   13413:	3c 65                	cmp    $0x65,%al
   13415:	75 3d                	jne    13454 <lodepng_encode+0xb26>
           k[4] == 'P' && k[5] == 'N' && k[6] == 'G' && k[7] == '\0') {
   13417:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   1341a:	83 c0 04             	add    $0x4,%eax
   1341d:	0f b6 00             	movzbl (%eax),%eax
    if(state->encoder.add_id) {
      unsigned already_added_id_text = 0;
      for(i = 0; i != info.text_num; ++i) {
        const char* k = info.text_keys[i];
        /* Could use strcmp, but we're not calling or reimplementing this C library function for this use only */
        if(k[0] == 'L' && k[1] == 'o' && k[2] == 'd' && k[3] == 'e' &&
   13420:	3c 50                	cmp    $0x50,%al
   13422:	75 30                	jne    13454 <lodepng_encode+0xb26>
           k[4] == 'P' && k[5] == 'N' && k[6] == 'G' && k[7] == '\0') {
   13424:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   13427:	83 c0 05             	add    $0x5,%eax
   1342a:	0f b6 00             	movzbl (%eax),%eax
   1342d:	3c 4e                	cmp    $0x4e,%al
   1342f:	75 23                	jne    13454 <lodepng_encode+0xb26>
   13431:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   13434:	83 c0 06             	add    $0x6,%eax
   13437:	0f b6 00             	movzbl (%eax),%eax
   1343a:	3c 47                	cmp    $0x47,%al
   1343c:	75 16                	jne    13454 <lodepng_encode+0xb26>
   1343e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   13441:	83 c0 07             	add    $0x7,%eax
   13444:	0f b6 00             	movzbl (%eax),%eax
   13447:	84 c0                	test   %al,%al
   13449:	75 09                	jne    13454 <lodepng_encode+0xb26>
          already_added_id_text = 1;
   1344b:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
          break;
   13452:	eb 13                	jmp    13467 <lodepng_encode+0xb39>
      }
    }
    /*LodePNG version id in text chunk*/
    if(state->encoder.add_id) {
      unsigned already_added_id_text = 0;
      for(i = 0; i != info.text_num; ++i) {
   13454:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   13458:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
   1345e:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   13461:	0f 85 6c ff ff ff    	jne    133d3 <lodepng_encode+0xaa5>
           k[4] == 'P' && k[5] == 'N' && k[6] == 'G' && k[7] == '\0') {
          already_added_id_text = 1;
          break;
        }
      }
      if(already_added_id_text == 0) {
   13467:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   1346b:	75 36                	jne    134a3 <lodepng_encode+0xb75>
        state->error = addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
   1346d:	a1 e0 e1 01 00       	mov    0x1e1e0,%eax
   13472:	83 ec 04             	sub    $0x4,%esp
   13475:	50                   	push   %eax
   13476:	68 a4 a1 01 00       	push   $0x1a1a4
   1347b:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1347e:	50                   	push   %eax
   1347f:	e8 e8 d7 ff ff       	call   10c6c <addChunk_tEXt>
   13484:	83 c4 10             	add    $0x10,%esp
   13487:	89 c2                	mov    %eax,%edx
   13489:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1348c:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) goto cleanup;
   13492:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13495:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1349b:	85 c0                	test   %eax,%eax
   1349d:	0f 85 9d 01 00 00    	jne    13640 <lodepng_encode+0xd12>
      }
    }
    /*iTXt*/
    for(i = 0; i != info.itext_num; ++i) {
   134a3:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   134aa:	e9 e6 00 00 00       	jmp    13595 <lodepng_encode+0xc67>
      if(lodepng_strlen(info.itext_keys[i]) > 79) {
   134af:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
   134b5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   134b8:	c1 e2 02             	shl    $0x2,%edx
   134bb:	01 d0                	add    %edx,%eax
   134bd:	8b 00                	mov    (%eax),%eax
   134bf:	83 ec 0c             	sub    $0xc,%esp
   134c2:	50                   	push   %eax
   134c3:	e8 d7 ff fe ff       	call   349f <lodepng_strlen>
   134c8:	83 c4 10             	add    $0x10,%esp
   134cb:	83 f8 4f             	cmp    $0x4f,%eax
   134ce:	7e 12                	jle    134e2 <lodepng_encode+0xbb4>
        state->error = 66; /*text chunk too large*/
   134d0:	8b 45 1c             	mov    0x1c(%ebp),%eax
   134d3:	c7 80 7c 01 00 00 42 	movl   $0x42,0x17c(%eax)
   134da:	00 00 00 
        goto cleanup;
   134dd:	e9 65 01 00 00       	jmp    13647 <lodepng_encode+0xd19>
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
   134e2:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
   134e8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   134eb:	c1 e2 02             	shl    $0x2,%edx
   134ee:	01 d0                	add    %edx,%eax
   134f0:	8b 00                	mov    (%eax),%eax
   134f2:	83 ec 0c             	sub    $0xc,%esp
   134f5:	50                   	push   %eax
   134f6:	e8 a4 ff fe ff       	call   349f <lodepng_strlen>
   134fb:	83 c4 10             	add    $0x10,%esp
   134fe:	85 c0                	test   %eax,%eax
   13500:	7f 12                	jg     13514 <lodepng_encode+0xbe6>
        state->error = 67; /*text chunk too small*/
   13502:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13505:	c7 80 7c 01 00 00 43 	movl   $0x43,0x17c(%eax)
   1350c:	00 00 00 
        goto cleanup;
   1350f:	e9 33 01 00 00       	jmp    13647 <lodepng_encode+0xd19>
      }
      state->error = addChunk_iTXt(
   13514:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13517:	8d 78 38             	lea    0x38(%eax),%edi
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   1351a:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
   13520:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13523:	c1 e2 02             	shl    $0x2,%edx
   13526:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   13528:	8b 30                	mov    (%eax),%esi
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   1352a:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
   13530:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13533:	c1 e2 02             	shl    $0x2,%edx
   13536:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   13538:	8b 18                	mov    (%eax),%ebx
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   1353a:	8b 85 1c ff ff ff    	mov    -0xe4(%ebp),%eax
   13540:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13543:	c1 e2 02             	shl    $0x2,%edx
   13546:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   13548:	8b 08                	mov    (%eax),%ecx
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   1354a:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
   13550:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13553:	c1 e2 02             	shl    $0x2,%edx
   13556:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   13558:	8b 10                	mov    (%eax),%edx
   1355a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1355d:	8b 40 74             	mov    0x74(%eax),%eax
   13560:	83 ec 04             	sub    $0x4,%esp
   13563:	57                   	push   %edi
   13564:	56                   	push   %esi
   13565:	53                   	push   %ebx
   13566:	51                   	push   %ecx
   13567:	52                   	push   %edx
   13568:	50                   	push   %eax
   13569:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1356c:	50                   	push   %eax
   1356d:	e8 dc d8 ff ff       	call   10e4e <addChunk_iTXt>
   13572:	83 c4 20             	add    $0x20,%esp
   13575:	89 c2                	mov    %eax,%edx
   13577:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1357a:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
          &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
   13580:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13583:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13589:	85 c0                	test   %eax,%eax
   1358b:	0f 85 b2 00 00 00    	jne    13643 <lodepng_encode+0xd15>
        state->error = addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
        if(state->error) goto cleanup;
      }
    }
    /*iTXt*/
    for(i = 0; i != info.itext_num; ++i) {
   13591:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   13595:	8b 85 14 ff ff ff    	mov    -0xec(%ebp),%eax
   1359b:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   1359e:	0f 85 0b ff ff ff    	jne    134af <lodepng_encode+0xb81>
          &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
    }

    /*unknown chunks between IDAT and IEND*/
    if(info.unknown_chunks_data[2]) {
   135a4:	8b 45 a0             	mov    -0x60(%ebp),%eax
   135a7:	85 c0                	test   %eax,%eax
   135a9:	74 2f                	je     135da <lodepng_encode+0xcac>
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[2], info.unknown_chunks_size[2]);
   135ab:	8b 55 ac             	mov    -0x54(%ebp),%edx
   135ae:	8b 45 a0             	mov    -0x60(%ebp),%eax
   135b1:	83 ec 04             	sub    $0x4,%esp
   135b4:	52                   	push   %edx
   135b5:	50                   	push   %eax
   135b6:	8d 45 b0             	lea    -0x50(%ebp),%eax
   135b9:	50                   	push   %eax
   135ba:	e8 60 f2 ff ff       	call   1281f <addUnknownChunks>
   135bf:	83 c4 10             	add    $0x10,%esp
   135c2:	89 c2                	mov    %eax,%edx
   135c4:	8b 45 1c             	mov    0x1c(%ebp),%eax
   135c7:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   135cd:	8b 45 1c             	mov    0x1c(%ebp),%eax
   135d0:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   135d6:	85 c0                	test   %eax,%eax
   135d8:	75 6c                	jne    13646 <lodepng_encode+0xd18>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    state->error = addChunk_IEND(&outv);
   135da:	83 ec 0c             	sub    $0xc,%esp
   135dd:	8d 45 b0             	lea    -0x50(%ebp),%eax
   135e0:	50                   	push   %eax
   135e1:	e8 6d d6 ff ff       	call   10c53 <addChunk_IEND>
   135e6:	83 c4 10             	add    $0x10,%esp
   135e9:	89 c2                	mov    %eax,%edx
   135eb:	8b 45 1c             	mov    0x1c(%ebp),%eax
   135ee:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   135f4:	8b 45 1c             	mov    0x1c(%ebp),%eax
   135f7:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   135fd:	85 c0                	test   %eax,%eax
   135ff:	eb 46                	jmp    13647 <lodepng_encode+0xd19>
  if(info_png->interlace_method > 1) {
    state->error = 71; /*error: invalid interlace mode*/
    goto cleanup;
  }
  state->error = checkColorValidity(info_png->color.colortype, info_png->color.bitdepth);
  if(state->error) goto cleanup; /*error: invalid color type given*/
   13601:	90                   	nop
   13602:	eb 43                	jmp    13647 <lodepng_encode+0xd19>
  state->error = checkColorValidity(state->info_raw.colortype, state->info_raw.bitdepth);
  if(state->error) goto cleanup; /*error: invalid color type given*/
   13604:	90                   	nop
   13605:	eb 40                	jmp    13647 <lodepng_encode+0xd19>
      /*the PNG specification does not allow to use grayscale color with RGB ICC profile, so disallow gray.*/
      stats.allow_greyscale = 0;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = lodepng_compute_color_stats(&stats, image, w, h, &state->info_raw);
    if(state->error) goto cleanup;
   13607:	90                   	nop
   13608:	eb 3d                	jmp    13647 <lodepng_encode+0xd19>
      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);
      if(state->error) goto cleanup;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = auto_choose_color(&info.color, &state->info_raw, &stats);
    if(state->error) goto cleanup;
   1360a:	90                   	nop
   1360b:	eb 3a                	jmp    13647 <lodepng_encode+0xd19>
    }
    lodepng_free(converted);
    if(state->error) goto cleanup;
  } else {
    state->error = preProcessScanlines(&data, &datasize, image, w, h, &info, &state->encoder);
    if(state->error) goto cleanup;
   1360d:	90                   	nop
   1360e:	eb 37                	jmp    13647 <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    size_t i;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*write signature and chunks*/
    state->error = writeSignature(&outv);
    if(state->error) goto cleanup;
   13610:	90                   	nop
   13611:	eb 34                	jmp    13647 <lodepng_encode+0xd19>
    /*IHDR*/
    state->error = addChunk_IHDR(&outv, w, h, info.color.colortype, info.color.bitdepth, info.interlace_method);
    if(state->error) goto cleanup;
   13613:	90                   	nop
   13614:	eb 31                	jmp    13647 <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*unknown chunks between IHDR and PLTE*/
    if(info.unknown_chunks_data[0]) {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[0], info.unknown_chunks_size[0]);
      if(state->error) goto cleanup;
   13616:	90                   	nop
   13617:	eb 2e                	jmp    13647 <lodepng_encode+0xd19>
    }
    /*color profile chunks must come before PLTE */
    if(info.iccp_defined) {
      state->error = addChunk_iCCP(&outv, &info, &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
   13619:	90                   	nop
   1361a:	eb 2b                	jmp    13647 <lodepng_encode+0xd19>
    }
    if(info.srgb_defined) {
      state->error = addChunk_sRGB(&outv, &info);
      if(state->error) goto cleanup;
   1361c:	90                   	nop
   1361d:	eb 28                	jmp    13647 <lodepng_encode+0xd19>
    }
    if(info.gama_defined) {
      state->error = addChunk_gAMA(&outv, &info);
      if(state->error) goto cleanup;
   1361f:	90                   	nop
   13620:	eb 25                	jmp    13647 <lodepng_encode+0xd19>
    }
    if(info.chrm_defined) {
      state->error = addChunk_cHRM(&outv, &info);
      if(state->error) goto cleanup;
   13622:	90                   	nop
   13623:	eb 22                	jmp    13647 <lodepng_encode+0xd19>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*PLTE*/
    if(info.color.colortype == LCT_PALETTE) {
      state->error = addChunk_PLTE(&outv, &info.color);
      if(state->error) goto cleanup;
   13625:	90                   	nop
   13626:	eb 1f                	jmp    13647 <lodepng_encode+0xd19>
    }
    if(state->encoder.force_palette && (info.color.colortype == LCT_RGB || info.color.colortype == LCT_RGBA)) {
      /*force_palette means: write suggested palette for truecolor in PLTE chunk*/
      state->error = addChunk_PLTE(&outv, &info.color);
      if(state->error) goto cleanup;
   13628:	90                   	nop
   13629:	eb 1c                	jmp    13647 <lodepng_encode+0xd19>
    }
    /*tRNS (this will only add if when necessary) */
    state->error = addChunk_tRNS(&outv, &info.color);
    if(state->error) goto cleanup;
   1362b:	90                   	nop
   1362c:	eb 19                	jmp    13647 <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*bKGD (must come between PLTE and the IDAt chunks*/
    if(info.background_defined) {
      state->error = addChunk_bKGD(&outv, &info);
      if(state->error) goto cleanup;
   1362e:	90                   	nop
   1362f:	eb 16                	jmp    13647 <lodepng_encode+0xd19>
    }
    /*pHYs (must come before the IDAT chunks)*/
    if(info.phys_defined) {
      state->error = addChunk_pHYs(&outv, &info);
      if(state->error) goto cleanup;
   13631:	90                   	nop
   13632:	eb 13                	jmp    13647 <lodepng_encode+0xd19>
    }

    /*unknown chunks between PLTE and IDAT*/
    if(info.unknown_chunks_data[1]) {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[1], info.unknown_chunks_size[1]);
      if(state->error) goto cleanup;
   13634:	90                   	nop
   13635:	eb 10                	jmp    13647 <lodepng_encode+0xd19>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*IDAT (multiple IDAT chunks must be consecutive)*/
    state->error = addChunk_IDAT(&outv, data, datasize, &state->encoder.zlibsettings);
    if(state->error) goto cleanup;
   13637:	90                   	nop
   13638:	eb 0d                	jmp    13647 <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*tIME*/
    if(info.time_defined) {
      state->error = addChunk_tIME(&outv, &info.time);
      if(state->error) goto cleanup;
   1363a:	90                   	nop
   1363b:	eb 0a                	jmp    13647 <lodepng_encode+0xd19>
      if(state->encoder.text_compression) {
        state->error = addChunk_zTXt(&outv, info.text_keys[i], info.text_strings[i], &state->encoder.zlibsettings);
        if(state->error) goto cleanup;
      } else {
        state->error = addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
        if(state->error) goto cleanup;
   1363d:	90                   	nop
   1363e:	eb 07                	jmp    13647 <lodepng_encode+0xd19>
          break;
        }
      }
      if(already_added_id_text == 0) {
        state->error = addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
        if(state->error) goto cleanup;
   13640:	90                   	nop
   13641:	eb 04                	jmp    13647 <lodepng_encode+0xd19>
      }
      state->error = addChunk_iTXt(
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
          &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
   13643:	90                   	nop
   13644:	eb 01                	jmp    13647 <lodepng_encode+0xd19>
    }

    /*unknown chunks between IDAT and IEND*/
    if(info.unknown_chunks_data[2]) {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[2], info.unknown_chunks_size[2]);
      if(state->error) goto cleanup;
   13646:	90                   	nop
    state->error = addChunk_IEND(&outv);
    if(state->error) goto cleanup;
  }

cleanup:
  lodepng_info_cleanup(&info);
   13647:	83 ec 0c             	sub    $0xc,%esp
   1364a:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13650:	50                   	push   %eax
   13651:	e8 34 65 ff ff       	call   9b8a <lodepng_info_cleanup>
   13656:	83 c4 10             	add    $0x10,%esp
  lodepng_free(data);
   13659:	8b 45 c0             	mov    -0x40(%ebp),%eax
   1365c:	83 ec 0c             	sub    $0xc,%esp
   1365f:	50                   	push   %eax
   13660:	e8 bf fd fe ff       	call   3424 <lodepng_free>
   13665:	83 c4 10             	add    $0x10,%esp

  /*instead of cleaning the vector up, give it to the output*/
  *out = outv.data;
   13668:	8b 55 b0             	mov    -0x50(%ebp),%edx
   1366b:	8b 45 08             	mov    0x8(%ebp),%eax
   1366e:	89 10                	mov    %edx,(%eax)
  *outsize = outv.size;
   13670:	8b 55 b4             	mov    -0x4c(%ebp),%edx
   13673:	8b 45 0c             	mov    0xc(%ebp),%eax
   13676:	89 10                	mov    %edx,(%eax)

  return state->error;
   13678:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1367b:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
}
   13681:	8d 65 f4             	lea    -0xc(%ebp),%esp
   13684:	5b                   	pop    %ebx
   13685:	5e                   	pop    %esi
   13686:	5f                   	pop    %edi
   13687:	5d                   	pop    %ebp
   13688:	c3                   	ret    

00013689 <lodepng_encode_memory>:

unsigned lodepng_encode_memory(unsigned char** out, size_t* outsize, const unsigned char* image,
                               unsigned w, unsigned h, LodePNGColorType colortype, unsigned bitdepth) {
   13689:	55                   	push   %ebp
   1368a:	89 e5                	mov    %esp,%ebp
   1368c:	81 ec 98 01 00 00    	sub    $0x198,%esp
  unsigned error;
  LodePNGState state;
  lodepng_state_init(&state);
   13692:	83 ec 0c             	sub    $0xc,%esp
   13695:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   1369b:	50                   	push   %eax
   1369c:	e8 38 d0 ff ff       	call   106d9 <lodepng_state_init>
   136a1:	83 c4 10             	add    $0x10,%esp
  state.info_raw.colortype = colortype;
   136a4:	8b 45 1c             	mov    0x1c(%ebp),%eax
   136a7:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
  state.info_raw.bitdepth = bitdepth;
   136ad:	8b 45 20             	mov    0x20(%ebp),%eax
   136b0:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
  state.info_png.color.colortype = colortype;
   136b6:	8b 45 1c             	mov    0x1c(%ebp),%eax
   136b9:	89 85 18 ff ff ff    	mov    %eax,-0xe8(%ebp)
  state.info_png.color.bitdepth = bitdepth;
   136bf:	8b 45 20             	mov    0x20(%ebp),%eax
   136c2:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%ebp)
  lodepng_encode(out, outsize, image, w, h, &state);
   136c8:	83 ec 08             	sub    $0x8,%esp
   136cb:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   136d1:	50                   	push   %eax
   136d2:	ff 75 18             	pushl  0x18(%ebp)
   136d5:	ff 75 14             	pushl  0x14(%ebp)
   136d8:	ff 75 10             	pushl  0x10(%ebp)
   136db:	ff 75 0c             	pushl  0xc(%ebp)
   136de:	ff 75 08             	pushl  0x8(%ebp)
   136e1:	e8 48 f2 ff ff       	call   1292e <lodepng_encode>
   136e6:	83 c4 20             	add    $0x20,%esp
  error = state.error;
   136e9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   136ec:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_state_cleanup(&state);
   136ef:	83 ec 0c             	sub    $0xc,%esp
   136f2:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   136f8:	50                   	push   %eax
   136f9:	e8 35 d0 ff ff       	call   10733 <lodepng_state_cleanup>
   136fe:	83 c4 10             	add    $0x10,%esp
  return error;
   13701:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   13704:	c9                   	leave  
   13705:	c3                   	ret    

00013706 <lodepng_encode32>:

unsigned lodepng_encode32(unsigned char** out, size_t* outsize, const unsigned char* image, unsigned w, unsigned h) {
   13706:	55                   	push   %ebp
   13707:	89 e5                	mov    %esp,%ebp
   13709:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_memory(out, outsize, image, w, h, LCT_RGBA, 8);
   1370c:	83 ec 04             	sub    $0x4,%esp
   1370f:	6a 08                	push   $0x8
   13711:	6a 06                	push   $0x6
   13713:	ff 75 18             	pushl  0x18(%ebp)
   13716:	ff 75 14             	pushl  0x14(%ebp)
   13719:	ff 75 10             	pushl  0x10(%ebp)
   1371c:	ff 75 0c             	pushl  0xc(%ebp)
   1371f:	ff 75 08             	pushl  0x8(%ebp)
   13722:	e8 62 ff ff ff       	call   13689 <lodepng_encode_memory>
   13727:	83 c4 20             	add    $0x20,%esp
}
   1372a:	c9                   	leave  
   1372b:	c3                   	ret    

0001372c <lodepng_encode24>:

unsigned lodepng_encode24(unsigned char** out, size_t* outsize, const unsigned char* image, unsigned w, unsigned h) {
   1372c:	55                   	push   %ebp
   1372d:	89 e5                	mov    %esp,%ebp
   1372f:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_memory(out, outsize, image, w, h, LCT_RGB, 8);
   13732:	83 ec 04             	sub    $0x4,%esp
   13735:	6a 08                	push   $0x8
   13737:	6a 02                	push   $0x2
   13739:	ff 75 18             	pushl  0x18(%ebp)
   1373c:	ff 75 14             	pushl  0x14(%ebp)
   1373f:	ff 75 10             	pushl  0x10(%ebp)
   13742:	ff 75 0c             	pushl  0xc(%ebp)
   13745:	ff 75 08             	pushl  0x8(%ebp)
   13748:	e8 3c ff ff ff       	call   13689 <lodepng_encode_memory>
   1374d:	83 c4 20             	add    $0x20,%esp
}
   13750:	c9                   	leave  
   13751:	c3                   	ret    

00013752 <lodepng_encode_file>:

#ifdef LODEPNG_COMPILE_DISK
unsigned lodepng_encode_file(const char* filename, const unsigned char* image, unsigned w, unsigned h,
                             LodePNGColorType colortype, unsigned bitdepth) {
   13752:	55                   	push   %ebp
   13753:	89 e5                	mov    %esp,%ebp
   13755:	83 ec 18             	sub    $0x18,%esp
  unsigned char* buffer;
  size_t buffersize;
  unsigned error = lodepng_encode_memory(&buffer, &buffersize, image, w, h, colortype, bitdepth);
   13758:	83 ec 04             	sub    $0x4,%esp
   1375b:	ff 75 1c             	pushl  0x1c(%ebp)
   1375e:	ff 75 18             	pushl  0x18(%ebp)
   13761:	ff 75 14             	pushl  0x14(%ebp)
   13764:	ff 75 10             	pushl  0x10(%ebp)
   13767:	ff 75 0c             	pushl  0xc(%ebp)
   1376a:	8d 45 ec             	lea    -0x14(%ebp),%eax
   1376d:	50                   	push   %eax
   1376e:	8d 45 f0             	lea    -0x10(%ebp),%eax
   13771:	50                   	push   %eax
   13772:	e8 12 ff ff ff       	call   13689 <lodepng_encode_memory>
   13777:	83 c4 20             	add    $0x20,%esp
   1377a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = lodepng_save_file(buffer, buffersize, filename);
   1377d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   13781:	75 19                	jne    1379c <lodepng_encode_file+0x4a>
   13783:	8b 55 ec             	mov    -0x14(%ebp),%edx
   13786:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13789:	83 ec 04             	sub    $0x4,%esp
   1378c:	ff 75 08             	pushl  0x8(%ebp)
   1378f:	52                   	push   %edx
   13790:	50                   	push   %eax
   13791:	e8 36 01 ff ff       	call   38cc <lodepng_save_file>
   13796:	83 c4 10             	add    $0x10,%esp
   13799:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_free(buffer);
   1379c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1379f:	83 ec 0c             	sub    $0xc,%esp
   137a2:	50                   	push   %eax
   137a3:	e8 7c fc fe ff       	call   3424 <lodepng_free>
   137a8:	83 c4 10             	add    $0x10,%esp
  return error;
   137ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   137ae:	c9                   	leave  
   137af:	c3                   	ret    

000137b0 <lodepng_encode32_file>:

unsigned lodepng_encode32_file(const char* filename, const unsigned char* image, unsigned w, unsigned h) {
   137b0:	55                   	push   %ebp
   137b1:	89 e5                	mov    %esp,%ebp
   137b3:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_file(filename, image, w, h, LCT_RGBA, 8);
   137b6:	83 ec 08             	sub    $0x8,%esp
   137b9:	6a 08                	push   $0x8
   137bb:	6a 06                	push   $0x6
   137bd:	ff 75 14             	pushl  0x14(%ebp)
   137c0:	ff 75 10             	pushl  0x10(%ebp)
   137c3:	ff 75 0c             	pushl  0xc(%ebp)
   137c6:	ff 75 08             	pushl  0x8(%ebp)
   137c9:	e8 84 ff ff ff       	call   13752 <lodepng_encode_file>
   137ce:	83 c4 20             	add    $0x20,%esp
}
   137d1:	c9                   	leave  
   137d2:	c3                   	ret    

000137d3 <lodepng_encode24_file>:

unsigned lodepng_encode24_file(const char* filename, const unsigned char* image, unsigned w, unsigned h) {
   137d3:	55                   	push   %ebp
   137d4:	89 e5                	mov    %esp,%ebp
   137d6:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_file(filename, image, w, h, LCT_RGB, 8);
   137d9:	83 ec 08             	sub    $0x8,%esp
   137dc:	6a 08                	push   $0x8
   137de:	6a 02                	push   $0x2
   137e0:	ff 75 14             	pushl  0x14(%ebp)
   137e3:	ff 75 10             	pushl  0x10(%ebp)
   137e6:	ff 75 0c             	pushl  0xc(%ebp)
   137e9:	ff 75 08             	pushl  0x8(%ebp)
   137ec:	e8 61 ff ff ff       	call   13752 <lodepng_encode_file>
   137f1:	83 c4 20             	add    $0x20,%esp
}
   137f4:	c9                   	leave  
   137f5:	c3                   	ret    

000137f6 <lodepng_encoder_settings_init>:
#endif /*LODEPNG_COMPILE_DISK*/

void lodepng_encoder_settings_init(LodePNGEncoderSettings* settings) {
   137f6:	55                   	push   %ebp
   137f7:	89 e5                	mov    %esp,%ebp
  lodepng_compress_settings_init(&settings->zlibsettings);
   137f9:	8b 45 08             	mov    0x8(%ebp),%eax
   137fc:	50                   	push   %eax
   137fd:	e8 71 49 ff ff       	call   8173 <lodepng_compress_settings_init>
   13802:	83 c4 04             	add    $0x4,%esp
  settings->filter_palette_zero = 1;
   13805:	8b 45 08             	mov    0x8(%ebp),%eax
   13808:	c7 40 28 01 00 00 00 	movl   $0x1,0x28(%eax)
  settings->filter_strategy = LFS_MINSUM;
   1380f:	8b 45 08             	mov    0x8(%ebp),%eax
   13812:	c7 40 2c 05 00 00 00 	movl   $0x5,0x2c(%eax)
  settings->auto_convert = 1;
   13819:	8b 45 08             	mov    0x8(%ebp),%eax
   1381c:	c7 40 24 01 00 00 00 	movl   $0x1,0x24(%eax)
  settings->force_palette = 0;
   13823:	8b 45 08             	mov    0x8(%ebp),%eax
   13826:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%eax)
  settings->predefined_filters = 0;
   1382d:	8b 45 08             	mov    0x8(%ebp),%eax
   13830:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  settings->add_id = 0;
   13837:	8b 45 08             	mov    0x8(%ebp),%eax
   1383a:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
  settings->text_compression = 1;
   13841:	8b 45 08             	mov    0x8(%ebp),%eax
   13844:	c7 40 3c 01 00 00 00 	movl   $0x1,0x3c(%eax)
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}
   1384b:	90                   	nop
   1384c:	c9                   	leave  
   1384d:	c3                   	ret    

0001384e <lodepng_error_text>:
#ifdef LODEPNG_COMPILE_ERROR_TEXT
/*
This returns the description of a numerical error code in English. This is also
the documentation of all the error codes.
*/
const char* lodepng_error_text(unsigned code) {
   1384e:	55                   	push   %ebp
   1384f:	89 e5                	mov    %esp,%ebp
  switch(code) {
   13851:	83 7d 08 71          	cmpl   $0x71,0x8(%ebp)
   13855:	0f 87 c1 03 00 00    	ja     13c1c <lodepng_error_text+0x3ce>
   1385b:	8b 45 08             	mov    0x8(%ebp),%eax
   1385e:	c1 e0 02             	shl    $0x2,%eax
   13861:	05 e0 b4 01 00       	add    $0x1b4e0,%eax
   13866:	8b 00                	mov    (%eax),%eax
   13868:	ff e0                	jmp    *%eax
    case 0: return "no error, everything went ok";
   1386a:	b8 ac a1 01 00       	mov    $0x1a1ac,%eax
   1386f:	e9 ad 03 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 1: return "nothing done yet"; /*the Encoder/Decoder has done nothing yet, error checking makes no sense yet*/
   13874:	b8 c9 a1 01 00       	mov    $0x1a1c9,%eax
   13879:	e9 a3 03 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 10: return "end of input memory reached without huffman end code"; /*while huffman decoding*/
   1387e:	b8 dc a1 01 00       	mov    $0x1a1dc,%eax
   13883:	e9 99 03 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 11: return "error in code tree made it jump outside of huffman tree"; /*while huffman decoding*/
   13888:	b8 14 a2 01 00       	mov    $0x1a214,%eax
   1388d:	e9 8f 03 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 13: return "problem while processing dynamic deflate block";
   13892:	b8 4c a2 01 00       	mov    $0x1a24c,%eax
   13897:	e9 85 03 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 14: return "problem while processing dynamic deflate block";
   1389c:	b8 4c a2 01 00       	mov    $0x1a24c,%eax
   138a1:	e9 7b 03 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 15: return "problem while processing dynamic deflate block";
   138a6:	b8 4c a2 01 00       	mov    $0x1a24c,%eax
   138ab:	e9 71 03 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    /*this error could happen if there are only 0 or 1 symbols present in the huffman code:*/
    case 16: return "invalid code while processing dynamic deflate block";
   138b0:	b8 7c a2 01 00       	mov    $0x1a27c,%eax
   138b5:	e9 67 03 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 17: return "end of out buffer memory reached while inflating";
   138ba:	b8 b0 a2 01 00       	mov    $0x1a2b0,%eax
   138bf:	e9 5d 03 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 18: return "invalid distance code while inflating";
   138c4:	b8 e4 a2 01 00       	mov    $0x1a2e4,%eax
   138c9:	e9 53 03 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 19: return "end of out buffer memory reached while inflating";
   138ce:	b8 b0 a2 01 00       	mov    $0x1a2b0,%eax
   138d3:	e9 49 03 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 20: return "invalid deflate block BTYPE encountered while decoding";
   138d8:	b8 0c a3 01 00       	mov    $0x1a30c,%eax
   138dd:	e9 3f 03 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 21: return "NLEN is not ones complement of LEN in a deflate block";
   138e2:	b8 44 a3 01 00       	mov    $0x1a344,%eax
   138e7:	e9 35 03 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>

    /*end of out buffer memory reached while inflating:
    This can happen if the inflated deflate data is longer than the amount of bytes required to fill up
    all the pixels of the image, given the color depth and image dimensions. Something that doesn't
    happen in a normal, well encoded, PNG image.*/
    case 22: return "end of out buffer memory reached while inflating";
   138ec:	b8 b0 a2 01 00       	mov    $0x1a2b0,%eax
   138f1:	e9 2b 03 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 23: return "end of in buffer memory reached while inflating";
   138f6:	b8 7c a3 01 00       	mov    $0x1a37c,%eax
   138fb:	e9 21 03 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 24: return "invalid FCHECK in zlib header";
   13900:	b8 ac a3 01 00       	mov    $0x1a3ac,%eax
   13905:	e9 17 03 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 25: return "invalid compression method in zlib header";
   1390a:	b8 cc a3 01 00       	mov    $0x1a3cc,%eax
   1390f:	e9 0d 03 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 26: return "FDICT encountered in zlib header while it's not used for PNG";
   13914:	b8 f8 a3 01 00       	mov    $0x1a3f8,%eax
   13919:	e9 03 03 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 27: return "PNG file is smaller than a PNG header";
   1391e:	b8 38 a4 01 00       	mov    $0x1a438,%eax
   13923:	e9 f9 02 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    /*Checks the magic file header, the first 8 bytes of the PNG file*/
    case 28: return "incorrect PNG signature, it's no PNG or corrupted";
   13928:	b8 60 a4 01 00       	mov    $0x1a460,%eax
   1392d:	e9 ef 02 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 29: return "first chunk is not the header chunk";
   13932:	b8 94 a4 01 00       	mov    $0x1a494,%eax
   13937:	e9 e5 02 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 30: return "chunk length too large, chunk broken off at end of file";
   1393c:	b8 b8 a4 01 00       	mov    $0x1a4b8,%eax
   13941:	e9 db 02 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 31: return "illegal PNG color type or bpp";
   13946:	b8 f0 a4 01 00       	mov    $0x1a4f0,%eax
   1394b:	e9 d1 02 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 32: return "illegal PNG compression method";
   13950:	b8 10 a5 01 00       	mov    $0x1a510,%eax
   13955:	e9 c7 02 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 33: return "illegal PNG filter method";
   1395a:	b8 2f a5 01 00       	mov    $0x1a52f,%eax
   1395f:	e9 bd 02 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 34: return "illegal PNG interlace method";
   13964:	b8 49 a5 01 00       	mov    $0x1a549,%eax
   13969:	e9 b3 02 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 35: return "chunk length of a chunk is too large or the chunk too small";
   1396e:	b8 68 a5 01 00       	mov    $0x1a568,%eax
   13973:	e9 a9 02 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 36: return "illegal PNG filter type encountered";
   13978:	b8 a4 a5 01 00       	mov    $0x1a5a4,%eax
   1397d:	e9 9f 02 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 37: return "illegal bit depth for this color type given";
   13982:	b8 c8 a5 01 00       	mov    $0x1a5c8,%eax
   13987:	e9 95 02 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 38: return "the palette is too small or too big"; /*0, or more than 256 colors*/
   1398c:	b8 f4 a5 01 00       	mov    $0x1a5f4,%eax
   13991:	e9 8b 02 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 39: return "tRNS chunk before PLTE or has more entries than palette size";
   13996:	b8 18 a6 01 00       	mov    $0x1a618,%eax
   1399b:	e9 81 02 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 40: return "tRNS chunk has wrong size for grayscale image";
   139a0:	b8 58 a6 01 00       	mov    $0x1a658,%eax
   139a5:	e9 77 02 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 41: return "tRNS chunk has wrong size for RGB image";
   139aa:	b8 88 a6 01 00       	mov    $0x1a688,%eax
   139af:	e9 6d 02 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 42: return "tRNS chunk appeared while it was not allowed for this color type";
   139b4:	b8 b0 a6 01 00       	mov    $0x1a6b0,%eax
   139b9:	e9 63 02 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 43: return "bKGD chunk has wrong size for palette image";
   139be:	b8 f4 a6 01 00       	mov    $0x1a6f4,%eax
   139c3:	e9 59 02 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 44: return "bKGD chunk has wrong size for grayscale image";
   139c8:	b8 20 a7 01 00       	mov    $0x1a720,%eax
   139cd:	e9 4f 02 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 45: return "bKGD chunk has wrong size for RGB image";
   139d2:	b8 50 a7 01 00       	mov    $0x1a750,%eax
   139d7:	e9 45 02 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 48: return "empty input buffer given to decoder. Maybe caused by non-existing file?";
   139dc:	b8 78 a7 01 00       	mov    $0x1a778,%eax
   139e1:	e9 3b 02 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 49: return "jumped past memory while generating dynamic huffman tree";
   139e6:	b8 c0 a7 01 00       	mov    $0x1a7c0,%eax
   139eb:	e9 31 02 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 50: return "jumped past memory while generating dynamic huffman tree";
   139f0:	b8 c0 a7 01 00       	mov    $0x1a7c0,%eax
   139f5:	e9 27 02 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 51: return "jumped past memory while inflating huffman block";
   139fa:	b8 fc a7 01 00       	mov    $0x1a7fc,%eax
   139ff:	e9 1d 02 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 52: return "jumped past memory while inflating";
   13a04:	b8 30 a8 01 00       	mov    $0x1a830,%eax
   13a09:	e9 13 02 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 53: return "size of zlib data too small";
   13a0e:	b8 53 a8 01 00       	mov    $0x1a853,%eax
   13a13:	e9 09 02 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 54: return "repeat symbol in tree while there was no value symbol yet";
   13a18:	b8 70 a8 01 00       	mov    $0x1a870,%eax
   13a1d:	e9 ff 01 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    /*jumped past tree while generating huffman tree, this could be when the
    tree will have more leaves than symbols after generating it out of the
    given lengths. They call this an oversubscribed dynamic bit lengths tree in zlib.*/
    case 55: return "jumped past tree while generating huffman tree";
   13a22:	b8 ac a8 01 00       	mov    $0x1a8ac,%eax
   13a27:	e9 f5 01 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 56: return "given output image colortype or bitdepth not supported for color conversion";
   13a2c:	b8 dc a8 01 00       	mov    $0x1a8dc,%eax
   13a31:	e9 eb 01 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 57: return "invalid CRC encountered (checking CRC can be disabled)";
   13a36:	b8 28 a9 01 00       	mov    $0x1a928,%eax
   13a3b:	e9 e1 01 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 58: return "invalid ADLER32 encountered (checking ADLER32 can be disabled)";
   13a40:	b8 60 a9 01 00       	mov    $0x1a960,%eax
   13a45:	e9 d7 01 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 59: return "requested color conversion not supported";
   13a4a:	b8 a0 a9 01 00       	mov    $0x1a9a0,%eax
   13a4f:	e9 cd 01 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 60: return "invalid window size given in the settings of the encoder (must be 0-32768)";
   13a54:	b8 cc a9 01 00       	mov    $0x1a9cc,%eax
   13a59:	e9 c3 01 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 61: return "invalid BTYPE given in the settings of the encoder (only 0, 1 and 2 are allowed)";
   13a5e:	b8 18 aa 01 00       	mov    $0x1aa18,%eax
   13a63:	e9 b9 01 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    /*LodePNG leaves the choice of RGB to grayscale conversion formula to the user.*/
    case 62: return "conversion from color to grayscale not supported";
   13a68:	b8 6c aa 01 00       	mov    $0x1aa6c,%eax
   13a6d:	e9 af 01 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    /*(2^31-1)*/
    case 63: return "length of a chunk too long, max allowed for PNG is 2147483647 bytes per chunk";
   13a72:	b8 a0 aa 01 00       	mov    $0x1aaa0,%eax
   13a77:	e9 a5 01 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    /*this would result in the inability of a deflated block to ever contain an end code. It must be at least 1.*/
    case 64: return "the length of the END symbol 256 in the Huffman tree is 0";
   13a7c:	b8 f0 aa 01 00       	mov    $0x1aaf0,%eax
   13a81:	e9 9b 01 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 66: return "the length of a text chunk keyword given to the encoder is longer than the maximum of 79 bytes";
   13a86:	b8 2c ab 01 00       	mov    $0x1ab2c,%eax
   13a8b:	e9 91 01 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 67: return "the length of a text chunk keyword given to the encoder is smaller than the minimum of 1 byte";
   13a90:	b8 8c ab 01 00       	mov    $0x1ab8c,%eax
   13a95:	e9 87 01 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 68: return "tried to encode a PLTE chunk with a palette that has less than 1 or more than 256 colors";
   13a9a:	b8 ec ab 01 00       	mov    $0x1abec,%eax
   13a9f:	e9 7d 01 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 69: return "unknown chunk type with 'critical' flag encountered by the decoder";
   13aa4:	b8 48 ac 01 00       	mov    $0x1ac48,%eax
   13aa9:	e9 73 01 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 71: return "invalid interlace mode given to encoder (must be 0 or 1)";
   13aae:	b8 8c ac 01 00       	mov    $0x1ac8c,%eax
   13ab3:	e9 69 01 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 72: return "while decoding, invalid compression method encountering in zTXt or iTXt chunk (it must be 0)";
   13ab8:	b8 c8 ac 01 00       	mov    $0x1acc8,%eax
   13abd:	e9 5f 01 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 73: return "invalid tIME chunk size";
   13ac2:	b8 25 ad 01 00       	mov    $0x1ad25,%eax
   13ac7:	e9 55 01 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 74: return "invalid pHYs chunk size";
   13acc:	b8 3d ad 01 00       	mov    $0x1ad3d,%eax
   13ad1:	e9 4b 01 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    /*length could be wrong, or data chopped off*/
    case 75: return "no null termination char found while decoding text chunk";
   13ad6:	b8 58 ad 01 00       	mov    $0x1ad58,%eax
   13adb:	e9 41 01 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 76: return "iTXt chunk too short to contain required bytes";
   13ae0:	b8 94 ad 01 00       	mov    $0x1ad94,%eax
   13ae5:	e9 37 01 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 77: return "integer overflow in buffer size";
   13aea:	b8 c4 ad 01 00       	mov    $0x1adc4,%eax
   13aef:	e9 2d 01 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 78: return "failed to open file for reading"; /*file doesn't exist or couldn't be opened for reading*/
   13af4:	b8 e4 ad 01 00       	mov    $0x1ade4,%eax
   13af9:	e9 23 01 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 79: return "failed to open file for writing";
   13afe:	b8 04 ae 01 00       	mov    $0x1ae04,%eax
   13b03:	e9 19 01 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 80: return "tried creating a tree of 0 symbols";
   13b08:	b8 24 ae 01 00       	mov    $0x1ae24,%eax
   13b0d:	e9 0f 01 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 81: return "lazy matching at pos 0 is impossible";
   13b12:	b8 48 ae 01 00       	mov    $0x1ae48,%eax
   13b17:	e9 05 01 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 82: return "color conversion to palette requested while a color isn't in palette, or index out of bounds";
   13b1c:	b8 70 ae 01 00       	mov    $0x1ae70,%eax
   13b21:	e9 fb 00 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 83: return "memory allocation failed";
   13b26:	b8 cd ae 01 00       	mov    $0x1aecd,%eax
   13b2b:	e9 f1 00 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 84: return "given image too small to contain all pixels to be encoded";
   13b30:	b8 e8 ae 01 00       	mov    $0x1aee8,%eax
   13b35:	e9 e7 00 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 86: return "impossible offset in lz77 encoding (internal bug)";
   13b3a:	b8 24 af 01 00       	mov    $0x1af24,%eax
   13b3f:	e9 dd 00 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 87: return "must provide custom zlib function pointer if LODEPNG_COMPILE_ZLIB is not defined";
   13b44:	b8 58 af 01 00       	mov    $0x1af58,%eax
   13b49:	e9 d3 00 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 88: return "invalid filter strategy given for LodePNGEncoderSettings.filter_strategy";
   13b4e:	b8 ac af 01 00       	mov    $0x1afac,%eax
   13b53:	e9 c9 00 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 89: return "text chunk keyword too short or long: must have size 1-79";
   13b58:	b8 f8 af 01 00       	mov    $0x1aff8,%eax
   13b5d:	e9 bf 00 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    /*the windowsize in the LodePNGCompressSettings. Requiring POT(==> & instead of %) makes encoding 12% faster.*/
    case 90: return "windowsize must be a power of two";
   13b62:	b8 34 b0 01 00       	mov    $0x1b034,%eax
   13b67:	e9 b5 00 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 91: return "invalid decompressed idat size";
   13b6c:	b8 58 b0 01 00       	mov    $0x1b058,%eax
   13b71:	e9 ab 00 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 92: return "integer overflow due to too many pixels";
   13b76:	b8 78 b0 01 00       	mov    $0x1b078,%eax
   13b7b:	e9 a1 00 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 93: return "zero width or height is invalid";
   13b80:	b8 a0 b0 01 00       	mov    $0x1b0a0,%eax
   13b85:	e9 97 00 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 94: return "header chunk must have a size of 13 bytes";
   13b8a:	b8 c0 b0 01 00       	mov    $0x1b0c0,%eax
   13b8f:	e9 8d 00 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 95: return "integer overflow with combined idat chunk size";
   13b94:	b8 ec b0 01 00       	mov    $0x1b0ec,%eax
   13b99:	e9 83 00 00 00       	jmp    13c21 <lodepng_error_text+0x3d3>
    case 96: return "invalid gAMA chunk size";
   13b9e:	b8 1b b1 01 00       	mov    $0x1b11b,%eax
   13ba3:	eb 7c                	jmp    13c21 <lodepng_error_text+0x3d3>
    case 97: return "invalid cHRM chunk size";
   13ba5:	b8 33 b1 01 00       	mov    $0x1b133,%eax
   13baa:	eb 75                	jmp    13c21 <lodepng_error_text+0x3d3>
    case 98: return "invalid sRGB chunk size";
   13bac:	b8 4b b1 01 00       	mov    $0x1b14b,%eax
   13bb1:	eb 6e                	jmp    13c21 <lodepng_error_text+0x3d3>
    case 99: return "invalid sRGB rendering intent";
   13bb3:	b8 63 b1 01 00       	mov    $0x1b163,%eax
   13bb8:	eb 67                	jmp    13c21 <lodepng_error_text+0x3d3>
    case 100: return "invalid ICC profile color type, the PNG specification only allows RGB or GRAY";
   13bba:	b8 84 b1 01 00       	mov    $0x1b184,%eax
   13bbf:	eb 60                	jmp    13c21 <lodepng_error_text+0x3d3>
    case 101: return "PNG specification does not allow RGB ICC profile on gray color types and vice versa";
   13bc1:	b8 d4 b1 01 00       	mov    $0x1b1d4,%eax
   13bc6:	eb 59                	jmp    13c21 <lodepng_error_text+0x3d3>
    case 102: return "not allowed to set grayscale ICC profile with colored pixels by PNG specification";
   13bc8:	b8 28 b2 01 00       	mov    $0x1b228,%eax
   13bcd:	eb 52                	jmp    13c21 <lodepng_error_text+0x3d3>
    case 103: return "invalid palette index in bKGD chunk. Maybe it came before PLTE chunk?";
   13bcf:	b8 7c b2 01 00       	mov    $0x1b27c,%eax
   13bd4:	eb 4b                	jmp    13c21 <lodepng_error_text+0x3d3>
    case 104: return "invalid bKGD color while encoding (e.g. palette index out of range)";
   13bd6:	b8 c4 b2 01 00       	mov    $0x1b2c4,%eax
   13bdb:	eb 44                	jmp    13c21 <lodepng_error_text+0x3d3>
    case 105: return "integer overflow of bitsize";
   13bdd:	b8 08 b3 01 00       	mov    $0x1b308,%eax
   13be2:	eb 3d                	jmp    13c21 <lodepng_error_text+0x3d3>
    case 106: return "PNG file must have PLTE chunk if color type is palette";
   13be4:	b8 24 b3 01 00       	mov    $0x1b324,%eax
   13be9:	eb 36                	jmp    13c21 <lodepng_error_text+0x3d3>
    case 107: return "color convert from palette mode requested without setting the palette data in it";
   13beb:	b8 5c b3 01 00       	mov    $0x1b35c,%eax
   13bf0:	eb 2f                	jmp    13c21 <lodepng_error_text+0x3d3>
    case 108: return "tried to add more than 256 values to a palette";
   13bf2:	b8 b0 b3 01 00       	mov    $0x1b3b0,%eax
   13bf7:	eb 28                	jmp    13c21 <lodepng_error_text+0x3d3>
    /*this limit can be configured in LodePNGDecompressSettings*/
    case 109: return "tried to decompress zlib or deflate data larger than desired max_output_size";
   13bf9:	b8 e0 b3 01 00       	mov    $0x1b3e0,%eax
   13bfe:	eb 21                	jmp    13c21 <lodepng_error_text+0x3d3>
    case 110: return "custom zlib or inflate decompression failed";
   13c00:	b8 30 b4 01 00       	mov    $0x1b430,%eax
   13c05:	eb 1a                	jmp    13c21 <lodepng_error_text+0x3d3>
    case 111: return "custom zlib or deflate compression failed";
   13c07:	b8 5c b4 01 00       	mov    $0x1b45c,%eax
   13c0c:	eb 13                	jmp    13c21 <lodepng_error_text+0x3d3>
    /*max text size limit can be configured in LodePNGDecoderSettings. This error prevents
    unreasonable memory consumption when decoding due to impossibly large text sizes.*/
    case 112: return "compressed text unreasonably large";
   13c0e:	b8 88 b4 01 00       	mov    $0x1b488,%eax
   13c13:	eb 0c                	jmp    13c21 <lodepng_error_text+0x3d3>
    /*max ICC size limit can be configured in LodePNGDecoderSettings. This error prevents
    unreasonable memory consumption when decoding due to impossibly large ICC profile*/
    case 113: return "ICC profile unreasonably large";
   13c15:	b8 ac b4 01 00       	mov    $0x1b4ac,%eax
   13c1a:	eb 05                	jmp    13c21 <lodepng_error_text+0x3d3>
  }
  return "unknown error code";
   13c1c:	b8 cb b4 01 00       	mov    $0x1b4cb,%eax
}
   13c21:	5d                   	pop    %ebp
   13c22:	c3                   	ret    

00013c23 <GetImage>:
#include "loadjpeg.h"

uchar* GetImage(Context* ctx){
   13c23:	55                   	push   %ebp
   13c24:	89 e5                	mov    %esp,%ebp
    return (ctx->compNum == 1) ? ctx->comp[0].pixels : ctx->rgb;
   13c26:	8b 45 08             	mov    0x8(%ebp),%eax
   13c29:	8b 40 28             	mov    0x28(%eax),%eax
   13c2c:	83 f8 01             	cmp    $0x1,%eax
   13c2f:	75 08                	jne    13c39 <GetImage+0x16>
   13c31:	8b 45 08             	mov    0x8(%ebp),%eax
   13c34:	8b 40 54             	mov    0x54(%eax),%eax
   13c37:	eb 09                	jmp    13c42 <GetImage+0x1f>
   13c39:	8b 45 08             	mov    0x8(%ebp),%eax
   13c3c:	8b 80 c4 02 08 00    	mov    0x802c4(%eax),%eax

}
   13c42:	5d                   	pop    %ebp
   13c43:	c3                   	ret    

00013c44 <GetWidth>:

int GetWidth(Context* ctx){
   13c44:	55                   	push   %ebp
   13c45:	89 e5                	mov    %esp,%ebp
    return ctx->width;
   13c47:	8b 45 08             	mov    0x8(%ebp),%eax
   13c4a:	8b 40 10             	mov    0x10(%eax),%eax
}
   13c4d:	5d                   	pop    %ebp
   13c4e:	c3                   	ret    

00013c4f <GetHeight>:

int GetHeight(Context* ctx){
   13c4f:	55                   	push   %ebp
   13c50:	89 e5                	mov    %esp,%ebp
    return ctx->height;
   13c52:	8b 45 08             	mov    0x8(%ebp),%eax
   13c55:	8b 40 14             	mov    0x14(%eax),%eax
}
   13c58:	5d                   	pop    %ebp
   13c59:	c3                   	ret    

00013c5a <GetImageSize>:

uint GetImageSize(Context* ctx){
   13c5a:	55                   	push   %ebp
   13c5b:	89 e5                	mov    %esp,%ebp
    return ctx->width * ctx->height * ctx->compNum;
   13c5d:	8b 45 08             	mov    0x8(%ebp),%eax
   13c60:	8b 50 10             	mov    0x10(%eax),%edx
   13c63:	8b 45 08             	mov    0x8(%ebp),%eax
   13c66:	8b 40 14             	mov    0x14(%eax),%eax
   13c69:	0f af d0             	imul   %eax,%edx
   13c6c:	8b 45 08             	mov    0x8(%ebp),%eax
   13c6f:	8b 40 28             	mov    0x28(%eax),%eax
   13c72:	0f af c2             	imul   %edx,%eax
}
   13c75:	5d                   	pop    %ebp
   13c76:	c3                   	ret    

00013c77 <_Clip>:

uchar _Clip(const int x){
   13c77:	55                   	push   %ebp
   13c78:	89 e5                	mov    %esp,%ebp
    return x < 0 ? 0: ((x > 0xFF) ? 0xFF : (uchar)x);
   13c7a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   13c7e:	78 15                	js     13c95 <_Clip+0x1e>
   13c80:	81 7d 08 ff 00 00 00 	cmpl   $0xff,0x8(%ebp)
   13c87:	7f 05                	jg     13c8e <_Clip+0x17>
   13c89:	8b 45 08             	mov    0x8(%ebp),%eax
   13c8c:	eb 0c                	jmp    13c9a <_Clip+0x23>
   13c8e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   13c93:	eb 05                	jmp    13c9a <_Clip+0x23>
   13c95:	b8 00 00 00 00       	mov    $0x0,%eax
}
   13c9a:	5d                   	pop    %ebp
   13c9b:	c3                   	ret    

00013c9c <_Skip>:

void _Skip(Context* ctx, int c){
   13c9c:	55                   	push   %ebp
   13c9d:	89 e5                	mov    %esp,%ebp
    ctx->pos += c;
   13c9f:	8b 45 08             	mov    0x8(%ebp),%eax
   13ca2:	8b 50 04             	mov    0x4(%eax),%edx
   13ca5:	8b 45 0c             	mov    0xc(%ebp),%eax
   13ca8:	01 c2                	add    %eax,%edx
   13caa:	8b 45 08             	mov    0x8(%ebp),%eax
   13cad:	89 50 04             	mov    %edx,0x4(%eax)
    ctx->size -= c;
   13cb0:	8b 45 08             	mov    0x8(%ebp),%eax
   13cb3:	8b 40 08             	mov    0x8(%eax),%eax
   13cb6:	2b 45 0c             	sub    0xc(%ebp),%eax
   13cb9:	89 c2                	mov    %eax,%edx
   13cbb:	8b 45 08             	mov    0x8(%ebp),%eax
   13cbe:	89 50 08             	mov    %edx,0x8(%eax)
    ctx->length -= c;
   13cc1:	8b 45 08             	mov    0x8(%ebp),%eax
   13cc4:	8b 40 0c             	mov    0xc(%eax),%eax
   13cc7:	2b 45 0c             	sub    0xc(%ebp),%eax
   13cca:	89 c2                	mov    %eax,%edx
   13ccc:	8b 45 08             	mov    0x8(%ebp),%eax
   13ccf:	89 50 0c             	mov    %edx,0xc(%eax)
    if(ctx->size < 0) ctx->result = SyntaxError;
   13cd2:	8b 45 08             	mov    0x8(%ebp),%eax
   13cd5:	8b 40 08             	mov    0x8(%eax),%eax
   13cd8:	85 c0                	test   %eax,%eax
   13cda:	79 09                	jns    13ce5 <_Skip+0x49>
   13cdc:	8b 45 08             	mov    0x8(%ebp),%eax
   13cdf:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
}
   13ce5:	90                   	nop
   13ce6:	5d                   	pop    %ebp
   13ce7:	c3                   	ret    

00013ce8 <_DecodeLength>:

void _DecodeLength(Context* ctx){
   13ce8:	55                   	push   %ebp
   13ce9:	89 e5                	mov    %esp,%ebp
   13ceb:	83 ec 08             	sub    $0x8,%esp
    if(ctx->size < 2) ERROR_RETURN(SyntaxError);
   13cee:	8b 45 08             	mov    0x8(%ebp),%eax
   13cf1:	8b 40 08             	mov    0x8(%eax),%eax
   13cf4:	83 f8 01             	cmp    $0x1,%eax
   13cf7:	7f 0b                	jg     13d04 <_DecodeLength+0x1c>
   13cf9:	8b 45 08             	mov    0x8(%ebp),%eax
   13cfc:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   13d02:	eb 45                	jmp    13d49 <_DecodeLength+0x61>
    ctx->length = _Decode2Bytes(ctx->pos);
   13d04:	8b 45 08             	mov    0x8(%ebp),%eax
   13d07:	8b 40 04             	mov    0x4(%eax),%eax
   13d0a:	83 ec 0c             	sub    $0xc,%esp
   13d0d:	50                   	push   %eax
   13d0e:	e8 38 00 00 00       	call   13d4b <_Decode2Bytes>
   13d13:	83 c4 10             	add    $0x10,%esp
   13d16:	89 c2                	mov    %eax,%edx
   13d18:	8b 45 08             	mov    0x8(%ebp),%eax
   13d1b:	89 50 0c             	mov    %edx,0xc(%eax)
    if(ctx->length > ctx->size) ERROR_RETURN(SyntaxError);
   13d1e:	8b 45 08             	mov    0x8(%ebp),%eax
   13d21:	8b 50 0c             	mov    0xc(%eax),%edx
   13d24:	8b 45 08             	mov    0x8(%ebp),%eax
   13d27:	8b 40 08             	mov    0x8(%eax),%eax
   13d2a:	39 c2                	cmp    %eax,%edx
   13d2c:	7e 0b                	jle    13d39 <_DecodeLength+0x51>
   13d2e:	8b 45 08             	mov    0x8(%ebp),%eax
   13d31:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   13d37:	eb 10                	jmp    13d49 <_DecodeLength+0x61>
    _Skip(ctx, 2);
   13d39:	83 ec 08             	sub    $0x8,%esp
   13d3c:	6a 02                	push   $0x2
   13d3e:	ff 75 08             	pushl  0x8(%ebp)
   13d41:	e8 56 ff ff ff       	call   13c9c <_Skip>
   13d46:	83 c4 10             	add    $0x10,%esp
}
   13d49:	c9                   	leave  
   13d4a:	c3                   	ret    

00013d4b <_Decode2Bytes>:

int _Decode2Bytes(const uchar* pos){
   13d4b:	55                   	push   %ebp
   13d4c:	89 e5                	mov    %esp,%ebp
    return (pos[0] << 8) | pos[1];
   13d4e:	8b 45 08             	mov    0x8(%ebp),%eax
   13d51:	0f b6 00             	movzbl (%eax),%eax
   13d54:	0f b6 c0             	movzbl %al,%eax
   13d57:	c1 e0 08             	shl    $0x8,%eax
   13d5a:	89 c2                	mov    %eax,%edx
   13d5c:	8b 45 08             	mov    0x8(%ebp),%eax
   13d5f:	83 c0 01             	add    $0x1,%eax
   13d62:	0f b6 00             	movzbl (%eax),%eax
   13d65:	0f b6 c0             	movzbl %al,%eax
   13d68:	09 d0                	or     %edx,%eax
}
   13d6a:	5d                   	pop    %ebp
   13d6b:	c3                   	ret    

00013d6c <_DecodeJPEG>:

int _DecodeJPEG(Context* ctx, char* ZZ, const uchar* jpeg, const int size){
   13d6c:	55                   	push   %ebp
   13d6d:	89 e5                	mov    %esp,%ebp
   13d6f:	83 ec 08             	sub    $0x8,%esp
    ctx->pos = jpeg;
   13d72:	8b 45 08             	mov    0x8(%ebp),%eax
   13d75:	8b 55 10             	mov    0x10(%ebp),%edx
   13d78:	89 50 04             	mov    %edx,0x4(%eax)
    ctx->size = size & 0x7FFFFFFF;
   13d7b:	8b 45 14             	mov    0x14(%ebp),%eax
   13d7e:	25 ff ff ff 7f       	and    $0x7fffffff,%eax
   13d83:	89 c2                	mov    %eax,%edx
   13d85:	8b 45 08             	mov    0x8(%ebp),%eax
   13d88:	89 50 08             	mov    %edx,0x8(%eax)
    if( (ctx->size < 2) || ((ctx->pos[0] != 0xFF) || (ctx->pos[1] != 0xD8)) ) return NotJPEG;
   13d8b:	8b 45 08             	mov    0x8(%ebp),%eax
   13d8e:	8b 40 08             	mov    0x8(%eax),%eax
   13d91:	83 f8 01             	cmp    $0x1,%eax
   13d94:	7e 1d                	jle    13db3 <_DecodeJPEG+0x47>
   13d96:	8b 45 08             	mov    0x8(%ebp),%eax
   13d99:	8b 40 04             	mov    0x4(%eax),%eax
   13d9c:	0f b6 00             	movzbl (%eax),%eax
   13d9f:	3c ff                	cmp    $0xff,%al
   13da1:	75 10                	jne    13db3 <_DecodeJPEG+0x47>
   13da3:	8b 45 08             	mov    0x8(%ebp),%eax
   13da6:	8b 40 04             	mov    0x4(%eax),%eax
   13da9:	83 c0 01             	add    $0x1,%eax
   13dac:	0f b6 00             	movzbl (%eax),%eax
   13daf:	3c d8                	cmp    $0xd8,%al
   13db1:	74 0a                	je     13dbd <_DecodeJPEG+0x51>
   13db3:	b8 01 00 00 00       	mov    $0x1,%eax
   13db8:	e9 56 01 00 00       	jmp    13f13 <_DecodeJPEG+0x1a7>
    _Skip(ctx, 2);
   13dbd:	6a 02                	push   $0x2
   13dbf:	ff 75 08             	pushl  0x8(%ebp)
   13dc2:	e8 d5 fe ff ff       	call   13c9c <_Skip>
   13dc7:	83 c4 08             	add    $0x8,%esp
    while(!ctx->result){
   13dca:	e9 0a 01 00 00       	jmp    13ed9 <_DecodeJPEG+0x16d>
        if(ctx->size < 0 || ctx->pos[0] != 0xFF) return SyntaxError;
   13dcf:	8b 45 08             	mov    0x8(%ebp),%eax
   13dd2:	8b 40 08             	mov    0x8(%eax),%eax
   13dd5:	85 c0                	test   %eax,%eax
   13dd7:	78 0d                	js     13de6 <_DecodeJPEG+0x7a>
   13dd9:	8b 45 08             	mov    0x8(%ebp),%eax
   13ddc:	8b 40 04             	mov    0x4(%eax),%eax
   13ddf:	0f b6 00             	movzbl (%eax),%eax
   13de2:	3c ff                	cmp    $0xff,%al
   13de4:	74 0a                	je     13df0 <_DecodeJPEG+0x84>
   13de6:	b8 05 00 00 00       	mov    $0x5,%eax
   13deb:	e9 23 01 00 00       	jmp    13f13 <_DecodeJPEG+0x1a7>
        _Skip(ctx, 2);
   13df0:	6a 02                	push   $0x2
   13df2:	ff 75 08             	pushl  0x8(%ebp)
   13df5:	e8 a2 fe ff ff       	call   13c9c <_Skip>
   13dfa:	83 c4 08             	add    $0x8,%esp
        switch(ctx->pos[-1]){
   13dfd:	8b 45 08             	mov    0x8(%ebp),%eax
   13e00:	8b 40 04             	mov    0x4(%eax),%eax
   13e03:	83 e8 01             	sub    $0x1,%eax
   13e06:	0f b6 00             	movzbl (%eax),%eax
   13e09:	0f b6 c0             	movzbl %al,%eax
   13e0c:	3d da 00 00 00       	cmp    $0xda,%eax
   13e11:	74 71                	je     13e84 <_DecodeJPEG+0x118>
   13e13:	3d da 00 00 00       	cmp    $0xda,%eax
   13e18:	7f 10                	jg     13e2a <_DecodeJPEG+0xbe>
   13e1a:	3d c0 00 00 00       	cmp    $0xc0,%eax
   13e1f:	74 20                	je     13e41 <_DecodeJPEG+0xd5>
   13e21:	3d c4 00 00 00       	cmp    $0xc4,%eax
   13e26:	74 2c                	je     13e54 <_DecodeJPEG+0xe8>
   13e28:	eb 7d                	jmp    13ea7 <_DecodeJPEG+0x13b>
   13e2a:	3d dd 00 00 00       	cmp    $0xdd,%eax
   13e2f:	74 43                	je     13e74 <_DecodeJPEG+0x108>
   13e31:	3d fe 00 00 00       	cmp    $0xfe,%eax
   13e36:	74 5f                	je     13e97 <_DecodeJPEG+0x12b>
   13e38:	3d db 00 00 00       	cmp    $0xdb,%eax
   13e3d:	74 25                	je     13e64 <_DecodeJPEG+0xf8>
   13e3f:	eb 66                	jmp    13ea7 <_DecodeJPEG+0x13b>
            case 0xC0: _DecodeSOF(ctx); break;
   13e41:	83 ec 0c             	sub    $0xc,%esp
   13e44:	ff 75 08             	pushl  0x8(%ebp)
   13e47:	e8 c9 00 00 00       	call   13f15 <_DecodeSOF>
   13e4c:	83 c4 10             	add    $0x10,%esp
   13e4f:	e9 85 00 00 00       	jmp    13ed9 <_DecodeJPEG+0x16d>
            case 0xC4: _DecodeDHT(ctx); break;
   13e54:	83 ec 0c             	sub    $0xc,%esp
   13e57:	ff 75 08             	pushl  0x8(%ebp)
   13e5a:	e8 28 05 00 00       	call   14387 <_DecodeDHT>
   13e5f:	83 c4 10             	add    $0x10,%esp
   13e62:	eb 75                	jmp    13ed9 <_DecodeJPEG+0x16d>
            case 0xDB: _DecodeDQT(ctx); break;
   13e64:	83 ec 0c             	sub    $0xc,%esp
   13e67:	ff 75 08             	pushl  0x8(%ebp)
   13e6a:	e8 05 07 00 00       	call   14574 <_DecodeDQT>
   13e6f:	83 c4 10             	add    $0x10,%esp
   13e72:	eb 65                	jmp    13ed9 <_DecodeJPEG+0x16d>
            case 0xDD: _DecodeDRI(ctx); break;
   13e74:	83 ec 0c             	sub    $0xc,%esp
   13e77:	ff 75 08             	pushl  0x8(%ebp)
   13e7a:	e8 ff 07 00 00       	call   1467e <_DecodeDRI>
   13e7f:	83 c4 10             	add    $0x10,%esp
   13e82:	eb 55                	jmp    13ed9 <_DecodeJPEG+0x16d>
            case 0xDA: _DecodeSOS(ctx, ZZ); break;
   13e84:	83 ec 08             	sub    $0x8,%esp
   13e87:	ff 75 0c             	pushl  0xc(%ebp)
   13e8a:	ff 75 08             	pushl  0x8(%ebp)
   13e8d:	e8 56 08 00 00       	call   146e8 <_DecodeSOS>
   13e92:	83 c4 10             	add    $0x10,%esp
   13e95:	eb 42                	jmp    13ed9 <_DecodeJPEG+0x16d>
            case 0xFE: _SkipMarker(ctx); break;
   13e97:	83 ec 0c             	sub    $0xc,%esp
   13e9a:	ff 75 08             	pushl  0x8(%ebp)
   13e9d:	e8 a8 15 00 00       	call   1544a <_SkipMarker>
   13ea2:	83 c4 10             	add    $0x10,%esp
   13ea5:	eb 32                	jmp    13ed9 <_DecodeJPEG+0x16d>
            default:
                if( (ctx->pos[-1] & 0xF0) == 0xE0) _SkipMarker(ctx);
   13ea7:	8b 45 08             	mov    0x8(%ebp),%eax
   13eaa:	8b 40 04             	mov    0x4(%eax),%eax
   13ead:	83 e8 01             	sub    $0x1,%eax
   13eb0:	0f b6 00             	movzbl (%eax),%eax
   13eb3:	0f b6 c0             	movzbl %al,%eax
   13eb6:	25 f0 00 00 00       	and    $0xf0,%eax
   13ebb:	3d e0 00 00 00       	cmp    $0xe0,%eax
   13ec0:	75 10                	jne    13ed2 <_DecodeJPEG+0x166>
   13ec2:	83 ec 0c             	sub    $0xc,%esp
   13ec5:	ff 75 08             	pushl  0x8(%ebp)
   13ec8:	e8 7d 15 00 00       	call   1544a <_SkipMarker>
   13ecd:	83 c4 10             	add    $0x10,%esp
   13ed0:	eb 07                	jmp    13ed9 <_DecodeJPEG+0x16d>
                else return Unsupported;
   13ed2:	b8 02 00 00 00       	mov    $0x2,%eax
   13ed7:	eb 3a                	jmp    13f13 <_DecodeJPEG+0x1a7>
int _DecodeJPEG(Context* ctx, char* ZZ, const uchar* jpeg, const int size){
    ctx->pos = jpeg;
    ctx->size = size & 0x7FFFFFFF;
    if( (ctx->size < 2) || ((ctx->pos[0] != 0xFF) || (ctx->pos[1] != 0xD8)) ) return NotJPEG;
    _Skip(ctx, 2);
    while(!ctx->result){
   13ed9:	8b 45 08             	mov    0x8(%ebp),%eax
   13edc:	8b 00                	mov    (%eax),%eax
   13ede:	85 c0                	test   %eax,%eax
   13ee0:	0f 84 e9 fe ff ff    	je     13dcf <_DecodeJPEG+0x63>
            default:
                if( (ctx->pos[-1] & 0xF0) == 0xE0) _SkipMarker(ctx);
                else return Unsupported;
        }
    }
    if(ctx->result != InternalFinished) return ctx->result;
   13ee6:	8b 45 08             	mov    0x8(%ebp),%eax
   13ee9:	8b 00                	mov    (%eax),%eax
   13eeb:	83 f8 06             	cmp    $0x6,%eax
   13eee:	74 07                	je     13ef7 <_DecodeJPEG+0x18b>
   13ef0:	8b 45 08             	mov    0x8(%ebp),%eax
   13ef3:	8b 00                	mov    (%eax),%eax
   13ef5:	eb 1c                	jmp    13f13 <_DecodeJPEG+0x1a7>
    ctx->result = OK;
   13ef7:	8b 45 08             	mov    0x8(%ebp),%eax
   13efa:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    _Convert(ctx);
   13f00:	83 ec 0c             	sub    $0xc,%esp
   13f03:	ff 75 08             	pushl  0x8(%ebp)
   13f06:	e8 6b 15 00 00       	call   15476 <_Convert>
   13f0b:	83 c4 10             	add    $0x10,%esp
    return ctx->result;
   13f0e:	8b 45 08             	mov    0x8(%ebp),%eax
   13f11:	8b 00                	mov    (%eax),%eax
 }
   13f13:	c9                   	leave  
   13f14:	c3                   	ret    

00013f15 <_DecodeSOF>:

void _DecodeSOF(Context* ctx){
   13f15:	55                   	push   %ebp
   13f16:	89 e5                	mov    %esp,%ebp
   13f18:	53                   	push   %ebx
   13f19:	83 ec 14             	sub    $0x14,%esp
    _DecodeLength(ctx);
   13f1c:	83 ec 0c             	sub    $0xc,%esp
   13f1f:	ff 75 08             	pushl  0x8(%ebp)
   13f22:	e8 c1 fd ff ff       	call   13ce8 <_DecodeLength>
   13f27:	83 c4 10             	add    $0x10,%esp
    if(ctx->result)return;
   13f2a:	8b 45 08             	mov    0x8(%ebp),%eax
   13f2d:	8b 00                	mov    (%eax),%eax
   13f2f:	85 c0                	test   %eax,%eax
   13f31:	0f 85 4a 04 00 00    	jne    14381 <_DecodeSOF+0x46c>
    if(ctx->length < 9) ERROR_RETURN(SyntaxError);
   13f37:	8b 45 08             	mov    0x8(%ebp),%eax
   13f3a:	8b 40 0c             	mov    0xc(%eax),%eax
   13f3d:	83 f8 08             	cmp    $0x8,%eax
   13f40:	7f 0e                	jg     13f50 <_DecodeSOF+0x3b>
   13f42:	8b 45 08             	mov    0x8(%ebp),%eax
   13f45:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   13f4b:	e9 32 04 00 00       	jmp    14382 <_DecodeSOF+0x46d>
    if(ctx->pos[0] != 8) ERROR_RETURN(Unsupported);
   13f50:	8b 45 08             	mov    0x8(%ebp),%eax
   13f53:	8b 40 04             	mov    0x4(%eax),%eax
   13f56:	0f b6 00             	movzbl (%eax),%eax
   13f59:	3c 08                	cmp    $0x8,%al
   13f5b:	74 0e                	je     13f6b <_DecodeSOF+0x56>
   13f5d:	8b 45 08             	mov    0x8(%ebp),%eax
   13f60:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   13f66:	e9 17 04 00 00       	jmp    14382 <_DecodeSOF+0x46d>
    ctx->height = _Decode2Bytes(ctx->pos + 1);
   13f6b:	8b 45 08             	mov    0x8(%ebp),%eax
   13f6e:	8b 40 04             	mov    0x4(%eax),%eax
   13f71:	83 c0 01             	add    $0x1,%eax
   13f74:	83 ec 0c             	sub    $0xc,%esp
   13f77:	50                   	push   %eax
   13f78:	e8 ce fd ff ff       	call   13d4b <_Decode2Bytes>
   13f7d:	83 c4 10             	add    $0x10,%esp
   13f80:	89 c2                	mov    %eax,%edx
   13f82:	8b 45 08             	mov    0x8(%ebp),%eax
   13f85:	89 50 14             	mov    %edx,0x14(%eax)
    ctx->width = _Decode2Bytes(ctx->pos + 3);
   13f88:	8b 45 08             	mov    0x8(%ebp),%eax
   13f8b:	8b 40 04             	mov    0x4(%eax),%eax
   13f8e:	83 c0 03             	add    $0x3,%eax
   13f91:	83 ec 0c             	sub    $0xc,%esp
   13f94:	50                   	push   %eax
   13f95:	e8 b1 fd ff ff       	call   13d4b <_Decode2Bytes>
   13f9a:	83 c4 10             	add    $0x10,%esp
   13f9d:	89 c2                	mov    %eax,%edx
   13f9f:	8b 45 08             	mov    0x8(%ebp),%eax
   13fa2:	89 50 10             	mov    %edx,0x10(%eax)
    ctx->compNum = ctx->pos[5];
   13fa5:	8b 45 08             	mov    0x8(%ebp),%eax
   13fa8:	8b 40 04             	mov    0x4(%eax),%eax
   13fab:	83 c0 05             	add    $0x5,%eax
   13fae:	0f b6 00             	movzbl (%eax),%eax
   13fb1:	0f b6 d0             	movzbl %al,%edx
   13fb4:	8b 45 08             	mov    0x8(%ebp),%eax
   13fb7:	89 50 28             	mov    %edx,0x28(%eax)
    _Skip(ctx, 6);
   13fba:	83 ec 08             	sub    $0x8,%esp
   13fbd:	6a 06                	push   $0x6
   13fbf:	ff 75 08             	pushl  0x8(%ebp)
   13fc2:	e8 d5 fc ff ff       	call   13c9c <_Skip>
   13fc7:	83 c4 10             	add    $0x10,%esp
    switch(ctx->compNum){
   13fca:	8b 45 08             	mov    0x8(%ebp),%eax
   13fcd:	8b 40 28             	mov    0x28(%eax),%eax
   13fd0:	83 f8 01             	cmp    $0x1,%eax
   13fd3:	74 13                	je     13fe8 <_DecodeSOF+0xd3>
   13fd5:	83 f8 03             	cmp    $0x3,%eax
   13fd8:	74 0e                	je     13fe8 <_DecodeSOF+0xd3>
        case 1:
        case 3:break;
        default: ERROR_RETURN(Unsupported);
   13fda:	8b 45 08             	mov    0x8(%ebp),%eax
   13fdd:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   13fe3:	e9 9a 03 00 00       	jmp    14382 <_DecodeSOF+0x46d>
    ctx->width = _Decode2Bytes(ctx->pos + 3);
    ctx->compNum = ctx->pos[5];
    _Skip(ctx, 6);
    switch(ctx->compNum){
        case 1:
        case 3:break;
   13fe8:	90                   	nop
        default: ERROR_RETURN(Unsupported);
    }
    if(ctx->length < (ctx->compNum * 3)) ERROR_RETURN(SyntaxError);
   13fe9:	8b 45 08             	mov    0x8(%ebp),%eax
   13fec:	8b 48 0c             	mov    0xc(%eax),%ecx
   13fef:	8b 45 08             	mov    0x8(%ebp),%eax
   13ff2:	8b 50 28             	mov    0x28(%eax),%edx
   13ff5:	89 d0                	mov    %edx,%eax
   13ff7:	01 c0                	add    %eax,%eax
   13ff9:	01 d0                	add    %edx,%eax
   13ffb:	39 c1                	cmp    %eax,%ecx
   13ffd:	7d 0e                	jge    1400d <_DecodeSOF+0xf8>
   13fff:	8b 45 08             	mov    0x8(%ebp),%eax
   14002:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14008:	e9 75 03 00 00       	jmp    14382 <_DecodeSOF+0x46d>
    int i, Vmax=0, Hmax=0;
   1400d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   14014:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   1401b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14022:	8b 45 08             	mov    0x8(%ebp),%eax
   14025:	83 c0 2c             	add    $0x2c,%eax
   14028:	89 45 e8             	mov    %eax,-0x18(%ebp)
   1402b:	e9 50 01 00 00       	jmp    14180 <_DecodeSOF+0x26b>
        c->cid = ctx->pos[0];
   14030:	8b 45 08             	mov    0x8(%ebp),%eax
   14033:	8b 40 04             	mov    0x4(%eax),%eax
   14036:	0f b6 00             	movzbl (%eax),%eax
   14039:	0f b6 d0             	movzbl %al,%edx
   1403c:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1403f:	89 10                	mov    %edx,(%eax)
        if(!(c->ssx = ctx->pos[1] >> 4)) ERROR_RETURN(SyntaxError);
   14041:	8b 45 08             	mov    0x8(%ebp),%eax
   14044:	8b 40 04             	mov    0x4(%eax),%eax
   14047:	83 c0 01             	add    $0x1,%eax
   1404a:	0f b6 00             	movzbl (%eax),%eax
   1404d:	c0 e8 04             	shr    $0x4,%al
   14050:	0f b6 d0             	movzbl %al,%edx
   14053:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14056:	89 50 04             	mov    %edx,0x4(%eax)
   14059:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1405c:	8b 40 04             	mov    0x4(%eax),%eax
   1405f:	85 c0                	test   %eax,%eax
   14061:	75 0e                	jne    14071 <_DecodeSOF+0x15c>
   14063:	8b 45 08             	mov    0x8(%ebp),%eax
   14066:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1406c:	e9 11 03 00 00       	jmp    14382 <_DecodeSOF+0x46d>
        if(!(c->ssy = ctx->pos[1] & 0xF)) ERROR_RETURN(SyntaxError);
   14071:	8b 45 08             	mov    0x8(%ebp),%eax
   14074:	8b 40 04             	mov    0x4(%eax),%eax
   14077:	83 c0 01             	add    $0x1,%eax
   1407a:	0f b6 00             	movzbl (%eax),%eax
   1407d:	0f b6 c0             	movzbl %al,%eax
   14080:	83 e0 0f             	and    $0xf,%eax
   14083:	89 c2                	mov    %eax,%edx
   14085:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14088:	89 50 08             	mov    %edx,0x8(%eax)
   1408b:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1408e:	8b 40 08             	mov    0x8(%eax),%eax
   14091:	85 c0                	test   %eax,%eax
   14093:	75 0e                	jne    140a3 <_DecodeSOF+0x18e>
   14095:	8b 45 08             	mov    0x8(%ebp),%eax
   14098:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1409e:	e9 df 02 00 00       	jmp    14382 <_DecodeSOF+0x46d>
        //ssx, ssy must be 1, 2, 4, 8...
        if(c->ssx & (c->ssx - 1)) ERROR_RETURN(Unsupported);
   140a3:	8b 45 e8             	mov    -0x18(%ebp),%eax
   140a6:	8b 50 04             	mov    0x4(%eax),%edx
   140a9:	8b 45 e8             	mov    -0x18(%ebp),%eax
   140ac:	8b 40 04             	mov    0x4(%eax),%eax
   140af:	83 e8 01             	sub    $0x1,%eax
   140b2:	21 d0                	and    %edx,%eax
   140b4:	85 c0                	test   %eax,%eax
   140b6:	74 0e                	je     140c6 <_DecodeSOF+0x1b1>
   140b8:	8b 45 08             	mov    0x8(%ebp),%eax
   140bb:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   140c1:	e9 bc 02 00 00       	jmp    14382 <_DecodeSOF+0x46d>
        if(c->ssy & (c->ssy - 1)) ERROR_RETURN(Unsupported);
   140c6:	8b 45 e8             	mov    -0x18(%ebp),%eax
   140c9:	8b 50 08             	mov    0x8(%eax),%edx
   140cc:	8b 45 e8             	mov    -0x18(%ebp),%eax
   140cf:	8b 40 08             	mov    0x8(%eax),%eax
   140d2:	83 e8 01             	sub    $0x1,%eax
   140d5:	21 d0                	and    %edx,%eax
   140d7:	85 c0                	test   %eax,%eax
   140d9:	74 0e                	je     140e9 <_DecodeSOF+0x1d4>
   140db:	8b 45 08             	mov    0x8(%ebp),%eax
   140de:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   140e4:	e9 99 02 00 00       	jmp    14382 <_DecodeSOF+0x46d>
        if((c->qtselect = ctx->pos[2]) & 0xFC) ERROR_RETURN(SyntaxError);
   140e9:	8b 45 08             	mov    0x8(%ebp),%eax
   140ec:	8b 40 04             	mov    0x4(%eax),%eax
   140ef:	83 c0 02             	add    $0x2,%eax
   140f2:	0f b6 00             	movzbl (%eax),%eax
   140f5:	0f b6 d0             	movzbl %al,%edx
   140f8:	8b 45 e8             	mov    -0x18(%ebp),%eax
   140fb:	89 50 18             	mov    %edx,0x18(%eax)
   140fe:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14101:	8b 40 18             	mov    0x18(%eax),%eax
   14104:	25 fc 00 00 00       	and    $0xfc,%eax
   14109:	85 c0                	test   %eax,%eax
   1410b:	74 0e                	je     1411b <_DecodeSOF+0x206>
   1410d:	8b 45 08             	mov    0x8(%ebp),%eax
   14110:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14116:	e9 67 02 00 00       	jmp    14382 <_DecodeSOF+0x46d>
        _Skip(ctx, 3);
   1411b:	83 ec 08             	sub    $0x8,%esp
   1411e:	6a 03                	push   $0x3
   14120:	ff 75 08             	pushl  0x8(%ebp)
   14123:	e8 74 fb ff ff       	call   13c9c <_Skip>
   14128:	83 c4 10             	add    $0x10,%esp
        ctx->qtused |= 1 << c->qtselect;
   1412b:	8b 45 08             	mov    0x8(%ebp),%eax
   1412e:	8b 90 b0 00 00 00    	mov    0xb0(%eax),%edx
   14134:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14137:	8b 40 18             	mov    0x18(%eax),%eax
   1413a:	bb 01 00 00 00       	mov    $0x1,%ebx
   1413f:	89 c1                	mov    %eax,%ecx
   14141:	d3 e3                	shl    %cl,%ebx
   14143:	89 d8                	mov    %ebx,%eax
   14145:	09 c2                	or     %eax,%edx
   14147:	8b 45 08             	mov    0x8(%ebp),%eax
   1414a:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)
        if(c->ssx > Hmax) Hmax =c->ssx;
   14150:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14153:	8b 40 04             	mov    0x4(%eax),%eax
   14156:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   14159:	7e 09                	jle    14164 <_DecodeSOF+0x24f>
   1415b:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1415e:	8b 40 04             	mov    0x4(%eax),%eax
   14161:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if(c->ssy > Vmax) Vmax =c->ssy;
   14164:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14167:	8b 40 08             	mov    0x8(%eax),%eax
   1416a:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   1416d:	7e 09                	jle    14178 <_DecodeSOF+0x263>
   1416f:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14172:	8b 40 08             	mov    0x8(%eax),%eax
   14175:	89 45 f0             	mov    %eax,-0x10(%ebp)
        default: ERROR_RETURN(Unsupported);
    }
    if(ctx->length < (ctx->compNum * 3)) ERROR_RETURN(SyntaxError);
    int i, Vmax=0, Hmax=0;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   14178:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1417c:	83 45 e8 2c          	addl   $0x2c,-0x18(%ebp)
   14180:	8b 45 08             	mov    0x8(%ebp),%eax
   14183:	8b 40 28             	mov    0x28(%eax),%eax
   14186:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   14189:	0f 8f a1 fe ff ff    	jg     14030 <_DecodeSOF+0x11b>
        _Skip(ctx, 3);
        ctx->qtused |= 1 << c->qtselect;
        if(c->ssx > Hmax) Hmax =c->ssx;
        if(c->ssy > Vmax) Vmax =c->ssy;
    }
    ctx->MCUsizex = Hmax << 3;
   1418f:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14192:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   14199:	8b 45 08             	mov    0x8(%ebp),%eax
   1419c:	89 50 20             	mov    %edx,0x20(%eax)
    ctx->MCUsizey = Vmax << 3;
   1419f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   141a2:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   141a9:	8b 45 08             	mov    0x8(%ebp),%eax
   141ac:	89 50 24             	mov    %edx,0x24(%eax)
    ctx->MCUwidth = (ctx->width + ctx->MCUsizex - 1) / ctx->MCUsizex;
   141af:	8b 45 08             	mov    0x8(%ebp),%eax
   141b2:	8b 50 10             	mov    0x10(%eax),%edx
   141b5:	8b 45 08             	mov    0x8(%ebp),%eax
   141b8:	8b 40 20             	mov    0x20(%eax),%eax
   141bb:	01 d0                	add    %edx,%eax
   141bd:	8d 48 ff             	lea    -0x1(%eax),%ecx
   141c0:	8b 45 08             	mov    0x8(%ebp),%eax
   141c3:	8b 58 20             	mov    0x20(%eax),%ebx
   141c6:	89 c8                	mov    %ecx,%eax
   141c8:	99                   	cltd   
   141c9:	f7 fb                	idiv   %ebx
   141cb:	89 c2                	mov    %eax,%edx
   141cd:	8b 45 08             	mov    0x8(%ebp),%eax
   141d0:	89 50 18             	mov    %edx,0x18(%eax)
    ctx->MCUheight = (ctx->height + ctx->MCUsizey - 1) / ctx->MCUsizey;
   141d3:	8b 45 08             	mov    0x8(%ebp),%eax
   141d6:	8b 50 14             	mov    0x14(%eax),%edx
   141d9:	8b 45 08             	mov    0x8(%ebp),%eax
   141dc:	8b 40 24             	mov    0x24(%eax),%eax
   141df:	01 d0                	add    %edx,%eax
   141e1:	8d 48 ff             	lea    -0x1(%eax),%ecx
   141e4:	8b 45 08             	mov    0x8(%ebp),%eax
   141e7:	8b 58 24             	mov    0x24(%eax),%ebx
   141ea:	89 c8                	mov    %ecx,%eax
   141ec:	99                   	cltd   
   141ed:	f7 fb                	idiv   %ebx
   141ef:	89 c2                	mov    %eax,%edx
   141f1:	8b 45 08             	mov    0x8(%ebp),%eax
   141f4:	89 50 1c             	mov    %edx,0x1c(%eax)
    for(i=0, c=ctx->comp; i< ctx->compNum; ++i, ++c){
   141f7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   141fe:	8b 45 08             	mov    0x8(%ebp),%eax
   14201:	83 c0 2c             	add    $0x2c,%eax
   14204:	89 45 e8             	mov    %eax,-0x18(%ebp)
   14207:	e9 fd 00 00 00       	jmp    14309 <_DecodeSOF+0x3f4>
        c->width = (ctx->width * c->ssx + Hmax - 1) / Hmax;
   1420c:	8b 45 08             	mov    0x8(%ebp),%eax
   1420f:	8b 50 10             	mov    0x10(%eax),%edx
   14212:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14215:	8b 40 04             	mov    0x4(%eax),%eax
   14218:	0f af d0             	imul   %eax,%edx
   1421b:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1421e:	01 d0                	add    %edx,%eax
   14220:	83 e8 01             	sub    $0x1,%eax
   14223:	99                   	cltd   
   14224:	f7 7d ec             	idivl  -0x14(%ebp)
   14227:	89 c2                	mov    %eax,%edx
   14229:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1422c:	89 50 0c             	mov    %edx,0xc(%eax)
        c->height = (ctx->height * c->ssy + Vmax - 1) / Vmax;
   1422f:	8b 45 08             	mov    0x8(%ebp),%eax
   14232:	8b 50 14             	mov    0x14(%eax),%edx
   14235:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14238:	8b 40 08             	mov    0x8(%eax),%eax
   1423b:	0f af d0             	imul   %eax,%edx
   1423e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14241:	01 d0                	add    %edx,%eax
   14243:	83 e8 01             	sub    $0x1,%eax
   14246:	99                   	cltd   
   14247:	f7 7d f0             	idivl  -0x10(%ebp)
   1424a:	89 c2                	mov    %eax,%edx
   1424c:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1424f:	89 50 10             	mov    %edx,0x10(%eax)
        c->stride = ctx->MCUwidth * ctx->MCUsizex * c->ssx / Hmax;
   14252:	8b 45 08             	mov    0x8(%ebp),%eax
   14255:	8b 50 18             	mov    0x18(%eax),%edx
   14258:	8b 45 08             	mov    0x8(%ebp),%eax
   1425b:	8b 40 20             	mov    0x20(%eax),%eax
   1425e:	0f af d0             	imul   %eax,%edx
   14261:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14264:	8b 40 04             	mov    0x4(%eax),%eax
   14267:	0f af c2             	imul   %edx,%eax
   1426a:	99                   	cltd   
   1426b:	f7 7d ec             	idivl  -0x14(%ebp)
   1426e:	89 c2                	mov    %eax,%edx
   14270:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14273:	89 50 14             	mov    %edx,0x14(%eax)
        if(((c->width < 3) && (c->ssx != Hmax)) || (c->height < 3) && (c->ssy != Vmax)) ERROR_RETURN(Unsupported);
   14276:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14279:	8b 40 0c             	mov    0xc(%eax),%eax
   1427c:	83 f8 02             	cmp    $0x2,%eax
   1427f:	7f 0b                	jg     1428c <_DecodeSOF+0x377>
   14281:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14284:	8b 40 04             	mov    0x4(%eax),%eax
   14287:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   1428a:	75 16                	jne    142a2 <_DecodeSOF+0x38d>
   1428c:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1428f:	8b 40 10             	mov    0x10(%eax),%eax
   14292:	83 f8 02             	cmp    $0x2,%eax
   14295:	7f 19                	jg     142b0 <_DecodeSOF+0x39b>
   14297:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1429a:	8b 40 08             	mov    0x8(%eax),%eax
   1429d:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   142a0:	74 0e                	je     142b0 <_DecodeSOF+0x39b>
   142a2:	8b 45 08             	mov    0x8(%ebp),%eax
   142a5:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   142ab:	e9 d2 00 00 00       	jmp    14382 <_DecodeSOF+0x46d>
        if(!(c->pixels = (uchar*)malloc(c->stride * (ctx->MCUheight * ctx->MCUsizey * c->ssy / Vmax)))) ERROR_RETURN(OutOfMemory);
   142b0:	8b 45 e8             	mov    -0x18(%ebp),%eax
   142b3:	8b 48 14             	mov    0x14(%eax),%ecx
   142b6:	8b 45 08             	mov    0x8(%ebp),%eax
   142b9:	8b 50 1c             	mov    0x1c(%eax),%edx
   142bc:	8b 45 08             	mov    0x8(%ebp),%eax
   142bf:	8b 40 24             	mov    0x24(%eax),%eax
   142c2:	0f af d0             	imul   %eax,%edx
   142c5:	8b 45 e8             	mov    -0x18(%ebp),%eax
   142c8:	8b 40 08             	mov    0x8(%eax),%eax
   142cb:	0f af c2             	imul   %edx,%eax
   142ce:	99                   	cltd   
   142cf:	f7 7d f0             	idivl  -0x10(%ebp)
   142d2:	0f af c1             	imul   %ecx,%eax
   142d5:	83 ec 0c             	sub    $0xc,%esp
   142d8:	50                   	push   %eax
   142d9:	e8 45 c5 fe ff       	call   823 <malloc>
   142de:	83 c4 10             	add    $0x10,%esp
   142e1:	89 c2                	mov    %eax,%edx
   142e3:	8b 45 e8             	mov    -0x18(%ebp),%eax
   142e6:	89 50 28             	mov    %edx,0x28(%eax)
   142e9:	8b 45 e8             	mov    -0x18(%ebp),%eax
   142ec:	8b 40 28             	mov    0x28(%eax),%eax
   142ef:	85 c0                	test   %eax,%eax
   142f1:	75 0e                	jne    14301 <_DecodeSOF+0x3ec>
   142f3:	8b 45 08             	mov    0x8(%ebp),%eax
   142f6:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   142fc:	e9 81 00 00 00       	jmp    14382 <_DecodeSOF+0x46d>
    }
    ctx->MCUsizex = Hmax << 3;
    ctx->MCUsizey = Vmax << 3;
    ctx->MCUwidth = (ctx->width + ctx->MCUsizex - 1) / ctx->MCUsizex;
    ctx->MCUheight = (ctx->height + ctx->MCUsizey - 1) / ctx->MCUsizey;
    for(i=0, c=ctx->comp; i< ctx->compNum; ++i, ++c){
   14301:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14305:	83 45 e8 2c          	addl   $0x2c,-0x18(%ebp)
   14309:	8b 45 08             	mov    0x8(%ebp),%eax
   1430c:	8b 40 28             	mov    0x28(%eax),%eax
   1430f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   14312:	0f 8f f4 fe ff ff    	jg     1420c <_DecodeSOF+0x2f7>
        c->height = (ctx->height * c->ssy + Vmax - 1) / Vmax;
        c->stride = ctx->MCUwidth * ctx->MCUsizex * c->ssx / Hmax;
        if(((c->width < 3) && (c->ssx != Hmax)) || (c->height < 3) && (c->ssy != Vmax)) ERROR_RETURN(Unsupported);
        if(!(c->pixels = (uchar*)malloc(c->stride * (ctx->MCUheight * ctx->MCUsizey * c->ssy / Vmax)))) ERROR_RETURN(OutOfMemory);
    }
    if(ctx->compNum == 3){
   14318:	8b 45 08             	mov    0x8(%ebp),%eax
   1431b:	8b 40 28             	mov    0x28(%eax),%eax
   1431e:	83 f8 03             	cmp    $0x3,%eax
   14321:	75 47                	jne    1436a <_DecodeSOF+0x455>
        ctx->rgb = (uchar*)malloc(ctx->width * ctx->height * ctx->compNum);
   14323:	8b 45 08             	mov    0x8(%ebp),%eax
   14326:	8b 50 10             	mov    0x10(%eax),%edx
   14329:	8b 45 08             	mov    0x8(%ebp),%eax
   1432c:	8b 40 14             	mov    0x14(%eax),%eax
   1432f:	0f af d0             	imul   %eax,%edx
   14332:	8b 45 08             	mov    0x8(%ebp),%eax
   14335:	8b 40 28             	mov    0x28(%eax),%eax
   14338:	0f af c2             	imul   %edx,%eax
   1433b:	83 ec 0c             	sub    $0xc,%esp
   1433e:	50                   	push   %eax
   1433f:	e8 df c4 fe ff       	call   823 <malloc>
   14344:	83 c4 10             	add    $0x10,%esp
   14347:	89 c2                	mov    %eax,%edx
   14349:	8b 45 08             	mov    0x8(%ebp),%eax
   1434c:	89 90 c4 02 08 00    	mov    %edx,0x802c4(%eax)
        if(!ctx->rgb) ERROR_RETURN(OutOfMemory);
   14352:	8b 45 08             	mov    0x8(%ebp),%eax
   14355:	8b 80 c4 02 08 00    	mov    0x802c4(%eax),%eax
   1435b:	85 c0                	test   %eax,%eax
   1435d:	75 0b                	jne    1436a <_DecodeSOF+0x455>
   1435f:	8b 45 08             	mov    0x8(%ebp),%eax
   14362:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   14368:	eb 18                	jmp    14382 <_DecodeSOF+0x46d>
    }
    _Skip(ctx, ctx->length);
   1436a:	8b 45 08             	mov    0x8(%ebp),%eax
   1436d:	8b 40 0c             	mov    0xc(%eax),%eax
   14370:	83 ec 08             	sub    $0x8,%esp
   14373:	50                   	push   %eax
   14374:	ff 75 08             	pushl  0x8(%ebp)
   14377:	e8 20 f9 ff ff       	call   13c9c <_Skip>
   1437c:	83 c4 10             	add    $0x10,%esp
   1437f:	eb 01                	jmp    14382 <_DecodeSOF+0x46d>
    return ctx->result;
 }

void _DecodeSOF(Context* ctx){
    _DecodeLength(ctx);
    if(ctx->result)return;
   14381:	90                   	nop
    if(ctx->compNum == 3){
        ctx->rgb = (uchar*)malloc(ctx->width * ctx->height * ctx->compNum);
        if(!ctx->rgb) ERROR_RETURN(OutOfMemory);
    }
    _Skip(ctx, ctx->length);
}
   14382:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   14385:	c9                   	leave  
   14386:	c3                   	ret    

00014387 <_DecodeDHT>:

void _DecodeDHT(Context* ctx){
   14387:	55                   	push   %ebp
   14388:	89 e5                	mov    %esp,%ebp
   1438a:	53                   	push   %ebx
   1438b:	83 ec 34             	sub    $0x34,%esp
    int i, codelen, remain, spread, curcount;
    uchar counts[16];
    _DecodeLength(ctx);
   1438e:	83 ec 0c             	sub    $0xc,%esp
   14391:	ff 75 08             	pushl  0x8(%ebp)
   14394:	e8 4f f9 ff ff       	call   13ce8 <_DecodeLength>
   14399:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   1439c:	8b 45 08             	mov    0x8(%ebp),%eax
   1439f:	8b 00                	mov    (%eax),%eax
   143a1:	85 c0                	test   %eax,%eax
   143a3:	0f 85 c5 01 00 00    	jne    1456e <_DecodeDHT+0x1e7>
    while(ctx->length >= 17){
   143a9:	e9 9c 01 00 00       	jmp    1454a <_DecodeDHT+0x1c3>
        i = ctx->pos[0];
   143ae:	8b 45 08             	mov    0x8(%ebp),%eax
   143b1:	8b 40 04             	mov    0x4(%eax),%eax
   143b4:	0f b6 00             	movzbl (%eax),%eax
   143b7:	0f b6 c0             	movzbl %al,%eax
   143ba:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(i & 0xEC) ERROR_RETURN(SyntaxError);
   143bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
   143c0:	25 ec 00 00 00       	and    $0xec,%eax
   143c5:	85 c0                	test   %eax,%eax
   143c7:	74 0e                	je     143d7 <_DecodeDHT+0x50>
   143c9:	8b 45 08             	mov    0x8(%ebp),%eax
   143cc:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   143d2:	e9 98 01 00 00       	jmp    1456f <_DecodeDHT+0x1e8>
        if(i & 0x02) ERROR_RETURN(Unsupported);
   143d7:	8b 45 f4             	mov    -0xc(%ebp),%eax
   143da:	83 e0 02             	and    $0x2,%eax
   143dd:	85 c0                	test   %eax,%eax
   143df:	74 0e                	je     143ef <_DecodeDHT+0x68>
   143e1:	8b 45 08             	mov    0x8(%ebp),%eax
   143e4:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   143ea:	e9 80 01 00 00       	jmp    1456f <_DecodeDHT+0x1e8>
        i =(i | (i >> 3)) & 3;
   143ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
   143f2:	c1 f8 03             	sar    $0x3,%eax
   143f5:	0b 45 f4             	or     -0xc(%ebp),%eax
   143f8:	83 e0 03             	and    $0x3,%eax
   143fb:	89 45 f4             	mov    %eax,-0xc(%ebp)
        for(codelen = 1; codelen <= 16; ++codelen){
   143fe:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
   14405:	eb 1c                	jmp    14423 <_DecodeDHT+0x9c>
            counts[codelen - 1] = ctx->pos[codelen];
   14407:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1440a:	8d 50 ff             	lea    -0x1(%eax),%edx
   1440d:	8b 45 08             	mov    0x8(%ebp),%eax
   14410:	8b 48 04             	mov    0x4(%eax),%ecx
   14413:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14416:	01 c8                	add    %ecx,%eax
   14418:	0f b6 00             	movzbl (%eax),%eax
   1441b:	88 44 15 d0          	mov    %al,-0x30(%ebp,%edx,1)
    while(ctx->length >= 17){
        i = ctx->pos[0];
        if(i & 0xEC) ERROR_RETURN(SyntaxError);
        if(i & 0x02) ERROR_RETURN(Unsupported);
        i =(i | (i >> 3)) & 3;
        for(codelen = 1; codelen <= 16; ++codelen){
   1441f:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   14423:	83 7d f0 10          	cmpl   $0x10,-0x10(%ebp)
   14427:	7e de                	jle    14407 <_DecodeDHT+0x80>
            counts[codelen - 1] = ctx->pos[codelen];
        }
        _Skip(ctx, 17);
   14429:	83 ec 08             	sub    $0x8,%esp
   1442c:	6a 11                	push   $0x11
   1442e:	ff 75 08             	pushl  0x8(%ebp)
   14431:	e8 66 f8 ff ff       	call   13c9c <_Skip>
   14436:	83 c4 10             	add    $0x10,%esp
        VlcCode* vlc = &ctx->vlctable[i][0];
   14439:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1443c:	c1 e0 11             	shl    $0x11,%eax
   1443f:	8d 90 b0 01 00 00    	lea    0x1b0(%eax),%edx
   14445:	8b 45 08             	mov    0x8(%ebp),%eax
   14448:	01 d0                	add    %edx,%eax
   1444a:	83 c0 08             	add    $0x8,%eax
   1444d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        remain = spread = 65536;
   14450:	c7 45 e8 00 00 01 00 	movl   $0x10000,-0x18(%ebp)
   14457:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1445a:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for(codelen = 1; codelen <= 16; ++codelen){
   1445d:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
   14464:	e9 be 00 00 00       	jmp    14527 <_DecodeDHT+0x1a0>
            spread >>= 1;
   14469:	d1 7d e8             	sarl   -0x18(%ebp)
            curcount = counts[codelen - 1];
   1446c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1446f:	83 e8 01             	sub    $0x1,%eax
   14472:	0f b6 44 05 d0       	movzbl -0x30(%ebp,%eax,1),%eax
   14477:	0f b6 c0             	movzbl %al,%eax
   1447a:	89 45 e0             	mov    %eax,-0x20(%ebp)
            if(!curcount) continue;
   1447d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   14481:	0f 84 9b 00 00 00    	je     14522 <_DecodeDHT+0x19b>
            if(ctx->length < curcount) ERROR_RETURN(SyntaxError);
   14487:	8b 45 08             	mov    0x8(%ebp),%eax
   1448a:	8b 40 0c             	mov    0xc(%eax),%eax
   1448d:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   14490:	7d 0e                	jge    144a0 <_DecodeDHT+0x119>
   14492:	8b 45 08             	mov    0x8(%ebp),%eax
   14495:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1449b:	e9 cf 00 00 00       	jmp    1456f <_DecodeDHT+0x1e8>
            remain -= curcount << (16 - codelen);
   144a0:	b8 10 00 00 00       	mov    $0x10,%eax
   144a5:	2b 45 f0             	sub    -0x10(%ebp),%eax
   144a8:	8b 55 e0             	mov    -0x20(%ebp),%edx
   144ab:	89 c1                	mov    %eax,%ecx
   144ad:	d3 e2                	shl    %cl,%edx
   144af:	89 d0                	mov    %edx,%eax
   144b1:	29 45 ec             	sub    %eax,-0x14(%ebp)
            if(remain < 0) ERROR_RETURN(SyntaxError);
   144b4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   144b8:	79 0e                	jns    144c8 <_DecodeDHT+0x141>
   144ba:	8b 45 08             	mov    0x8(%ebp),%eax
   144bd:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   144c3:	e9 a7 00 00 00       	jmp    1456f <_DecodeDHT+0x1e8>
            for(i=0; i<curcount; ++i){
   144c8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   144cf:	eb 36                	jmp    14507 <_DecodeDHT+0x180>
                register uchar code = ctx->pos[i];
   144d1:	8b 45 08             	mov    0x8(%ebp),%eax
   144d4:	8b 50 04             	mov    0x4(%eax),%edx
   144d7:	8b 45 f4             	mov    -0xc(%ebp),%eax
   144da:	01 d0                	add    %edx,%eax
   144dc:	0f b6 00             	movzbl (%eax),%eax
   144df:	89 c1                	mov    %eax,%ecx
                register int j = spread;
   144e1:	8b 5d e8             	mov    -0x18(%ebp),%ebx
                while(j--){
   144e4:	eb 14                	jmp    144fa <_DecodeDHT+0x173>
                    vlc->bits = (uchar)codelen;
   144e6:	8b 45 f0             	mov    -0x10(%ebp),%eax
   144e9:	89 c2                	mov    %eax,%edx
   144eb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   144ee:	88 10                	mov    %dl,(%eax)
                    vlc->code = code;
   144f0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   144f3:	88 48 01             	mov    %cl,0x1(%eax)
                    ++vlc;
   144f6:	83 45 e4 02          	addl   $0x2,-0x1c(%ebp)
            remain -= curcount << (16 - codelen);
            if(remain < 0) ERROR_RETURN(SyntaxError);
            for(i=0; i<curcount; ++i){
                register uchar code = ctx->pos[i];
                register int j = spread;
                while(j--){
   144fa:	89 d8                	mov    %ebx,%eax
   144fc:	8d 58 ff             	lea    -0x1(%eax),%ebx
   144ff:	85 c0                	test   %eax,%eax
   14501:	75 e3                	jne    144e6 <_DecodeDHT+0x15f>
            curcount = counts[codelen - 1];
            if(!curcount) continue;
            if(ctx->length < curcount) ERROR_RETURN(SyntaxError);
            remain -= curcount << (16 - codelen);
            if(remain < 0) ERROR_RETURN(SyntaxError);
            for(i=0; i<curcount; ++i){
   14503:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14507:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1450a:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   1450d:	7c c2                	jl     144d1 <_DecodeDHT+0x14a>
                    vlc->bits = (uchar)codelen;
                    vlc->code = code;
                    ++vlc;
                }
            }
            _Skip(ctx, curcount);
   1450f:	83 ec 08             	sub    $0x8,%esp
   14512:	ff 75 e0             	pushl  -0x20(%ebp)
   14515:	ff 75 08             	pushl  0x8(%ebp)
   14518:	e8 7f f7 ff ff       	call   13c9c <_Skip>
   1451d:	83 c4 10             	add    $0x10,%esp
   14520:	eb 01                	jmp    14523 <_DecodeDHT+0x19c>
        VlcCode* vlc = &ctx->vlctable[i][0];
        remain = spread = 65536;
        for(codelen = 1; codelen <= 16; ++codelen){
            spread >>= 1;
            curcount = counts[codelen - 1];
            if(!curcount) continue;
   14522:	90                   	nop
            counts[codelen - 1] = ctx->pos[codelen];
        }
        _Skip(ctx, 17);
        VlcCode* vlc = &ctx->vlctable[i][0];
        remain = spread = 65536;
        for(codelen = 1; codelen <= 16; ++codelen){
   14523:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   14527:	83 7d f0 10          	cmpl   $0x10,-0x10(%ebp)
   1452b:	0f 8e 38 ff ff ff    	jle    14469 <_DecodeDHT+0xe2>
                    ++vlc;
                }
            }
            _Skip(ctx, curcount);
        }
        while(remain--){
   14531:	eb 0a                	jmp    1453d <_DecodeDHT+0x1b6>
            vlc->bits = 0;
   14533:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   14536:	c6 00 00             	movb   $0x0,(%eax)
            ++vlc;
   14539:	83 45 e4 02          	addl   $0x2,-0x1c(%ebp)
                    ++vlc;
                }
            }
            _Skip(ctx, curcount);
        }
        while(remain--){
   1453d:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14540:	8d 50 ff             	lea    -0x1(%eax),%edx
   14543:	89 55 ec             	mov    %edx,-0x14(%ebp)
   14546:	85 c0                	test   %eax,%eax
   14548:	75 e9                	jne    14533 <_DecodeDHT+0x1ac>
void _DecodeDHT(Context* ctx){
    int i, codelen, remain, spread, curcount;
    uchar counts[16];
    _DecodeLength(ctx);
    if(ctx->result) return;
    while(ctx->length >= 17){
   1454a:	8b 45 08             	mov    0x8(%ebp),%eax
   1454d:	8b 40 0c             	mov    0xc(%eax),%eax
   14550:	83 f8 10             	cmp    $0x10,%eax
   14553:	0f 8f 55 fe ff ff    	jg     143ae <_DecodeDHT+0x27>
        while(remain--){
            vlc->bits = 0;
            ++vlc;
        }
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
   14559:	8b 45 08             	mov    0x8(%ebp),%eax
   1455c:	8b 40 0c             	mov    0xc(%eax),%eax
   1455f:	85 c0                	test   %eax,%eax
   14561:	74 0c                	je     1456f <_DecodeDHT+0x1e8>
   14563:	8b 45 08             	mov    0x8(%ebp),%eax
   14566:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1456c:	eb 01                	jmp    1456f <_DecodeDHT+0x1e8>

void _DecodeDHT(Context* ctx){
    int i, codelen, remain, spread, curcount;
    uchar counts[16];
    _DecodeLength(ctx);
    if(ctx->result) return;
   1456e:	90                   	nop
            vlc->bits = 0;
            ++vlc;
        }
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
}
   1456f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   14572:	c9                   	leave  
   14573:	c3                   	ret    

00014574 <_DecodeDQT>:

void _DecodeDQT(Context* ctx){
   14574:	55                   	push   %ebp
   14575:	89 e5                	mov    %esp,%ebp
   14577:	53                   	push   %ebx
   14578:	83 ec 14             	sub    $0x14,%esp
    int i;
    uchar* t;
    _DecodeLength(ctx);
   1457b:	83 ec 0c             	sub    $0xc,%esp
   1457e:	ff 75 08             	pushl  0x8(%ebp)
   14581:	e8 62 f7 ff ff       	call   13ce8 <_DecodeLength>
   14586:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   14589:	8b 45 08             	mov    0x8(%ebp),%eax
   1458c:	8b 00                	mov    (%eax),%eax
   1458e:	85 c0                	test   %eax,%eax
   14590:	0f 85 e2 00 00 00    	jne    14678 <_DecodeDQT+0x104>
    while(ctx->length >= 65){
   14596:	e9 b8 00 00 00       	jmp    14653 <_DecodeDQT+0xdf>
        i = ctx->pos[0];
   1459b:	8b 45 08             	mov    0x8(%ebp),%eax
   1459e:	8b 40 04             	mov    0x4(%eax),%eax
   145a1:	0f b6 00             	movzbl (%eax),%eax
   145a4:	0f b6 c0             	movzbl %al,%eax
   145a7:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(i & 0xEC) ERROR_RETURN(SyntaxError);
   145aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
   145ad:	25 ec 00 00 00       	and    $0xec,%eax
   145b2:	85 c0                	test   %eax,%eax
   145b4:	74 0e                	je     145c4 <_DecodeDQT+0x50>
   145b6:	8b 45 08             	mov    0x8(%ebp),%eax
   145b9:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   145bf:	e9 b5 00 00 00       	jmp    14679 <_DecodeDQT+0x105>
        if(i & 0x10) ERROR_RETURN(Unsupported);
   145c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   145c7:	83 e0 10             	and    $0x10,%eax
   145ca:	85 c0                	test   %eax,%eax
   145cc:	74 0e                	je     145dc <_DecodeDQT+0x68>
   145ce:	8b 45 08             	mov    0x8(%ebp),%eax
   145d1:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   145d7:	e9 9d 00 00 00       	jmp    14679 <_DecodeDQT+0x105>
        ctx->qtavail |= 1 << i;
   145dc:	8b 45 08             	mov    0x8(%ebp),%eax
   145df:	8b 90 b4 00 00 00    	mov    0xb4(%eax),%edx
   145e5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   145e8:	bb 01 00 00 00       	mov    $0x1,%ebx
   145ed:	89 c1                	mov    %eax,%ecx
   145ef:	d3 e3                	shl    %cl,%ebx
   145f1:	89 d8                	mov    %ebx,%eax
   145f3:	09 c2                	or     %eax,%edx
   145f5:	8b 45 08             	mov    0x8(%ebp),%eax
   145f8:	89 90 b4 00 00 00    	mov    %edx,0xb4(%eax)
        t =&ctx->qtable[i][0];
   145fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14601:	c1 e0 06             	shl    $0x6,%eax
   14604:	8d 90 b0 00 00 00    	lea    0xb0(%eax),%edx
   1460a:	8b 45 08             	mov    0x8(%ebp),%eax
   1460d:	01 d0                	add    %edx,%eax
   1460f:	83 c0 08             	add    $0x8,%eax
   14612:	89 45 f0             	mov    %eax,-0x10(%ebp)
        for(i=0; i<64; ++i) t[i] = ctx->pos[i + 1];
   14615:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1461c:	eb 1f                	jmp    1463d <_DecodeDQT+0xc9>
   1461e:	8b 55 f4             	mov    -0xc(%ebp),%edx
   14621:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14624:	01 c2                	add    %eax,%edx
   14626:	8b 45 08             	mov    0x8(%ebp),%eax
   14629:	8b 40 04             	mov    0x4(%eax),%eax
   1462c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   1462f:	83 c1 01             	add    $0x1,%ecx
   14632:	01 c8                	add    %ecx,%eax
   14634:	0f b6 00             	movzbl (%eax),%eax
   14637:	88 02                	mov    %al,(%edx)
   14639:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1463d:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
   14641:	7e db                	jle    1461e <_DecodeDQT+0xaa>
        _Skip(ctx, 65);
   14643:	83 ec 08             	sub    $0x8,%esp
   14646:	6a 41                	push   $0x41
   14648:	ff 75 08             	pushl  0x8(%ebp)
   1464b:	e8 4c f6 ff ff       	call   13c9c <_Skip>
   14650:	83 c4 10             	add    $0x10,%esp
void _DecodeDQT(Context* ctx){
    int i;
    uchar* t;
    _DecodeLength(ctx);
    if(ctx->result) return;
    while(ctx->length >= 65){
   14653:	8b 45 08             	mov    0x8(%ebp),%eax
   14656:	8b 40 0c             	mov    0xc(%eax),%eax
   14659:	83 f8 40             	cmp    $0x40,%eax
   1465c:	0f 8f 39 ff ff ff    	jg     1459b <_DecodeDQT+0x27>
        ctx->qtavail |= 1 << i;
        t =&ctx->qtable[i][0];
        for(i=0; i<64; ++i) t[i] = ctx->pos[i + 1];
        _Skip(ctx, 65);
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
   14662:	8b 45 08             	mov    0x8(%ebp),%eax
   14665:	8b 40 0c             	mov    0xc(%eax),%eax
   14668:	85 c0                	test   %eax,%eax
   1466a:	74 0d                	je     14679 <_DecodeDQT+0x105>
   1466c:	8b 45 08             	mov    0x8(%ebp),%eax
   1466f:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14675:	90                   	nop
   14676:	eb 01                	jmp    14679 <_DecodeDQT+0x105>

void _DecodeDQT(Context* ctx){
    int i;
    uchar* t;
    _DecodeLength(ctx);
    if(ctx->result) return;
   14678:	90                   	nop
        t =&ctx->qtable[i][0];
        for(i=0; i<64; ++i) t[i] = ctx->pos[i + 1];
        _Skip(ctx, 65);
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
}
   14679:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1467c:	c9                   	leave  
   1467d:	c3                   	ret    

0001467e <_DecodeDRI>:

void _DecodeDRI(Context* ctx){
   1467e:	55                   	push   %ebp
   1467f:	89 e5                	mov    %esp,%ebp
   14681:	83 ec 08             	sub    $0x8,%esp
    _DecodeLength(ctx);
   14684:	83 ec 0c             	sub    $0xc,%esp
   14687:	ff 75 08             	pushl  0x8(%ebp)
   1468a:	e8 59 f6 ff ff       	call   13ce8 <_DecodeLength>
   1468f:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   14692:	8b 45 08             	mov    0x8(%ebp),%eax
   14695:	8b 00                	mov    (%eax),%eax
   14697:	85 c0                	test   %eax,%eax
   14699:	75 4a                	jne    146e5 <_DecodeDRI+0x67>
    if(ctx->length < 2) ERROR_RETURN(SyntaxError);
   1469b:	8b 45 08             	mov    0x8(%ebp),%eax
   1469e:	8b 40 0c             	mov    0xc(%eax),%eax
   146a1:	83 f8 01             	cmp    $0x1,%eax
   146a4:	7f 0b                	jg     146b1 <_DecodeDRI+0x33>
   146a6:	8b 45 08             	mov    0x8(%ebp),%eax
   146a9:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   146af:	eb 35                	jmp    146e6 <_DecodeDRI+0x68>
    ctx->rstInterval = _Decode2Bytes(ctx->pos);
   146b1:	8b 45 08             	mov    0x8(%ebp),%eax
   146b4:	8b 40 04             	mov    0x4(%eax),%eax
   146b7:	83 ec 0c             	sub    $0xc,%esp
   146ba:	50                   	push   %eax
   146bb:	e8 8b f6 ff ff       	call   13d4b <_Decode2Bytes>
   146c0:	83 c4 10             	add    $0x10,%esp
   146c3:	89 c2                	mov    %eax,%edx
   146c5:	8b 45 08             	mov    0x8(%ebp),%eax
   146c8:	89 90 c0 02 08 00    	mov    %edx,0x802c0(%eax)
    _Skip(ctx, ctx->length);
   146ce:	8b 45 08             	mov    0x8(%ebp),%eax
   146d1:	8b 40 0c             	mov    0xc(%eax),%eax
   146d4:	83 ec 08             	sub    $0x8,%esp
   146d7:	50                   	push   %eax
   146d8:	ff 75 08             	pushl  0x8(%ebp)
   146db:	e8 bc f5 ff ff       	call   13c9c <_Skip>
   146e0:	83 c4 10             	add    $0x10,%esp
   146e3:	eb 01                	jmp    146e6 <_DecodeDRI+0x68>
    if(ctx->length) ERROR_RETURN(SyntaxError);
}

void _DecodeDRI(Context* ctx){
    _DecodeLength(ctx);
    if(ctx->result) return;
   146e5:	90                   	nop
    if(ctx->length < 2) ERROR_RETURN(SyntaxError);
    ctx->rstInterval = _Decode2Bytes(ctx->pos);
    _Skip(ctx, ctx->length);
}
   146e6:	c9                   	leave  
   146e7:	c3                   	ret    

000146e8 <_DecodeSOS>:

void _DecodeSOS(Context* ctx, char* ZZ){
   146e8:	55                   	push   %ebp
   146e9:	89 e5                	mov    %esp,%ebp
   146eb:	83 ec 28             	sub    $0x28,%esp
    int i, MCUx, MCUy, sbx, sby;
    int rstcount = ctx->rstInterval, nextrst = 0;
   146ee:	8b 45 08             	mov    0x8(%ebp),%eax
   146f1:	8b 80 c0 02 08 00    	mov    0x802c0(%eax),%eax
   146f7:	89 45 e0             	mov    %eax,-0x20(%ebp)
   146fa:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    Component* c;
    _DecodeLength(ctx);
   14701:	83 ec 0c             	sub    $0xc,%esp
   14704:	ff 75 08             	pushl  0x8(%ebp)
   14707:	e8 dc f5 ff ff       	call   13ce8 <_DecodeLength>
   1470c:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   1470f:	8b 45 08             	mov    0x8(%ebp),%eax
   14712:	8b 00                	mov    (%eax),%eax
   14714:	85 c0                	test   %eax,%eax
   14716:	0f 85 c2 02 00 00    	jne    149de <_DecodeSOS+0x2f6>
    if((ctx->length < (4 + 2 * ctx->compNum)) || (ctx->pos[0] != ctx->compNum)) ERROR_RETURN(SyntaxError);
   1471c:	8b 45 08             	mov    0x8(%ebp),%eax
   1471f:	8b 50 0c             	mov    0xc(%eax),%edx
   14722:	8b 45 08             	mov    0x8(%ebp),%eax
   14725:	8b 40 28             	mov    0x28(%eax),%eax
   14728:	83 c0 02             	add    $0x2,%eax
   1472b:	01 c0                	add    %eax,%eax
   1472d:	39 c2                	cmp    %eax,%edx
   1472f:	7c 16                	jl     14747 <_DecodeSOS+0x5f>
   14731:	8b 45 08             	mov    0x8(%ebp),%eax
   14734:	8b 40 04             	mov    0x4(%eax),%eax
   14737:	0f b6 00             	movzbl (%eax),%eax
   1473a:	0f b6 d0             	movzbl %al,%edx
   1473d:	8b 45 08             	mov    0x8(%ebp),%eax
   14740:	8b 40 28             	mov    0x28(%eax),%eax
   14743:	39 c2                	cmp    %eax,%edx
   14745:	74 0e                	je     14755 <_DecodeSOS+0x6d>
   14747:	8b 45 08             	mov    0x8(%ebp),%eax
   1474a:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14750:	e9 8d 02 00 00       	jmp    149e2 <_DecodeSOS+0x2fa>
    _Skip(ctx, 1);
   14755:	83 ec 08             	sub    $0x8,%esp
   14758:	6a 01                	push   $0x1
   1475a:	ff 75 08             	pushl  0x8(%ebp)
   1475d:	e8 3a f5 ff ff       	call   13c9c <_Skip>
   14762:	83 c4 10             	add    $0x10,%esp
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   14765:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1476c:	8b 45 08             	mov    0x8(%ebp),%eax
   1476f:	83 c0 2c             	add    $0x2c,%eax
   14772:	89 45 dc             	mov    %eax,-0x24(%ebp)
   14775:	e9 ba 00 00 00       	jmp    14834 <_DecodeSOS+0x14c>
        if(ctx->pos[0] != c->cid) ERROR_RETURN(SyntaxError);
   1477a:	8b 45 08             	mov    0x8(%ebp),%eax
   1477d:	8b 40 04             	mov    0x4(%eax),%eax
   14780:	0f b6 00             	movzbl (%eax),%eax
   14783:	0f b6 d0             	movzbl %al,%edx
   14786:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14789:	8b 00                	mov    (%eax),%eax
   1478b:	39 c2                	cmp    %eax,%edx
   1478d:	74 0e                	je     1479d <_DecodeSOS+0xb5>
   1478f:	8b 45 08             	mov    0x8(%ebp),%eax
   14792:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14798:	e9 45 02 00 00       	jmp    149e2 <_DecodeSOS+0x2fa>
        if(ctx->pos[1] & 0xEC) ERROR_RETURN(SyntaxError);
   1479d:	8b 45 08             	mov    0x8(%ebp),%eax
   147a0:	8b 40 04             	mov    0x4(%eax),%eax
   147a3:	83 c0 01             	add    $0x1,%eax
   147a6:	0f b6 00             	movzbl (%eax),%eax
   147a9:	0f b6 c0             	movzbl %al,%eax
   147ac:	25 ec 00 00 00       	and    $0xec,%eax
   147b1:	85 c0                	test   %eax,%eax
   147b3:	74 0e                	je     147c3 <_DecodeSOS+0xdb>
   147b5:	8b 45 08             	mov    0x8(%ebp),%eax
   147b8:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   147be:	e9 1f 02 00 00       	jmp    149e2 <_DecodeSOS+0x2fa>
        if(ctx->pos[1] & 0x02) ERROR_RETURN(Unsupported);
   147c3:	8b 45 08             	mov    0x8(%ebp),%eax
   147c6:	8b 40 04             	mov    0x4(%eax),%eax
   147c9:	83 c0 01             	add    $0x1,%eax
   147cc:	0f b6 00             	movzbl (%eax),%eax
   147cf:	0f b6 c0             	movzbl %al,%eax
   147d2:	83 e0 02             	and    $0x2,%eax
   147d5:	85 c0                	test   %eax,%eax
   147d7:	74 0e                	je     147e7 <_DecodeSOS+0xff>
   147d9:	8b 45 08             	mov    0x8(%ebp),%eax
   147dc:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   147e2:	e9 fb 01 00 00       	jmp    149e2 <_DecodeSOS+0x2fa>
        c->dctabsel = ctx->pos[1] >> 4;
   147e7:	8b 45 08             	mov    0x8(%ebp),%eax
   147ea:	8b 40 04             	mov    0x4(%eax),%eax
   147ed:	83 c0 01             	add    $0x1,%eax
   147f0:	0f b6 00             	movzbl (%eax),%eax
   147f3:	c0 e8 04             	shr    $0x4,%al
   147f6:	0f b6 d0             	movzbl %al,%edx
   147f9:	8b 45 dc             	mov    -0x24(%ebp),%eax
   147fc:	89 50 20             	mov    %edx,0x20(%eax)
        c->actabsel = (ctx->pos[1] & 1) | 2;
   147ff:	8b 45 08             	mov    0x8(%ebp),%eax
   14802:	8b 40 04             	mov    0x4(%eax),%eax
   14805:	83 c0 01             	add    $0x1,%eax
   14808:	0f b6 00             	movzbl (%eax),%eax
   1480b:	0f b6 c0             	movzbl %al,%eax
   1480e:	83 e0 01             	and    $0x1,%eax
   14811:	83 c8 02             	or     $0x2,%eax
   14814:	89 c2                	mov    %eax,%edx
   14816:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14819:	89 50 1c             	mov    %edx,0x1c(%eax)
        _Skip(ctx, 2);
   1481c:	83 ec 08             	sub    $0x8,%esp
   1481f:	6a 02                	push   $0x2
   14821:	ff 75 08             	pushl  0x8(%ebp)
   14824:	e8 73 f4 ff ff       	call   13c9c <_Skip>
   14829:	83 c4 10             	add    $0x10,%esp
    Component* c;
    _DecodeLength(ctx);
    if(ctx->result) return;
    if((ctx->length < (4 + 2 * ctx->compNum)) || (ctx->pos[0] != ctx->compNum)) ERROR_RETURN(SyntaxError);
    _Skip(ctx, 1);
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   1482c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14830:	83 45 dc 2c          	addl   $0x2c,-0x24(%ebp)
   14834:	8b 45 08             	mov    0x8(%ebp),%eax
   14837:	8b 40 28             	mov    0x28(%eax),%eax
   1483a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   1483d:	0f 8f 37 ff ff ff    	jg     1477a <_DecodeSOS+0x92>
        if(ctx->pos[1] & 0x02) ERROR_RETURN(Unsupported);
        c->dctabsel = ctx->pos[1] >> 4;
        c->actabsel = (ctx->pos[1] & 1) | 2;
        _Skip(ctx, 2);
    }
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
   14843:	8b 45 08             	mov    0x8(%ebp),%eax
   14846:	8b 40 04             	mov    0x4(%eax),%eax
   14849:	0f b6 00             	movzbl (%eax),%eax
   1484c:	84 c0                	test   %al,%al
   1484e:	75 10                	jne    14860 <_DecodeSOS+0x178>
   14850:	8b 45 08             	mov    0x8(%ebp),%eax
   14853:	8b 40 04             	mov    0x4(%eax),%eax
   14856:	83 c0 01             	add    $0x1,%eax
   14859:	0f b6 00             	movzbl (%eax),%eax
   1485c:	3c 3f                	cmp    $0x3f,%al
   1485e:	74 0e                	je     1486e <_DecodeSOS+0x186>
   14860:	8b 45 08             	mov    0x8(%ebp),%eax
   14863:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14869:	e9 74 01 00 00       	jmp    149e2 <_DecodeSOS+0x2fa>
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
   1486e:	8b 45 08             	mov    0x8(%ebp),%eax
   14871:	8b 40 04             	mov    0x4(%eax),%eax
   14874:	83 c0 02             	add    $0x2,%eax
   14877:	0f b6 00             	movzbl (%eax),%eax
   1487a:	84 c0                	test   %al,%al
   1487c:	74 0e                	je     1488c <_DecodeSOS+0x1a4>
   1487e:	8b 45 08             	mov    0x8(%ebp),%eax
   14881:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   14887:	e9 56 01 00 00       	jmp    149e2 <_DecodeSOS+0x2fa>
    _Skip(ctx, ctx->length);
   1488c:	8b 45 08             	mov    0x8(%ebp),%eax
   1488f:	8b 40 0c             	mov    0xc(%eax),%eax
   14892:	83 ec 08             	sub    $0x8,%esp
   14895:	50                   	push   %eax
   14896:	ff 75 08             	pushl  0x8(%ebp)
   14899:	e8 fe f3 ff ff       	call   13c9c <_Skip>
   1489e:	83 c4 10             	add    $0x10,%esp
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
   148a1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   148a8:	e9 17 01 00 00       	jmp    149c4 <_DecodeSOS+0x2dc>
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
   148ad:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   148b4:	e9 f8 00 00 00       	jmp    149b1 <_DecodeSOS+0x2c9>
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
   148b9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   148c0:	8b 45 08             	mov    0x8(%ebp),%eax
   148c3:	83 c0 2c             	add    $0x2c,%eax
   148c6:	89 45 dc             	mov    %eax,-0x24(%ebp)
   148c9:	e9 8d 00 00 00       	jmp    1495b <_DecodeSOS+0x273>
                for(sby=0; sby<c->ssy; ++sby)
   148ce:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   148d5:	eb 71                	jmp    14948 <_DecodeSOS+0x260>
                    for(sbx=0; sbx<c->ssx; ++sbx){
   148d7:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   148de:	eb 59                	jmp    14939 <_DecodeSOS+0x251>
                        _DecodeBlock(ctx, ZZ, c, &c->pixels[((MCUy * c->ssy + sby) * c->stride + MCUx * c->ssx + sbx) << 3]);
   148e0:	8b 45 dc             	mov    -0x24(%ebp),%eax
   148e3:	8b 50 28             	mov    0x28(%eax),%edx
   148e6:	8b 45 dc             	mov    -0x24(%ebp),%eax
   148e9:	8b 40 08             	mov    0x8(%eax),%eax
   148ec:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   148f0:	89 c1                	mov    %eax,%ecx
   148f2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   148f5:	01 c1                	add    %eax,%ecx
   148f7:	8b 45 dc             	mov    -0x24(%ebp),%eax
   148fa:	8b 40 14             	mov    0x14(%eax),%eax
   148fd:	0f af c8             	imul   %eax,%ecx
   14900:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14903:	8b 40 04             	mov    0x4(%eax),%eax
   14906:	0f af 45 f0          	imul   -0x10(%ebp),%eax
   1490a:	01 c1                	add    %eax,%ecx
   1490c:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1490f:	01 c8                	add    %ecx,%eax
   14911:	c1 e0 03             	shl    $0x3,%eax
   14914:	01 d0                	add    %edx,%eax
   14916:	50                   	push   %eax
   14917:	ff 75 dc             	pushl  -0x24(%ebp)
   1491a:	ff 75 0c             	pushl  0xc(%ebp)
   1491d:	ff 75 08             	pushl  0x8(%ebp)
   14920:	e8 bf 00 00 00       	call   149e4 <_DecodeBlock>
   14925:	83 c4 10             	add    $0x10,%esp
                        if(ctx->result) return;
   14928:	8b 45 08             	mov    0x8(%ebp),%eax
   1492b:	8b 00                	mov    (%eax),%eax
   1492d:	85 c0                	test   %eax,%eax
   1492f:	0f 85 ac 00 00 00    	jne    149e1 <_DecodeSOS+0x2f9>
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
                for(sby=0; sby<c->ssy; ++sby)
                    for(sbx=0; sbx<c->ssx; ++sbx){
   14935:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   14939:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1493c:	8b 40 04             	mov    0x4(%eax),%eax
   1493f:	3b 45 e8             	cmp    -0x18(%ebp),%eax
   14942:	7f 9c                	jg     148e0 <_DecodeSOS+0x1f8>
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
                for(sby=0; sby<c->ssy; ++sby)
   14944:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   14948:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1494b:	8b 40 08             	mov    0x8(%eax),%eax
   1494e:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   14951:	7f 84                	jg     148d7 <_DecodeSOS+0x1ef>
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
   14953:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14957:	83 45 dc 2c          	addl   $0x2c,-0x24(%ebp)
   1495b:	8b 45 08             	mov    0x8(%ebp),%eax
   1495e:	8b 40 28             	mov    0x28(%eax),%eax
   14961:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   14964:	0f 8f 64 ff ff ff    	jg     148ce <_DecodeSOS+0x1e6>
                for(sby=0; sby<c->ssy; ++sby)
                    for(sbx=0; sbx<c->ssx; ++sbx){
                        _DecodeBlock(ctx, ZZ, c, &c->pixels[((MCUy * c->ssy + sby) * c->stride + MCUx * c->ssx + sbx) << 3]);
                        if(ctx->result) return;
                    }
            if(ctx->rstInterval && !(--rstcount)){
   1496a:	8b 45 08             	mov    0x8(%ebp),%eax
   1496d:	8b 80 c0 02 08 00    	mov    0x802c0(%eax),%eax
   14973:	85 c0                	test   %eax,%eax
   14975:	74 36                	je     149ad <_DecodeSOS+0x2c5>
   14977:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
   1497b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   1497f:	75 2c                	jne    149ad <_DecodeSOS+0x2c5>
                _ByteAlign(ctx);
   14981:	83 ec 0c             	sub    $0xc,%esp
   14984:	ff 75 08             	pushl  0x8(%ebp)
   14987:	e8 9f 0a 00 00       	call   1542b <_ByteAlign>
   1498c:	83 c4 10             	add    $0x10,%esp
                i = _GetBits(ctx, 16);
   1498f:	83 ec 08             	sub    $0x8,%esp
   14992:	6a 10                	push   $0x10
   14994:	ff 75 08             	pushl  0x8(%ebp)
   14997:	e8 ce 04 00 00       	call   14e6a <_GetBits>
   1499c:	83 c4 10             	add    $0x10,%esp
   1499f:	89 45 f4             	mov    %eax,-0xc(%ebp)
                if(((i & 0xFFF8) != 0xFFFD0) || ((i & 7) != nextrst)) ERROR_RETURN(SyntaxError);
   149a2:	8b 45 08             	mov    0x8(%ebp),%eax
   149a5:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   149ab:	eb 35                	jmp    149e2 <_DecodeSOS+0x2fa>
    }
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
   149ad:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   149b1:	8b 45 08             	mov    0x8(%ebp),%eax
   149b4:	8b 40 18             	mov    0x18(%eax),%eax
   149b7:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   149ba:	0f 8f f9 fe ff ff    	jg     148b9 <_DecodeSOS+0x1d1>
        _Skip(ctx, 2);
    }
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
   149c0:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   149c4:	8b 45 08             	mov    0x8(%ebp),%eax
   149c7:	8b 40 1c             	mov    0x1c(%eax),%eax
   149ca:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   149cd:	0f 8f da fe ff ff    	jg     148ad <_DecodeSOS+0x1c5>
                nextrst = (nextrst + 1) & 7;
                rstcount = ctx->rstInterval;
                for(i=0; i<3; ++i) ctx->comp[i].dcpred = 0;
            }
        }
    ctx->result = InternalFinished;
   149d3:	8b 45 08             	mov    0x8(%ebp),%eax
   149d6:	c7 00 06 00 00 00    	movl   $0x6,(%eax)
   149dc:	eb 04                	jmp    149e2 <_DecodeSOS+0x2fa>
void _DecodeSOS(Context* ctx, char* ZZ){
    int i, MCUx, MCUy, sbx, sby;
    int rstcount = ctx->rstInterval, nextrst = 0;
    Component* c;
    _DecodeLength(ctx);
    if(ctx->result) return;
   149de:	90                   	nop
   149df:	eb 01                	jmp    149e2 <_DecodeSOS+0x2fa>
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
                for(sby=0; sby<c->ssy; ++sby)
                    for(sbx=0; sbx<c->ssx; ++sbx){
                        _DecodeBlock(ctx, ZZ, c, &c->pixels[((MCUy * c->ssy + sby) * c->stride + MCUx * c->ssx + sbx) << 3]);
                        if(ctx->result) return;
   149e1:	90                   	nop
                rstcount = ctx->rstInterval;
                for(i=0; i<3; ++i) ctx->comp[i].dcpred = 0;
            }
        }
    ctx->result = InternalFinished;
}
   149e2:	c9                   	leave  
   149e3:	c3                   	ret    

000149e4 <_DecodeBlock>:

void _DecodeBlock(Context* ctx, char * ZZ, Component* c, uchar* out){
   149e4:	55                   	push   %ebp
   149e5:	89 e5                	mov    %esp,%ebp
   149e7:	53                   	push   %ebx
   149e8:	83 ec 14             	sub    $0x14,%esp
    uchar code;
    int value, coef=0;
   149eb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    memset(ctx->block, 0, sizeof(ctx->block));
   149f2:	8b 45 08             	mov    0x8(%ebp),%eax
   149f5:	05 c0 01 08 00       	add    $0x801c0,%eax
   149fa:	83 ec 04             	sub    $0x4,%esp
   149fd:	68 00 01 00 00       	push   $0x100
   14a02:	6a 00                	push   $0x0
   14a04:	50                   	push   %eax
   14a05:	e8 04 b8 fe ff       	call   20e <memset>
   14a0a:	83 c4 10             	add    $0x10,%esp
    c->dcpred += _GetVLC(ctx, &ctx->vlctable[c->dctabsel][0], 0);
   14a0d:	8b 45 10             	mov    0x10(%ebp),%eax
   14a10:	8b 40 20             	mov    0x20(%eax),%eax
   14a13:	c1 e0 11             	shl    $0x11,%eax
   14a16:	8d 90 b0 01 00 00    	lea    0x1b0(%eax),%edx
   14a1c:	8b 45 08             	mov    0x8(%ebp),%eax
   14a1f:	01 d0                	add    %edx,%eax
   14a21:	83 c0 08             	add    $0x8,%eax
   14a24:	83 ec 04             	sub    $0x4,%esp
   14a27:	6a 00                	push   $0x0
   14a29:	50                   	push   %eax
   14a2a:	ff 75 08             	pushl  0x8(%ebp)
   14a2d:	e8 86 01 00 00       	call   14bb8 <_GetVLC>
   14a32:	83 c4 10             	add    $0x10,%esp
   14a35:	89 c2                	mov    %eax,%edx
   14a37:	8b 45 10             	mov    0x10(%ebp),%eax
   14a3a:	8b 40 24             	mov    0x24(%eax),%eax
   14a3d:	01 c2                	add    %eax,%edx
   14a3f:	8b 45 10             	mov    0x10(%ebp),%eax
   14a42:	89 50 24             	mov    %edx,0x24(%eax)
    ctx->block[0] = (c->dcpred) * ctx->qtable[c->qtselect][0];
   14a45:	8b 45 10             	mov    0x10(%ebp),%eax
   14a48:	8b 50 24             	mov    0x24(%eax),%edx
   14a4b:	8b 45 10             	mov    0x10(%ebp),%eax
   14a4e:	8b 48 18             	mov    0x18(%eax),%ecx
   14a51:	8b 45 08             	mov    0x8(%ebp),%eax
   14a54:	c1 e1 06             	shl    $0x6,%ecx
   14a57:	01 c8                	add    %ecx,%eax
   14a59:	05 b8 00 00 00       	add    $0xb8,%eax
   14a5e:	0f b6 00             	movzbl (%eax),%eax
   14a61:	0f b6 c0             	movzbl %al,%eax
   14a64:	0f af d0             	imul   %eax,%edx
   14a67:	8b 45 08             	mov    0x8(%ebp),%eax
   14a6a:	89 90 c0 01 08 00    	mov    %edx,0x801c0(%eax)
    do{
        value = _GetVLC(ctx, &ctx->vlctable[c->actabsel][0], &code);
   14a70:	8b 45 10             	mov    0x10(%ebp),%eax
   14a73:	8b 40 1c             	mov    0x1c(%eax),%eax
   14a76:	c1 e0 11             	shl    $0x11,%eax
   14a79:	8d 90 b0 01 00 00    	lea    0x1b0(%eax),%edx
   14a7f:	8b 45 08             	mov    0x8(%ebp),%eax
   14a82:	01 d0                	add    %edx,%eax
   14a84:	8d 50 08             	lea    0x8(%eax),%edx
   14a87:	83 ec 04             	sub    $0x4,%esp
   14a8a:	8d 45 ef             	lea    -0x11(%ebp),%eax
   14a8d:	50                   	push   %eax
   14a8e:	52                   	push   %edx
   14a8f:	ff 75 08             	pushl  0x8(%ebp)
   14a92:	e8 21 01 00 00       	call   14bb8 <_GetVLC>
   14a97:	83 c4 10             	add    $0x10,%esp
   14a9a:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(!code) break;   // EOB
   14a9d:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   14aa1:	84 c0                	test   %al,%al
   14aa3:	0f 84 92 00 00 00    	je     14b3b <_DecodeBlock+0x157>
        if(!(code & 0x0F) && (code != 0xF0)) ERROR_RETURN(SyntaxError);
   14aa9:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   14aad:	0f b6 c0             	movzbl %al,%eax
   14ab0:	83 e0 0f             	and    $0xf,%eax
   14ab3:	85 c0                	test   %eax,%eax
   14ab5:	75 16                	jne    14acd <_DecodeBlock+0xe9>
   14ab7:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   14abb:	3c f0                	cmp    $0xf0,%al
   14abd:	74 0e                	je     14acd <_DecodeBlock+0xe9>
   14abf:	8b 45 08             	mov    0x8(%ebp),%eax
   14ac2:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14ac8:	e9 e6 00 00 00       	jmp    14bb3 <_DecodeBlock+0x1cf>
        coef += (code >> 4) + 1;
   14acd:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   14ad1:	c0 e8 04             	shr    $0x4,%al
   14ad4:	0f b6 c0             	movzbl %al,%eax
   14ad7:	83 c0 01             	add    $0x1,%eax
   14ada:	01 45 f4             	add    %eax,-0xc(%ebp)
        if(coef>63) ERROR_RETURN(SyntaxError);
   14add:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
   14ae1:	7e 0e                	jle    14af1 <_DecodeBlock+0x10d>
   14ae3:	8b 45 08             	mov    0x8(%ebp),%eax
   14ae6:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14aec:	e9 c2 00 00 00       	jmp    14bb3 <_DecodeBlock+0x1cf>
        ctx->block[(int)ZZ[coef]] = value * ctx->qtable[c->qtselect][coef];
   14af1:	8b 55 f4             	mov    -0xc(%ebp),%edx
   14af4:	8b 45 0c             	mov    0xc(%ebp),%eax
   14af7:	01 d0                	add    %edx,%eax
   14af9:	0f b6 00             	movzbl (%eax),%eax
   14afc:	0f be c8             	movsbl %al,%ecx
   14aff:	8b 45 10             	mov    0x10(%ebp),%eax
   14b02:	8b 50 18             	mov    0x18(%eax),%edx
   14b05:	8b 45 08             	mov    0x8(%ebp),%eax
   14b08:	c1 e2 06             	shl    $0x6,%edx
   14b0b:	01 c2                	add    %eax,%edx
   14b0d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14b10:	01 d0                	add    %edx,%eax
   14b12:	05 b8 00 00 00       	add    $0xb8,%eax
   14b17:	0f b6 00             	movzbl (%eax),%eax
   14b1a:	0f b6 c0             	movzbl %al,%eax
   14b1d:	0f af 45 f0          	imul   -0x10(%ebp),%eax
   14b21:	89 c2                	mov    %eax,%edx
   14b23:	8b 45 08             	mov    0x8(%ebp),%eax
   14b26:	81 c1 70 00 02 00    	add    $0x20070,%ecx
   14b2c:	89 14 88             	mov    %edx,(%eax,%ecx,4)
    }while(coef < 63);
   14b2f:	83 7d f4 3e          	cmpl   $0x3e,-0xc(%ebp)
   14b33:	0f 8e 37 ff ff ff    	jle    14a70 <_DecodeBlock+0x8c>
   14b39:	eb 01                	jmp    14b3c <_DecodeBlock+0x158>
    memset(ctx->block, 0, sizeof(ctx->block));
    c->dcpred += _GetVLC(ctx, &ctx->vlctable[c->dctabsel][0], 0);
    ctx->block[0] = (c->dcpred) * ctx->qtable[c->qtselect][0];
    do{
        value = _GetVLC(ctx, &ctx->vlctable[c->actabsel][0], &code);
        if(!code) break;   // EOB
   14b3b:	90                   	nop
        if(!(code & 0x0F) && (code != 0xF0)) ERROR_RETURN(SyntaxError);
        coef += (code >> 4) + 1;
        if(coef>63) ERROR_RETURN(SyntaxError);
        ctx->block[(int)ZZ[coef]] = value * ctx->qtable[c->qtselect][coef];
    }while(coef < 63);
    for(coef=0; coef<64; coef+=8) _RowIDCT(&ctx->block[coef]);
   14b3c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14b43:	eb 24                	jmp    14b69 <_DecodeBlock+0x185>
   14b45:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14b48:	05 70 00 02 00       	add    $0x20070,%eax
   14b4d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   14b54:	8b 45 08             	mov    0x8(%ebp),%eax
   14b57:	01 d0                	add    %edx,%eax
   14b59:	83 ec 0c             	sub    $0xc,%esp
   14b5c:	50                   	push   %eax
   14b5d:	e8 32 03 00 00       	call   14e94 <_RowIDCT>
   14b62:	83 c4 10             	add    $0x10,%esp
   14b65:	83 45 f4 08          	addl   $0x8,-0xc(%ebp)
   14b69:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
   14b6d:	7e d6                	jle    14b45 <_DecodeBlock+0x161>
    for(coef=0; coef<8; ++coef) _ColIDCT(&ctx->block[coef], &out[coef], c->stride);
   14b6f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14b76:	eb 35                	jmp    14bad <_DecodeBlock+0x1c9>
   14b78:	8b 45 10             	mov    0x10(%ebp),%eax
   14b7b:	8b 40 14             	mov    0x14(%eax),%eax
   14b7e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   14b81:	8b 55 14             	mov    0x14(%ebp),%edx
   14b84:	01 d1                	add    %edx,%ecx
   14b86:	8b 55 f4             	mov    -0xc(%ebp),%edx
   14b89:	81 c2 70 00 02 00    	add    $0x20070,%edx
   14b8f:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
   14b96:	8b 55 08             	mov    0x8(%ebp),%edx
   14b99:	01 da                	add    %ebx,%edx
   14b9b:	83 ec 04             	sub    $0x4,%esp
   14b9e:	50                   	push   %eax
   14b9f:	51                   	push   %ecx
   14ba0:	52                   	push   %edx
   14ba1:	e8 7b 05 00 00       	call   15121 <_ColIDCT>
   14ba6:	83 c4 10             	add    $0x10,%esp
   14ba9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14bad:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
   14bb1:	7e c5                	jle    14b78 <_DecodeBlock+0x194>
}
   14bb3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   14bb6:	c9                   	leave  
   14bb7:	c3                   	ret    

00014bb8 <_GetVLC>:

int _GetVLC(Context* ctx, VlcCode* vlc, uchar* code){
   14bb8:	55                   	push   %ebp
   14bb9:	89 e5                	mov    %esp,%ebp
   14bbb:	83 ec 18             	sub    $0x18,%esp
    int value = _ShowBits(ctx, 16);
   14bbe:	83 ec 08             	sub    $0x8,%esp
   14bc1:	6a 10                	push   $0x10
   14bc3:	ff 75 08             	pushl  0x8(%ebp)
   14bc6:	e8 c2 00 00 00       	call   14c8d <_ShowBits>
   14bcb:	83 c4 10             	add    $0x10,%esp
   14bce:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int bits = vlc[value].bits;
   14bd1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14bd4:	8d 14 00             	lea    (%eax,%eax,1),%edx
   14bd7:	8b 45 0c             	mov    0xc(%ebp),%eax
   14bda:	01 d0                	add    %edx,%eax
   14bdc:	0f b6 00             	movzbl (%eax),%eax
   14bdf:	0f b6 c0             	movzbl %al,%eax
   14be2:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!bits){ ctx->result = SyntaxError; return 0; }
   14be5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   14be9:	75 13                	jne    14bfe <_GetVLC+0x46>
   14beb:	8b 45 08             	mov    0x8(%ebp),%eax
   14bee:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14bf4:	b8 00 00 00 00       	mov    $0x0,%eax
   14bf9:	e9 8d 00 00 00       	jmp    14c8b <_GetVLC+0xd3>
    _SkipBits(ctx, bits);
   14bfe:	83 ec 08             	sub    $0x8,%esp
   14c01:	ff 75 f0             	pushl  -0x10(%ebp)
   14c04:	ff 75 08             	pushl  0x8(%ebp)
   14c07:	e8 25 02 00 00       	call   14e31 <_SkipBits>
   14c0c:	83 c4 10             	add    $0x10,%esp
    value = vlc[value].code;
   14c0f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14c12:	8d 14 00             	lea    (%eax,%eax,1),%edx
   14c15:	8b 45 0c             	mov    0xc(%ebp),%eax
   14c18:	01 d0                	add    %edx,%eax
   14c1a:	0f b6 40 01          	movzbl 0x1(%eax),%eax
   14c1e:	0f b6 c0             	movzbl %al,%eax
   14c21:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(code) *code = (uchar)value;
   14c24:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   14c28:	74 0a                	je     14c34 <_GetVLC+0x7c>
   14c2a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14c2d:	89 c2                	mov    %eax,%edx
   14c2f:	8b 45 10             	mov    0x10(%ebp),%eax
   14c32:	88 10                	mov    %dl,(%eax)
    bits = value & 15;
   14c34:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14c37:	83 e0 0f             	and    $0xf,%eax
   14c3a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!bits) return 0;
   14c3d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   14c41:	75 07                	jne    14c4a <_GetVLC+0x92>
   14c43:	b8 00 00 00 00       	mov    $0x0,%eax
   14c48:	eb 41                	jmp    14c8b <_GetVLC+0xd3>
    value = _GetBits(ctx, bits);
   14c4a:	83 ec 08             	sub    $0x8,%esp
   14c4d:	ff 75 f0             	pushl  -0x10(%ebp)
   14c50:	ff 75 08             	pushl  0x8(%ebp)
   14c53:	e8 12 02 00 00       	call   14e6a <_GetBits>
   14c58:	83 c4 10             	add    $0x10,%esp
   14c5b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(value < (1 << (bits - 1)))
   14c5e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14c61:	83 e8 01             	sub    $0x1,%eax
   14c64:	ba 01 00 00 00       	mov    $0x1,%edx
   14c69:	89 c1                	mov    %eax,%ecx
   14c6b:	d3 e2                	shl    %cl,%edx
   14c6d:	89 d0                	mov    %edx,%eax
   14c6f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   14c72:	7e 14                	jle    14c88 <_GetVLC+0xd0>
        value += ((-1) << bits) + 1;
   14c74:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14c77:	ba ff ff ff ff       	mov    $0xffffffff,%edx
   14c7c:	89 c1                	mov    %eax,%ecx
   14c7e:	d3 e2                	shl    %cl,%edx
   14c80:	89 d0                	mov    %edx,%eax
   14c82:	83 c0 01             	add    $0x1,%eax
   14c85:	01 45 f4             	add    %eax,-0xc(%ebp)
    return value;
   14c88:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   14c8b:	c9                   	leave  
   14c8c:	c3                   	ret    

00014c8d <_ShowBits>:

int _ShowBits(Context* ctx, int bits){
   14c8d:	55                   	push   %ebp
   14c8e:	89 e5                	mov    %esp,%ebp
   14c90:	53                   	push   %ebx
   14c91:	83 ec 10             	sub    $0x10,%esp
    uchar nextbyte;
    if(!bits) return 0;
   14c94:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   14c98:	0f 85 4f 01 00 00    	jne    14ded <_ShowBits+0x160>
   14c9e:	b8 00 00 00 00       	mov    $0x0,%eax
   14ca3:	e9 83 01 00 00       	jmp    14e2b <_ShowBits+0x19e>
    while(ctx->bufferBits < bits){
        if(ctx->size <= 0){
   14ca8:	8b 45 08             	mov    0x8(%ebp),%eax
   14cab:	8b 40 08             	mov    0x8(%eax),%eax
   14cae:	85 c0                	test   %eax,%eax
   14cb0:	7f 33                	jg     14ce5 <_ShowBits+0x58>
            ctx->buffer = (ctx->buffer << 8) | 0xFF;
   14cb2:	8b 45 08             	mov    0x8(%ebp),%eax
   14cb5:	8b 80 b8 01 08 00    	mov    0x801b8(%eax),%eax
   14cbb:	c1 e0 08             	shl    $0x8,%eax
   14cbe:	0c ff                	or     $0xff,%al
   14cc0:	89 c2                	mov    %eax,%edx
   14cc2:	8b 45 08             	mov    0x8(%ebp),%eax
   14cc5:	89 90 b8 01 08 00    	mov    %edx,0x801b8(%eax)
            ctx->bufferBits += 8;
   14ccb:	8b 45 08             	mov    0x8(%ebp),%eax
   14cce:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14cd4:	8d 50 08             	lea    0x8(%eax),%edx
   14cd7:	8b 45 08             	mov    0x8(%ebp),%eax
   14cda:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
            continue;
   14ce0:	e9 08 01 00 00       	jmp    14ded <_ShowBits+0x160>
        }
        nextbyte = *ctx->pos++;
   14ce5:	8b 45 08             	mov    0x8(%ebp),%eax
   14ce8:	8b 40 04             	mov    0x4(%eax),%eax
   14ceb:	8d 48 01             	lea    0x1(%eax),%ecx
   14cee:	8b 55 08             	mov    0x8(%ebp),%edx
   14cf1:	89 4a 04             	mov    %ecx,0x4(%edx)
   14cf4:	0f b6 00             	movzbl (%eax),%eax
   14cf7:	88 45 fb             	mov    %al,-0x5(%ebp)
        --ctx->size;
   14cfa:	8b 45 08             	mov    0x8(%ebp),%eax
   14cfd:	8b 40 08             	mov    0x8(%eax),%eax
   14d00:	8d 50 ff             	lea    -0x1(%eax),%edx
   14d03:	8b 45 08             	mov    0x8(%ebp),%eax
   14d06:	89 50 08             	mov    %edx,0x8(%eax)
        ctx->bufferBits += 8;
   14d09:	8b 45 08             	mov    0x8(%ebp),%eax
   14d0c:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14d12:	8d 50 08             	lea    0x8(%eax),%edx
   14d15:	8b 45 08             	mov    0x8(%ebp),%eax
   14d18:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
        ctx->buffer = (ctx->buffer << 8) | nextbyte;
   14d1e:	8b 45 08             	mov    0x8(%ebp),%eax
   14d21:	8b 80 b8 01 08 00    	mov    0x801b8(%eax),%eax
   14d27:	c1 e0 08             	shl    $0x8,%eax
   14d2a:	89 c2                	mov    %eax,%edx
   14d2c:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
   14d30:	09 c2                	or     %eax,%edx
   14d32:	8b 45 08             	mov    0x8(%ebp),%eax
   14d35:	89 90 b8 01 08 00    	mov    %edx,0x801b8(%eax)
        if(nextbyte == 0xFF){
   14d3b:	80 7d fb ff          	cmpb   $0xff,-0x5(%ebp)
   14d3f:	0f 85 a8 00 00 00    	jne    14ded <_ShowBits+0x160>
            if(ctx->size){
   14d45:	8b 45 08             	mov    0x8(%ebp),%eax
   14d48:	8b 40 08             	mov    0x8(%eax),%eax
   14d4b:	85 c0                	test   %eax,%eax
   14d4d:	0f 84 91 00 00 00    	je     14de4 <_ShowBits+0x157>
                uchar marker = *ctx->pos++;
   14d53:	8b 45 08             	mov    0x8(%ebp),%eax
   14d56:	8b 40 04             	mov    0x4(%eax),%eax
   14d59:	8d 48 01             	lea    0x1(%eax),%ecx
   14d5c:	8b 55 08             	mov    0x8(%ebp),%edx
   14d5f:	89 4a 04             	mov    %ecx,0x4(%edx)
   14d62:	0f b6 00             	movzbl (%eax),%eax
   14d65:	88 45 fa             	mov    %al,-0x6(%ebp)
                --ctx->size;
   14d68:	8b 45 08             	mov    0x8(%ebp),%eax
   14d6b:	8b 40 08             	mov    0x8(%eax),%eax
   14d6e:	8d 50 ff             	lea    -0x1(%eax),%edx
   14d71:	8b 45 08             	mov    0x8(%ebp),%eax
   14d74:	89 50 08             	mov    %edx,0x8(%eax)
                switch(marker){
   14d77:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   14d7b:	85 c0                	test   %eax,%eax
   14d7d:	74 62                	je     14de1 <_ShowBits+0x154>
   14d7f:	3d d9 00 00 00       	cmp    $0xd9,%eax
   14d84:	75 0c                	jne    14d92 <_ShowBits+0x105>
                    case 0: break;
                    case 0xD9: ctx->size = 0; break;
   14d86:	8b 45 08             	mov    0x8(%ebp),%eax
   14d89:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
   14d90:	eb 5b                	jmp    14ded <_ShowBits+0x160>
                    default:
                        if((marker & 0xF8) != 0xD0)
   14d92:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   14d96:	25 f8 00 00 00       	and    $0xf8,%eax
   14d9b:	3d d0 00 00 00       	cmp    $0xd0,%eax
   14da0:	74 0b                	je     14dad <_ShowBits+0x120>
                            ctx->result = SyntaxError;
   14da2:	8b 45 08             	mov    0x8(%ebp),%eax
   14da5:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14dab:	eb 40                	jmp    14ded <_ShowBits+0x160>
                        else {
                            ctx->buffer = (ctx->buffer << 8) | marker;
   14dad:	8b 45 08             	mov    0x8(%ebp),%eax
   14db0:	8b 80 b8 01 08 00    	mov    0x801b8(%eax),%eax
   14db6:	c1 e0 08             	shl    $0x8,%eax
   14db9:	89 c2                	mov    %eax,%edx
   14dbb:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   14dbf:	09 c2                	or     %eax,%edx
   14dc1:	8b 45 08             	mov    0x8(%ebp),%eax
   14dc4:	89 90 b8 01 08 00    	mov    %edx,0x801b8(%eax)
                            ctx->bufferBits += 8;
   14dca:	8b 45 08             	mov    0x8(%ebp),%eax
   14dcd:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14dd3:	8d 50 08             	lea    0x8(%eax),%edx
   14dd6:	8b 45 08             	mov    0x8(%ebp),%eax
   14dd9:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
   14ddf:	eb 0c                	jmp    14ded <_ShowBits+0x160>
        if(nextbyte == 0xFF){
            if(ctx->size){
                uchar marker = *ctx->pos++;
                --ctx->size;
                switch(marker){
                    case 0: break;
   14de1:	90                   	nop
   14de2:	eb 09                	jmp    14ded <_ShowBits+0x160>
                            ctx->buffer = (ctx->buffer << 8) | marker;
                            ctx->bufferBits += 8;
                        }
                }
            }
            else ctx->result = SyntaxError;
   14de4:	8b 45 08             	mov    0x8(%ebp),%eax
   14de7:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
}

int _ShowBits(Context* ctx, int bits){
    uchar nextbyte;
    if(!bits) return 0;
    while(ctx->bufferBits < bits){
   14ded:	8b 45 08             	mov    0x8(%ebp),%eax
   14df0:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14df6:	3b 45 0c             	cmp    0xc(%ebp),%eax
   14df9:	0f 8c a9 fe ff ff    	jl     14ca8 <_ShowBits+0x1b>
                }
            }
            else ctx->result = SyntaxError;
        }
    }
    return (ctx->buffer >> (ctx->bufferBits - bits)) & ((1 << bits) - 1);
   14dff:	8b 45 08             	mov    0x8(%ebp),%eax
   14e02:	8b 90 b8 01 08 00    	mov    0x801b8(%eax),%edx
   14e08:	8b 45 08             	mov    0x8(%ebp),%eax
   14e0b:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14e11:	2b 45 0c             	sub    0xc(%ebp),%eax
   14e14:	89 c1                	mov    %eax,%ecx
   14e16:	d3 fa                	sar    %cl,%edx
   14e18:	8b 45 0c             	mov    0xc(%ebp),%eax
   14e1b:	bb 01 00 00 00       	mov    $0x1,%ebx
   14e20:	89 c1                	mov    %eax,%ecx
   14e22:	d3 e3                	shl    %cl,%ebx
   14e24:	89 d8                	mov    %ebx,%eax
   14e26:	83 e8 01             	sub    $0x1,%eax
   14e29:	21 d0                	and    %edx,%eax
}
   14e2b:	83 c4 10             	add    $0x10,%esp
   14e2e:	5b                   	pop    %ebx
   14e2f:	5d                   	pop    %ebp
   14e30:	c3                   	ret    

00014e31 <_SkipBits>:

void _SkipBits(Context* ctx, int bits){
   14e31:	55                   	push   %ebp
   14e32:	89 e5                	mov    %esp,%ebp
    if(ctx->bufferBits < bits) _ShowBits(ctx, bits);
   14e34:	8b 45 08             	mov    0x8(%ebp),%eax
   14e37:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14e3d:	3b 45 0c             	cmp    0xc(%ebp),%eax
   14e40:	7d 0e                	jge    14e50 <_SkipBits+0x1f>
   14e42:	ff 75 0c             	pushl  0xc(%ebp)
   14e45:	ff 75 08             	pushl  0x8(%ebp)
   14e48:	e8 40 fe ff ff       	call   14c8d <_ShowBits>
   14e4d:	83 c4 08             	add    $0x8,%esp
    ctx->bufferBits -= bits;
   14e50:	8b 45 08             	mov    0x8(%ebp),%eax
   14e53:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14e59:	2b 45 0c             	sub    0xc(%ebp),%eax
   14e5c:	89 c2                	mov    %eax,%edx
   14e5e:	8b 45 08             	mov    0x8(%ebp),%eax
   14e61:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
}
   14e67:	90                   	nop
   14e68:	c9                   	leave  
   14e69:	c3                   	ret    

00014e6a <_GetBits>:

int _GetBits(Context* ctx, int bits){
   14e6a:	55                   	push   %ebp
   14e6b:	89 e5                	mov    %esp,%ebp
   14e6d:	83 ec 10             	sub    $0x10,%esp
    int res = _ShowBits(ctx, bits);
   14e70:	ff 75 0c             	pushl  0xc(%ebp)
   14e73:	ff 75 08             	pushl  0x8(%ebp)
   14e76:	e8 12 fe ff ff       	call   14c8d <_ShowBits>
   14e7b:	83 c4 08             	add    $0x8,%esp
   14e7e:	89 45 fc             	mov    %eax,-0x4(%ebp)
    _SkipBits(ctx, bits);
   14e81:	ff 75 0c             	pushl  0xc(%ebp)
   14e84:	ff 75 08             	pushl  0x8(%ebp)
   14e87:	e8 a5 ff ff ff       	call   14e31 <_SkipBits>
   14e8c:	83 c4 08             	add    $0x8,%esp
    return res;
   14e8f:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   14e92:	c9                   	leave  
   14e93:	c3                   	ret    

00014e94 <_RowIDCT>:
    W5 = 1609,
    W6 = 1108,
    W7 = 565,
};

void _RowIDCT(int* blk){
   14e94:	55                   	push   %ebp
   14e95:	89 e5                	mov    %esp,%ebp
   14e97:	57                   	push   %edi
   14e98:	56                   	push   %esi
   14e99:	53                   	push   %ebx
   14e9a:	83 ec 38             	sub    $0x38,%esp
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[4] << 11)
   14e9d:	8b 45 08             	mov    0x8(%ebp),%eax
   14ea0:	83 c0 10             	add    $0x10,%eax
   14ea3:	8b 00                	mov    (%eax),%eax
   14ea5:	c1 e0 0b             	shl    $0xb,%eax
   14ea8:	89 45 f0             	mov    %eax,-0x10(%ebp)
        | (x2 = blk[6])
   14eab:	8b 45 08             	mov    0x8(%ebp),%eax
   14eae:	8b 40 18             	mov    0x18(%eax),%eax
   14eb1:	89 45 ec             	mov    %eax,-0x14(%ebp)
   14eb4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14eb7:	0b 45 ec             	or     -0x14(%ebp),%eax
        | (x3 = blk[2])
   14eba:	8b 55 08             	mov    0x8(%ebp),%edx
   14ebd:	8b 52 08             	mov    0x8(%edx),%edx
   14ec0:	89 55 e8             	mov    %edx,-0x18(%ebp)
   14ec3:	0b 45 e8             	or     -0x18(%ebp),%eax
        | (x4 = blk[1])
   14ec6:	8b 55 08             	mov    0x8(%ebp),%edx
   14ec9:	8b 52 04             	mov    0x4(%edx),%edx
   14ecc:	89 55 e4             	mov    %edx,-0x1c(%ebp)
   14ecf:	0b 45 e4             	or     -0x1c(%ebp),%eax
        | (x5 = blk[7])
   14ed2:	8b 55 08             	mov    0x8(%ebp),%edx
   14ed5:	8b 52 1c             	mov    0x1c(%edx),%edx
   14ed8:	89 55 e0             	mov    %edx,-0x20(%ebp)
   14edb:	0b 45 e0             	or     -0x20(%ebp),%eax
        | (x6 = blk[5])
   14ede:	8b 55 08             	mov    0x8(%ebp),%edx
   14ee1:	8b 52 14             	mov    0x14(%edx),%edx
   14ee4:	89 55 dc             	mov    %edx,-0x24(%ebp)
   14ee7:	0b 45 dc             	or     -0x24(%ebp),%eax
        | (x7 = blk[3])))
   14eea:	8b 55 08             	mov    0x8(%ebp),%edx
   14eed:	8b 52 0c             	mov    0xc(%edx),%edx
   14ef0:	89 55 d8             	mov    %edx,-0x28(%ebp)
   14ef3:	0b 45 d8             	or     -0x28(%ebp),%eax
    W7 = 565,
};

void _RowIDCT(int* blk){
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[4] << 11)
   14ef6:	85 c0                	test   %eax,%eax
   14ef8:	75 68                	jne    14f62 <_RowIDCT+0xce>
        | (x4 = blk[1])
        | (x5 = blk[7])
        | (x6 = blk[5])
        | (x7 = blk[3])))
    {
        blk[0] = blk[1] = blk[2] = blk[3] = blk[4] = blk[5] = blk[6] = blk[7] = blk[0] << 3;
   14efa:	8b 45 08             	mov    0x8(%ebp),%eax
   14efd:	8d 48 04             	lea    0x4(%eax),%ecx
   14f00:	8b 45 08             	mov    0x8(%ebp),%eax
   14f03:	8d 58 08             	lea    0x8(%eax),%ebx
   14f06:	8b 45 08             	mov    0x8(%ebp),%eax
   14f09:	8d 70 0c             	lea    0xc(%eax),%esi
   14f0c:	8b 45 08             	mov    0x8(%ebp),%eax
   14f0f:	8d 78 10             	lea    0x10(%eax),%edi
   14f12:	8b 45 08             	mov    0x8(%ebp),%eax
   14f15:	83 c0 14             	add    $0x14,%eax
   14f18:	89 45 c0             	mov    %eax,-0x40(%ebp)
   14f1b:	8b 45 08             	mov    0x8(%ebp),%eax
   14f1e:	83 c0 18             	add    $0x18,%eax
   14f21:	89 45 bc             	mov    %eax,-0x44(%ebp)
   14f24:	8b 45 08             	mov    0x8(%ebp),%eax
   14f27:	8d 50 1c             	lea    0x1c(%eax),%edx
   14f2a:	8b 45 08             	mov    0x8(%ebp),%eax
   14f2d:	8b 00                	mov    (%eax),%eax
   14f2f:	c1 e0 03             	shl    $0x3,%eax
   14f32:	89 02                	mov    %eax,(%edx)
   14f34:	8b 02                	mov    (%edx),%eax
   14f36:	8b 55 bc             	mov    -0x44(%ebp),%edx
   14f39:	89 02                	mov    %eax,(%edx)
   14f3b:	89 d0                	mov    %edx,%eax
   14f3d:	8b 00                	mov    (%eax),%eax
   14f3f:	8b 55 c0             	mov    -0x40(%ebp),%edx
   14f42:	89 02                	mov    %eax,(%edx)
   14f44:	89 d0                	mov    %edx,%eax
   14f46:	8b 00                	mov    (%eax),%eax
   14f48:	89 07                	mov    %eax,(%edi)
   14f4a:	8b 07                	mov    (%edi),%eax
   14f4c:	89 06                	mov    %eax,(%esi)
   14f4e:	8b 06                	mov    (%esi),%eax
   14f50:	89 03                	mov    %eax,(%ebx)
   14f52:	8b 03                	mov    (%ebx),%eax
   14f54:	89 01                	mov    %eax,(%ecx)
   14f56:	8b 11                	mov    (%ecx),%edx
   14f58:	8b 45 08             	mov    0x8(%ebp),%eax
   14f5b:	89 10                	mov    %edx,(%eax)
        return;
   14f5d:	e9 b7 01 00 00       	jmp    15119 <_RowIDCT+0x285>
    }
    x0 = (blk[0] << 11) + 128;
   14f62:	8b 45 08             	mov    0x8(%ebp),%eax
   14f65:	8b 00                	mov    (%eax),%eax
   14f67:	c1 e0 0b             	shl    $0xb,%eax
   14f6a:	83 e8 80             	sub    $0xffffff80,%eax
   14f6d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    x8 = W7 * (x4 + x5);
   14f70:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   14f73:	8b 45 e0             	mov    -0x20(%ebp),%eax
   14f76:	01 d0                	add    %edx,%eax
   14f78:	69 c0 35 02 00 00    	imul   $0x235,%eax,%eax
   14f7e:	89 45 d0             	mov    %eax,-0x30(%ebp)
    x4 = x8 + (W1 - W7) * x4;
   14f81:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   14f84:	69 d0 e4 08 00 00    	imul   $0x8e4,%eax,%edx
   14f8a:	8b 45 d0             	mov    -0x30(%ebp),%eax
   14f8d:	01 d0                	add    %edx,%eax
   14f8f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    x5 = x8 - (W1 + W7) * x5;
   14f92:	8b 45 e0             	mov    -0x20(%ebp),%eax
   14f95:	69 d0 b2 f2 ff ff    	imul   $0xfffff2b2,%eax,%edx
   14f9b:	8b 45 d0             	mov    -0x30(%ebp),%eax
   14f9e:	01 d0                	add    %edx,%eax
   14fa0:	89 45 e0             	mov    %eax,-0x20(%ebp)
    x8 = W3 * (x6 + x7);
   14fa3:	8b 55 dc             	mov    -0x24(%ebp),%edx
   14fa6:	8b 45 d8             	mov    -0x28(%ebp),%eax
   14fa9:	01 d0                	add    %edx,%eax
   14fab:	69 c0 68 09 00 00    	imul   $0x968,%eax,%eax
   14fb1:	89 45 d0             	mov    %eax,-0x30(%ebp)
    x6 = x8 - (W3 - W5) * x6;
   14fb4:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14fb7:	69 d0 e1 fc ff ff    	imul   $0xfffffce1,%eax,%edx
   14fbd:	8b 45 d0             	mov    -0x30(%ebp),%eax
   14fc0:	01 d0                	add    %edx,%eax
   14fc2:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x7 = x8 - (W3 + W5) * x7;
   14fc5:	8b 45 d8             	mov    -0x28(%ebp),%eax
   14fc8:	69 d0 4f f0 ff ff    	imul   $0xfffff04f,%eax,%edx
   14fce:	8b 45 d0             	mov    -0x30(%ebp),%eax
   14fd1:	01 d0                	add    %edx,%eax
   14fd3:	89 45 d8             	mov    %eax,-0x28(%ebp)
    x8 = x0 + x1;
   14fd6:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   14fd9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14fdc:	01 d0                	add    %edx,%eax
   14fde:	89 45 d0             	mov    %eax,-0x30(%ebp)
    x0 -= x1;
   14fe1:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14fe4:	29 45 d4             	sub    %eax,-0x2c(%ebp)
    x1 = W6 * (x3 + x2);
   14fe7:	8b 55 e8             	mov    -0x18(%ebp),%edx
   14fea:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14fed:	01 d0                	add    %edx,%eax
   14fef:	69 c0 54 04 00 00    	imul   $0x454,%eax,%eax
   14ff5:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x2 = x1 - (W2 + W6) * x2;
   14ff8:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14ffb:	69 d0 38 f1 ff ff    	imul   $0xfffff138,%eax,%edx
   15001:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15004:	01 d0                	add    %edx,%eax
   15006:	89 45 ec             	mov    %eax,-0x14(%ebp)
    x3 = x1 + (W2 - W6) * x3;
   15009:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1500c:	69 d0 20 06 00 00    	imul   $0x620,%eax,%edx
   15012:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15015:	01 d0                	add    %edx,%eax
   15017:	89 45 e8             	mov    %eax,-0x18(%ebp)
    x1 = x4 + x6;
   1501a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   1501d:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15020:	01 d0                	add    %edx,%eax
   15022:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x4 -= x6;
   15025:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15028:	29 45 e4             	sub    %eax,-0x1c(%ebp)
    x6 = x5 + x7;
   1502b:	8b 55 e0             	mov    -0x20(%ebp),%edx
   1502e:	8b 45 d8             	mov    -0x28(%ebp),%eax
   15031:	01 d0                	add    %edx,%eax
   15033:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x5 -= x7;
   15036:	8b 45 d8             	mov    -0x28(%ebp),%eax
   15039:	29 45 e0             	sub    %eax,-0x20(%ebp)
    x7 = x8 + x3;
   1503c:	8b 55 d0             	mov    -0x30(%ebp),%edx
   1503f:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15042:	01 d0                	add    %edx,%eax
   15044:	89 45 d8             	mov    %eax,-0x28(%ebp)
    x8 -= x3;
   15047:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1504a:	29 45 d0             	sub    %eax,-0x30(%ebp)
    x3 = x0 + x2;
   1504d:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   15050:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15053:	01 d0                	add    %edx,%eax
   15055:	89 45 e8             	mov    %eax,-0x18(%ebp)
    x0 -= x2;
   15058:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1505b:	29 45 d4             	sub    %eax,-0x2c(%ebp)
    x2 = (181 * (x4 + x5) + 128) >> 8;
   1505e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   15061:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15064:	01 d0                	add    %edx,%eax
   15066:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   1506c:	83 e8 80             	sub    $0xffffff80,%eax
   1506f:	c1 f8 08             	sar    $0x8,%eax
   15072:	89 45 ec             	mov    %eax,-0x14(%ebp)
    x4 = (181 * (x4 - x5) + 128) >> 8;
   15075:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15078:	2b 45 e0             	sub    -0x20(%ebp),%eax
   1507b:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   15081:	83 e8 80             	sub    $0xffffff80,%eax
   15084:	c1 f8 08             	sar    $0x8,%eax
   15087:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    blk[0] = (x7 + x1) >> 8;
   1508a:	8b 55 d8             	mov    -0x28(%ebp),%edx
   1508d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15090:	01 d0                	add    %edx,%eax
   15092:	c1 f8 08             	sar    $0x8,%eax
   15095:	89 c2                	mov    %eax,%edx
   15097:	8b 45 08             	mov    0x8(%ebp),%eax
   1509a:	89 10                	mov    %edx,(%eax)
    blk[1] = (x3 + x2) >> 8;
   1509c:	8b 45 08             	mov    0x8(%ebp),%eax
   1509f:	83 c0 04             	add    $0x4,%eax
   150a2:	8b 4d e8             	mov    -0x18(%ebp),%ecx
   150a5:	8b 55 ec             	mov    -0x14(%ebp),%edx
   150a8:	01 ca                	add    %ecx,%edx
   150aa:	c1 fa 08             	sar    $0x8,%edx
   150ad:	89 10                	mov    %edx,(%eax)
    blk[2] = (x0 + x4) >> 8;
   150af:	8b 45 08             	mov    0x8(%ebp),%eax
   150b2:	83 c0 08             	add    $0x8,%eax
   150b5:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
   150b8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   150bb:	01 ca                	add    %ecx,%edx
   150bd:	c1 fa 08             	sar    $0x8,%edx
   150c0:	89 10                	mov    %edx,(%eax)
    blk[3] = (x8 + x6) >> 8;
   150c2:	8b 45 08             	mov    0x8(%ebp),%eax
   150c5:	83 c0 0c             	add    $0xc,%eax
   150c8:	8b 4d d0             	mov    -0x30(%ebp),%ecx
   150cb:	8b 55 dc             	mov    -0x24(%ebp),%edx
   150ce:	01 ca                	add    %ecx,%edx
   150d0:	c1 fa 08             	sar    $0x8,%edx
   150d3:	89 10                	mov    %edx,(%eax)
    blk[4] = (x8 - x6) >> 8;
   150d5:	8b 45 08             	mov    0x8(%ebp),%eax
   150d8:	8d 50 10             	lea    0x10(%eax),%edx
   150db:	8b 45 d0             	mov    -0x30(%ebp),%eax
   150de:	2b 45 dc             	sub    -0x24(%ebp),%eax
   150e1:	c1 f8 08             	sar    $0x8,%eax
   150e4:	89 02                	mov    %eax,(%edx)
    blk[5] = (x0 - x4) >> 8;
   150e6:	8b 45 08             	mov    0x8(%ebp),%eax
   150e9:	8d 50 14             	lea    0x14(%eax),%edx
   150ec:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   150ef:	2b 45 e4             	sub    -0x1c(%ebp),%eax
   150f2:	c1 f8 08             	sar    $0x8,%eax
   150f5:	89 02                	mov    %eax,(%edx)
    blk[6] = (x3 - x2) >> 8;
   150f7:	8b 45 08             	mov    0x8(%ebp),%eax
   150fa:	8d 50 18             	lea    0x18(%eax),%edx
   150fd:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15100:	2b 45 ec             	sub    -0x14(%ebp),%eax
   15103:	c1 f8 08             	sar    $0x8,%eax
   15106:	89 02                	mov    %eax,(%edx)
    blk[7] = (x7 - x1) >> 8;
   15108:	8b 45 08             	mov    0x8(%ebp),%eax
   1510b:	8d 50 1c             	lea    0x1c(%eax),%edx
   1510e:	8b 45 d8             	mov    -0x28(%ebp),%eax
   15111:	2b 45 f0             	sub    -0x10(%ebp),%eax
   15114:	c1 f8 08             	sar    $0x8,%eax
   15117:	89 02                	mov    %eax,(%edx)
}
   15119:	83 c4 38             	add    $0x38,%esp
   1511c:	5b                   	pop    %ebx
   1511d:	5e                   	pop    %esi
   1511e:	5f                   	pop    %edi
   1511f:	5d                   	pop    %ebp
   15120:	c3                   	ret    

00015121 <_ColIDCT>:

void _ColIDCT(const int* blk, uchar* out, int stride){
   15121:	55                   	push   %ebp
   15122:	89 e5                	mov    %esp,%ebp
   15124:	83 ec 30             	sub    $0x30,%esp
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[8 * 4] << 8)
   15127:	8b 45 08             	mov    0x8(%ebp),%eax
   1512a:	83 e8 80             	sub    $0xffffff80,%eax
   1512d:	8b 00                	mov    (%eax),%eax
   1512f:	c1 e0 08             	shl    $0x8,%eax
   15132:	89 45 f8             	mov    %eax,-0x8(%ebp)
        | (x2 = blk[8 * 6])
   15135:	8b 45 08             	mov    0x8(%ebp),%eax
   15138:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   1513e:	89 45 f4             	mov    %eax,-0xc(%ebp)
   15141:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15144:	0b 45 f4             	or     -0xc(%ebp),%eax
        | (x3 = blk[8 * 2])
   15147:	8b 55 08             	mov    0x8(%ebp),%edx
   1514a:	8b 52 40             	mov    0x40(%edx),%edx
   1514d:	89 55 f0             	mov    %edx,-0x10(%ebp)
   15150:	0b 45 f0             	or     -0x10(%ebp),%eax
        | (x4 = blk[8 * 1])
   15153:	8b 55 08             	mov    0x8(%ebp),%edx
   15156:	8b 52 20             	mov    0x20(%edx),%edx
   15159:	89 55 ec             	mov    %edx,-0x14(%ebp)
   1515c:	0b 45 ec             	or     -0x14(%ebp),%eax
        | (x5 = blk[8 * 7])
   1515f:	8b 55 08             	mov    0x8(%ebp),%edx
   15162:	8b 92 e0 00 00 00    	mov    0xe0(%edx),%edx
   15168:	89 55 e8             	mov    %edx,-0x18(%ebp)
   1516b:	0b 45 e8             	or     -0x18(%ebp),%eax
        | (x6 = blk[8 * 5])
   1516e:	8b 55 08             	mov    0x8(%ebp),%edx
   15171:	8b 92 a0 00 00 00    	mov    0xa0(%edx),%edx
   15177:	89 55 e4             	mov    %edx,-0x1c(%ebp)
   1517a:	0b 45 e4             	or     -0x1c(%ebp),%eax
        | (x7 = blk[8 * 3])))
   1517d:	8b 55 08             	mov    0x8(%ebp),%edx
   15180:	8b 52 60             	mov    0x60(%edx),%edx
   15183:	89 55 e0             	mov    %edx,-0x20(%ebp)
   15186:	0b 45 e0             	or     -0x20(%ebp),%eax
    blk[7] = (x7 - x1) >> 8;
}

void _ColIDCT(const int* blk, uchar* out, int stride){
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[8 * 4] << 8)
   15189:	85 c0                	test   %eax,%eax
   1518b:	75 45                	jne    151d2 <_ColIDCT+0xb1>
        | (x4 = blk[8 * 1])
        | (x5 = blk[8 * 7])
        | (x6 = blk[8 * 5])
        | (x7 = blk[8 * 3])))
    {
        x1 = _Clip(((blk[0] + 32) >> 6) + 128);
   1518d:	8b 45 08             	mov    0x8(%ebp),%eax
   15190:	8b 00                	mov    (%eax),%eax
   15192:	83 c0 20             	add    $0x20,%eax
   15195:	c1 f8 06             	sar    $0x6,%eax
   15198:	83 e8 80             	sub    $0xffffff80,%eax
   1519b:	50                   	push   %eax
   1519c:	e8 d6 ea ff ff       	call   13c77 <_Clip>
   151a1:	83 c4 04             	add    $0x4,%esp
   151a4:	0f b6 c0             	movzbl %al,%eax
   151a7:	89 45 f8             	mov    %eax,-0x8(%ebp)
        for (x0 = 8; x0; --x0) {
   151aa:	c7 45 fc 08 00 00 00 	movl   $0x8,-0x4(%ebp)
   151b1:	eb 14                	jmp    151c7 <_ColIDCT+0xa6>
            *out = (unsigned char)x1;
   151b3:	8b 45 f8             	mov    -0x8(%ebp),%eax
   151b6:	89 c2                	mov    %eax,%edx
   151b8:	8b 45 0c             	mov    0xc(%ebp),%eax
   151bb:	88 10                	mov    %dl,(%eax)
            out += stride;
   151bd:	8b 45 10             	mov    0x10(%ebp),%eax
   151c0:	01 45 0c             	add    %eax,0xc(%ebp)
        | (x5 = blk[8 * 7])
        | (x6 = blk[8 * 5])
        | (x7 = blk[8 * 3])))
    {
        x1 = _Clip(((blk[0] + 32) >> 6) + 128);
        for (x0 = 8; x0; --x0) {
   151c3:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
   151c7:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   151cb:	75 e6                	jne    151b3 <_ColIDCT+0x92>
            *out = (unsigned char)x1;
            out += stride;
        }
        return;
   151cd:	e9 57 02 00 00       	jmp    15429 <_ColIDCT+0x308>
    }
    x0 = (blk[0] << 8) + 8192;
   151d2:	8b 45 08             	mov    0x8(%ebp),%eax
   151d5:	8b 00                	mov    (%eax),%eax
   151d7:	c1 e0 08             	shl    $0x8,%eax
   151da:	05 00 20 00 00       	add    $0x2000,%eax
   151df:	89 45 fc             	mov    %eax,-0x4(%ebp)
    x8 = W7 * (x4 + x5) + 4;
   151e2:	8b 55 ec             	mov    -0x14(%ebp),%edx
   151e5:	8b 45 e8             	mov    -0x18(%ebp),%eax
   151e8:	01 d0                	add    %edx,%eax
   151ea:	69 c0 35 02 00 00    	imul   $0x235,%eax,%eax
   151f0:	83 c0 04             	add    $0x4,%eax
   151f3:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x4 = (x8 + (W1 - W7) * x4) >> 3;
   151f6:	8b 45 ec             	mov    -0x14(%ebp),%eax
   151f9:	69 d0 e4 08 00 00    	imul   $0x8e4,%eax,%edx
   151ff:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15202:	01 d0                	add    %edx,%eax
   15204:	c1 f8 03             	sar    $0x3,%eax
   15207:	89 45 ec             	mov    %eax,-0x14(%ebp)
    x5 = (x8 - (W1 + W7) * x5) >> 3;
   1520a:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1520d:	69 d0 b2 f2 ff ff    	imul   $0xfffff2b2,%eax,%edx
   15213:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15216:	01 d0                	add    %edx,%eax
   15218:	c1 f8 03             	sar    $0x3,%eax
   1521b:	89 45 e8             	mov    %eax,-0x18(%ebp)
    x8 = W3 * (x6 + x7) + 4;
   1521e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   15221:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15224:	01 d0                	add    %edx,%eax
   15226:	69 c0 68 09 00 00    	imul   $0x968,%eax,%eax
   1522c:	83 c0 04             	add    $0x4,%eax
   1522f:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x6 = (x8 - (W3 - W5) * x6) >> 3;
   15232:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15235:	69 d0 e1 fc ff ff    	imul   $0xfffffce1,%eax,%edx
   1523b:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1523e:	01 d0                	add    %edx,%eax
   15240:	c1 f8 03             	sar    $0x3,%eax
   15243:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    x7 = (x8 - (W3 + W5) * x7) >> 3;
   15246:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15249:	69 d0 4f f0 ff ff    	imul   $0xfffff04f,%eax,%edx
   1524f:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15252:	01 d0                	add    %edx,%eax
   15254:	c1 f8 03             	sar    $0x3,%eax
   15257:	89 45 e0             	mov    %eax,-0x20(%ebp)
    x8 = x0 + x1;
   1525a:	8b 55 fc             	mov    -0x4(%ebp),%edx
   1525d:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15260:	01 d0                	add    %edx,%eax
   15262:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x0 -= x1;
   15265:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15268:	29 45 fc             	sub    %eax,-0x4(%ebp)
    x1 = W6 * (x3 + x2) + 4;
   1526b:	8b 55 f0             	mov    -0x10(%ebp),%edx
   1526e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15271:	01 d0                	add    %edx,%eax
   15273:	69 c0 54 04 00 00    	imul   $0x454,%eax,%eax
   15279:	83 c0 04             	add    $0x4,%eax
   1527c:	89 45 f8             	mov    %eax,-0x8(%ebp)
    x2 = (x1 - (W2 + W6) * x2) >> 3;
   1527f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15282:	69 d0 38 f1 ff ff    	imul   $0xfffff138,%eax,%edx
   15288:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1528b:	01 d0                	add    %edx,%eax
   1528d:	c1 f8 03             	sar    $0x3,%eax
   15290:	89 45 f4             	mov    %eax,-0xc(%ebp)
    x3 = (x1 + (W2 - W6) * x3) >> 3;
   15293:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15296:	69 d0 20 06 00 00    	imul   $0x620,%eax,%edx
   1529c:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1529f:	01 d0                	add    %edx,%eax
   152a1:	c1 f8 03             	sar    $0x3,%eax
   152a4:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x1 = x4 + x6;
   152a7:	8b 55 ec             	mov    -0x14(%ebp),%edx
   152aa:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   152ad:	01 d0                	add    %edx,%eax
   152af:	89 45 f8             	mov    %eax,-0x8(%ebp)
    x4 -= x6;
   152b2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   152b5:	29 45 ec             	sub    %eax,-0x14(%ebp)
    x6 = x5 + x7;
   152b8:	8b 55 e8             	mov    -0x18(%ebp),%edx
   152bb:	8b 45 e0             	mov    -0x20(%ebp),%eax
   152be:	01 d0                	add    %edx,%eax
   152c0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    x5 -= x7;
   152c3:	8b 45 e0             	mov    -0x20(%ebp),%eax
   152c6:	29 45 e8             	sub    %eax,-0x18(%ebp)
    x7 = x8 + x3;
   152c9:	8b 55 dc             	mov    -0x24(%ebp),%edx
   152cc:	8b 45 f0             	mov    -0x10(%ebp),%eax
   152cf:	01 d0                	add    %edx,%eax
   152d1:	89 45 e0             	mov    %eax,-0x20(%ebp)
    x8 -= x3;
   152d4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   152d7:	29 45 dc             	sub    %eax,-0x24(%ebp)
    x3 = x0 + x2;
   152da:	8b 55 fc             	mov    -0x4(%ebp),%edx
   152dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
   152e0:	01 d0                	add    %edx,%eax
   152e2:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x0 -= x2;
   152e5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   152e8:	29 45 fc             	sub    %eax,-0x4(%ebp)
    x2 = (181 * (x4 + x5) + 128) >> 8;
   152eb:	8b 55 ec             	mov    -0x14(%ebp),%edx
   152ee:	8b 45 e8             	mov    -0x18(%ebp),%eax
   152f1:	01 d0                	add    %edx,%eax
   152f3:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   152f9:	83 e8 80             	sub    $0xffffff80,%eax
   152fc:	c1 f8 08             	sar    $0x8,%eax
   152ff:	89 45 f4             	mov    %eax,-0xc(%ebp)
    x4 = (181 * (x4 - x5) + 128) >> 8;
   15302:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15305:	2b 45 e8             	sub    -0x18(%ebp),%eax
   15308:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   1530e:	83 e8 80             	sub    $0xffffff80,%eax
   15311:	c1 f8 08             	sar    $0x8,%eax
   15314:	89 45 ec             	mov    %eax,-0x14(%ebp)
    *out = _Clip(((x7 + x1) >> 14) + 128);  out += stride;
   15317:	8b 55 e0             	mov    -0x20(%ebp),%edx
   1531a:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1531d:	01 d0                	add    %edx,%eax
   1531f:	c1 f8 0e             	sar    $0xe,%eax
   15322:	83 e8 80             	sub    $0xffffff80,%eax
   15325:	50                   	push   %eax
   15326:	e8 4c e9 ff ff       	call   13c77 <_Clip>
   1532b:	83 c4 04             	add    $0x4,%esp
   1532e:	89 c2                	mov    %eax,%edx
   15330:	8b 45 0c             	mov    0xc(%ebp),%eax
   15333:	88 10                	mov    %dl,(%eax)
   15335:	8b 45 10             	mov    0x10(%ebp),%eax
   15338:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x3 + x2) >> 14) + 128);  out += stride;
   1533b:	8b 55 f0             	mov    -0x10(%ebp),%edx
   1533e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15341:	01 d0                	add    %edx,%eax
   15343:	c1 f8 0e             	sar    $0xe,%eax
   15346:	83 e8 80             	sub    $0xffffff80,%eax
   15349:	50                   	push   %eax
   1534a:	e8 28 e9 ff ff       	call   13c77 <_Clip>
   1534f:	83 c4 04             	add    $0x4,%esp
   15352:	89 c2                	mov    %eax,%edx
   15354:	8b 45 0c             	mov    0xc(%ebp),%eax
   15357:	88 10                	mov    %dl,(%eax)
   15359:	8b 45 10             	mov    0x10(%ebp),%eax
   1535c:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x0 + x4) >> 14) + 128);  out += stride;
   1535f:	8b 55 fc             	mov    -0x4(%ebp),%edx
   15362:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15365:	01 d0                	add    %edx,%eax
   15367:	c1 f8 0e             	sar    $0xe,%eax
   1536a:	83 e8 80             	sub    $0xffffff80,%eax
   1536d:	50                   	push   %eax
   1536e:	e8 04 e9 ff ff       	call   13c77 <_Clip>
   15373:	83 c4 04             	add    $0x4,%esp
   15376:	89 c2                	mov    %eax,%edx
   15378:	8b 45 0c             	mov    0xc(%ebp),%eax
   1537b:	88 10                	mov    %dl,(%eax)
   1537d:	8b 45 10             	mov    0x10(%ebp),%eax
   15380:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x8 + x6) >> 14) + 128);  out += stride;
   15383:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15386:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15389:	01 d0                	add    %edx,%eax
   1538b:	c1 f8 0e             	sar    $0xe,%eax
   1538e:	83 e8 80             	sub    $0xffffff80,%eax
   15391:	50                   	push   %eax
   15392:	e8 e0 e8 ff ff       	call   13c77 <_Clip>
   15397:	83 c4 04             	add    $0x4,%esp
   1539a:	89 c2                	mov    %eax,%edx
   1539c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1539f:	88 10                	mov    %dl,(%eax)
   153a1:	8b 45 10             	mov    0x10(%ebp),%eax
   153a4:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x8 - x6) >> 14) + 128);  out += stride;
   153a7:	8b 45 dc             	mov    -0x24(%ebp),%eax
   153aa:	2b 45 e4             	sub    -0x1c(%ebp),%eax
   153ad:	c1 f8 0e             	sar    $0xe,%eax
   153b0:	83 e8 80             	sub    $0xffffff80,%eax
   153b3:	50                   	push   %eax
   153b4:	e8 be e8 ff ff       	call   13c77 <_Clip>
   153b9:	83 c4 04             	add    $0x4,%esp
   153bc:	89 c2                	mov    %eax,%edx
   153be:	8b 45 0c             	mov    0xc(%ebp),%eax
   153c1:	88 10                	mov    %dl,(%eax)
   153c3:	8b 45 10             	mov    0x10(%ebp),%eax
   153c6:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x0 - x4) >> 14) + 128);  out += stride;
   153c9:	8b 45 fc             	mov    -0x4(%ebp),%eax
   153cc:	2b 45 ec             	sub    -0x14(%ebp),%eax
   153cf:	c1 f8 0e             	sar    $0xe,%eax
   153d2:	83 e8 80             	sub    $0xffffff80,%eax
   153d5:	50                   	push   %eax
   153d6:	e8 9c e8 ff ff       	call   13c77 <_Clip>
   153db:	83 c4 04             	add    $0x4,%esp
   153de:	89 c2                	mov    %eax,%edx
   153e0:	8b 45 0c             	mov    0xc(%ebp),%eax
   153e3:	88 10                	mov    %dl,(%eax)
   153e5:	8b 45 10             	mov    0x10(%ebp),%eax
   153e8:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x3 - x2) >> 14) + 128);  out += stride;
   153eb:	8b 45 f0             	mov    -0x10(%ebp),%eax
   153ee:	2b 45 f4             	sub    -0xc(%ebp),%eax
   153f1:	c1 f8 0e             	sar    $0xe,%eax
   153f4:	83 e8 80             	sub    $0xffffff80,%eax
   153f7:	50                   	push   %eax
   153f8:	e8 7a e8 ff ff       	call   13c77 <_Clip>
   153fd:	83 c4 04             	add    $0x4,%esp
   15400:	89 c2                	mov    %eax,%edx
   15402:	8b 45 0c             	mov    0xc(%ebp),%eax
   15405:	88 10                	mov    %dl,(%eax)
   15407:	8b 45 10             	mov    0x10(%ebp),%eax
   1540a:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x7 - x1) >> 14) + 128);
   1540d:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15410:	2b 45 f8             	sub    -0x8(%ebp),%eax
   15413:	c1 f8 0e             	sar    $0xe,%eax
   15416:	83 e8 80             	sub    $0xffffff80,%eax
   15419:	50                   	push   %eax
   1541a:	e8 58 e8 ff ff       	call   13c77 <_Clip>
   1541f:	83 c4 04             	add    $0x4,%esp
   15422:	89 c2                	mov    %eax,%edx
   15424:	8b 45 0c             	mov    0xc(%ebp),%eax
   15427:	88 10                	mov    %dl,(%eax)
}
   15429:	c9                   	leave  
   1542a:	c3                   	ret    

0001542b <_ByteAlign>:

void _ByteAlign(Context* ctx){
   1542b:	55                   	push   %ebp
   1542c:	89 e5                	mov    %esp,%ebp
    ctx->bufferBits &= 0xF8;
   1542e:	8b 45 08             	mov    0x8(%ebp),%eax
   15431:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   15437:	25 f8 00 00 00       	and    $0xf8,%eax
   1543c:	89 c2                	mov    %eax,%edx
   1543e:	8b 45 08             	mov    0x8(%ebp),%eax
   15441:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
}
   15447:	90                   	nop
   15448:	5d                   	pop    %ebp
   15449:	c3                   	ret    

0001544a <_SkipMarker>:

void _SkipMarker(Context* ctx){
   1544a:	55                   	push   %ebp
   1544b:	89 e5                	mov    %esp,%ebp
   1544d:	83 ec 08             	sub    $0x8,%esp
    _DecodeLength(ctx);
   15450:	83 ec 0c             	sub    $0xc,%esp
   15453:	ff 75 08             	pushl  0x8(%ebp)
   15456:	e8 8d e8 ff ff       	call   13ce8 <_DecodeLength>
   1545b:	83 c4 10             	add    $0x10,%esp
    _Skip(ctx, ctx->length);
   1545e:	8b 45 08             	mov    0x8(%ebp),%eax
   15461:	8b 40 0c             	mov    0xc(%eax),%eax
   15464:	83 ec 08             	sub    $0x8,%esp
   15467:	50                   	push   %eax
   15468:	ff 75 08             	pushl  0x8(%ebp)
   1546b:	e8 2c e8 ff ff       	call   13c9c <_Skip>
   15470:	83 c4 10             	add    $0x10,%esp
}
   15473:	90                   	nop
   15474:	c9                   	leave  
   15475:	c3                   	ret    

00015476 <_Convert>:

void _Convert(Context* ctx){
   15476:	55                   	push   %ebp
   15477:	89 e5                	mov    %esp,%ebp
   15479:	57                   	push   %edi
   1547a:	56                   	push   %esi
   1547b:	53                   	push   %ebx
   1547c:	83 ec 4c             	sub    $0x4c,%esp
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   1547f:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   15486:	8b 45 08             	mov    0x8(%ebp),%eax
   15489:	83 c0 2c             	add    $0x2c,%eax
   1548c:	89 45 e0             	mov    %eax,-0x20(%ebp)
   1548f:	e9 b2 00 00 00       	jmp    15546 <_Convert+0xd0>
        while((c->width < ctx->width) || (c->height < ctx->height)){
            if(c->width < ctx->width) _UpsampleH(ctx, c);
   15494:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15497:	8b 50 0c             	mov    0xc(%eax),%edx
   1549a:	8b 45 08             	mov    0x8(%ebp),%eax
   1549d:	8b 40 10             	mov    0x10(%eax),%eax
   154a0:	39 c2                	cmp    %eax,%edx
   154a2:	7d 11                	jge    154b5 <_Convert+0x3f>
   154a4:	83 ec 08             	sub    $0x8,%esp
   154a7:	ff 75 e0             	pushl  -0x20(%ebp)
   154aa:	ff 75 08             	pushl  0x8(%ebp)
   154ad:	e8 79 02 00 00       	call   1572b <_UpsampleH>
   154b2:	83 c4 10             	add    $0x10,%esp
            if(ctx->result) return;
   154b5:	8b 45 08             	mov    0x8(%ebp),%eax
   154b8:	8b 00                	mov    (%eax),%eax
   154ba:	85 c0                	test   %eax,%eax
   154bc:	0f 85 5d 02 00 00    	jne    1571f <_Convert+0x2a9>
            if(c->height < ctx->height) _UpsampleV(ctx, c);
   154c2:	8b 45 e0             	mov    -0x20(%ebp),%eax
   154c5:	8b 50 10             	mov    0x10(%eax),%edx
   154c8:	8b 45 08             	mov    0x8(%ebp),%eax
   154cb:	8b 40 14             	mov    0x14(%eax),%eax
   154ce:	39 c2                	cmp    %eax,%edx
   154d0:	7d 11                	jge    154e3 <_Convert+0x6d>
   154d2:	83 ec 08             	sub    $0x8,%esp
   154d5:	ff 75 e0             	pushl  -0x20(%ebp)
   154d8:	ff 75 08             	pushl  0x8(%ebp)
   154db:	e8 db 05 00 00       	call   15abb <_UpsampleV>
   154e0:	83 c4 10             	add    $0x10,%esp
            if(ctx->result) return;
   154e3:	8b 45 08             	mov    0x8(%ebp),%eax
   154e6:	8b 00                	mov    (%eax),%eax
   154e8:	85 c0                	test   %eax,%eax
   154ea:	0f 85 32 02 00 00    	jne    15722 <_Convert+0x2ac>

void _Convert(Context* ctx){
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
        while((c->width < ctx->width) || (c->height < ctx->height)){
   154f0:	8b 45 e0             	mov    -0x20(%ebp),%eax
   154f3:	8b 50 0c             	mov    0xc(%eax),%edx
   154f6:	8b 45 08             	mov    0x8(%ebp),%eax
   154f9:	8b 40 10             	mov    0x10(%eax),%eax
   154fc:	39 c2                	cmp    %eax,%edx
   154fe:	7c 94                	jl     15494 <_Convert+0x1e>
   15500:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15503:	8b 50 10             	mov    0x10(%eax),%edx
   15506:	8b 45 08             	mov    0x8(%ebp),%eax
   15509:	8b 40 14             	mov    0x14(%eax),%eax
   1550c:	39 c2                	cmp    %eax,%edx
   1550e:	7c 84                	jl     15494 <_Convert+0x1e>
            if(c->width < ctx->width) _UpsampleH(ctx, c);
            if(ctx->result) return;
            if(c->height < ctx->height) _UpsampleV(ctx, c);
            if(ctx->result) return;
        }
        if((c->width < ctx->width) || (c->height < ctx->height)) ERROR_RETURN(InternalError);
   15510:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15513:	8b 50 0c             	mov    0xc(%eax),%edx
   15516:	8b 45 08             	mov    0x8(%ebp),%eax
   15519:	8b 40 10             	mov    0x10(%eax),%eax
   1551c:	39 c2                	cmp    %eax,%edx
   1551e:	7c 10                	jl     15530 <_Convert+0xba>
   15520:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15523:	8b 50 10             	mov    0x10(%eax),%edx
   15526:	8b 45 08             	mov    0x8(%ebp),%eax
   15529:	8b 40 14             	mov    0x14(%eax),%eax
   1552c:	39 c2                	cmp    %eax,%edx
   1552e:	7d 0e                	jge    1553e <_Convert+0xc8>
   15530:	8b 45 08             	mov    0x8(%ebp),%eax
   15533:	c7 00 04 00 00 00    	movl   $0x4,(%eax)
   15539:	e9 e5 01 00 00       	jmp    15723 <_Convert+0x2ad>
}

void _Convert(Context* ctx){
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   1553e:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   15542:	83 45 e0 2c          	addl   $0x2c,-0x20(%ebp)
   15546:	8b 45 08             	mov    0x8(%ebp),%eax
   15549:	8b 40 28             	mov    0x28(%eax),%eax
   1554c:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   1554f:	7f 9f                	jg     154f0 <_Convert+0x7a>
            if(c->height < ctx->height) _UpsampleV(ctx, c);
            if(ctx->result) return;
        }
        if((c->width < ctx->width) || (c->height < ctx->height)) ERROR_RETURN(InternalError);
    }
    if(ctx->compNum == 3){
   15551:	8b 45 08             	mov    0x8(%ebp),%eax
   15554:	8b 40 28             	mov    0x28(%eax),%eax
   15557:	83 f8 03             	cmp    $0x3,%eax
   1555a:	0f 85 3d 01 00 00    	jne    1569d <_Convert+0x227>
        // convert to RGB
        int x, yy;
        uchar *prgb = ctx->rgb;
   15560:	8b 45 08             	mov    0x8(%ebp),%eax
   15563:	8b 80 c4 02 08 00    	mov    0x802c4(%eax),%eax
   15569:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        const uchar *py = ctx->comp[0].pixels;
   1556c:	8b 45 08             	mov    0x8(%ebp),%eax
   1556f:	8b 40 54             	mov    0x54(%eax),%eax
   15572:	89 45 d0             	mov    %eax,-0x30(%ebp)
        const uchar *pcb = ctx->comp[1].pixels;
   15575:	8b 45 08             	mov    0x8(%ebp),%eax
   15578:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
   1557e:	89 45 cc             	mov    %eax,-0x34(%ebp)
        const uchar *pcr = ctx->comp[2].pixels;
   15581:	8b 45 08             	mov    0x8(%ebp),%eax
   15584:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   1558a:	89 45 c8             	mov    %eax,-0x38(%ebp)
        for(yy=ctx->height; yy; --yy){
   1558d:	8b 45 08             	mov    0x8(%ebp),%eax
   15590:	8b 40 14             	mov    0x14(%eax),%eax
   15593:	89 45 d8             	mov    %eax,-0x28(%ebp)
   15596:	e9 f3 00 00 00       	jmp    1568e <_Convert+0x218>
            for(x=0; x<ctx->width; ++x){
   1559b:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
   155a2:	e9 b6 00 00 00       	jmp    1565d <_Convert+0x1e7>
                register int y = py[x] << 8;
   155a7:	8b 55 dc             	mov    -0x24(%ebp),%edx
   155aa:	8b 45 d0             	mov    -0x30(%ebp),%eax
   155ad:	01 d0                	add    %edx,%eax
   155af:	0f b6 00             	movzbl (%eax),%eax
   155b2:	0f b6 c0             	movzbl %al,%eax
   155b5:	c1 e0 08             	shl    $0x8,%eax
   155b8:	89 c3                	mov    %eax,%ebx
                register int cb = pcb[x] - 128;
   155ba:	8b 55 dc             	mov    -0x24(%ebp),%edx
   155bd:	8b 45 cc             	mov    -0x34(%ebp),%eax
   155c0:	01 d0                	add    %edx,%eax
   155c2:	0f b6 00             	movzbl (%eax),%eax
   155c5:	0f b6 c0             	movzbl %al,%eax
   155c8:	8d 78 80             	lea    -0x80(%eax),%edi
                register int cr = pcr[x] - 128;
   155cb:	8b 55 dc             	mov    -0x24(%ebp),%edx
   155ce:	8b 45 c8             	mov    -0x38(%ebp),%eax
   155d1:	01 d0                	add    %edx,%eax
   155d3:	0f b6 00             	movzbl (%eax),%eax
   155d6:	0f b6 c0             	movzbl %al,%eax
   155d9:	83 c0 80             	add    $0xffffff80,%eax
   155dc:	89 c1                	mov    %eax,%ecx
                *prgb++ = _Clip((y + 359 * cr + 128) >> 8);
   155de:	8b 75 d4             	mov    -0x2c(%ebp),%esi
   155e1:	8d 46 01             	lea    0x1(%esi),%eax
   155e4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   155e7:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
   155ea:	89 c8                	mov    %ecx,%eax
   155ec:	69 c0 67 01 00 00    	imul   $0x167,%eax,%eax
   155f2:	01 d8                	add    %ebx,%eax
   155f4:	83 e8 80             	sub    $0xffffff80,%eax
   155f7:	c1 f8 08             	sar    $0x8,%eax
   155fa:	83 ec 0c             	sub    $0xc,%esp
   155fd:	50                   	push   %eax
   155fe:	e8 74 e6 ff ff       	call   13c77 <_Clip>
   15603:	83 c4 10             	add    $0x10,%esp
   15606:	88 06                	mov    %al,(%esi)
                *prgb++ = _Clip((y - 88 * cb - 183 * cr + 128) >> 8);
   15608:	8b 75 d4             	mov    -0x2c(%ebp),%esi
   1560b:	8d 46 01             	lea    0x1(%esi),%eax
   1560e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   15611:	6b c7 a8             	imul   $0xffffffa8,%edi,%eax
   15614:	8d 14 18             	lea    (%eax,%ebx,1),%edx
   15617:	69 45 b4 49 ff ff ff 	imul   $0xffffff49,-0x4c(%ebp),%eax
   1561e:	01 d0                	add    %edx,%eax
   15620:	83 e8 80             	sub    $0xffffff80,%eax
   15623:	c1 f8 08             	sar    $0x8,%eax
   15626:	83 ec 0c             	sub    $0xc,%esp
   15629:	50                   	push   %eax
   1562a:	e8 48 e6 ff ff       	call   13c77 <_Clip>
   1562f:	83 c4 10             	add    $0x10,%esp
   15632:	88 06                	mov    %al,(%esi)
                *prgb++ = _Clip((y + 454 * cb + 128) >> 8);
   15634:	8b 75 d4             	mov    -0x2c(%ebp),%esi
   15637:	8d 46 01             	lea    0x1(%esi),%eax
   1563a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   1563d:	69 c7 c6 01 00 00    	imul   $0x1c6,%edi,%eax
   15643:	01 d8                	add    %ebx,%eax
   15645:	83 e8 80             	sub    $0xffffff80,%eax
   15648:	c1 f8 08             	sar    $0x8,%eax
   1564b:	83 ec 0c             	sub    $0xc,%esp
   1564e:	50                   	push   %eax
   1564f:	e8 23 e6 ff ff       	call   13c77 <_Clip>
   15654:	83 c4 10             	add    $0x10,%esp
   15657:	88 06                	mov    %al,(%esi)
        uchar *prgb = ctx->rgb;
        const uchar *py = ctx->comp[0].pixels;
        const uchar *pcb = ctx->comp[1].pixels;
        const uchar *pcr = ctx->comp[2].pixels;
        for(yy=ctx->height; yy; --yy){
            for(x=0; x<ctx->width; ++x){
   15659:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
   1565d:	8b 45 08             	mov    0x8(%ebp),%eax
   15660:	8b 40 10             	mov    0x10(%eax),%eax
   15663:	3b 45 dc             	cmp    -0x24(%ebp),%eax
   15666:	0f 8f 3b ff ff ff    	jg     155a7 <_Convert+0x131>
                register int cr = pcr[x] - 128;
                *prgb++ = _Clip((y + 359 * cr + 128) >> 8);
                *prgb++ = _Clip((y - 88 * cb - 183 * cr + 128) >> 8);
                *prgb++ = _Clip((y + 454 * cb + 128) >> 8);
            }
            py += ctx->comp[0].stride;
   1566c:	8b 45 08             	mov    0x8(%ebp),%eax
   1566f:	8b 40 40             	mov    0x40(%eax),%eax
   15672:	01 45 d0             	add    %eax,-0x30(%ebp)
            pcb += ctx->comp[1].stride;
   15675:	8b 45 08             	mov    0x8(%ebp),%eax
   15678:	8b 40 6c             	mov    0x6c(%eax),%eax
   1567b:	01 45 cc             	add    %eax,-0x34(%ebp)
            pcr += ctx->comp[2].stride;
   1567e:	8b 45 08             	mov    0x8(%ebp),%eax
   15681:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
   15687:	01 45 c8             	add    %eax,-0x38(%ebp)
        int x, yy;
        uchar *prgb = ctx->rgb;
        const uchar *py = ctx->comp[0].pixels;
        const uchar *pcb = ctx->comp[1].pixels;
        const uchar *pcr = ctx->comp[2].pixels;
        for(yy=ctx->height; yy; --yy){
   1568a:	83 6d d8 01          	subl   $0x1,-0x28(%ebp)
   1568e:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   15692:	0f 85 03 ff ff ff    	jne    1559b <_Convert+0x125>
   15698:	e9 86 00 00 00       	jmp    15723 <_Convert+0x2ad>
            py += ctx->comp[0].stride;
            pcb += ctx->comp[1].stride;
            pcr += ctx->comp[2].stride;
        }
    }
    else if(ctx->comp[0].width != ctx->comp[0].stride){
   1569d:	8b 45 08             	mov    0x8(%ebp),%eax
   156a0:	8b 50 38             	mov    0x38(%eax),%edx
   156a3:	8b 45 08             	mov    0x8(%ebp),%eax
   156a6:	8b 40 40             	mov    0x40(%eax),%eax
   156a9:	39 c2                	cmp    %eax,%edx
   156ab:	74 76                	je     15723 <_Convert+0x2ad>
        // grayscale -> only remove stride
        uchar *pin = &ctx->comp[0].pixels[ctx->comp[0].stride];
   156ad:	8b 45 08             	mov    0x8(%ebp),%eax
   156b0:	8b 50 54             	mov    0x54(%eax),%edx
   156b3:	8b 45 08             	mov    0x8(%ebp),%eax
   156b6:	8b 40 40             	mov    0x40(%eax),%eax
   156b9:	01 d0                	add    %edx,%eax
   156bb:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        uchar *pout = &ctx->comp[0].pixels[ctx->comp[0].width];
   156be:	8b 45 08             	mov    0x8(%ebp),%eax
   156c1:	8b 50 54             	mov    0x54(%eax),%edx
   156c4:	8b 45 08             	mov    0x8(%ebp),%eax
   156c7:	8b 40 38             	mov    0x38(%eax),%eax
   156ca:	01 d0                	add    %edx,%eax
   156cc:	89 45 c0             	mov    %eax,-0x40(%ebp)
        int y;
        for(y = ctx->comp[0].height - 1; y; --y){
   156cf:	8b 45 08             	mov    0x8(%ebp),%eax
   156d2:	8b 40 3c             	mov    0x3c(%eax),%eax
   156d5:	83 e8 01             	sub    $0x1,%eax
   156d8:	89 45 bc             	mov    %eax,-0x44(%ebp)
   156db:	eb 2e                	jmp    1570b <_Convert+0x295>
            memmove(pout, pin, ctx->comp[0].width);
   156dd:	8b 45 08             	mov    0x8(%ebp),%eax
   156e0:	8b 40 38             	mov    0x38(%eax),%eax
   156e3:	83 ec 04             	sub    $0x4,%esp
   156e6:	50                   	push   %eax
   156e7:	ff 75 c4             	pushl  -0x3c(%ebp)
   156ea:	ff 75 c0             	pushl  -0x40(%ebp)
   156ed:	e8 72 ac fe ff       	call   364 <memmove>
   156f2:	83 c4 10             	add    $0x10,%esp
            pin += ctx->comp[0].stride;
   156f5:	8b 45 08             	mov    0x8(%ebp),%eax
   156f8:	8b 40 40             	mov    0x40(%eax),%eax
   156fb:	01 45 c4             	add    %eax,-0x3c(%ebp)
            pout += ctx->comp[0].width;
   156fe:	8b 45 08             	mov    0x8(%ebp),%eax
   15701:	8b 40 38             	mov    0x38(%eax),%eax
   15704:	01 45 c0             	add    %eax,-0x40(%ebp)
    else if(ctx->comp[0].width != ctx->comp[0].stride){
        // grayscale -> only remove stride
        uchar *pin = &ctx->comp[0].pixels[ctx->comp[0].stride];
        uchar *pout = &ctx->comp[0].pixels[ctx->comp[0].width];
        int y;
        for(y = ctx->comp[0].height - 1; y; --y){
   15707:	83 6d bc 01          	subl   $0x1,-0x44(%ebp)
   1570b:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
   1570f:	75 cc                	jne    156dd <_Convert+0x267>
            memmove(pout, pin, ctx->comp[0].width);
            pin += ctx->comp[0].stride;
            pout += ctx->comp[0].width;
        }
        ctx->comp[0].stride = ctx->comp[0].width;
   15711:	8b 45 08             	mov    0x8(%ebp),%eax
   15714:	8b 50 38             	mov    0x38(%eax),%edx
   15717:	8b 45 08             	mov    0x8(%ebp),%eax
   1571a:	89 50 40             	mov    %edx,0x40(%eax)
   1571d:	eb 04                	jmp    15723 <_Convert+0x2ad>
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
        while((c->width < ctx->width) || (c->height < ctx->height)){
            if(c->width < ctx->width) _UpsampleH(ctx, c);
            if(ctx->result) return;
   1571f:	90                   	nop
   15720:	eb 01                	jmp    15723 <_Convert+0x2ad>
            if(c->height < ctx->height) _UpsampleV(ctx, c);
            if(ctx->result) return;
   15722:	90                   	nop
            pin += ctx->comp[0].stride;
            pout += ctx->comp[0].width;
        }
        ctx->comp[0].stride = ctx->comp[0].width;
    }
}
   15723:	8d 65 f4             	lea    -0xc(%ebp),%esp
   15726:	5b                   	pop    %ebx
   15727:	5e                   	pop    %esi
   15728:	5f                   	pop    %edi
   15729:	5d                   	pop    %ebp
   1572a:	c3                   	ret    

0001572b <_UpsampleH>:
    CF3Z = (-3),
    CF2A = (139),
    CF2B = (-11),
};

void _UpsampleH(Context* ctx, Component* c){
   1572b:	55                   	push   %ebp
   1572c:	89 e5                	mov    %esp,%ebp
   1572e:	53                   	push   %ebx
   1572f:	83 ec 24             	sub    $0x24,%esp
    const int xmax = c->width - 3;
   15732:	8b 45 0c             	mov    0xc(%ebp),%eax
   15735:	8b 40 0c             	mov    0xc(%eax),%eax
   15738:	83 e8 03             	sub    $0x3,%eax
   1573b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    uchar *out, *lin, *lout;
    int x, y;
    out = (uchar*)malloc((c->width * c->height) << 1);
   1573e:	8b 45 0c             	mov    0xc(%ebp),%eax
   15741:	8b 50 0c             	mov    0xc(%eax),%edx
   15744:	8b 45 0c             	mov    0xc(%ebp),%eax
   15747:	8b 40 10             	mov    0x10(%eax),%eax
   1574a:	0f af c2             	imul   %edx,%eax
   1574d:	01 c0                	add    %eax,%eax
   1574f:	83 ec 0c             	sub    $0xc,%esp
   15752:	50                   	push   %eax
   15753:	e8 cb b0 fe ff       	call   823 <malloc>
   15758:	83 c4 10             	add    $0x10,%esp
   1575b:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(!out) ERROR_RETURN(OutOfMemory);
   1575e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   15762:	75 0e                	jne    15772 <_UpsampleH+0x47>
   15764:	8b 45 08             	mov    0x8(%ebp),%eax
   15767:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   1576d:	e9 44 03 00 00       	jmp    15ab6 <_UpsampleH+0x38b>
    lin = c->pixels;
   15772:	8b 45 0c             	mov    0xc(%ebp),%eax
   15775:	8b 40 28             	mov    0x28(%eax),%eax
   15778:	89 45 f4             	mov    %eax,-0xc(%ebp)
    lout = out;
   1577b:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1577e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    y =c->height;
   15781:	8b 45 0c             	mov    0xc(%ebp),%eax
   15784:	8b 40 10             	mov    0x10(%eax),%eax
   15787:	89 45 e8             	mov    %eax,-0x18(%ebp)
   while(y--){
   1578a:	e9 e0 02 00 00       	jmp    15a6f <_UpsampleH+0x344>
        lout[0] = CF(CF2A * lin[0] + CF2B * lin[1]);
   1578f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15792:	0f b6 00             	movzbl (%eax),%eax
   15795:	0f b6 c0             	movzbl %al,%eax
   15798:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   1579e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   157a1:	83 c0 01             	add    $0x1,%eax
   157a4:	0f b6 00             	movzbl (%eax),%eax
   157a7:	0f b6 c0             	movzbl %al,%eax
   157aa:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   157ad:	01 d0                	add    %edx,%eax
   157af:	83 ec 0c             	sub    $0xc,%esp
   157b2:	50                   	push   %eax
   157b3:	e8 c4 06 00 00       	call   15e7c <CF>
   157b8:	83 c4 10             	add    $0x10,%esp
   157bb:	89 c2                	mov    %eax,%edx
   157bd:	8b 45 f0             	mov    -0x10(%ebp),%eax
   157c0:	88 10                	mov    %dl,(%eax)
        lout[1] = CF(CF3X * lin[0] + CF3Y * lin[1] + CF3Z * lin[2]);
   157c2:	8b 45 f0             	mov    -0x10(%ebp),%eax
   157c5:	8d 58 01             	lea    0x1(%eax),%ebx
   157c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   157cb:	0f b6 00             	movzbl (%eax),%eax
   157ce:	0f b6 c0             	movzbl %al,%eax
   157d1:	6b c8 68             	imul   $0x68,%eax,%ecx
   157d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   157d7:	83 c0 01             	add    $0x1,%eax
   157da:	0f b6 00             	movzbl (%eax),%eax
   157dd:	0f b6 d0             	movzbl %al,%edx
   157e0:	89 d0                	mov    %edx,%eax
   157e2:	01 c0                	add    %eax,%eax
   157e4:	01 d0                	add    %edx,%eax
   157e6:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   157ed:	01 d0                	add    %edx,%eax
   157ef:	01 c1                	add    %eax,%ecx
   157f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   157f4:	83 c0 02             	add    $0x2,%eax
   157f7:	0f b6 00             	movzbl (%eax),%eax
   157fa:	0f b6 d0             	movzbl %al,%edx
   157fd:	89 d0                	mov    %edx,%eax
   157ff:	01 c0                	add    %eax,%eax
   15801:	01 d0                	add    %edx,%eax
   15803:	f7 d8                	neg    %eax
   15805:	01 c8                	add    %ecx,%eax
   15807:	83 ec 0c             	sub    $0xc,%esp
   1580a:	50                   	push   %eax
   1580b:	e8 6c 06 00 00       	call   15e7c <CF>
   15810:	83 c4 10             	add    $0x10,%esp
   15813:	88 03                	mov    %al,(%ebx)
        lout[2] = CF(CF3A * lin[0] + CF3B * lin[1] + CF3C * lin[2]);
   15815:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15818:	8d 58 02             	lea    0x2(%eax),%ebx
   1581b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1581e:	0f b6 00             	movzbl (%eax),%eax
   15821:	0f b6 c0             	movzbl %al,%eax
   15824:	c1 e0 02             	shl    $0x2,%eax
   15827:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   1582e:	29 c2                	sub    %eax,%edx
   15830:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15833:	83 c0 01             	add    $0x1,%eax
   15836:	0f b6 00             	movzbl (%eax),%eax
   15839:	0f b6 c0             	movzbl %al,%eax
   1583c:	6b c0 6d             	imul   $0x6d,%eax,%eax
   1583f:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   15842:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15845:	83 c0 02             	add    $0x2,%eax
   15848:	0f b6 00             	movzbl (%eax),%eax
   1584b:	0f b6 d0             	movzbl %al,%edx
   1584e:	89 d0                	mov    %edx,%eax
   15850:	c1 e0 03             	shl    $0x3,%eax
   15853:	01 d0                	add    %edx,%eax
   15855:	f7 d8                	neg    %eax
   15857:	01 c8                	add    %ecx,%eax
   15859:	83 ec 0c             	sub    $0xc,%esp
   1585c:	50                   	push   %eax
   1585d:	e8 1a 06 00 00       	call   15e7c <CF>
   15862:	83 c4 10             	add    $0x10,%esp
   15865:	88 03                	mov    %al,(%ebx)
        for (x = 0; x < xmax; ++x) {
   15867:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   1586e:	e9 fa 00 00 00       	jmp    1596d <_UpsampleH+0x242>
            lout[(x << 1) + 3] = CF(CF4A * lin[x] + CF4B * lin[x + 1] + CF4C * lin[x + 2] + CF4D * lin[x + 3]);
   15873:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15876:	01 c0                	add    %eax,%eax
   15878:	8d 50 03             	lea    0x3(%eax),%edx
   1587b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1587e:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   15881:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15884:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15887:	01 d0                	add    %edx,%eax
   15889:	0f b6 00             	movzbl (%eax),%eax
   1588c:	0f b6 d0             	movzbl %al,%edx
   1588f:	89 d0                	mov    %edx,%eax
   15891:	c1 e0 03             	shl    $0x3,%eax
   15894:	01 d0                	add    %edx,%eax
   15896:	f7 d8                	neg    %eax
   15898:	8b 55 ec             	mov    -0x14(%ebp),%edx
   1589b:	8d 4a 01             	lea    0x1(%edx),%ecx
   1589e:	8b 55 f4             	mov    -0xc(%ebp),%edx
   158a1:	01 ca                	add    %ecx,%edx
   158a3:	0f b6 12             	movzbl (%edx),%edx
   158a6:	0f b6 d2             	movzbl %dl,%edx
   158a9:	6b d2 6f             	imul   $0x6f,%edx,%edx
   158ac:	01 c2                	add    %eax,%edx
   158ae:	8b 45 ec             	mov    -0x14(%ebp),%eax
   158b1:	8d 48 02             	lea    0x2(%eax),%ecx
   158b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   158b7:	01 c8                	add    %ecx,%eax
   158b9:	0f b6 00             	movzbl (%eax),%eax
   158bc:	0f b6 c0             	movzbl %al,%eax
   158bf:	6b c0 1d             	imul   $0x1d,%eax,%eax
   158c2:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   158c5:	8b 45 ec             	mov    -0x14(%ebp),%eax
   158c8:	8d 50 03             	lea    0x3(%eax),%edx
   158cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
   158ce:	01 d0                	add    %edx,%eax
   158d0:	0f b6 00             	movzbl (%eax),%eax
   158d3:	0f b6 d0             	movzbl %al,%edx
   158d6:	89 d0                	mov    %edx,%eax
   158d8:	01 c0                	add    %eax,%eax
   158da:	01 d0                	add    %edx,%eax
   158dc:	f7 d8                	neg    %eax
   158de:	01 c8                	add    %ecx,%eax
   158e0:	83 ec 0c             	sub    $0xc,%esp
   158e3:	50                   	push   %eax
   158e4:	e8 93 05 00 00       	call   15e7c <CF>
   158e9:	83 c4 10             	add    $0x10,%esp
   158ec:	88 03                	mov    %al,(%ebx)
            lout[(x << 1) + 4] = CF(CF4D * lin[x] + CF4C * lin[x + 1] + CF4B * lin[x + 2] + CF4A * lin[x + 3]);
   158ee:	8b 45 ec             	mov    -0x14(%ebp),%eax
   158f1:	01 c0                	add    %eax,%eax
   158f3:	8d 50 04             	lea    0x4(%eax),%edx
   158f6:	8b 45 f0             	mov    -0x10(%ebp),%eax
   158f9:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   158fc:	8b 55 ec             	mov    -0x14(%ebp),%edx
   158ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15902:	01 d0                	add    %edx,%eax
   15904:	0f b6 00             	movzbl (%eax),%eax
   15907:	0f b6 d0             	movzbl %al,%edx
   1590a:	89 d0                	mov    %edx,%eax
   1590c:	01 c0                	add    %eax,%eax
   1590e:	01 d0                	add    %edx,%eax
   15910:	f7 d8                	neg    %eax
   15912:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15915:	8d 4a 01             	lea    0x1(%edx),%ecx
   15918:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1591b:	01 ca                	add    %ecx,%edx
   1591d:	0f b6 12             	movzbl (%edx),%edx
   15920:	0f b6 d2             	movzbl %dl,%edx
   15923:	6b d2 1d             	imul   $0x1d,%edx,%edx
   15926:	01 c2                	add    %eax,%edx
   15928:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1592b:	8d 48 02             	lea    0x2(%eax),%ecx
   1592e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15931:	01 c8                	add    %ecx,%eax
   15933:	0f b6 00             	movzbl (%eax),%eax
   15936:	0f b6 c0             	movzbl %al,%eax
   15939:	6b c0 6f             	imul   $0x6f,%eax,%eax
   1593c:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   1593f:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15942:	8d 50 03             	lea    0x3(%eax),%edx
   15945:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15948:	01 d0                	add    %edx,%eax
   1594a:	0f b6 00             	movzbl (%eax),%eax
   1594d:	0f b6 d0             	movzbl %al,%edx
   15950:	89 d0                	mov    %edx,%eax
   15952:	c1 e0 03             	shl    $0x3,%eax
   15955:	01 d0                	add    %edx,%eax
   15957:	f7 d8                	neg    %eax
   15959:	01 c8                	add    %ecx,%eax
   1595b:	83 ec 0c             	sub    $0xc,%esp
   1595e:	50                   	push   %eax
   1595f:	e8 18 05 00 00       	call   15e7c <CF>
   15964:	83 c4 10             	add    $0x10,%esp
   15967:	88 03                	mov    %al,(%ebx)
    y =c->height;
   while(y--){
        lout[0] = CF(CF2A * lin[0] + CF2B * lin[1]);
        lout[1] = CF(CF3X * lin[0] + CF3Y * lin[1] + CF3Z * lin[2]);
        lout[2] = CF(CF3A * lin[0] + CF3B * lin[1] + CF3C * lin[2]);
        for (x = 0; x < xmax; ++x) {
   15969:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   1596d:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15970:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   15973:	0f 8c fa fe ff ff    	jl     15873 <_UpsampleH+0x148>
            lout[(x << 1) + 3] = CF(CF4A * lin[x] + CF4B * lin[x + 1] + CF4C * lin[x + 2] + CF4D * lin[x + 3]);
            lout[(x << 1) + 4] = CF(CF4D * lin[x] + CF4C * lin[x + 1] + CF4B * lin[x + 2] + CF4A * lin[x + 3]);
        }
        lin += c->stride;
   15979:	8b 45 0c             	mov    0xc(%ebp),%eax
   1597c:	8b 40 14             	mov    0x14(%eax),%eax
   1597f:	01 45 f4             	add    %eax,-0xc(%ebp)
        lout += c->width << 1;
   15982:	8b 45 0c             	mov    0xc(%ebp),%eax
   15985:	8b 40 0c             	mov    0xc(%eax),%eax
   15988:	01 c0                	add    %eax,%eax
   1598a:	01 45 f0             	add    %eax,-0x10(%ebp)
        lout[-3] = CF(CF3A * lin[-1] + CF3B * lin[-2] + CF3C * lin[-3]);
   1598d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15990:	8d 58 fd             	lea    -0x3(%eax),%ebx
   15993:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15996:	83 e8 01             	sub    $0x1,%eax
   15999:	0f b6 00             	movzbl (%eax),%eax
   1599c:	0f b6 c0             	movzbl %al,%eax
   1599f:	c1 e0 02             	shl    $0x2,%eax
   159a2:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   159a9:	29 c2                	sub    %eax,%edx
   159ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
   159ae:	83 e8 02             	sub    $0x2,%eax
   159b1:	0f b6 00             	movzbl (%eax),%eax
   159b4:	0f b6 c0             	movzbl %al,%eax
   159b7:	6b c0 6d             	imul   $0x6d,%eax,%eax
   159ba:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   159bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
   159c0:	83 e8 03             	sub    $0x3,%eax
   159c3:	0f b6 00             	movzbl (%eax),%eax
   159c6:	0f b6 d0             	movzbl %al,%edx
   159c9:	89 d0                	mov    %edx,%eax
   159cb:	c1 e0 03             	shl    $0x3,%eax
   159ce:	01 d0                	add    %edx,%eax
   159d0:	f7 d8                	neg    %eax
   159d2:	01 c8                	add    %ecx,%eax
   159d4:	83 ec 0c             	sub    $0xc,%esp
   159d7:	50                   	push   %eax
   159d8:	e8 9f 04 00 00       	call   15e7c <CF>
   159dd:	83 c4 10             	add    $0x10,%esp
   159e0:	88 03                	mov    %al,(%ebx)
        lout[-2] = CF(CF3X * lin[-1] + CF3Y * lin[-2] + CF3Z * lin[-3]);
   159e2:	8b 45 f0             	mov    -0x10(%ebp),%eax
   159e5:	8d 58 fe             	lea    -0x2(%eax),%ebx
   159e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   159eb:	83 e8 01             	sub    $0x1,%eax
   159ee:	0f b6 00             	movzbl (%eax),%eax
   159f1:	0f b6 c0             	movzbl %al,%eax
   159f4:	6b c8 68             	imul   $0x68,%eax,%ecx
   159f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
   159fa:	83 e8 02             	sub    $0x2,%eax
   159fd:	0f b6 00             	movzbl (%eax),%eax
   15a00:	0f b6 d0             	movzbl %al,%edx
   15a03:	89 d0                	mov    %edx,%eax
   15a05:	01 c0                	add    %eax,%eax
   15a07:	01 d0                	add    %edx,%eax
   15a09:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15a10:	01 d0                	add    %edx,%eax
   15a12:	01 c1                	add    %eax,%ecx
   15a14:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15a17:	83 e8 03             	sub    $0x3,%eax
   15a1a:	0f b6 00             	movzbl (%eax),%eax
   15a1d:	0f b6 d0             	movzbl %al,%edx
   15a20:	89 d0                	mov    %edx,%eax
   15a22:	01 c0                	add    %eax,%eax
   15a24:	01 d0                	add    %edx,%eax
   15a26:	f7 d8                	neg    %eax
   15a28:	01 c8                	add    %ecx,%eax
   15a2a:	83 ec 0c             	sub    $0xc,%esp
   15a2d:	50                   	push   %eax
   15a2e:	e8 49 04 00 00       	call   15e7c <CF>
   15a33:	83 c4 10             	add    $0x10,%esp
   15a36:	88 03                	mov    %al,(%ebx)
        lout[-1] = CF(CF2A * lin[-1] + CF2B * lin[-2]);
   15a38:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15a3b:	8d 58 ff             	lea    -0x1(%eax),%ebx
   15a3e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15a41:	83 e8 01             	sub    $0x1,%eax
   15a44:	0f b6 00             	movzbl (%eax),%eax
   15a47:	0f b6 c0             	movzbl %al,%eax
   15a4a:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   15a50:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15a53:	83 e8 02             	sub    $0x2,%eax
   15a56:	0f b6 00             	movzbl (%eax),%eax
   15a59:	0f b6 c0             	movzbl %al,%eax
   15a5c:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   15a5f:	01 d0                	add    %edx,%eax
   15a61:	83 ec 0c             	sub    $0xc,%esp
   15a64:	50                   	push   %eax
   15a65:	e8 12 04 00 00       	call   15e7c <CF>
   15a6a:	83 c4 10             	add    $0x10,%esp
   15a6d:	88 03                	mov    %al,(%ebx)
    out = (uchar*)malloc((c->width * c->height) << 1);
    if(!out) ERROR_RETURN(OutOfMemory);
    lin = c->pixels;
    lout = out;
    y =c->height;
   while(y--){
   15a6f:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15a72:	8d 50 ff             	lea    -0x1(%eax),%edx
   15a75:	89 55 e8             	mov    %edx,-0x18(%ebp)
   15a78:	85 c0                	test   %eax,%eax
   15a7a:	0f 85 0f fd ff ff    	jne    1578f <_UpsampleH+0x64>
        lout += c->width << 1;
        lout[-3] = CF(CF3A * lin[-1] + CF3B * lin[-2] + CF3C * lin[-3]);
        lout[-2] = CF(CF3X * lin[-1] + CF3Y * lin[-2] + CF3Z * lin[-3]);
        lout[-1] = CF(CF2A * lin[-1] + CF2B * lin[-2]);
    }
    c->width <<= 1;
   15a80:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a83:	8b 40 0c             	mov    0xc(%eax),%eax
   15a86:	8d 14 00             	lea    (%eax,%eax,1),%edx
   15a89:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a8c:	89 50 0c             	mov    %edx,0xc(%eax)
    c->stride = c->width;
   15a8f:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a92:	8b 50 0c             	mov    0xc(%eax),%edx
   15a95:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a98:	89 50 14             	mov    %edx,0x14(%eax)
    free(c->pixels);
   15a9b:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a9e:	8b 40 28             	mov    0x28(%eax),%eax
   15aa1:	83 ec 0c             	sub    $0xc,%esp
   15aa4:	50                   	push   %eax
   15aa5:	e8 37 ac fe ff       	call   6e1 <free>
   15aaa:	83 c4 10             	add    $0x10,%esp
    c->pixels = out;
   15aad:	8b 45 0c             	mov    0xc(%ebp),%eax
   15ab0:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15ab3:	89 50 28             	mov    %edx,0x28(%eax)
}
   15ab6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   15ab9:	c9                   	leave  
   15aba:	c3                   	ret    

00015abb <_UpsampleV>:
void _UpsampleV(Context* ctx, Component* c){
   15abb:	55                   	push   %ebp
   15abc:	89 e5                	mov    %esp,%ebp
   15abe:	83 ec 28             	sub    $0x28,%esp
    const int w = c->width, s1 = c->stride, s2 = s1 + s1;
   15ac1:	8b 45 0c             	mov    0xc(%ebp),%eax
   15ac4:	8b 40 0c             	mov    0xc(%eax),%eax
   15ac7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
   15aca:	8b 45 0c             	mov    0xc(%ebp),%eax
   15acd:	8b 40 14             	mov    0x14(%eax),%eax
   15ad0:	89 45 e0             	mov    %eax,-0x20(%ebp)
   15ad3:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15ad6:	01 c0                	add    %eax,%eax
   15ad8:	89 45 dc             	mov    %eax,-0x24(%ebp)
    uchar *out, *cin, *cout;
    int x, y;
    out = (uchar*)malloc((c->width * c->height) << 1);
   15adb:	8b 45 0c             	mov    0xc(%ebp),%eax
   15ade:	8b 50 0c             	mov    0xc(%eax),%edx
   15ae1:	8b 45 0c             	mov    0xc(%ebp),%eax
   15ae4:	8b 40 10             	mov    0x10(%eax),%eax
   15ae7:	0f af c2             	imul   %edx,%eax
   15aea:	01 c0                	add    %eax,%eax
   15aec:	83 ec 0c             	sub    $0xc,%esp
   15aef:	50                   	push   %eax
   15af0:	e8 2e ad fe ff       	call   823 <malloc>
   15af5:	83 c4 10             	add    $0x10,%esp
   15af8:	89 45 d8             	mov    %eax,-0x28(%ebp)
    if(!out) ERROR_RETURN(OutOfMemory);
   15afb:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   15aff:	75 0e                	jne    15b0f <_UpsampleV+0x54>
   15b01:	8b 45 08             	mov    0x8(%ebp),%eax
   15b04:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   15b0a:	e9 6b 03 00 00       	jmp    15e7a <_UpsampleV+0x3bf>
    for(x = 0; x<w; ++x){
   15b0f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   15b16:	e9 1d 03 00 00       	jmp    15e38 <_UpsampleV+0x37d>
        cin = &c->pixels[x];
   15b1b:	8b 45 0c             	mov    0xc(%ebp),%eax
   15b1e:	8b 50 28             	mov    0x28(%eax),%edx
   15b21:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15b24:	01 d0                	add    %edx,%eax
   15b26:	89 45 f4             	mov    %eax,-0xc(%ebp)
        cout = &out[x];
   15b29:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15b2c:	8b 45 d8             	mov    -0x28(%ebp),%eax
   15b2f:	01 d0                	add    %edx,%eax
   15b31:	89 45 f0             	mov    %eax,-0x10(%ebp)
        *cout = CF(CF2A * cin[0] + CF2B * cin[s1]);  cout += w;
   15b34:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15b37:	0f b6 00             	movzbl (%eax),%eax
   15b3a:	0f b6 c0             	movzbl %al,%eax
   15b3d:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   15b43:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   15b46:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15b49:	01 c8                	add    %ecx,%eax
   15b4b:	0f b6 00             	movzbl (%eax),%eax
   15b4e:	0f b6 c0             	movzbl %al,%eax
   15b51:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   15b54:	01 d0                	add    %edx,%eax
   15b56:	83 ec 0c             	sub    $0xc,%esp
   15b59:	50                   	push   %eax
   15b5a:	e8 1d 03 00 00       	call   15e7c <CF>
   15b5f:	83 c4 10             	add    $0x10,%esp
   15b62:	89 c2                	mov    %eax,%edx
   15b64:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15b67:	88 10                	mov    %dl,(%eax)
   15b69:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15b6c:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF3X * cin[0] + CF3Y * cin[s1] + CF3Z * cin[s2]);  cout += w;
   15b6f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15b72:	0f b6 00             	movzbl (%eax),%eax
   15b75:	0f b6 c0             	movzbl %al,%eax
   15b78:	6b c8 68             	imul   $0x68,%eax,%ecx
   15b7b:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15b7e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15b81:	01 d0                	add    %edx,%eax
   15b83:	0f b6 00             	movzbl (%eax),%eax
   15b86:	0f b6 d0             	movzbl %al,%edx
   15b89:	89 d0                	mov    %edx,%eax
   15b8b:	01 c0                	add    %eax,%eax
   15b8d:	01 d0                	add    %edx,%eax
   15b8f:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15b96:	01 d0                	add    %edx,%eax
   15b98:	01 c1                	add    %eax,%ecx
   15b9a:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15b9d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15ba0:	01 d0                	add    %edx,%eax
   15ba2:	0f b6 00             	movzbl (%eax),%eax
   15ba5:	0f b6 d0             	movzbl %al,%edx
   15ba8:	89 d0                	mov    %edx,%eax
   15baa:	01 c0                	add    %eax,%eax
   15bac:	01 d0                	add    %edx,%eax
   15bae:	f7 d8                	neg    %eax
   15bb0:	01 c8                	add    %ecx,%eax
   15bb2:	83 ec 0c             	sub    $0xc,%esp
   15bb5:	50                   	push   %eax
   15bb6:	e8 c1 02 00 00       	call   15e7c <CF>
   15bbb:	83 c4 10             	add    $0x10,%esp
   15bbe:	89 c2                	mov    %eax,%edx
   15bc0:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15bc3:	88 10                	mov    %dl,(%eax)
   15bc5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15bc8:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF3A * cin[0] + CF3B * cin[s1] + CF3C * cin[s2]);  cout += w;
   15bcb:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15bce:	0f b6 00             	movzbl (%eax),%eax
   15bd1:	0f b6 c0             	movzbl %al,%eax
   15bd4:	c1 e0 02             	shl    $0x2,%eax
   15bd7:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15bde:	89 d1                	mov    %edx,%ecx
   15be0:	29 c1                	sub    %eax,%ecx
   15be2:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15be5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15be8:	01 d0                	add    %edx,%eax
   15bea:	0f b6 00             	movzbl (%eax),%eax
   15bed:	0f b6 c0             	movzbl %al,%eax
   15bf0:	6b c0 6d             	imul   $0x6d,%eax,%eax
   15bf3:	01 c1                	add    %eax,%ecx
   15bf5:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15bf8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15bfb:	01 d0                	add    %edx,%eax
   15bfd:	0f b6 00             	movzbl (%eax),%eax
   15c00:	0f b6 d0             	movzbl %al,%edx
   15c03:	89 d0                	mov    %edx,%eax
   15c05:	c1 e0 03             	shl    $0x3,%eax
   15c08:	01 d0                	add    %edx,%eax
   15c0a:	f7 d8                	neg    %eax
   15c0c:	01 c8                	add    %ecx,%eax
   15c0e:	83 ec 0c             	sub    $0xc,%esp
   15c11:	50                   	push   %eax
   15c12:	e8 65 02 00 00       	call   15e7c <CF>
   15c17:	83 c4 10             	add    $0x10,%esp
   15c1a:	89 c2                	mov    %eax,%edx
   15c1c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15c1f:	88 10                	mov    %dl,(%eax)
   15c21:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15c24:	01 45 f0             	add    %eax,-0x10(%ebp)
        cin += s1;
   15c27:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15c2a:	01 45 f4             	add    %eax,-0xc(%ebp)
        for(y=c->height-3; y; --y) {
   15c2d:	8b 45 0c             	mov    0xc(%ebp),%eax
   15c30:	8b 40 10             	mov    0x10(%eax),%eax
   15c33:	83 e8 03             	sub    $0x3,%eax
   15c36:	89 45 e8             	mov    %eax,-0x18(%ebp)
   15c39:	e9 e6 00 00 00       	jmp    15d24 <_UpsampleV+0x269>
            *cout = CF(CF4A * cin[-s1] + CF4B * cin[0] + CF4C * cin[s1] + CF4D * cin[s2]);  cout += w;
   15c3e:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15c41:	f7 d8                	neg    %eax
   15c43:	89 c2                	mov    %eax,%edx
   15c45:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15c48:	01 d0                	add    %edx,%eax
   15c4a:	0f b6 00             	movzbl (%eax),%eax
   15c4d:	0f b6 d0             	movzbl %al,%edx
   15c50:	89 d0                	mov    %edx,%eax
   15c52:	c1 e0 03             	shl    $0x3,%eax
   15c55:	01 d0                	add    %edx,%eax
   15c57:	f7 d8                	neg    %eax
   15c59:	8b 55 f4             	mov    -0xc(%ebp),%edx
   15c5c:	0f b6 12             	movzbl (%edx),%edx
   15c5f:	0f b6 d2             	movzbl %dl,%edx
   15c62:	6b d2 6f             	imul   $0x6f,%edx,%edx
   15c65:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
   15c68:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15c6b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15c6e:	01 d0                	add    %edx,%eax
   15c70:	0f b6 00             	movzbl (%eax),%eax
   15c73:	0f b6 c0             	movzbl %al,%eax
   15c76:	6b c0 1d             	imul   $0x1d,%eax,%eax
   15c79:	01 c1                	add    %eax,%ecx
   15c7b:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15c7e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15c81:	01 d0                	add    %edx,%eax
   15c83:	0f b6 00             	movzbl (%eax),%eax
   15c86:	0f b6 d0             	movzbl %al,%edx
   15c89:	89 d0                	mov    %edx,%eax
   15c8b:	01 c0                	add    %eax,%eax
   15c8d:	01 d0                	add    %edx,%eax
   15c8f:	f7 d8                	neg    %eax
   15c91:	01 c8                	add    %ecx,%eax
   15c93:	83 ec 0c             	sub    $0xc,%esp
   15c96:	50                   	push   %eax
   15c97:	e8 e0 01 00 00       	call   15e7c <CF>
   15c9c:	83 c4 10             	add    $0x10,%esp
   15c9f:	89 c2                	mov    %eax,%edx
   15ca1:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15ca4:	88 10                	mov    %dl,(%eax)
   15ca6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15ca9:	01 45 f0             	add    %eax,-0x10(%ebp)
            *cout = CF(CF4D * cin[-s1] + CF4C * cin[0] + CF4B * cin[s1] + CF4A * cin[s2]);  cout += w;
   15cac:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15caf:	f7 d8                	neg    %eax
   15cb1:	89 c2                	mov    %eax,%edx
   15cb3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15cb6:	01 d0                	add    %edx,%eax
   15cb8:	0f b6 00             	movzbl (%eax),%eax
   15cbb:	0f b6 d0             	movzbl %al,%edx
   15cbe:	89 d0                	mov    %edx,%eax
   15cc0:	01 c0                	add    %eax,%eax
   15cc2:	01 d0                	add    %edx,%eax
   15cc4:	f7 d8                	neg    %eax
   15cc6:	8b 55 f4             	mov    -0xc(%ebp),%edx
   15cc9:	0f b6 12             	movzbl (%edx),%edx
   15ccc:	0f b6 d2             	movzbl %dl,%edx
   15ccf:	6b d2 1d             	imul   $0x1d,%edx,%edx
   15cd2:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
   15cd5:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15cd8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15cdb:	01 d0                	add    %edx,%eax
   15cdd:	0f b6 00             	movzbl (%eax),%eax
   15ce0:	0f b6 c0             	movzbl %al,%eax
   15ce3:	6b c0 6f             	imul   $0x6f,%eax,%eax
   15ce6:	01 c1                	add    %eax,%ecx
   15ce8:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15ceb:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15cee:	01 d0                	add    %edx,%eax
   15cf0:	0f b6 00             	movzbl (%eax),%eax
   15cf3:	0f b6 d0             	movzbl %al,%edx
   15cf6:	89 d0                	mov    %edx,%eax
   15cf8:	c1 e0 03             	shl    $0x3,%eax
   15cfb:	01 d0                	add    %edx,%eax
   15cfd:	f7 d8                	neg    %eax
   15cff:	01 c8                	add    %ecx,%eax
   15d01:	83 ec 0c             	sub    $0xc,%esp
   15d04:	50                   	push   %eax
   15d05:	e8 72 01 00 00       	call   15e7c <CF>
   15d0a:	83 c4 10             	add    $0x10,%esp
   15d0d:	89 c2                	mov    %eax,%edx
   15d0f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15d12:	88 10                	mov    %dl,(%eax)
   15d14:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15d17:	01 45 f0             	add    %eax,-0x10(%ebp)
            cin += s1;
   15d1a:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15d1d:	01 45 f4             	add    %eax,-0xc(%ebp)
        cout = &out[x];
        *cout = CF(CF2A * cin[0] + CF2B * cin[s1]);  cout += w;
        *cout = CF(CF3X * cin[0] + CF3Y * cin[s1] + CF3Z * cin[s2]);  cout += w;
        *cout = CF(CF3A * cin[0] + CF3B * cin[s1] + CF3C * cin[s2]);  cout += w;
        cin += s1;
        for(y=c->height-3; y; --y) {
   15d20:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
   15d24:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   15d28:	0f 85 10 ff ff ff    	jne    15c3e <_UpsampleV+0x183>
            *cout = CF(CF4A * cin[-s1] + CF4B * cin[0] + CF4C * cin[s1] + CF4D * cin[s2]);  cout += w;
            *cout = CF(CF4D * cin[-s1] + CF4C * cin[0] + CF4B * cin[s1] + CF4A * cin[s2]);  cout += w;
            cin += s1;
        }
        cin += s1;
   15d2e:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15d31:	01 45 f4             	add    %eax,-0xc(%ebp)
        *cout = CF(CF3A * cin[0] + CF3B * cin[-s1] + CF3C * cin[-s2]);  cout += w;
   15d34:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15d37:	0f b6 00             	movzbl (%eax),%eax
   15d3a:	0f b6 c0             	movzbl %al,%eax
   15d3d:	c1 e0 02             	shl    $0x2,%eax
   15d40:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15d47:	29 c2                	sub    %eax,%edx
   15d49:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15d4c:	f7 d8                	neg    %eax
   15d4e:	89 c1                	mov    %eax,%ecx
   15d50:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15d53:	01 c8                	add    %ecx,%eax
   15d55:	0f b6 00             	movzbl (%eax),%eax
   15d58:	0f b6 c0             	movzbl %al,%eax
   15d5b:	6b c0 6d             	imul   $0x6d,%eax,%eax
   15d5e:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   15d61:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15d64:	f7 d8                	neg    %eax
   15d66:	89 c2                	mov    %eax,%edx
   15d68:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15d6b:	01 d0                	add    %edx,%eax
   15d6d:	0f b6 00             	movzbl (%eax),%eax
   15d70:	0f b6 d0             	movzbl %al,%edx
   15d73:	89 d0                	mov    %edx,%eax
   15d75:	c1 e0 03             	shl    $0x3,%eax
   15d78:	01 d0                	add    %edx,%eax
   15d7a:	f7 d8                	neg    %eax
   15d7c:	01 c8                	add    %ecx,%eax
   15d7e:	83 ec 0c             	sub    $0xc,%esp
   15d81:	50                   	push   %eax
   15d82:	e8 f5 00 00 00       	call   15e7c <CF>
   15d87:	83 c4 10             	add    $0x10,%esp
   15d8a:	89 c2                	mov    %eax,%edx
   15d8c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15d8f:	88 10                	mov    %dl,(%eax)
   15d91:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15d94:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF3X * cin[0] + CF3Y * cin[-s1] + CF3Z * cin[-s2]);  cout += w;
   15d97:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15d9a:	0f b6 00             	movzbl (%eax),%eax
   15d9d:	0f b6 c0             	movzbl %al,%eax
   15da0:	6b c8 68             	imul   $0x68,%eax,%ecx
   15da3:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15da6:	f7 d8                	neg    %eax
   15da8:	89 c2                	mov    %eax,%edx
   15daa:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15dad:	01 d0                	add    %edx,%eax
   15daf:	0f b6 00             	movzbl (%eax),%eax
   15db2:	0f b6 d0             	movzbl %al,%edx
   15db5:	89 d0                	mov    %edx,%eax
   15db7:	01 c0                	add    %eax,%eax
   15db9:	01 d0                	add    %edx,%eax
   15dbb:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15dc2:	01 d0                	add    %edx,%eax
   15dc4:	01 c1                	add    %eax,%ecx
   15dc6:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15dc9:	f7 d8                	neg    %eax
   15dcb:	89 c2                	mov    %eax,%edx
   15dcd:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15dd0:	01 d0                	add    %edx,%eax
   15dd2:	0f b6 00             	movzbl (%eax),%eax
   15dd5:	0f b6 d0             	movzbl %al,%edx
   15dd8:	89 d0                	mov    %edx,%eax
   15dda:	01 c0                	add    %eax,%eax
   15ddc:	01 d0                	add    %edx,%eax
   15dde:	f7 d8                	neg    %eax
   15de0:	01 c8                	add    %ecx,%eax
   15de2:	83 ec 0c             	sub    $0xc,%esp
   15de5:	50                   	push   %eax
   15de6:	e8 91 00 00 00       	call   15e7c <CF>
   15deb:	83 c4 10             	add    $0x10,%esp
   15dee:	89 c2                	mov    %eax,%edx
   15df0:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15df3:	88 10                	mov    %dl,(%eax)
   15df5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15df8:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF2A * cin[0] + CF2B * cin[-s1]);
   15dfb:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15dfe:	0f b6 00             	movzbl (%eax),%eax
   15e01:	0f b6 c0             	movzbl %al,%eax
   15e04:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   15e0a:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15e0d:	f7 d8                	neg    %eax
   15e0f:	89 c1                	mov    %eax,%ecx
   15e11:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15e14:	01 c8                	add    %ecx,%eax
   15e16:	0f b6 00             	movzbl (%eax),%eax
   15e19:	0f b6 c0             	movzbl %al,%eax
   15e1c:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   15e1f:	01 d0                	add    %edx,%eax
   15e21:	83 ec 0c             	sub    $0xc,%esp
   15e24:	50                   	push   %eax
   15e25:	e8 52 00 00 00       	call   15e7c <CF>
   15e2a:	83 c4 10             	add    $0x10,%esp
   15e2d:	89 c2                	mov    %eax,%edx
   15e2f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15e32:	88 10                	mov    %dl,(%eax)
    const int w = c->width, s1 = c->stride, s2 = s1 + s1;
    uchar *out, *cin, *cout;
    int x, y;
    out = (uchar*)malloc((c->width * c->height) << 1);
    if(!out) ERROR_RETURN(OutOfMemory);
    for(x = 0; x<w; ++x){
   15e34:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   15e38:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15e3b:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   15e3e:	0f 8c d7 fc ff ff    	jl     15b1b <_UpsampleV+0x60>
        cin += s1;
        *cout = CF(CF3A * cin[0] + CF3B * cin[-s1] + CF3C * cin[-s2]);  cout += w;
        *cout = CF(CF3X * cin[0] + CF3Y * cin[-s1] + CF3Z * cin[-s2]);  cout += w;
        *cout = CF(CF2A * cin[0] + CF2B * cin[-s1]);
    }
    c->height <<= 1;
   15e44:	8b 45 0c             	mov    0xc(%ebp),%eax
   15e47:	8b 40 10             	mov    0x10(%eax),%eax
   15e4a:	8d 14 00             	lea    (%eax,%eax,1),%edx
   15e4d:	8b 45 0c             	mov    0xc(%ebp),%eax
   15e50:	89 50 10             	mov    %edx,0x10(%eax)
    c->stride = c->width;
   15e53:	8b 45 0c             	mov    0xc(%ebp),%eax
   15e56:	8b 50 0c             	mov    0xc(%eax),%edx
   15e59:	8b 45 0c             	mov    0xc(%ebp),%eax
   15e5c:	89 50 14             	mov    %edx,0x14(%eax)
    free(c->pixels);
   15e5f:	8b 45 0c             	mov    0xc(%ebp),%eax
   15e62:	8b 40 28             	mov    0x28(%eax),%eax
   15e65:	83 ec 0c             	sub    $0xc,%esp
   15e68:	50                   	push   %eax
   15e69:	e8 73 a8 fe ff       	call   6e1 <free>
   15e6e:	83 c4 10             	add    $0x10,%esp
    c->pixels = out;
   15e71:	8b 45 0c             	mov    0xc(%ebp),%eax
   15e74:	8b 55 d8             	mov    -0x28(%ebp),%edx
   15e77:	89 50 28             	mov    %edx,0x28(%eax)
}
   15e7a:	c9                   	leave  
   15e7b:	c3                   	ret    

00015e7c <CF>:

uchar CF(const int x){
   15e7c:	55                   	push   %ebp
   15e7d:	89 e5                	mov    %esp,%ebp
    return _Clip((x + 64) >> 7);
   15e7f:	8b 45 08             	mov    0x8(%ebp),%eax
   15e82:	83 c0 40             	add    $0x40,%eax
   15e85:	c1 f8 07             	sar    $0x7,%eax
   15e88:	50                   	push   %eax
   15e89:	e8 e9 dd ff ff       	call   13c77 <_Clip>
   15e8e:	83 c4 04             	add    $0x4,%esp
}
   15e91:	c9                   	leave  
   15e92:	c3                   	ret    
